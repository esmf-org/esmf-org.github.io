<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002 (1.67)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>3 Infrastructure: Fields and Grids</TITLE>
<META NAME="description" CONTENT="3 Infrastructure: Fields and Grids">
<META NAME="keywords" CONTENT="ESMF_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="ESMF_refdoc.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html1450"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1446"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1440"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1448"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1451"
  HREF="node5.html">4 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html1447"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1441"
  HREF="node3.html">2 Superstructure</A>
 &nbsp <B>  <A NAME="tex2html1449"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html1452"
  HREF="node4.html#SECTION04010000000000000000">16 Overview of Infrastructure Data Handling</A>
<UL>
<LI><A NAME="tex2html1453"
  HREF="node4.html#SECTION04011000000000000000">16.1 Infrastructure Data Classes</A>
<LI><A NAME="tex2html1454"
  HREF="node4.html#SECTION04012000000000000000">16.2 Design and Implementation Notes</A>
</UL>
<LI><A NAME="tex2html1455"
  HREF="node4.html#SECTION04020000000000000000">17 FieldBundle Class</A>
<UL>
<LI><A NAME="tex2html1456"
  HREF="node4.html#SECTION04021000000000000000">17.1 Description</A>
<LI><A NAME="tex2html1457"
  HREF="node4.html#SECTION04022000000000000000">17.2 FieldBundle Options</A>
<UL>
<LI><A NAME="tex2html1458"
  HREF="node4.html#SECTION04022100000000000000">17.2.1 ESMF_PackFlag</A>
</UL>
<LI><A NAME="tex2html1459"
  HREF="node4.html#SECTION04023000000000000000">17.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1460"
  HREF="node4.html#SECTION04023100000000000000">17.3.1 FieldBundle Creation</A>
<LI><A NAME="tex2html1461"
  HREF="node4.html#SECTION04023200000000000000">17.3.2 Accessing FieldBundle Data</A>
<LI><A NAME="tex2html1462"
  HREF="node4.html#SECTION04023300000000000000">17.3.3 FieldBundle Deletion</A>
<LI><A NAME="tex2html1463"
  HREF="node4.html#SECTION04023400000000000000">17.3.4 Redistribute data from source FieldBundle to destination FieldBundle</A>
<LI><A NAME="tex2html1464"
  HREF="node4.html#SECTION04023500000000000000">17.3.5 Perform Sparse Matrix Multiplication from source FieldBundle 
    to destination FieldBundle</A>
<LI><A NAME="tex2html1465"
  HREF="node4.html#SECTION04023600000000000000">17.3.6 Perform FieldBundle halo update</A>
</UL>
<LI><A NAME="tex2html1466"
  HREF="node4.html#SECTION04024000000000000000">17.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html1467"
  HREF="node4.html#SECTION04025000000000000000">17.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html1468"
  HREF="node4.html#SECTION04026000000000000000">17.6 Class API: Basic FieldBundle Methods</A>
<UL>
<LI><A NAME="tex2html1469"
  HREF="node4.html#SECTION04026100000000000000">17.6.1 ESMF_FieldBundleAdd</A>
<LI><A NAME="tex2html1470"
  HREF="node4.html#SECTION04026200000000000000">17.6.2 ESMF_FieldBundleAdd</A>
<LI><A NAME="tex2html1471"
  HREF="node4.html#SECTION04026300000000000000">17.6.3 ESMF_FieldBundleCreate</A>
<LI><A NAME="tex2html1472"
  HREF="node4.html#SECTION04026400000000000000">17.6.4 ESMF_FieldBundleCreate</A>
<LI><A NAME="tex2html1473"
  HREF="node4.html#SECTION04026500000000000000">17.6.5 ESMF_FieldBundleCreate</A>
<LI><A NAME="tex2html1474"
  HREF="node4.html#SECTION04026600000000000000">17.6.6 ESMF_FieldBundleCreate</A>
<LI><A NAME="tex2html1475"
  HREF="node4.html#SECTION04026700000000000000">17.6.7 ESMF_FieldBundleCreate</A>
<LI><A NAME="tex2html1476"
  HREF="node4.html#SECTION04026800000000000000">17.6.8 ESMF_FieldBundleDestroy</A>
<LI><A NAME="tex2html1477"
  HREF="node4.html#SECTION04026900000000000000">17.6.9 ESMF_FieldBundleGet</A>
<LI><A NAME="tex2html1478"
  HREF="node4.html#SECTION040261000000000000000">17.6.10 ESMF_FieldBundleGet</A>
<LI><A NAME="tex2html1479"
  HREF="node4.html#SECTION040261100000000000000">17.6.11 ESMF_FieldBundleGet</A>
<LI><A NAME="tex2html1480"
  HREF="node4.html#SECTION040261200000000000000">17.6.12 ESMF_FieldBundleGet</A>
<LI><A NAME="tex2html1481"
  HREF="node4.html#SECTION040261300000000000000">17.6.13 ESMF_FieldBundlePrint</A>
<LI><A NAME="tex2html1482"
  HREF="node4.html#SECTION040261400000000000000">17.6.14 ESMF_FieldBundleSet</A>
<LI><A NAME="tex2html1483"
  HREF="node4.html#SECTION040261500000000000000">17.6.15 ESMF_FieldBundleSet</A>
<LI><A NAME="tex2html1484"
  HREF="node4.html#SECTION040261600000000000000">17.6.16 ESMF_FieldBundleSet</A>
<LI><A NAME="tex2html1485"
  HREF="node4.html#SECTION040261700000000000000">17.6.17 ESMF_FieldBundleValidate</A>
</UL>
<LI><A NAME="tex2html1486"
  HREF="node4.html#SECTION04027000000000000000">17.7 Class API: FieldBundle Communications</A>
<UL>
<LI><A NAME="tex2html1487"
  HREF="node4.html#SECTION04027100000000000000">17.7.1 ESMF_FieldBundleHalo</A>
<LI><A NAME="tex2html1488"
  HREF="node4.html#SECTION04027200000000000000">17.7.2 ESMF_FieldBundleHaloRelease</A>
<LI><A NAME="tex2html1489"
  HREF="node4.html#SECTION04027300000000000000">17.7.3 ESMF_FieldBundleHaloStore</A>
<LI><A NAME="tex2html1490"
  HREF="node4.html#SECTION04027400000000000000">17.7.4 ESMF_FieldBundleRedist</A>
<LI><A NAME="tex2html1491"
  HREF="node4.html#SECTION04027500000000000000">17.7.5 ESMF_FieldBundleRedistRelease</A>
<LI><A NAME="tex2html1492"
  HREF="node4.html#SECTION04027600000000000000">17.7.6 ESMF_FieldBundleRedistStore</A>
<LI><A NAME="tex2html1493"
  HREF="node4.html#SECTION04027700000000000000">17.7.7 ESMF_FieldBundleRedistStore</A>
<LI><A NAME="tex2html1494"
  HREF="node4.html#SECTION04027800000000000000">17.7.8 ESMF_FieldBundleRegrid</A>
<LI><A NAME="tex2html1495"
  HREF="node4.html#SECTION04027900000000000000">17.7.9 ESMF_FieldBundleRegridRelease</A>
<LI><A NAME="tex2html1496"
  HREF="node4.html#SECTION040271000000000000000">17.7.10 ESMF_FieldBundleRegridStore</A>
<LI><A NAME="tex2html1497"
  HREF="node4.html#SECTION040271100000000000000">17.7.11 ESMF_FieldBundleSMM</A>
<LI><A NAME="tex2html1498"
  HREF="node4.html#SECTION040271200000000000000">17.7.12 ESMF_FieldBundleSMMRelease</A>
<LI><A NAME="tex2html1499"
  HREF="node4.html#SECTION040271300000000000000">17.7.13 ESMF_FieldBundleSMMStore</A>
<LI><A NAME="tex2html1500"
  HREF="node4.html#SECTION040271400000000000000">17.7.14 ESMF_FieldBundleSMMStore</A>
</UL>
</UL>
<LI><A NAME="tex2html1501"
  HREF="node4.html#SECTION04030000000000000000">18 Field Class</A>
<UL>
<LI><A NAME="tex2html1502"
  HREF="node4.html#SECTION04031000000000000000">18.1 Description</A>
<LI><A NAME="tex2html1503"
  HREF="node4.html#SECTION04032000000000000000">18.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1504"
  HREF="node4.html#SECTION04032100000000000000">18.2.1 Field Creation and Destruction</A>
<LI><A NAME="tex2html1505"
  HREF="node4.html#SECTION04032200000000000000">18.2.2 Get Fortran data pointer, bounds, and counts information from a Field</A>
<LI><A NAME="tex2html1506"
  HREF="node4.html#SECTION04032300000000000000">18.2.3 Get Grid and Array and other information from a Field</A>
<LI><A NAME="tex2html1507"
  HREF="node4.html#SECTION04032400000000000000">18.2.4 Create Field with Grid and Arrayspec</A>
<LI><A NAME="tex2html1508"
  HREF="node4.html#SECTION04032500000000000000">18.2.5 Create Field with Grid and Array</A>
<LI><A NAME="tex2html1509"
  HREF="node4.html#SECTION04032600000000000000">18.2.6 Create an empty Field and finish it with FieldSetCommit</A>
<LI><A NAME="tex2html1510"
  HREF="node4.html#SECTION04032700000000000000">18.2.7 Create 7D Field with 5D Grid and 2D ungridded bounds
   from Fortran data array</A>
<LI><A NAME="tex2html1511"
  HREF="node4.html#SECTION04032800000000000000">18.2.8 Create 2D Field with 2D Grid and Fortran data array</A>
<LI><A NAME="tex2html1512"
  HREF="node4.html#SECTION04032900000000000000">18.2.9 Create 2D Field with 2D Grid and Fortran data pointer</A>
<LI><A NAME="tex2html1513"
  HREF="node4.html#SECTION040321000000000000000">18.2.10 Create 3D Field with 2D Grid and 3D Fortran data array</A>
<LI><A NAME="tex2html1514"
  HREF="node4.html#SECTION040321100000000000000">18.2.11 Create 3D Field with 2D Grid and 3D Fortran data array with gridToFieldMap</A>
<LI><A NAME="tex2html1515"
  HREF="node4.html#SECTION040321200000000000000">18.2.12 Create 3D Field with 2D Grid and 3D Fortran data array with halos</A>
<LI><A NAME="tex2html1516"
  HREF="node4.html#SECTION040321300000000000000">18.2.13 Create a Field from a LocStream</A>
<LI><A NAME="tex2html1517"
  HREF="node4.html#SECTION040321400000000000000">18.2.14 Create a Field from a Mesh</A>
<LI><A NAME="tex2html1518"
  HREF="node4.html#SECTION040321500000000000000">18.2.15 Create a Field from a Mesh and an Array</A>
<LI><A NAME="tex2html1519"
  HREF="node4.html#SECTION040321600000000000000">18.2.16 Create a Field from a Mesh and an ArraySpec with optional features</A>
<LI><A NAME="tex2html1520"
  HREF="node4.html#SECTION040321700000000000000">18.2.17 Field with replicated dimension</A>
<LI><A NAME="tex2html1521"
  HREF="node4.html#SECTION040321800000000000000">18.2.18 Field on arbitrarily distributed Grid</A>
<LI><A NAME="tex2html1522"
  HREF="node4.html#SECTION040321900000000000000">18.2.19 Field on arbitrarily distributed Grid with replicated dimension and ungridded bounds</A>
<LI><A NAME="tex2html1523"
  HREF="node4.html#SECTION040322000000000000000">18.2.20 Field Regrid</A>
<LI><A NAME="tex2html1524"
  HREF="node4.html#SECTION040322100000000000000">18.2.21 Creating a Regrid Operator from two Fields</A>
<LI><A NAME="tex2html1525"
  HREF="node4.html#SECTION040322200000000000000">18.2.22 Applying the Regrid Operator to a pair of Fields</A>
<LI><A NAME="tex2html1526"
  HREF="node4.html#SECTION040322300000000000000">18.2.23 Release a Regrid Operator</A>
<LI><A NAME="tex2html1527"
  HREF="node4.html#SECTION040322400000000000000">18.2.24 Creating a Regrid Operator Using Masks</A>
<LI><A NAME="tex2html1528"
  HREF="node4.html#SECTION040322500000000000000">18.2.25 Regrid Troubleshooting Guide</A>
<LI><A NAME="tex2html1529"
  HREF="node4.html#SECTION040322600000000000000">18.2.26 Field Regrid Example: Mesh to Mesh</A>
<LI><A NAME="tex2html1530"
  HREF="node4.html#SECTION040322700000000000000">18.2.27 Gather Field data onto root PET</A>
<LI><A NAME="tex2html1531"
  HREF="node4.html#SECTION040322800000000000000">18.2.28 Scatter Field data from root PET onto its set of joint PETs</A>
<LI><A NAME="tex2html1532"
  HREF="node4.html#SECTION040322900000000000000">18.2.29 Redistribute data from source Field to destination Field</A>
<LI><A NAME="tex2html1533"
  HREF="node4.html#SECTION040323000000000000000">18.2.30 Field redistribution as a form of scattering on arbitrarily distributed structures</A>
<LI><A NAME="tex2html1534"
  HREF="node4.html#SECTION040323100000000000000">18.2.31 Sparse matrix multiplication from source Field to destination Field</A>
<LI><A NAME="tex2html1535"
  HREF="node4.html#SECTION040323200000000000000">18.2.32 Field Halo solving a domain decomposed heat transfer problem</A>
</UL>
<LI><A NAME="tex2html1536"
  HREF="node4.html#SECTION04033000000000000000">18.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1537"
  HREF="node4.html#SECTION04034000000000000000">18.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html1538"
  HREF="node4.html#SECTION04035000000000000000">18.5 Class API</A>
<UL>
<LI><A NAME="tex2html1539"
  HREF="node4.html#SECTION04035100000000000000">18.5.1 ESMF_FieldCreateEmpty</A>
<LI><A NAME="tex2html1540"
  HREF="node4.html#SECTION04035200000000000000">18.5.2 ESMF_FieldDestroy</A>
<LI><A NAME="tex2html1541"
  HREF="node4.html#SECTION04035300000000000000">18.5.3 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1542"
  HREF="node4.html#SECTION04035400000000000000">18.5.4 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1543"
  HREF="node4.html#SECTION04035500000000000000">18.5.5 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1544"
  HREF="node4.html#SECTION04035600000000000000">18.5.6 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1545"
  HREF="node4.html#SECTION04035700000000000000">18.5.7 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1546"
  HREF="node4.html#SECTION04035800000000000000">18.5.8 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1547"
  HREF="node4.html#SECTION04035900000000000000">18.5.9 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1548"
  HREF="node4.html#SECTION040351000000000000000">18.5.10 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1549"
  HREF="node4.html#SECTION040351100000000000000">18.5.11 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1550"
  HREF="node4.html#SECTION040351200000000000000">18.5.12 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1551"
  HREF="node4.html#SECTION040351300000000000000">18.5.13 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1552"
  HREF="node4.html#SECTION040351400000000000000">18.5.14 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1553"
  HREF="node4.html#SECTION040351500000000000000">18.5.15 ESMF_FieldGet</A>
<LI><A NAME="tex2html1554"
  HREF="node4.html#SECTION040351600000000000000">18.5.16 ESMF_FieldGet</A>
<LI><A NAME="tex2html1555"
  HREF="node4.html#SECTION040351700000000000000">18.5.17 ESMF_FieldGetBounds</A>
<LI><A NAME="tex2html1556"
  HREF="node4.html#SECTION040351800000000000000">18.5.18 ESMF_FieldGet</A>
<LI><A NAME="tex2html1557"
  HREF="node4.html#SECTION040351900000000000000">18.5.19 ESMF_FieldGet</A>
<LI><A NAME="tex2html1558"
  HREF="node4.html#SECTION040352000000000000000">18.5.20 ESMF_FieldGet</A>
<LI><A NAME="tex2html1559"
  HREF="node4.html#SECTION040352100000000000000">18.5.21 ESMF_FieldPrint</A>
<LI><A NAME="tex2html1560"
  HREF="node4.html#SECTION040352200000000000000">18.5.22 ESMF_FieldSetCommit</A>
<LI><A NAME="tex2html1561"
  HREF="node4.html#SECTION040352300000000000000">18.5.23 ESMF_FieldSetCommit</A>
<LI><A NAME="tex2html1562"
  HREF="node4.html#SECTION040352400000000000000">18.5.24 ESMF_FieldSetCommit</A>
<LI><A NAME="tex2html1563"
  HREF="node4.html#SECTION040352500000000000000">18.5.25 ESMF_FieldSetCommit</A>
<LI><A NAME="tex2html1564"
  HREF="node4.html#SECTION040352600000000000000">18.5.26 ESMF_FieldSetCommit</A>
<LI><A NAME="tex2html1565"
  HREF="node4.html#SECTION040352700000000000000">18.5.27 ESMF_FieldSetCommit</A>
<LI><A NAME="tex2html1566"
  HREF="node4.html#SECTION040352800000000000000">18.5.28 ESMF_FieldValidate</A>
</UL>
<LI><A NAME="tex2html1567"
  HREF="node4.html#SECTION04036000000000000000">18.6 Class API: Field Communications</A>
<UL>
<LI><A NAME="tex2html1568"
  HREF="node4.html#SECTION04036100000000000000">18.6.1 ESMF_FieldGather</A>
<LI><A NAME="tex2html1569"
  HREF="node4.html#SECTION04036200000000000000">18.6.2 ESMF_FieldHalo</A>
<LI><A NAME="tex2html1570"
  HREF="node4.html#SECTION04036300000000000000">18.6.3 ESMF_FieldHaloRelease</A>
<LI><A NAME="tex2html1571"
  HREF="node4.html#SECTION04036400000000000000">18.6.4 ESMF_FieldHaloStore</A>
<LI><A NAME="tex2html1572"
  HREF="node4.html#SECTION04036500000000000000">18.6.5 ESMF_FieldRedist</A>
<LI><A NAME="tex2html1573"
  HREF="node4.html#SECTION04036600000000000000">18.6.6 ESMF_FieldRedistRelease</A>
<LI><A NAME="tex2html1574"
  HREF="node4.html#SECTION04036700000000000000">18.6.7 ESMF_FieldRedistStore</A>
<LI><A NAME="tex2html1575"
  HREF="node4.html#SECTION04036800000000000000">18.6.8 ESMF_FieldRedistStore</A>
<LI><A NAME="tex2html1576"
  HREF="node4.html#SECTION04036900000000000000">18.6.9 ESMF_FieldRegrid</A>
<LI><A NAME="tex2html1577"
  HREF="node4.html#SECTION040361000000000000000">18.6.10 ESMF_FieldRegridRelease</A>
<LI><A NAME="tex2html1578"
  HREF="node4.html#SECTION040361100000000000000">18.6.11 ESMF_FieldRegridStore</A>
<LI><A NAME="tex2html1579"
  HREF="node4.html#SECTION040361200000000000000">18.6.12 ESMF_FieldScatter</A>
<LI><A NAME="tex2html1580"
  HREF="node4.html#SECTION040361300000000000000">18.6.13 ESMF_FieldSMM</A>
<LI><A NAME="tex2html1581"
  HREF="node4.html#SECTION040361400000000000000">18.6.14 ESMF_FieldSMMRelease</A>
<LI><A NAME="tex2html1582"
  HREF="node4.html#SECTION040361500000000000000">18.6.15 ESMF_FieldSMMStore</A>
<LI><A NAME="tex2html1583"
  HREF="node4.html#SECTION040361600000000000000">18.6.16 ESMF_FieldSMMStore</A>
</UL>
</UL>
<LI><A NAME="tex2html1584"
  HREF="node4.html#SECTION04040000000000000000">19 ArrayBundle Class</A>
<UL>
<LI><A NAME="tex2html1585"
  HREF="node4.html#SECTION04041000000000000000">19.1 Description</A>
<LI><A NAME="tex2html1586"
  HREF="node4.html#SECTION04042000000000000000">19.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1587"
  HREF="node4.html#SECTION04042100000000000000">19.2.1 ArrayBundle creation from a list of Arrays</A>
<LI><A NAME="tex2html1588"
  HREF="node4.html#SECTION04042200000000000000">19.2.2 Access Arrays inside the ArrayBundle</A>
<LI><A NAME="tex2html1589"
  HREF="node4.html#SECTION04042300000000000000">19.2.3 Destroy an ArrayBundle and its constituents</A>
<LI><A NAME="tex2html1590"
  HREF="node4.html#SECTION04042400000000000000">19.2.4 Communication - Halo</A>
</UL>
<LI><A NAME="tex2html1591"
  HREF="node4.html#SECTION04043000000000000000">19.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1592"
  HREF="node4.html#SECTION04044000000000000000">19.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html1593"
  HREF="node4.html#SECTION04045000000000000000">19.5 Class API</A>
<UL>
<LI><A NAME="tex2html1594"
  HREF="node4.html#SECTION04045100000000000000">19.5.1 ESMF_ArrayBundleCreate</A>
<LI><A NAME="tex2html1595"
  HREF="node4.html#SECTION04045200000000000000">19.5.2 ESMF_ArrayBundleDestroy</A>
<LI><A NAME="tex2html1596"
  HREF="node4.html#SECTION04045300000000000000">19.5.3 ESMF_ArrayBundleGet</A>
<LI><A NAME="tex2html1597"
  HREF="node4.html#SECTION04045400000000000000">19.5.4 ESMF_ArrayBundleHalo</A>
<LI><A NAME="tex2html1598"
  HREF="node4.html#SECTION04045500000000000000">19.5.5 ESMF_ArrayBundleHaloRelease</A>
<LI><A NAME="tex2html1599"
  HREF="node4.html#SECTION04045600000000000000">19.5.6 ESMF_ArrayBundleHaloStore</A>
<LI><A NAME="tex2html1600"
  HREF="node4.html#SECTION04045700000000000000">19.5.7 ESMF_ArrayBundlePrint</A>
<LI><A NAME="tex2html1601"
  HREF="node4.html#SECTION04045800000000000000">19.5.8 ESMF_ArrayBundleRedist</A>
<LI><A NAME="tex2html1602"
  HREF="node4.html#SECTION04045900000000000000">19.5.9 ESMF_ArrayBundleRedistRelease</A>
<LI><A NAME="tex2html1603"
  HREF="node4.html#SECTION040451000000000000000">19.5.10 ESMF_ArrayBundleRedistStore</A>
<LI><A NAME="tex2html1604"
  HREF="node4.html#SECTION040451100000000000000">19.5.11 ESMF_ArrayBundleRedistStore</A>
<LI><A NAME="tex2html1605"
  HREF="node4.html#SECTION040451200000000000000">19.5.12 ESMF_ArrayBundleSMM</A>
<LI><A NAME="tex2html1606"
  HREF="node4.html#SECTION040451300000000000000">19.5.13 ESMF_ArrayBundleSMMRelease</A>
<LI><A NAME="tex2html1607"
  HREF="node4.html#SECTION040451400000000000000">19.5.14 ESMF_ArrayBundleSMMStore</A>
<LI><A NAME="tex2html1608"
  HREF="node4.html#SECTION040451500000000000000">19.5.15 ESMF_ArrayBundleSMMStore</A>
</UL>
</UL>
<LI><A NAME="tex2html1609"
  HREF="node4.html#SECTION04050000000000000000">20 Array Class</A>
<UL>
<LI><A NAME="tex2html1610"
  HREF="node4.html#SECTION04051000000000000000">20.1 Description</A>
<LI><A NAME="tex2html1611"
  HREF="node4.html#SECTION04052000000000000000">20.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1612"
  HREF="node4.html#SECTION04052100000000000000">20.2.1 Array from native Fortran array with 1 DE per PET</A>
<LI><A NAME="tex2html1613"
  HREF="node4.html#SECTION04052200000000000000">20.2.2 Array from native Fortran array with extra elements for halo or padding</A>
<LI><A NAME="tex2html1614"
  HREF="node4.html#SECTION04052300000000000000">20.2.3 Array from <TT>ESMF_LocalArray</TT></A>
<LI><A NAME="tex2html1615"
  HREF="node4.html#SECTION04052400000000000000">20.2.4 Array creation with automatic memory allocation</A>
<LI><A NAME="tex2html1616"
  HREF="node4.html#SECTION04052500000000000000">20.2.5 Native language memory access</A>
<LI><A NAME="tex2html1617"
  HREF="node4.html#SECTION04052600000000000000">20.2.6 Regions and default bounds</A>
<LI><A NAME="tex2html1618"
  HREF="node4.html#SECTION04052700000000000000">20.2.7 Array bounds</A>
<LI><A NAME="tex2html1619"
  HREF="node4.html#SECTION04052800000000000000">20.2.8 Computational region and extra elements for halo or padding</A>
<LI><A NAME="tex2html1620"
  HREF="node4.html#SECTION04052900000000000000">20.2.9 1D and 3D Arrays</A>
<LI><A NAME="tex2html1621"
  HREF="node4.html#SECTION040521000000000000000">20.2.10 Working with Arrays of different rank</A>
<LI><A NAME="tex2html1622"
  HREF="node4.html#SECTION040521100000000000000">20.2.11 Array and DistGrid rank - 2D+1 Arrays</A>
<LI><A NAME="tex2html1623"
  HREF="node4.html#SECTION040521200000000000000">20.2.12 Arrays with replicated dimensions</A>
<LI><A NAME="tex2html1624"
  HREF="node4.html#SECTION040521300000000000000">20.2.13 Communication - Scatter and Gather</A>
<LI><A NAME="tex2html1625"
  HREF="node4.html#SECTION040521400000000000000">20.2.14 Communication - Halo</A>
<LI><A NAME="tex2html1626"
  HREF="node4.html#SECTION040521500000000000000">20.2.15 Communication - Redist</A>
<LI><A NAME="tex2html1627"
  HREF="node4.html#SECTION040521600000000000000">20.2.16 Communication - SparseMatMul</A>
<LI><A NAME="tex2html1628"
  HREF="node4.html#SECTION040521700000000000000">20.2.17 Communication - Scatter and Gather, revisited</A>
<LI><A NAME="tex2html1629"
  HREF="node4.html#SECTION040521800000000000000">20.2.18 Non-blocking Communications</A>
</UL>
<LI><A NAME="tex2html1630"
  HREF="node4.html#SECTION04053000000000000000">20.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1631"
  HREF="node4.html#SECTION04054000000000000000">20.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html1632"
  HREF="node4.html#SECTION04055000000000000000">20.5 Class API</A>
<UL>
<LI><A NAME="tex2html1633"
  HREF="node4.html#SECTION04055100000000000000">20.5.1 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html1634"
  HREF="node4.html#SECTION04055200000000000000">20.5.2 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html1635"
  HREF="node4.html#SECTION04055300000000000000">20.5.3 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html1636"
  HREF="node4.html#SECTION04055400000000000000">20.5.4 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html1637"
  HREF="node4.html#SECTION04055500000000000000">20.5.5 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html1638"
  HREF="node4.html#SECTION04055600000000000000">20.5.6 ESMF_ArrayDestroy</A>
<LI><A NAME="tex2html1639"
  HREF="node4.html#SECTION04055700000000000000">20.5.7 ESMF_ArrayGather</A>
<LI><A NAME="tex2html1640"
  HREF="node4.html#SECTION04055800000000000000">20.5.8 ESMF_ArrayGet</A>
<LI><A NAME="tex2html1641"
  HREF="node4.html#SECTION04055900000000000000">20.5.9 ESMF_ArrayGet</A>
<LI><A NAME="tex2html1642"
  HREF="node4.html#SECTION040551000000000000000">20.5.10 ESMF_ArrayGet</A>
<LI><A NAME="tex2html1643"
  HREF="node4.html#SECTION040551100000000000000">20.5.11 ESMF_ArrayGet</A>
<LI><A NAME="tex2html1644"
  HREF="node4.html#SECTION040551200000000000000">20.5.12 ESMF_ArrayHalo</A>
<LI><A NAME="tex2html1645"
  HREF="node4.html#SECTION040551300000000000000">20.5.13 ESMF_ArrayHaloRelease</A>
<LI><A NAME="tex2html1646"
  HREF="node4.html#SECTION040551400000000000000">20.5.14 ESMF_ArrayHaloStore</A>
<LI><A NAME="tex2html1647"
  HREF="node4.html#SECTION040551500000000000000">20.5.15 ESMF_ArrayPrint</A>
<LI><A NAME="tex2html1648"
  HREF="node4.html#SECTION040551600000000000000">20.5.16 ESMF_ArrayRedist</A>
<LI><A NAME="tex2html1649"
  HREF="node4.html#SECTION040551700000000000000">20.5.17 ESMF_ArrayRedistRelease</A>
<LI><A NAME="tex2html1650"
  HREF="node4.html#SECTION040551800000000000000">20.5.18 ESMF_ArrayRedistStore</A>
<LI><A NAME="tex2html1651"
  HREF="node4.html#SECTION040551900000000000000">20.5.19 ESMF_ArrayRedistStore</A>
<LI><A NAME="tex2html1652"
  HREF="node4.html#SECTION040552000000000000000">20.5.20 ESMF_ArrayScatter</A>
<LI><A NAME="tex2html1653"
  HREF="node4.html#SECTION040552100000000000000">20.5.21 ESMF_ArraySet</A>
<LI><A NAME="tex2html1654"
  HREF="node4.html#SECTION040552200000000000000">20.5.22 ESMF_ArraySMM</A>
<LI><A NAME="tex2html1655"
  HREF="node4.html#SECTION040552300000000000000">20.5.23 ESMF_ArraySMMRelease</A>
<LI><A NAME="tex2html1656"
  HREF="node4.html#SECTION040552400000000000000">20.5.24 ESMF_ArraySMMStore</A>
<LI><A NAME="tex2html1657"
  HREF="node4.html#SECTION040552500000000000000">20.5.25 ESMF_ArraySMMStore</A>
<LI><A NAME="tex2html1658"
  HREF="node4.html#SECTION040552600000000000000">20.5.26 ESMF_ArrayValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html1659"
  HREF="node4.html#SECTION04060000000000000000">21 LocalArray Class</A>
<UL>
<LI><A NAME="tex2html1660"
  HREF="node4.html#SECTION04061000000000000000">21.1 Description</A>
<LI><A NAME="tex2html1661"
  HREF="node4.html#SECTION04062000000000000000">21.2 Restrictions and Future Work</A>
<LI><A NAME="tex2html1662"
  HREF="node4.html#SECTION04063000000000000000">21.3 Class API</A>
<UL>
<LI><A NAME="tex2html1663"
  HREF="node4.html#SECTION04063100000000000000">21.3.1 ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html1664"
  HREF="node4.html#SECTION04063200000000000000">21.3.2 ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html1665"
  HREF="node4.html#SECTION04063300000000000000">21.3.3 ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html1666"
  HREF="node4.html#SECTION04063400000000000000">21.3.4 ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html1667"
  HREF="node4.html#SECTION04063500000000000000">21.3.5 ESMF_LocalArrayDestroy</A>
<LI><A NAME="tex2html1668"
  HREF="node4.html#SECTION04063600000000000000">21.3.6 ESMF_LocalArrayGet</A>
<LI><A NAME="tex2html1669"
  HREF="node4.html#SECTION04063700000000000000">21.3.7 ESMF_LocalArrayGet</A>
</UL>
</UL>
<LI><A NAME="tex2html1670"
  HREF="node4.html#SECTION04070000000000000000">22 ArraySpec Class</A>
<UL>
<LI><A NAME="tex2html1671"
  HREF="node4.html#SECTION04071000000000000000">22.1 Description</A>
<LI><A NAME="tex2html1672"
  HREF="node4.html#SECTION04072000000000000000">22.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1673"
  HREF="node4.html#SECTION04072100000000000000">22.2.1 Setting ArraySpec Values</A>
<LI><A NAME="tex2html1674"
  HREF="node4.html#SECTION04072200000000000000">22.2.2 Getting ArraySpec Values</A>
</UL>
<LI><A NAME="tex2html1675"
  HREF="node4.html#SECTION04073000000000000000">22.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1676"
  HREF="node4.html#SECTION04074000000000000000">22.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html1677"
  HREF="node4.html#SECTION04075000000000000000">22.5 Class API</A>
<UL>
<LI><A NAME="tex2html1678"
  HREF="node4.html#SECTION04075100000000000000">22.5.1 ESMF_ArraySpecGet</A>
<LI><A NAME="tex2html1679"
  HREF="node4.html#SECTION04075200000000000000">22.5.2 ESMF_ArraySpecSet</A>
<LI><A NAME="tex2html1680"
  HREF="node4.html#SECTION04075300000000000000">22.5.3 ESMF_ArraySpecValidate</A>
<LI><A NAME="tex2html1681"
  HREF="node4.html#SECTION04075400000000000000">22.5.4 ESMF_ArraySpecPrint</A>
</UL>
</UL>
<LI><A NAME="tex2html1682"
  HREF="node4.html#SECTION04080000000000000000">23 Grid Class</A>
<UL>
<LI><A NAME="tex2html1683"
  HREF="node4.html#SECTION04081000000000000000">23.1 Description</A>
<UL>
<LI><A NAME="tex2html1684"
  HREF="node4.html#SECTION04081100000000000000">23.1.1 Grid Representation in ESMF</A>
<LI><A NAME="tex2html1685"
  HREF="node4.html#SECTION04081200000000000000">23.1.2 Supported Grids</A>
<LI><A NAME="tex2html1686"
  HREF="node4.html#SECTION04081300000000000000">23.1.3 Grid Topologies and Periodicity</A>
<LI><A NAME="tex2html1687"
  HREF="node4.html#SECTION04081400000000000000">23.1.4 Grid Distribution</A>
<LI><A NAME="tex2html1688"
  HREF="node4.html#SECTION04081500000000000000">23.1.5 Grid Coordinates</A>
<LI><A NAME="tex2html1689"
  HREF="node4.html#SECTION04081600000000000000">23.1.6 Coordinate Specification and Generation</A>
<LI><A NAME="tex2html1690"
  HREF="node4.html#SECTION04081700000000000000">23.1.7 Staggering</A>
<LI><A NAME="tex2html1691"
  HREF="node4.html#SECTION04081800000000000000">23.1.8 Options for Building Grids</A>
</UL>
<LI><A NAME="tex2html1692"
  HREF="node4.html#SECTION04082000000000000000">23.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1693"
  HREF="node4.html#SECTION04082100000000000000">23.2.1 Shortcut Creation Method for Single-Tile Grids</A>
<LI><A NAME="tex2html1694"
  HREF="node4.html#SECTION04082200000000000000">23.2.2 Creating a 2D Regularly Distributed Rectilinear Grid
                    With Uniformly Spaced Coordinates</A>
<LI><A NAME="tex2html1695"
  HREF="node4.html#SECTION04082300000000000000">23.2.3 Creating a 2D Irregularly Distributed Rectilinear Grid
                    With Uniformly Spaced Coordinates</A>
<LI><A NAME="tex2html1696"
  HREF="node4.html#SECTION04082400000000000000">23.2.4 Creating a 2D Irregularly Distributed Grid
                    With Curvilinear Coordinates</A>
<LI><A NAME="tex2html1697"
  HREF="node4.html#SECTION04082500000000000000">23.2.5 Creating an Irregularly Distributed Rectilinear Grid with
                  a Non-Distributed Vertical Dimension</A>
<LI><A NAME="tex2html1698"
  HREF="node4.html#SECTION04082600000000000000">23.2.6 Creating an Arbitrarily Distributed Rectilinear Grid with
                  a Non-Distributed Vertical Dimension</A>
<LI><A NAME="tex2html1699"
  HREF="node4.html#SECTION04082700000000000000">23.2.7 Creating an Empty Grid in a Parent Component 
   for Completion in a Child Component</A>
<LI><A NAME="tex2html1700"
  HREF="node4.html#SECTION04082800000000000000">23.2.8 Grid Stagger Locations</A>
<LI><A NAME="tex2html1701"
  HREF="node4.html#SECTION04082900000000000000">23.2.9 Associating Coordinates with Stagger Locations</A>
<LI><A NAME="tex2html1702"
  HREF="node4.html#SECTION040821000000000000000">23.2.10 Specifying the Relationship of Coordinate Arrays
                 to Index Space Dimensions</A>
<LI><A NAME="tex2html1703"
  HREF="node4.html#SECTION040821100000000000000">23.2.11 Accessing Coordinates</A>
<LI><A NAME="tex2html1704"
  HREF="node4.html#SECTION040821200000000000000">23.2.12 Associating Items with Stagger Locations</A>
<LI><A NAME="tex2html1705"
  HREF="node4.html#SECTION040821300000000000000">23.2.13 Accessing Items</A>
<LI><A NAME="tex2html1706"
  HREF="node4.html#SECTION040821400000000000000">23.2.14 Grid Regions and Bounds</A>
<LI><A NAME="tex2html1707"
  HREF="node4.html#SECTION040821500000000000000">23.2.15 Getting Grid Coordinate Bounds</A>
<LI><A NAME="tex2html1708"
  HREF="node4.html#SECTION040821600000000000000">23.2.16 Getting Grid Stagger Location Bounds</A>
<LI><A NAME="tex2html1709"
  HREF="node4.html#SECTION040821700000000000000">23.2.17 Getting Grid Stagger Location Information</A>
<LI><A NAME="tex2html1710"
  HREF="node4.html#SECTION040821800000000000000">23.2.18 Creating an Array at a Stagger Location</A>
<LI><A NAME="tex2html1711"
  HREF="node4.html#SECTION040821900000000000000">23.2.19 Creating More Complex Grids Using DistGrid</A>
<LI><A NAME="tex2html1712"
  HREF="node4.html#SECTION040822000000000000000">23.2.20 Specifying Custom Stagger Locations</A>
<LI><A NAME="tex2html1713"
  HREF="node4.html#SECTION040822100000000000000">23.2.21 Specifying Custom Stagger Padding</A>
<LI><A NAME="tex2html1714"
  HREF="node4.html#SECTION040822200000000000000">23.2.22 Creating a 2D Regularly Distributed Rectilinear Grid from File</A>
</UL>
<LI><A NAME="tex2html1715"
  HREF="node4.html#SECTION04083000000000000000">23.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1716"
  HREF="node4.html#SECTION04084000000000000000">23.4 Design and Implementation Notes</A>
<UL>
<LI><A NAME="tex2html1717"
  HREF="node4.html#SECTION04084100000000000000">23.4.1 Grid Topology</A>
</UL>
<LI><A NAME="tex2html1718"
  HREF="node4.html#SECTION04085000000000000000">23.5 Grid Options</A>
<UL>
<LI><A NAME="tex2html1719"
  HREF="node4.html#SECTION04085100000000000000">23.5.1 ESMF_GridConn</A>
<LI><A NAME="tex2html1720"
  HREF="node4.html#SECTION04085200000000000000">23.5.2 ESMF_GridStatus</A>
<LI><A NAME="tex2html1721"
  HREF="node4.html#SECTION04085300000000000000">23.5.3 ESMF_GridItem</A>
<LI><A NAME="tex2html1722"
  HREF="node4.html#SECTION04085400000000000000">23.5.4 ESMF_StaggerLoc</A>
</UL>
<LI><A NAME="tex2html1723"
  HREF="node4.html#SECTION04086000000000000000">23.6 Class API: General Grid Methods</A>
<UL>
<LI><A NAME="tex2html1724"
  HREF="node4.html#SECTION04086100000000000000">23.6.1 ESMF_GridAddCoord</A>
<LI><A NAME="tex2html1725"
  HREF="node4.html#SECTION04086200000000000000">23.6.2 ESMF_GridAddItem</A>
<LI><A NAME="tex2html1726"
  HREF="node4.html#SECTION04086300000000000000">23.6.3 ESMF_GridCreate</A>
<LI><A NAME="tex2html1727"
  HREF="node4.html#SECTION04086400000000000000">23.6.4 ESMF_GridCreate</A>
<LI><A NAME="tex2html1728"
  HREF="node4.html#SECTION04086500000000000000">23.6.5 ESMF_GridCreate</A>
<LI><A NAME="tex2html1729"
  HREF="node4.html#SECTION04086600000000000000">23.6.6 ESMF_GridCreateEmpty</A>
<LI><A NAME="tex2html1730"
  HREF="node4.html#SECTION04086700000000000000">23.6.7 ESMF_GridCreateShapeTile</A>
<LI><A NAME="tex2html1731"
  HREF="node4.html#SECTION04086800000000000000">23.6.8 ESMF_GridCreateShapeTile</A>
<LI><A NAME="tex2html1732"
  HREF="node4.html#SECTION04086900000000000000">23.6.9 ESMF_GridCreateShapeTile</A>
<LI><A NAME="tex2html1733"
  HREF="node4.html#SECTION040861000000000000000">23.6.10 ESMF_GridDestroy</A>
<LI><A NAME="tex2html1734"
  HREF="node4.html#SECTION040861100000000000000">23.6.11 ESMF_GridGet</A>
<LI><A NAME="tex2html1735"
  HREF="node4.html#SECTION040861200000000000000">23.6.12 ESMF_GridGet</A>
<LI><A NAME="tex2html1736"
  HREF="node4.html#SECTION040861300000000000000">23.6.13 ESMF_GridGet</A>
<LI><A NAME="tex2html1737"
  HREF="node4.html#SECTION040861400000000000000">23.6.14 ESMF_GridGetCoord</A>
<LI><A NAME="tex2html1738"
  HREF="node4.html#SECTION040861500000000000000">23.6.15 ESMF_GridGetCoord</A>
<LI><A NAME="tex2html1739"
  HREF="node4.html#SECTION040861600000000000000">23.6.16 ESMF_GridGetCoord</A>
<LI><A NAME="tex2html1740"
  HREF="node4.html#SECTION040861700000000000000">23.6.17 ESMF_GridGetCoord</A>
<LI><A NAME="tex2html1741"
  HREF="node4.html#SECTION040861800000000000000">23.6.18 ESMF_GridGetCoord</A>
<LI><A NAME="tex2html1742"
  HREF="node4.html#SECTION040861900000000000000">23.6.19 ESMF_GridGetItem</A>
<LI><A NAME="tex2html1743"
  HREF="node4.html#SECTION040862000000000000000">23.6.20 ESMF_GridGetItem</A>
<LI><A NAME="tex2html1744"
  HREF="node4.html#SECTION040862100000000000000">23.6.21 ESMF_GridGetItem</A>
<LI><A NAME="tex2html1745"
  HREF="node4.html#SECTION040862200000000000000">23.6.22 ESMF_GridGetStatus</A>
<LI><A NAME="tex2html1746"
  HREF="node4.html#SECTION040862300000000000000">23.6.23 ESMF_GridMatch</A>
<LI><A NAME="tex2html1747"
  HREF="node4.html#SECTION040862400000000000000">23.6.24 ESMF_GridSetCoord</A>
<LI><A NAME="tex2html1748"
  HREF="node4.html#SECTION040862500000000000000">23.6.25 ESMF_GridSetCommitShapeTile</A>
<LI><A NAME="tex2html1749"
  HREF="node4.html#SECTION040862600000000000000">23.6.26 ESMF_GridSetCommitShapeTile</A>
<LI><A NAME="tex2html1750"
  HREF="node4.html#SECTION040862700000000000000">23.6.27 ESMF_GridSetCommitShapeTile</A>
<LI><A NAME="tex2html1751"
  HREF="node4.html#SECTION040862800000000000000">23.6.28 ESMF_GridSetItem</A>
<LI><A NAME="tex2html1752"
  HREF="node4.html#SECTION040862900000000000000">23.6.29 ESMF_GridValidate</A>
</UL>
<LI><A NAME="tex2html1753"
  HREF="node4.html#SECTION04087000000000000000">23.7 Class API: StaggerLoc Methods</A>
<UL>
<LI><A NAME="tex2html1754"
  HREF="node4.html#SECTION04087100000000000000">23.7.1 ESMF_StaggerLocSet</A>
<LI><A NAME="tex2html1755"
  HREF="node4.html#SECTION04087200000000000000">23.7.2 ESMF_StaggerLocSet</A>
<LI><A NAME="tex2html1756"
  HREF="node4.html#SECTION04087300000000000000">23.7.3 ESMF_StaggerLocString</A>
<LI><A NAME="tex2html1757"
  HREF="node4.html#SECTION04087400000000000000">23.7.4 ESMF_StaggerLocPrint</A>
</UL>
</UL>
<LI><A NAME="tex2html1758"
  HREF="node4.html#SECTION04090000000000000000">24 LocStream Class</A>
<UL>
<LI><A NAME="tex2html1759"
  HREF="node4.html#SECTION04091000000000000000">24.1 Description</A>
<UL>
<LI><A NAME="tex2html1760"
  HREF="node4.html#SECTION04091100000000000000">24.1.1 How is a LocStream different than a Grid?</A>
<LI><A NAME="tex2html1761"
  HREF="node4.html#SECTION04091200000000000000">24.1.2 How is a LocStream different than a Mesh?</A>
</UL>
<LI><A NAME="tex2html1762"
  HREF="node4.html#SECTION04092000000000000000">24.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1763"
  HREF="node4.html#SECTION04092100000000000000">24.2.1 Creating a LocStream Employing User Allocated Memory</A>
<LI><A NAME="tex2html1764"
  HREF="node4.html#SECTION04092200000000000000">24.2.2 Creating a LocStream Employing Internally Allocated Memory</A>
<LI><A NAME="tex2html1765"
  HREF="node4.html#SECTION04092300000000000000">24.2.3 Creating a LocStream from a Background Grid</A>
</UL>
<LI><A NAME="tex2html1766"
  HREF="node4.html#SECTION04093000000000000000">24.3 Class API</A>
<UL>
<LI><A NAME="tex2html1767"
  HREF="node4.html#SECTION04093100000000000000">24.3.1 ESMF_LocStreamAddKey</A>
<LI><A NAME="tex2html1768"
  HREF="node4.html#SECTION04093200000000000000">24.3.2 ESMF_LocStreamAddKey</A>
<LI><A NAME="tex2html1769"
  HREF="node4.html#SECTION04093300000000000000">24.3.3 ESMF_LocStreamAddKey</A>
<LI><A NAME="tex2html1770"
  HREF="node4.html#SECTION04093400000000000000">24.3.4 ESMF_LocStreamAddKey</A>
<LI><A NAME="tex2html1771"
  HREF="node4.html#SECTION04093500000000000000">24.3.5 ESMF_LocStreamAddKey</A>
<LI><A NAME="tex2html1772"
  HREF="node4.html#SECTION04093600000000000000">24.3.6 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html1773"
  HREF="node4.html#SECTION04093700000000000000">24.3.7 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html1774"
  HREF="node4.html#SECTION04093800000000000000">24.3.8 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html1775"
  HREF="node4.html#SECTION04093900000000000000">24.3.9 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html1776"
  HREF="node4.html#SECTION040931000000000000000">24.3.10 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html1777"
  HREF="node4.html#SECTION040931100000000000000">24.3.11 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html1778"
  HREF="node4.html#SECTION040931200000000000000">24.3.12 ESMF_LocStreamDestroy</A>
<LI><A NAME="tex2html1779"
  HREF="node4.html#SECTION040931300000000000000">24.3.13 ESMF_LocStreamGet</A>
<LI><A NAME="tex2html1780"
  HREF="node4.html#SECTION040931400000000000000">24.3.14 ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html1781"
  HREF="node4.html#SECTION040931500000000000000">24.3.15 ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html1782"
  HREF="node4.html#SECTION040931600000000000000">24.3.16 ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html1783"
  HREF="node4.html#SECTION040931700000000000000">24.3.17 ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html1784"
  HREF="node4.html#SECTION040931800000000000000">24.3.18 ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html1785"
  HREF="node4.html#SECTION040931900000000000000">24.3.19 ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html1786"
  HREF="node4.html#SECTION040932000000000000000">24.3.20 ESMF_LocStreamGet</A>
<LI><A NAME="tex2html1787"
  HREF="node4.html#SECTION040932100000000000000">24.3.21 ESMF_LocStreamPrint</A>
<LI><A NAME="tex2html1788"
  HREF="node4.html#SECTION040932200000000000000">24.3.22 ESMF_LocStreamValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html1789"
  HREF="node4.html#SECTION040100000000000000000">25 Mesh Class</A>
<UL>
<LI><A NAME="tex2html1790"
  HREF="node4.html#SECTION040101000000000000000">25.1 Description</A>
<UL>
<LI><A NAME="tex2html1791"
  HREF="node4.html#SECTION040101100000000000000">25.1.1 Mesh Representation in ESMF</A>
<LI><A NAME="tex2html1792"
  HREF="node4.html#SECTION040101200000000000000">25.1.2 Supported Meshes</A>
</UL>
<LI><A NAME="tex2html1793"
  HREF="node4.html#SECTION040102000000000000000">25.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1794"
  HREF="node4.html#SECTION040102100000000000000">25.2.1 Mesh Creation</A>
<LI><A NAME="tex2html1795"
  HREF="node4.html#SECTION040102200000000000000">25.2.2 Example: Creating a Small Single PET Mesh in one Step</A>
<LI><A NAME="tex2html1796"
  HREF="node4.html#SECTION040102300000000000000">25.2.3 Example: Creating a Small Single PET Mesh in Three Steps</A>
<LI><A NAME="tex2html1797"
  HREF="node4.html#SECTION040102400000000000000">25.2.4 Example: Creating a Small Mesh on 4 PETs in One Step</A>
<LI><A NAME="tex2html1798"
  HREF="node4.html#SECTION040102500000000000000">25.2.5 Removing Mesh Memory</A>
</UL>
<LI><A NAME="tex2html1799"
  HREF="node4.html#SECTION040103000000000000000">25.3 Mesh Options</A>
<UL>
<LI><A NAME="tex2html1800"
  HREF="node4.html#SECTION040103100000000000000">25.3.1 ESMF_MeshElemType</A>
</UL>
<LI><A NAME="tex2html1801"
  HREF="node4.html#SECTION040104000000000000000">25.4 Class API</A>
<UL>
<LI><A NAME="tex2html1802"
  HREF="node4.html#SECTION040104100000000000000">25.4.1 ESMF_MeshAddElements</A>
<LI><A NAME="tex2html1803"
  HREF="node4.html#SECTION040104200000000000000">25.4.2 ESMF_MeshAddNodes</A>
<LI><A NAME="tex2html1804"
  HREF="node4.html#SECTION040104300000000000000">25.4.3 ESMF_MeshCreate</A>
<LI><A NAME="tex2html1805"
  HREF="node4.html#SECTION040104400000000000000">25.4.4 ESMF_MeshCreate</A>
<LI><A NAME="tex2html1806"
  HREF="node4.html#SECTION040104500000000000000">25.4.5 ESMF_MeshDestroy</A>
<LI><A NAME="tex2html1807"
  HREF="node4.html#SECTION040104600000000000000">25.4.6 ESMF_MeshFreeMemory</A>
<LI><A NAME="tex2html1808"
  HREF="node4.html#SECTION040104700000000000000">25.4.7 ESMF_MeshGet</A>
</UL>
</UL>
<LI><A NAME="tex2html1809"
  HREF="node4.html#SECTION040110000000000000000">26 DistGrid Class</A>
<UL>
<LI><A NAME="tex2html1810"
  HREF="node4.html#SECTION040111000000000000000">26.1 Description</A>
<LI><A NAME="tex2html1811"
  HREF="node4.html#SECTION040112000000000000000">26.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1812"
  HREF="node4.html#SECTION040112100000000000000">26.2.1 Single patch DistGrid with regular decomposition</A>
<LI><A NAME="tex2html1813"
  HREF="node4.html#SECTION040112200000000000000">26.2.2 DistGrid and DELayout</A>
<LI><A NAME="tex2html1814"
  HREF="node4.html#SECTION040112300000000000000">26.2.3 Single patch DistGrid with decomposition by DE blocks</A>
<LI><A NAME="tex2html1815"
  HREF="node4.html#SECTION040112400000000000000">26.2.4 Single patch DistGrid with periodic boundaries</A>
<LI><A NAME="tex2html1816"
  HREF="node4.html#SECTION040112500000000000000">26.2.5 2D patchwork DistGrid with regular decomposition</A>
<LI><A NAME="tex2html1817"
  HREF="node4.html#SECTION040112600000000000000">26.2.6 Arbitrary DistGrids with user-supplied sequence indices</A>
</UL>
<LI><A NAME="tex2html1818"
  HREF="node4.html#SECTION040113000000000000000">26.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1819"
  HREF="node4.html#SECTION040114000000000000000">26.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html1820"
  HREF="node4.html#SECTION040115000000000000000">26.5 Class API</A>
<UL>
<LI><A NAME="tex2html1821"
  HREF="node4.html#SECTION040115100000000000000">26.5.1 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html1822"
  HREF="node4.html#SECTION040115200000000000000">26.5.2 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html1823"
  HREF="node4.html#SECTION040115300000000000000">26.5.3 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html1824"
  HREF="node4.html#SECTION040115400000000000000">26.5.4 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html1825"
  HREF="node4.html#SECTION040115500000000000000">26.5.5 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html1826"
  HREF="node4.html#SECTION040115600000000000000">26.5.6 ESMF_DistGridDestroy</A>
<LI><A NAME="tex2html1827"
  HREF="node4.html#SECTION040115700000000000000">26.5.7 ESMF_DistGridGet</A>
<LI><A NAME="tex2html1828"
  HREF="node4.html#SECTION040115800000000000000">26.5.8 ESMF_DistGridGet</A>
<LI><A NAME="tex2html1829"
  HREF="node4.html#SECTION040115900000000000000">26.5.9 ESMF_DistGridGet</A>
<LI><A NAME="tex2html1830"
  HREF="node4.html#SECTION0401151000000000000000">26.5.10 ESMF_DistGridPrint</A>
<LI><A NAME="tex2html1831"
  HREF="node4.html#SECTION0401151100000000000000">26.5.11 ESMF_DistGridMatch</A>
<LI><A NAME="tex2html1832"
  HREF="node4.html#SECTION0401151200000000000000">26.5.12 ESMF_DistGridValidate</A>
<LI><A NAME="tex2html1833"
  HREF="node4.html#SECTION0401151300000000000000">26.5.13 ESMF_DistGridConnection</A>
</UL>
</UL>
<LI><A NAME="tex2html1834"
  HREF="node4.html#SECTION040120000000000000000">27 IO Class</A>
<UL>
<LI><A NAME="tex2html1835"
  HREF="node4.html#SECTION040121000000000000000">27.1 Description</A>
<LI><A NAME="tex2html1836"
  HREF="node4.html#SECTION040122000000000000000">27.2 I/O architecture</A>
<LI><A NAME="tex2html1837"
  HREF="node4.html#SECTION040123000000000000000">27.3 Data models</A>
<LI><A NAME="tex2html1838"
  HREF="node4.html#SECTION040124000000000000000">27.4 ESMF metadata conventions</A>
<LI><A NAME="tex2html1839"
  HREF="node4.html#SECTION040125000000000000000">27.5 Data formats</A>
<LI><A NAME="tex2html1840"
  HREF="node4.html#SECTION040126000000000000000">27.6 Parallel I/O</A>
<LI><A NAME="tex2html1841"
  HREF="node4.html#SECTION040127000000000000000">27.7 Synchronous and Asynchronous IO</A>
<LI><A NAME="tex2html1842"
  HREF="node4.html#SECTION040128000000000000000">27.8 Location</A>
<LI><A NAME="tex2html1843"
  HREF="node4.html#SECTION040129000000000000000">27.9 Scope</A>
<LI><A NAME="tex2html1844"
  HREF="node4.html#SECTION0401210000000000000000">27.10 Restrictions and Future Work</A>
<LI><A NAME="tex2html1845"
  HREF="node4.html#SECTION0401211000000000000000">27.11 Design and Implementation Notes</A>
</UL>
<LI><A NAME="tex2html1846"
  HREF="node4.html#SECTION040130000000000000000">28 IOSpec Class</A>
<UL>
<LI><A NAME="tex2html1847"
  HREF="node4.html#SECTION040131000000000000000">28.1 Description</A>
<LI><A NAME="tex2html1848"
  HREF="node4.html#SECTION040132000000000000000">28.2 Use and Examples</A>
<LI><A NAME="tex2html1849"
  HREF="node4.html#SECTION040133000000000000000">28.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1850"
  HREF="node4.html#SECTION040134000000000000000">28.4 Class API</A>
<UL>
<LI><A NAME="tex2html1851"
  HREF="node4.html#SECTION040134100000000000000">28.4.1 ESMF_IOSpecGet</A>
<LI><A NAME="tex2html1852"
  HREF="node4.html#SECTION040134200000000000000">28.4.2 ESMF_IOSpecSet</A>
</UL>
</UL>
<LI><A NAME="tex2html1853"
  HREF="node4.html#SECTION040140000000000000000">29 Overview of Distributed Data Methods</A>
<UL>
<LI><A NAME="tex2html1854"
  HREF="node4.html#SECTION040141000000000000000">29.1 Higher Level Functions</A>
<LI><A NAME="tex2html1855"
  HREF="node4.html#SECTION040142000000000000000">29.2 Lower Level Functions</A>
<LI><A NAME="tex2html1856"
  HREF="node4.html#SECTION040143000000000000000">29.3 Common Options</A>
<LI><A NAME="tex2html1857"
  HREF="node4.html#SECTION040144000000000000000">29.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html1858"
  HREF="node4.html#SECTION040145000000000000000">29.5 Object Model</A>
<LI><A NAME="tex2html1859"
  HREF="node4.html#SECTION040146000000000000000">29.6 File Based Regrid Weight Applications</A>
<UL>
<LI><A NAME="tex2html1860"
  HREF="node4.html#SECTION040146100000000000000">29.6.1 Structured Grid to Structured Grid</A>
<LI><A NAME="tex2html1861"
  HREF="node4.html#SECTION040146200000000000000">29.6.2 Cubed Sphere to Structured Grid</A>
</UL></UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION04000000000000000000">
3 Infrastructure:  Fields and Grids</A>
</H1>

<P>

<P>

<H1><A NAME="SECTION04010000000000000000">
16 Overview of Infrastructure Data Handling</A>
</H1>

The ESMF infrastructure data classes are part of the framework's 
hierarchy of structures for handling Earth system model data and 
metadata on parallel platforms.  The hierarchy is in complexity; the 
simplest data class in the infrastructure represents a distributed 
array and the most complex data class represents a bundle of physical 
fields that are discretized on the same grid.  Data class methods 
are called both from user-written code and from other classes 
internal to the framework. 

Data classes are distributed over <B>DE</B>s, or <B>Decomposition Elements</B>.  
A DE represents a piece of a decomposition.  A DELayout is a collection
of DEs with some associated connectivity that describes a specific 
distribution.  For example, the distribution of a grid divided 
into four segments in the x-dimension would be expressed in ESMF as
a DELayout with four DEs lying along an x-axis. This abstract concept 
enables a data decomposition to be defined in 
terms of threads, MPI processes, virtual decomposition elements, or
combinations of these without changes to user code.  This is a
primary strategy for ensuring optimal performance and portability
for codes using the ESMF for communications.

ESMF data classes are useful because they provide a standard, 
convenient way for developers to collect together information 
related to model or observational data.  The information assembled 
in a data class includes a data pointer, a set of attributes 
(e.g. units, although attributes can also be user-defined), and a 
description of an associated grid.  The same set of information within 
an ESMF data object can be used by the framework to arrange 
intercomponent data transfers, to perform I/O, for communications
such as gathers and scatters, for simplification of interfaces 
within user code, for debugging, and for other functions.  
This unifies and organizes codes overall so that the user need not
define different representations of metadata for the same field 
for I/O and for component coupling.  

Since it is critical that users be able to introduce ESMF into their
codes easily and incrementally, ESMF data classes can be created based 
on native Fortran pointers.  Likewise, there are methods for retrieving 
native Fortran pointers from within ESMF data objects.  This allows
the user to perform allocations using ESMF, and to retrieve Fortran
arrays later for optimized model calculations.  The ESMF data classes 
do not have associated differential operators or other mathematical 
methods.

For flexibility, it is not necessary to build an ESMF data object 
all at once.  For example, it's possible to create a 
field but to defer allocation of the associated field data until 
a later time.

<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Hierarchy of data structures designed specifically for the Earth 
system domain and high performance, parallel computing.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Multi-use ESMF structures simplify user code overall.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Data objects support incremental construction and deferred allocation.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Native Fortran arrays can be associated with or retrieved from ESMF data
objects, for ease of adoption, convenience, and performance.</TD>
</TR>
</TABLE>
</DIV>
<H2><A NAME="SECTION04011000000000000000">
16.1 Infrastructure Data Classes</A>
</H2>

The main classes that are used for model and observational data manipulation
are as follows:

<UL>
<LI><B>Array</B>  An ESMF Array contains a data pointer, 
information about its associated datatype, precision, and 
dimension.  

Data elements in Arrays are partitioned into categories 
defined by the role the data element plays in distributed halo 
operations.  Haloing - sometimes called ghosting - is the 
practice of copying portions of array data to multiple memory 
locations to ensure that data dependencies can be satisfied 
quickly when performing a calculation.  ESMF Arrays contain 
an <B>exclusive</B> domain, which contains data elements
updated exclusively and definitively by a given DE; a 
<B>computational</B> domain, which contains all data elements
with values that are updated by the DE in computations; and 
a <B>total</B> domain, which includes both the computational 
domain and data elements from other DEs which may be read 
but are not updated in computations.

</LI>
<LI><B>ArrayBundle</B> ArrayBundles are collections of
Arrays that are stored in a single object.  Unlike FieldBundles,
they don't need to be distributed the same way across PETs.  The
motivation for ArrayBundles is both convenience and performance.

</LI>
<LI><B>Field</B>  A Field holds model and/or observational 
data together with its underlying grid or set of spatial 
locations.  It provides methods for configuration, 
initialization, setting and retrieving data values, 
data I/O, data regridding, and manipulation of attributes.

</LI>
<LI><B>FieldBundle</B> Groups of Fields on the same underlying 
physical grid can be collected into a single object called a FieldBundle.  
A FieldBundle provides two major functions: it allows groups of 
Fields to be manipulated using a single identifier, for example 
during export or import of data between Components; and 
it allows data from multiple Fields to be packed together 
in memory for higher locality of reference and ease in 
subsetting operations.  Packing a set of Fields into a single
FieldBundle before performing a data communication allows the set 
to be transferred at once rather than as a Field at a time.
This can improve performance on high-latency platforms.

FieldBundle objects contain methods for setting and retrieving constituent 
fields, regridding, data I/O, and reordering of data in memory.

</LI>
</UL>


<P>

<P>

<H2><A NAME="SECTION04012000000000000000">
16.2 Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>In communication methods such as Regrid, Redist, Scatter, etc. 
the FieldBundle and Field code cascades down through the Array code, so 
that the actual computations exist in only one place in the source.

<P>
</LI>
</OL>

<P>

<P>

<P>

<H1><A NAME="SECTION04020000000000000000">
17 FieldBundle Class</A>
</H1>

<P>

<H2><A NAME="SECTION04021000000000000000">
17.1 Description</A>
</H2>

<P>
A FieldBundle functions mainly as a convenient container for storing
similar Fields.  It represents ``bundles'' of Fields that are 
discretized on the same Grid and distributed in the same manner.
It is an important data structure because this is often the form that
data being transferred between Components takes.  

<P>
Fields within a FieldBundle may be located at different locations relative 
to the vertices of their common Grid.  The Fields in a FieldBundle may
be of different dimensions, as long as the Grid dimensions that 
are distributed are the same.  For example, a surface Field on 
a distributed lat/lon Grid and a 3D Field with an added vertical 
dimension on the same distributed lat/lon Grid can be included
in the same FieldBundle.

<P>
FieldBundles can be created and destroyed, can have Attributes 
added or retrieved, and can have Fields added or retrieved.
Methods include queries that return information about the FieldBundle
itself and about the Fields that it contains.  The Fortran 
data pointer of a Field within a FieldBundle can be obtained 
by first retrieving the the Field with a call to <TT>ESMF_FieldBundleGet</TT>,
and then using the <TT>ESMF_FieldGet()</TT> method to get the data.

<P>
FieldBundles can be added to States, which are used for sending
to or receiving data from Components.

<P>
In the future FieldBundles will serve as a mechanism for performance
optimization.  ESMF will take advantage of the similarities of the
Fields within a FieldBundle in order to implement collective communication,
IO, and regridding.  See Section <A HREF="node4.html#sec:bundlerest">17.4</A> for a 
description of features that are being planned.

<P>

<P>

<H2><A NAME="SECTION04022000000000000000">
17.2 FieldBundle Options</A>
</H2>

<P>

<H3><A NAME="SECTION04022100000000000000">
17.2.1 ESMF_PackFlag</A>
</H3>

<P>
<A NAME="opt:packflag"></A><I>DESCRIPTION:
<BR></I>
Specifies whether a FieldBundle is packed or not.  A packed 
FieldBundle contains an array in which all the data in its 
constituent Fields is packed contiguously.  FieldBundles that
are not packed are not guaranteed to carry a contiguous 
array of their data.  This flag is not yet implemented;
the value is always set to <TT>ESMF_NO_PACKED_DATA</TT>.

<P>
Valid values are:
<DL>
<DT><STRONG>ESMF_PACKED_DATA</STRONG></DT>
<DD>Contains a packed array.
   
</DD>
<DT><STRONG>ESMF_NO_PACKED_DATA</STRONG></DT>
<DD>Does not contain a packed array.
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION04023000000000000000">
17.3 Use and Examples</A>
</H2>

<P>
Examples of creating, destroying and accessing FieldBundles and their
constituent Fields are provided in this section, along with some
notes on FieldBundle methods.

<P>

<H3><A NAME="SECTION04023100000000000000">
17.3.1 FieldBundle Creation</A>
</H3>

<P>
After creating multiple Fields, a FieldBundle
can be created by passing a list of the Fields into the 
method <TT>ESMF_FieldBundleCreate()</TT>.  The FieldBundle will contain
references to the Fields.  An empty FieldBundle can also be created
and Fields added one at a time or in groups.

<P>

<H3><A NAME="SECTION04023200000000000000">
17.3.2 Accessing FieldBundle Data</A>
</H3>

<P>
To access data in a FieldBundle the user can provide a Field
name and retrieve the Field's Fortran data pointer.  Alternatively,
the user can retrieve the data in the form of an ESMF 
Field and use the Field-level interfaces.

<P>

<H3><A NAME="SECTION04023300000000000000">
17.3.3 FieldBundle Deletion</A>
</H3>

<P>
The user must call <TT>ESMF_FieldBundleDestroy()</TT> before 
deleting any of the Fields it contains.  Because Fields
can be shared by multiple FieldBundles and States, they are
not deleted by this call.

<P>

<P>

<P>

<P>
See the following code fragments for examples of how to create new FieldBundles.

<P>
<PRE>
 
     ! Example program showing various ways to create a FieldBundle object.
 
     program ESMF_FieldBundleCreateEx
 
     ! ESMF Framework module
     use ESMF_Mod
 
     implicit none
     
     ! Local variables
     integer :: i, rc, fieldcount
     type(ESMF_Grid) :: grid
     type(ESMF_ArraySpec) :: arrayspec
     character (len = ESMF_MAXSTR) :: bname1, fname1, fname2
     type(ESMF_Field) :: field(10), returnedfield1, returnedfield2, simplefield
     type(ESMF_FieldBundle) :: bundle1, bundle2, bundle3
</PRE> 

<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Create several Fields and add them to a new FieldBundle.
 
    grid = ESMF_GridCreateShapeTile(minIndex=(/1,1/), maxIndex=(/100,200/), &amp;
                                  regDecomp=(/2,2/), name="atmgrid", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R8, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    field(1) = ESMF_FieldCreate(grid, arrayspec, &amp;
                                staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
                                name="pressure", rc=rc)
</PRE>

<P>
<PRE>
    field(2) = ESMF_FieldCreate(grid, arrayspec, &amp;
                                staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
                                name="temperature", rc=rc)
</PRE>

<P>
<PRE>
    field(3) = ESMF_FieldCreate(grid, arrayspec, &amp;
                                staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
                                name="heat flux", rc=rc)
</PRE>

<P>
<PRE>
    bundle1 = ESMF_FieldBundleCreate(3, field, name="atmosphere data", rc=rc)

    print *, "FieldBundle example 1 returned"
</PRE>

<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Create an empty FieldBundle and then add a single field to it.


    simplefield = ESMF_FieldCreate(grid, arrayspec, &amp;
                                staggerloc=ESMF_STAGGERLOC_CENTER, name="rh", rc=rc)
</PRE>

<P>
<PRE>
    bundle2 = ESMF_FieldBundleCreate(name="time step 1", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleAdd(bundle2, simplefield, rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle2, fieldCount=fieldcount, rc=rc)

    print *, "FieldBundle example 2 returned, fieldcount =", fieldcount
</PRE>

<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Create an empty FieldBundle and then add multiple fields to it.


    bundle3 = ESMF_FieldBundleCreate(name="southern hemisphere", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleAdd(bundle3, 3, field, rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle3, fieldCount=fieldcount, rc=rc)

    print *, "FieldBundle example 3 returned, fieldcount =", fieldcount
</PRE>

<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Get a Field back from a FieldBundle, first by name and then by index.
!   !  Also get the FieldBundle name.

    call ESMF_FieldBundleGet(bundle1, "pressure", returnedfield1, rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldGet(returnedfield1, name=fname1, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle1, 2, returnedfield2, rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldGet(returnedfield2, name=fname2, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle1, name=bname1, rc=rc)

    print *, "FieldBundle example 4 returned, field names = ", &amp;
                   trim(fname1), ", ", trim(fname2)
    print *, "FieldBundle name = ", trim(bname1)
</PRE>

<P>
<PRE>
!-------------------------------------------------------------------------

     call ESMF_FieldBundleDestroy(bundle1, rc=rc)
</PRE>

<P>
<PRE>
     call ESMF_FieldBundleDestroy(bundle2, rc=rc)
</PRE>

<P>
<PRE>
     call ESMF_FieldBundleDestroy(bundle3, rc=rc)
</PRE>

<P>
<PRE>
     do i=1, 3
         call ESMF_FieldDestroy(field(i),rc=rc)
</PRE>

<P>
<PRE>
     enddo

     call ESMF_FieldDestroy(simplefield, rc=rc)
</PRE>

<P>
<PRE>
     end program ESMF_FieldBundleCreateEx
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04023400000000000000"></A>
   <A NAME="sec:fieldbundle:usage:redist_1dptr"></A>
<BR>
17.3.4 Redistribute data from source FieldBundle to destination FieldBundle
</H3>

<P>
A user can use <TT>ESMF_FieldBundleRedist</TT> interface to redistribute data from 
   source FieldBundle to destination FieldBundle. This interface is overloaded by type and kind;
   In the version of <TT>ESMF_FieldBundleRedist</TT> without factor argument, a default value
   of factor 1 is used.

<P>
In this example, we first create two FieldBundles, a source FieldBundle and a destination
   FieldBundle. Then we use <TT>ESMF_FieldBundleRedist</TT> to
   redistribute data from source FieldBundle to destination FieldBundle. 

<P>
<PRE>
    ! retrieve VM and its context info such as PET number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_VMGet(vm, localPet=lpe, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create distgrid and grid for field and fieldbundle creation
    distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
        regDecomp=(/2,2/), rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_ArraySpecSet(arrayspec, 3, ESMF_TYPEKIND_I4, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create src and dst FieldBundles pair
    srcFieldBundle = ESMF_FieldBundleCreate(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    dstFieldBundle = ESMF_FieldBundleCreate(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create src and dst Fields and add the Fields into FieldBundles
    do i = 1, 3
        srcField(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
            ungriddedLBound=(/1/), ungriddedUBound=(/4/), &amp;
            maxHaloLWidth=(/1,1/), maxHaloUWidth=(/1,2/), &amp;
            rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        call ESMF_FieldGet(srcField(i), localDe=0, farrayPtr=srcfptr, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        srcfptr = lpe

        call ESMF_FieldBundleAdd(srcFieldBundle, srcField(i), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        dstField(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
            ungriddedLBound=(/1/), ungriddedUBound=(/4/), &amp;
            maxHaloLWidth=(/1,1/), maxHaloUWidth=(/1,2/), &amp;
            rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        call ESMF_FieldGet(dstField(i), localDe=0, farrayPtr=dstfptr, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        dstfptr = 0

        call ESMF_FieldBundleAdd(dstFieldBundle, dstField(i), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! perform redist
    call ESMF_FieldBundleRedistStore(srcFieldBundle, dstFieldBundle, routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldBundleRedist(srcFieldBundle, dstFieldBundle, routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! verify redist
    do l = 1, 3
        call ESMF_FieldGet(dstField(l), localDe=0, farrayPtr=fptr, &amp;
          exclusiveLBound=exLB, exclusiveUBound=exUB, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        ! Verify that the redistributed data in dstField is correct.
        ! Before the redist op, the dst Field contains all 0. 
        ! The redist op reset the values to the PE value, verify this is the case.
        ! MUST use exclusive bounds because Redist operates within excl. region.
        do k = exLB(3), exUB(3)
            do j = exLB(2), exUB(2)
                do i = exLB(1), exUB(1)
                   if(fptr(i,j,k) .ne. lpe) finalrc = ESMF_FAILURE
                enddo
            enddo
        enddo
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! release route handle
    call ESMF_FieldRedistRelease(routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldBundleDestroy(srcFieldBundle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_FieldBundleDestroy(dstFieldBundle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    do i = 1, 3
        call ESMF_FieldDestroy(srcField(i), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
        call ESMF_FieldDestroy(dstField(i), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo
    call ESMF_GridDestroy(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_DistGridDestroy(distgrid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04023500000000000000"></A>
   <A NAME="sec:fieldbundle:usage:smm_1dptr"></A>
<BR>
17.3.5 Perform Sparse Matrix Multiplication from source FieldBundle 
    to destination FieldBundle
</H3>

<P>
A user can use <TT>ESMF_FieldBundleSMM</TT> interface to perform SMM from 
   source FieldBundle to destination FieldBundle. This interface is overloaded by type and kind;

<P>
In this example, we first create two FieldBundles, a source FieldBundle and a destination
   FieldBundle. Then we use <TT>ESMF_FieldBundleSMM</TT> to
   perform sparse matrix multiplication from source FieldBundle to destination FieldBundle.

<P>
The operation performed in this example is better illustrated in 
   section <A HREF="node4.html#sec:field:usage:smm_1dptr">18.2.31</A>.

<P>
Section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> provides a detailed discussion of the 
   sparse matrix mulitiplication operation implemented in ESMF. 

<P>
<PRE>
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_VMGet(vm, localPet=lpe, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create distgrid and grid
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/16/), &amp;
        regDecomp=(/4/), &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        gridEdgeLWidth=(/0/), gridEdgeUWidth=(/0/), &amp;
        name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_I4, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create field bundles and fields
    srcFieldBundle = ESMF_FieldBundleCreate(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    dstFieldBundle = ESMF_FieldBundleCreate(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    do i = 1, 3
        srcField(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
            maxHaloLWidth=(/1/), maxHaloUWidth=(/2/), &amp;
            rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        call ESMF_FieldGet(srcField(i), localDe=0, farrayPtr=srcfptr, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        srcfptr = 1

        call ESMF_FieldBundleAdd(srcFieldBundle, srcField(i), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        dstField(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
            maxHaloLWidth=(/1/), maxHaloUWidth=(/2/), &amp;
            rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        call ESMF_FieldGet(dstField(i), localDe=0, farrayPtr=dstfptr, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        dstfptr = 0

        call ESMF_FieldBundleAdd(dstFieldBundle, dstField(i), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! initialize factorList and factorIndexList
    allocate(factorList(4))
    allocate(factorIndexList(2,4))
    factorList = (/1,2,3,4/)
    factorIndexList(1,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)
    factorIndexList(2,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)
    call ESMF_FieldBundleSMMStore(srcFieldBundle, dstFieldBundle, routehandle, &amp;
        factorList, factorIndexList, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! perform smm
    call ESMF_FieldBundleSMM(srcFieldBundle, dstFieldBundle, routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! verify smm
    do l = 1, 3
        call ESMF_FieldGet(dstField(l), localDe=0, farrayPtr=fptr, &amp;
            exclusiveLBound=exlb, exclusiveUBound=exub, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        ! Verify that the smm data in dstField(l) is correct.
        ! Before the smm op, the dst Field contains all 0. 
        ! The smm op reset the values to the index value, verify this is the case.
        !write(*, '(9I3)') l, lpe, fptr
        do i = exlb(1), exub(1)
            if(fptr(i) .ne. i) finalrc = ESMF_FAILURE
        enddo
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! release SMM route handle
    call ESMF_FieldBundleSMMRelease(routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! release all acquired resources
    call ESMF_FieldBundleDestroy(srcFieldBundle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_FieldBundleDestroy(dstFieldBundle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    do l = 1, 3
        call ESMF_FieldDestroy(srcField(l), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
        call ESMF_FieldDestroy(dstField(l), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo
    call ESMF_GridDestroy(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_DistGridDestroy(distgrid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    deallocate(factorList, factorIndexList)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04023600000000000000"></A>
   <A NAME="sec:fieldbundle:usage:halo"></A>
<BR>
17.3.6 Perform FieldBundle halo update
</H3>

<P>
<TT>ESMF_FieldBundleHalo</TT> interface can be used to perform halo update
   of all the Fields contained in the <TT>ESMF_FieldBundle</TT>.

<P>
In this example, we will set up a FieldBundle for a 2D viscous and compressible
   flow problem. We will illustrate the FieldBundle halo update operation but we will
   not solve the non-linear PDEs here. The emphasis here is to demonstrate
   how to set up halo regions, how a numerical scheme updates
   the exclusive regions, and how halo update communicates data in the halo regions. Here
   are the governing equations:

<P>
<!-- MATH
 $u_t + u u_x + v u_y + \frac{1}{\rho} p_x = 0$
 -->
<IMG
 WIDTH="186" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img13.png"
 ALT="$u_t + u u_x + v u_y + \frac{1}{\rho} p_x = 0$"> (conservation of momentum in x-direction)

<P>
<!-- MATH
 $v_t + u v_x + v v_y + \frac{1}{\rho} p_y = 0$
 -->
<IMG
 WIDTH="181" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img14.png"
 ALT="$v_t + u v_x + v v_y + \frac{1}{\rho} p_y = 0$"> (conservation of momentum in y-direction)

<P>
<!-- MATH
 ${\rho}_t + {\rho u}_x + {\rho v}_y = 0$
 -->
<IMG
 WIDTH="138" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img15.png"
 ALT="${\rho}_t + {\rho u}_x + {\rho v}_y = 0$"> (conservation of mass)

<P>
<!-- MATH
 $\frac{\rho}{\rho^\gamma} + u {(\frac{p}{\rho^\gamma})}_x + v {(\frac{p}{\rho^\gamma})}_y = 0$
 -->
<IMG
 WIDTH="185" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img16.png"
 ALT="$\frac{\rho}{\rho^\gamma} + u {(\frac{p}{\rho^\gamma})}_x + v {(\frac{p}{\rho^\gamma})}_y = 0$"> (conservation of energy)

<P>
The four unknowns are pressure <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.png"
 ALT="$p$">, density <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$\rho$">, velocity (<IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img19.png"
 ALT="$u$">, <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img20.png"
 ALT="$v$">). The grids
   are set up using Arakawa D stagger (<IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.png"
 ALT="$p$"> on corner, <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$\rho$"> at center, <IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img19.png"
 ALT="$u$"> and <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img20.png"
 ALT="$v$"> on edges).
   <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.png"
 ALT="$p$">, <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$\rho$">, <IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img19.png"
 ALT="$u$">, and <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img20.png"
 ALT="$v$"> are bounded by necessary boundary conditions and initial conditions.

<P>
Section <A HREF="node4.html#Array:Halo">20.2.14</A> provides a detailed discussion of the 
   halo operation implemented in ESMF. 

<P>
<PRE>
    ! create distgrid and grid according to the following decomposition 
    ! and stagger pattern, r is density.
    !
    ! p--------u-------+p+-------u--------p
    ! !                 |                 |
    ! !                 |                 |
    ! !                 |                 |
    ! v        r        v        r        v
    ! !      PET 0      |      PET 1      |
    ! !                 |                 |
    ! !                 |                 |
    ! p--------u-------+p+-------u--------p
    ! !                 |                 |
    ! !                 |                 |
    ! !                 |                 |
    ! v        r        v        r        v
    ! !      PET 2      |      PET 3      |
    ! !                 |                 |
    ! !                 |                 |
    ! p--------u-------+p+-------u--------p
    !
    distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/256,256/), &amp;
        regDecomp=(/2,2/), &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R4, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create field bundles and fields
    fieldBundle = ESMF_FieldBundleCreate(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! set up exclusive/total region for the fields
    !
    ! halo: L/U, nDim, nField, nPet
    ! halo configuration for pressure, and similarly for density, u, and v
    halo(1,1,1,1) = 0
    halo(2,1,1,1) = 0
    halo(1,2,1,1) = 0
    halo(2,2,1,1) = 0
    halo(1,1,1,2) = 1   ! halo in x direction on left hand side of pet 1
    halo(2,1,1,2) = 0
    halo(1,2,1,2) = 0
    halo(2,2,1,2) = 0
    halo(1,1,1,3) = 0
    halo(2,1,1,3) = 1   ! halo in y direction on upper side of pet 2
    halo(1,2,1,3) = 0
    halo(2,2,1,3) = 0
    halo(1,1,1,4) = 1   ! halo in x direction on left hand side of pet 3
    halo(2,1,1,4) = 1   ! halo in y direction on upper side of pet 3
    halo(1,2,1,4) = 0
    halo(2,2,1,4) = 0
</PRE>

<P>
<PRE>
    ! names and staggers of the 4 unknown fields
    names(1) = "pressure"
    names(2) = "density"
    names(3) = "u"
    names(4) = "v"
    staggers(1) = ESMF_STAGGERLOC_CORNER
    staggers(2) = ESMF_STAGGERLOC_CENTER
    staggers(3) = ESMF_STAGGERLOC_EDGE2
    staggers(4) = ESMF_STAGGERLOC_EDGE1
    
    ! create a FieldBundle
    lpe = lpe + 1
    do i = 1, 4
        field(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
                maxHaloLWidth=(/halo(1,1,i,lpe), halo(1,2,i,lpe)/), &amp;
                maxHaloUWidth=(/halo(2,1,i,lpe), halo(2,2,i,lpe)/), &amp;
                staggerloc=staggers(i), name=names(i), &amp;
                rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
        call ESMF_FieldBundleAdd(fieldBundle, field(i), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! compute the routehandle
    call ESMF_FieldBundleHaloStore(fieldBundle, routehandle=routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    do iter = 1, 10
        do i = 1, 4
            call ESMF_FieldGet(field(i), farrayPtr=fptr, &amp;
                exclusiveLBound=excllb, exclusiveUBound=exclub, rc=rc)
            if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
            sizes = exclub - excllb
            ! fill the total region with 0.
            fptr = 0.
            ! only update the exclusive region on local PET
            do j = excllb(1), exclub(1)
                do k = excllb(2), exclub(2)
                    fptr(j,k) = iter * cos(2.*PI*j/sizes(1))*sin(2.*PI*k/sizes(2))
                enddo 
            enddo 
        enddo
        ! call halo execution to update the data in the halo region,
        ! it can be verified that the halo regions change from 0. to non zero values.
        call ESMF_FieldBundleHalo(fieldbundle, routehandle=routehandle, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo
    ! release halo route handle
    call ESMF_FieldBundleHaloRelease(routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<P>

<H2><A NAME="SECTION04024000000000000000">
17.4 Restrictions and Future Work</A>
</H2>

<P>
<A NAME="sec:bundlerest"></A>
<P>

<OL>
<LI><B>No mathematical operators.</B>
The FieldBundle class does not support differential or other
mathematical operators.  We do not anticipate providing this 
functionality in the near future.

<P>
</LI>
<LI><B>Limited validation and print options.</B>
We are planning to increase the number of validity checks available
for FieldBundles as soon as possible.  We also will
be working on print options.

<P>
</LI>
<LI><B>Limited communication support.</B>
Only a subset of the communication routines are currently supported
for FieldBundles, and the Fields contained in the FieldBundles must currently
have the same structure (e.g. same halo width, same dimensionality). 
Support for more variable data will be added in a later release.
For those routines not implemented yet, or for those FieldBundles which
contain Fields with differing data, the user can loop over the Fields 
in the FieldBundle and call the Field level communication routines instead.

<P>
</LI>
<LI><B>Packed data not supported.</B>
One of the options that we are currently working on for FieldBundles is
packing.  Packing means that the data from all the
Fields that comprise the FieldBundle are manipulated collectively.
This operation can be done without 
destroying the original Field data.  Packing is being designed to 
facilitate optimized regridding, data communication, and IO operations.  
This will reduce the latency overhead of the communication.  

<P>
</LI>
<LI><B>Interleaving Fields within a FieldBundle.</B>
Data locality is important for performance on some computing
platforms.  An interleave option will allow the user to create
a packed FieldBundle in which Fields are either concatenated in memory
or in which Field elements are interleaved.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION04025000000000000000">
17.5 Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI><B>Fields in a FieldBundle reference the same Grid.</B>
In order to reduce memory requirements and ensure consistency, the 
Fields within a FieldBundle all reference the same Grid object.  This
restriction may be relaxed in the future.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION04026000000000000000">
17.6 Class API: Basic FieldBundle Methods</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04026100000000000000">
17.6.1 ESMF_FieldBundleAdd - Add a Field to a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleAdd()
       subroutine ESMF_FieldBundleAddOneField(bundle, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(inout) :: bundle
       type(ESMF_Field), intent(inout) :: field
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Adds a single <TT>field</TT> to an existing <TT>bundle</TT>.  The
        <TT>field</TT> must be associated with the same geometry (i.e. ESMF_Grid, ESMF_Mesh, or ESMF_LocStream) 
        as the other <TT>ESMF_Field</TT>s in the <TT>bundle</TT>.   
        The <TT>field</TT> is referenced by the <TT>bundle</TT>, not copied.

<P>
The arguments are:
       <DL>
<DT><STRONG>bundle</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> to add the <TT>ESMF_Field</TT> to.
       
</DD>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> to add.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04026200000000000000">
17.6.2 ESMF_FieldBundleAdd - Add a list of Fields to a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleAdd()
       subroutine ESMF_FieldBundleAddFieldList(bundle, fieldCount, fieldList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(inout) :: bundle        
       integer, intent(in) :: fieldCount
       type(ESMF_Field), dimension(:), intent(inout) :: fieldList
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Adds a <TT>fieldList</TT> to an existing <TT>ESMF_FieldBundle</TT>.  
        The items added from the <TT>ESMF_fieldList</TT> must be associated 
        with the same geometry (i.e. ESMF_Grid, ESMF_Mesh, or ESMF_LocStream) 
         as the other <TT>ESMF_Field</TT>s in the 
        <TT>bundle</TT>.  The items in the <TT>fieldList</TT> are referenced by
        the <TT>bundle</TT>, not copied.  

<P>
The arguments are:
       <DL>
<DT><STRONG>bundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to add <TT>ESMF_Field</TT>s to.
       
</DD>
<DT><STRONG>fieldCount</STRONG></DT>
<DD>Number of <TT>ESMF_Field</TT>s to be added to the 
             <TT>ESMF_FieldBundle</TT>; must be equal to or less than the 
             number of items in the <TT>fieldList</TT>.
       
</DD>
<DT><STRONG>fieldList</STRONG></DT>
<DD>Array of existing <TT>ESMF_Field</TT>s.  The first <TT>fieldCount</TT>
             items will be added to the <TT>ESMF_FieldBundle</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04026300000000000000">
17.6.3 ESMF_FieldBundleCreate - Create a FieldBundle from existing Fields</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleCreate()
       function ESMF_FieldBundleCreateNew(fieldCount, fieldList, &amp;
                                     packflag, name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_FieldBundle) :: ESMF_FieldBundleCreateNew
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer, intent(in) :: fieldCount           
       type(ESMF_Field), dimension (:) :: fieldList
       type(ESMF_PackFlag), intent(in), optional :: packflag 
       character (len = *), intent(in), optional :: name 
       type(ESMF_IOSpec), intent(in), optional :: iospec
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates an <TT>ESMF_FieldBundle</TT> from a list of existing
     <TT>ESMF_Fields</TT> stored in a <TT>fieldList</TT>.  All items in 
     the <TT>fieldList</TT> must be associated with the same 
     geometry (i.e. ESMF_Grid, ESMF_Mesh, or ESMF_LocStream).  
     Returns a new <TT>ESMF_FieldBundle</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldCount</STRONG></DT>
<DD>Number of fields to be added to the new <TT>ESMF_FieldBundle</TT>.
        Must be equal to or less than the number of 
        <TT>ESMF_Field</TT>s in the <TT>fieldList</TT>.
     
</DD>
<DT><STRONG>fieldList</STRONG></DT>
<DD>Array of existing <TT>ESMF_Field</TT>s.  The first <TT>ESMF_FieldCount</TT>
        items will be added to the new <TT>ESMF_FieldBundle</TT>.
     
</DD>
<DT><STRONG>[packflag]</STRONG></DT>
<DD>The packing option is not yet implemented.  
        See Section&nbsp;<A HREF="node4.html#sec:bundlerest">17.4</A>
        for a description of packing, and Section&nbsp;<A HREF="node4.html#opt:packflag">17.2.1</A> for 
        anticipated values.  The current implementation corresponds to the
        value <TT>ESMF_NO_PACKED_DATA</TT>, which means that every 
        <TT>ESMF_Field</TT> is referenced separately rather 
        than being copied into a single contiguous buffer.  
        This is the case no matter what value, if any, is passed in for
        this argument.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> name.  A default name is generated if
        one is not specified.
     
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>The <TT>ESMF_IOSpec</TT> is not yet used by <TT>ESMF_FieldBundle</TT>s.  Any 
        values passed in will be ignored.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04026400000000000000">
17.6.4 ESMF_FieldBundleCreate - Create a FieldBundle with no Fields no Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleCreate()
       function ESMF_FieldBundleCreateNFNone(name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_FieldBundle) :: ESMF_FieldBundleCreateNFNone
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len = *), intent(in), optional :: name 
       type(ESMF_IOSpec), intent(in), optional :: iospec
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates an <TT>ESMF_FieldBundle</TT> with no associated <TT>ESMF_Fields</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> name.  A default name is generated if
         one is not specified.
     
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>The <TT>ESMF_IOSpec</TT> is not yet used by <TT>ESMF_FieldBundle</TT>s.  Any 
         values passed in will be ignored.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04026500000000000000">
17.6.5 ESMF_FieldBundleCreate - Create a FieldBundle with no Fields, but a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleCreate()
       function ESMF_FieldBundleCreateNFGrid(grid, name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_FieldBundle) :: ESMF_FieldBundleCreateNFGrid
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid), intent(in) :: grid
       character (len = *), intent(in), optional :: name 
       type(ESMF_IOSpec), intent(in), optional :: iospec
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates an <TT>ESMF_FieldBundle</TT> with no associated <TT>ESMF_Fields</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> which all <TT>ESMF_Field</TT>s added to this
         <TT>ESMF_FieldBundle</TT> must be associated with. 
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> name.  A default name is generated if
         one is not specified.
     
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>The <TT>ESMF_IOSpec</TT> is not yet used by <TT>ESMF_FieldBundle</TT>s.  Any 
         values passed in will be ignored.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04026600000000000000">
17.6.6 ESMF_FieldBundleCreate - Create a FieldBundle with no Fields, but a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleCreate()
       function ESMF_FieldBundleCreateNFMesh(mesh, name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_FieldBundle) :: ESMF_FieldBundleCreateNFMesh
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Mesh), intent(in) :: mesh
       character (len = *), intent(in), optional :: name 
       type(ESMF_IOSpec), intent(in), optional :: iospec
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates an <TT>ESMF_FieldBundle</TT> with no associated <TT>ESMF_Fields</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> which all <TT>ESMF_Field</TT>s added to this
         <TT>ESMF_FieldBundle</TT> must be associated with. 
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> name.  A default name is generated if
         one is not specified.
     
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>The <TT>ESMF_IOSpec</TT> is not yet used by <TT>ESMF_FieldBundle</TT>s.  Any 
         values passed in will be ignored.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04026700000000000000">
17.6.7 ESMF_FieldBundleCreate - Create a FieldBundle with no Fields, but a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleCreate()
       function ESMF_FieldBundleCreateNFLS(locstream, name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_FieldBundle) :: ESMF_FieldBundleCreateNFLS
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(in) :: locstream
       character (len = *), intent(in), optional :: name 
       type(ESMF_IOSpec), intent(in), optional :: iospec
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates an <TT>ESMF_FieldBundle</TT> with no associated <TT>ESMF_Fields</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> which all <TT>ESMF_Field</TT>s added to this
         <TT>ESMF_FieldBundle</TT> must be associated with. 
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> name.  A default name is generated if
         one is not specified.
     
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>The <TT>ESMF_IOSpec</TT> is not yet used by <TT>ESMF_FieldBundle</TT>s.  Any 
         values passed in will be ignored.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04026800000000000000">
17.6.8 ESMF_FieldBundleDestroy - Free all resources associated with a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldBundleDestroy(bundle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle) :: bundle
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Releases resources associated with the <TT>bundle</TT>.  This
       method does not destroy the <TT>ESMF_Field</TT>s that the
       <TT>bundle</TT> contains.  The
       <TT>bundle</TT> should be destroyed before the <TT>ESMF_Field</TT>s
       within it are.

<P>
<DL>
<DT><STRONG>bundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04026900000000000000">
17.6.9 ESMF_FieldBundleGet - Return information about a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleGet()
       subroutine ESMF_FieldBundleGetInfo(bundle, geomtype, grid, mesh, locstream, fieldCount, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(in) :: bundle
       type(ESMF_GeomType), intent(out), optional :: geomtype
       type(ESMF_Grid), intent(out), optional :: grid
       type(ESMF_Mesh), intent(out), optional :: mesh
       type(ESMF_LocStream), intent(out), optional :: locstream
       integer, intent(out), optional :: fieldCount
       character (len = *), intent(out), optional :: name
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns information about the <TT>bundle</TT>.  
        If the <TT>ESMF_FieldBundle</TT> was originally created
        without specifying a name, a unique name will have been generated
        by the framework.

<P>
The arguments are:
       <DL>
<DT><STRONG>bundle</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object to query.
       
</DD>
<DT><STRONG>[geomtype]</STRONG></DT>
<DD>Specifies the type of geometry on which the FieldBundle is built. Please see Section&nbsp;<A HREF="node2.html#opt:geomtype">9.3.4</A> for 
             the range of values. Based on this value the user can use this method to retrieve one and only one 
             of <TT>grid</TT>, <TT>mesh</TT>, or <TT>locstream</TT>. 
       
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> associated with the <TT>bundle</TT>.
       
</DD>
<DT><STRONG>[mesh]</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> associated with the <TT>bundle</TT>.
       
</DD>
<DT><STRONG>[locstream]</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> associated with the <TT>bundle</TT>.
       
</DD>
<DT><STRONG>[fieldCount]</STRONG></DT>
<DD>Number of <TT>ESMF_Field</TT>s in the <TT>bundle</TT>.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>A character string where the <TT>bundle</TT> name is returned.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040261000000000000000">
17.6.10 ESMF_FieldBundleGet - Retrieve a Field by name</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleGet()
       subroutine ESMF_FieldBundleGetFieldByName(bundle, name, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(in) :: bundle
       character (len = *), intent(in) :: name
       type(ESMF_Field), intent(out) :: field
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns a <TT>field</TT> from a <TT>bundle</TT> using
        the <TT>field</TT>'s <TT>name</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>bundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to query for <TT>ESMF_Field</TT>.
       
</DD>
<DT><STRONG>name</STRONG></DT>
<DD><TT>ESMF_Field</TT> name.
       
</DD>
<DT><STRONG>field</STRONG></DT>
<DD>Returned <TT>ESMF_Field</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040261100000000000000">
17.6.11 ESMF_FieldBundleGet - Retrieve a Field by index number</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleGet()
       subroutine ESMF_FieldBundleGetFieldByNum(bundle, fieldIndex, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(in) :: bundle
       integer, intent(in) :: fieldIndex
       type(ESMF_Field), intent(out) :: field
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns a <TT>field</TT> from a <TT>bundle</TT> by index number.

<P>
The arguments are:
       <DL>
<DT><STRONG>bundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to query for <TT>ESMF_Field</TT>.
       
</DD>
<DT><STRONG>fieldIndex</STRONG></DT>
<DD><TT>ESMF_Field</TT> index number; first <TT>fieldIndex</TT> is 1.
       
</DD>
<DT><STRONG>field</STRONG></DT>
<DD>Returned <TT>ESMF_Field</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040261200000000000000">
17.6.12 ESMF_FieldBundleGet - Return all Field names in a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleGet()
       subroutine ESMF_FieldBundleGetFieldNames(bundle, nameList, nameCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(in) :: bundle 
       character (len = *), intent(out) :: nameList(:)
       integer, intent(out), optional :: nameCount     
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns an array of <TT>ESMF_Field</TT> names in an <TT>ESMF_FieldBundle</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>bundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
       
</DD>
<DT><STRONG>nameList</STRONG></DT>
<DD>An array of character strings where each <TT>ESMF_Field</TT> name
             is returned.  Must be at least as long as <TT>nameCount</TT>.
       
</DD>
<DT><STRONG>[nameCount]</STRONG></DT>
<DD>A count of how many <TT>ESMF_Field</TT> names were returned.  Same as
             the number of <TT>ESMF_Field</TT>s in the <TT>ESMF_FieldBundle</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040261300000000000000">
17.6.13 ESMF_FieldBundlePrint - Print information about a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldBundlePrint(bundle, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(in) :: bundle
       character (len=*), intent(in), optional :: options
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints diagnostic information about the <TT>bundle</TT>
       to <TT>stdout</TT>. 
<BR>
<P>
Note:  Many <TT>ESMF_&lt;class&gt;Print</TT> methods are implemented in C++.
       On some platforms/compilers there is a potential issue with interleaving
       Fortran and C++ output to <TT>stdout</TT> such that it doesn't appear in
       the expected order.  If this occurs, the <TT>ESMF_IOUnitFlush()</TT> method
       may be used on unit 6 to get coherent output.  
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>bundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options are not yet supported.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040261400000000000000">
17.6.14 ESMF_FieldBundleSet - Associate a Grid with an empty FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleSet()
       subroutine ESMF_FieldBundleSetGrid(bundle, grid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(inout) :: bundle
       type(ESMF_Grid), intent(in) :: grid
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the <TT>grid</TT> for a <TT>bundle</TT> that contains no <TT>ESMF_Field</TT>s. 
     All <TT>ESMF_Field</TT>s added to this <TT>bundle</TT> must be
     associated with the same <TT>ESMF_Grid</TT>.  Returns an error if 
     there is already an <TT>ESMF_Grid</TT> associated with the <TT>bundle</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>bundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
     
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> which all <TT>ESMF_Field</TT>s added to this
          <TT>ESMF_FieldBundle</TT> must have.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040261500000000000000">
17.6.15 ESMF_FieldBundleSet - Associate a Mesh with an empty FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleSet()
       subroutine ESMF_FieldBundleSetMesh(bundle, mesh, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(inout) :: bundle
       type(ESMF_Mesh), intent(in) :: mesh
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the <TT>mesh</TT> for a <TT>bundle</TT> that contains no <TT>ESMF_Field</TT>s. 
     All <TT>ESMF_Field</TT>s added to this <TT>bundle</TT> must be
     associated with the same <TT>ESMF_Mesh</TT>.  Returns an error if 
     there is already an <TT>ESMF_Mesh</TT> associated with the <TT>bundle</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>bundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
     
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> which all <TT>ESMF_Field</TT>s added to this
          <TT>ESMF_FieldBundle</TT> must have.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040261600000000000000">
17.6.16 ESMF_FieldBundleSet - Associate a LocStream with an empty FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleSet()
       subroutine ESMF_FieldBundleSetLS(bundle, locstream, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(inout) :: bundle
       type(ESMF_LocStream), intent(in) :: locstream
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the <TT>locstream</TT> for a <TT>bundle</TT> that contains no <TT>ESMF_Field</TT>s. 
     All <TT>ESMF_Field</TT>s added to this <TT>bundle</TT> must be
     associated with the same <TT>ESMF_LocStream</TT>.  Returns an error if 
     there is already an <TT>ESMF_LocStream</TT> associated with the <TT>bundle</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>bundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
     
</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> which all <TT>ESMF_Field</TT>s added to this
          <TT>ESMF_FieldBundle</TT> must have.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040261700000000000000">
17.6.17 ESMF_FieldBundleValidate - Check validity of a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldBundleValidate(bundle, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(in) :: bundle
       character (len=*), intent(in), optional :: options 
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>bundle</TT> is internally consistent.
        Currently this method determines if the <TT>bundle</TT> is uninitialized 
        or already destroyed.  The method returns an error code if problems 
        are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>bundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to validate.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Validation options are not yet supported.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if the <TT>bundle</TT>
             is valid.
       
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION04027000000000000000">
17.7 Class API: FieldBundle Communications</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04027100000000000000">
17.7.1 ESMF_FieldBundleHalo - Execute an FieldBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleHalo(fieldBundle, routehandle, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(in)              :: fieldBundle
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         logical,                intent(in),   optional  :: checkflag
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed FieldBundle halo operation for the Fields in fieldBundle.
     See <TT>ESMF_FieldBundleStore()</TT> on how to compute routehandle.

<P>
<DL>
<DT><STRONG>fieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04027200000000000000">
17.7.2 ESMF_FieldBundleHaloRelease - Release resources associated with FieldBundle </A>
</H3>

<P>
halo operation

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleHaloRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an FieldBundle halo operation. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04027300000000000000">
17.7.3 ESMF_FieldBundleHaloStore - Precompute an FieldBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_FieldBundleHaloStore(fieldBundle, routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout)                :: fieldBundle
     type(ESMF_RouteHandle), intent(inout)                :: routehandle
     integer,                intent(out),        optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an FieldBundle halo operation over the data in <TT>fieldBundle</TT>. By 
     definition, all elements in the total Field regions that lie
     outside the exclusive regions will be considered potential destination
     elements for halo. However, only those elements that have a corresponding
     halo source element, i.e. an exclusive element on one of the DEs, will be
     updated under the halo operation. Elements that have no associated source
     remain unchanged under halo.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldBundleHalo()</TT> on any FieldBundle that is weakly congruent
     and typekind conform to <TT>fieldBundle</TT>. Congruency for FieldBundles is
     given by the congruency of its constituents.
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04027400000000000000">
17.7.4 ESMF_FieldBundleRedist - Execute an FieldBundle redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRedist(srcFieldBundle, dstFieldBundle, routehandle, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(in),   optional  :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout),optional  :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         logical,                intent(in),   optional  :: checkflag
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed FieldBundle redistribution from <TT>srcFieldBundle</TT> to
     <TT>dstFieldBundle</TT>. Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must be
     weakly congruent and typekind conform with the respective FieldBundles used during 
     <TT>ESMF_FieldBundleRedistStore()</TT>. Congruent FieldBundles possess
     matching DistGrids and the shape of the local array tiles matches between
     the FieldBundles for every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions. 

<P>
It is erroneous to specify the identical FieldBundle object for <TT>srcFieldBundle</TT> and
     <TT>dstFieldBundle</TT> arguments.

<P>
See <TT>ESMF_FieldBundleRedistStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentations using this method see Section  
     <A HREF="node4.html#sec:fieldbundle:usage:redist_1dptr">17.3.4</A>. 

<P>
<DL>
<DT><STRONG>[srcFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04027500000000000000">
17.7.5 ESMF_FieldBundleRedistRelease - Release resources associated with FieldBundle </A>
</H3>

<P>
redistribution

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRedistRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an FieldBundle redistribution. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04027600000000000000">
17.7.6 ESMF_FieldBundleRedistStore - Precompute FieldBundle redistribution </A>
</H3>

<P>
with local factor argument 

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleRedistStore() 
   subroutine ESMF_FieldBundleRedistStore&lt;type&gt;&lt;kind&gt;(srcFieldBundle, dstFieldBundle, &amp; 
          routehandle, factor, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle),   intent(in)            :: srcFieldBundle  
     type(ESMF_FieldBundle),   intent(inout)         :: dstFieldBundle  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)            :: factor
     integer,                  intent(in),  optional :: srcToDstTransposeMap(:)
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an FieldBundle redistribution operation from <TT>srcFieldBundle</TT> to <TT>dstFieldBundle</TT>. 
   PETs that
   specify a <TT>factor</TT> argument must use the &lt;type&gt;&lt;kind&gt; overloaded interface. Other 
   PETs call into the interface without <TT>factor</TT> argument. If multiple PETs specify 
   the <TT>factor</TT> argument its type and kind as well as its value must match across 
   all PETs. If none of the PETs specifies a <TT>factor</TT> argument the default will be a  
   factor of 1. 

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   patches within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition of <EM>sequence indices</EM>. 
   Redistribution corresponds to an identity mapping of the source FieldBundle vector to 
   the destination FieldBundle vector. 

<P>
Source and destination FieldBundles may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination FieldBundles may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle 
   and dstFieldBundle arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
   <TT>ESMF_FieldBundleRedist()</TT> on any pair of FieldBundles that are congruent and typekind 
   conform with the srcFieldBundle, dstFieldBundle pair. Congruent FieldBundles possess matching 
   DistGrids and the shape of the local array tiles matches between the FieldBundles for 
   every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions. 

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node4.html#sec:fieldbundle:usage:redist_1dptr">17.3.4</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data. 
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. 
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>FActor by which to multiply source data. Default is 1.
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcFieldBundle</TT>. Each 
   entry maps the corresponding <TT>srcFieldBundle</TT> dimension 
   against the specified <TT>dstFieldBundle</TT> 
   dimension. Mixing of distributed and undistributed dimensions is supported.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04027700000000000000">
17.7.7 ESMF_FieldBundleRedistStore - Precompute FieldBundle redistribution with local factor argument </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleRedistStore() 
   subroutine ESMF_FieldBundleRedistStoreNF(srcFieldBundle, dstFieldBundle, &amp; 
          routehandle, factor, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle),   intent(in)            :: srcFieldBundle  
     type(ESMF_FieldBundle),   intent(inout)         :: dstFieldBundle  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     integer,                  intent(in) , optional :: srcToDstTransposeMap(:)
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an FieldBundle redistribution operation from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   patches within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition of <EM>sequence indices</EM>. 
   Redistribution corresponds to an identity mapping of the source FieldBundle vector to 
   the destination FieldBundle vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle and dstFieldBundle 
   arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
   <TT>ESMF_FieldBundleRedist()</TT> on any pair of Fields that are congruent and typekind 
   conform with the srcFieldBundle, dstFieldBundle pair. Congruent Fields possess matching 
   DistGrids and the shape of the local array tiles matches between the Fields for 
   every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions. 

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node4.html#sec:fieldbundle:usage:redist_1dptr">17.3.4</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data. 
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. 
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcFieldBundle</TT>. Each 
   entry maps the corresponding <TT>srcFieldBundle</TT> dimension 
   against the specified <TT>dstFieldBundle</TT> 
   dimension. Mixing of distributed and undistributed dimensions is supported.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04027800000000000000">
17.7.8 ESMF_FieldBundleRegrid - Execute an FieldBundle Regrid operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRegrid(srcFieldBundle, dstFieldBundle, routehandle, zeroflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(in),   optional  :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout),optional  :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         type(ESMF_RegionFlag),  intent(in),   optional  :: zeroflag
         logical,                intent(in),   optional  :: checkflag
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed FieldBundle regrid from <TT>srcFieldBundle</TT> to
     <TT>dstFieldBundle</TT>. Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must be
     congruent and typekind conform with the respective FieldBundles used during 
     <TT>ESMF_FieldBundleRegridStore()</TT>. Congruent FieldBundles possess
     matching DistGrids and the shape of the local array tiles matches between
     the FieldBundles for every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions. 

<P>
It is erroneous to specify the identical FieldBundle object for <TT>srcFieldBundle</TT> and
     <TT>dstFieldBundle</TT> arguments.

<P>
See <TT>ESMF_FieldBundleRegridStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroflag]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstFieldBundle</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstFieldBundle</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroflag</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination FieldBundle that will be updated by the sparse matrix
       multiplication. See section <A HREF="node2.html#opt:regionflag">9.2.13</A> for a complete list of
       valid settings.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04027900000000000000">
17.7.9 ESMF_FieldBundleRegridRelease - Release resources associated with FieldBundle </A>
</H3>

<P>
Regrid operation

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRegridRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with FieldBundle Regrid operation. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040271000000000000000">
17.7.10 ESMF_FieldBundleRegridStore - Precompute an FieldBundle Regrid operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_FieldBundleRegridStore(srcFieldBundle, dstFieldBundle, regridMethod, &amp;
         regridScheme, routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout)                :: srcFieldBundle
     type(ESMF_FieldBundle), intent(inout)                :: dstFieldBundle
     type(ESMF_RegridMethod), intent(in), optional        :: regridMethod
     integer, intent(in), optional                        :: regridScheme
     type(ESMF_RouteHandle), intent(inout)                :: routehandle
     integer,                intent(out),        optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an FieldBundle Regrid operation over the data in <TT>srcFieldBundle</TT> and
     <TT>dstFieldBundle</TT> pair. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldBundleRegrid()</TT> on any FieldBundle pairs that are weakly congruent
     and typekind conform to the FieldBundle pair used here.
     Congruency for FieldBundles is
     given by the congruency of its constituents.
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>srcFieldbundle</STRONG></DT>
<DD>Source <TT>ESMF_FieldBundle</TT> containing data to be Regridded.
     
</DD>
<DT><STRONG>dstFieldbundle</STRONG></DT>
<DD>Destination <TT>ESMF_FieldBundle</TT>.
     
</DD>
<DT><STRONG>[regridMethod]</STRONG></DT>
<DD>The type of regrid. Options are ESMF_REGRID_METHOD_BILINEAR or 
       ESMF_REGRID_METHOD_PATCH. If not specified, defaults to 
       ESMF_REGRID_METHOD_BILINEAR. 
     
</DD>
<DT><STRONG>[regridScheme]</STRONG></DT>
<DD>Whether to convert to spherical coordinates (ESMF_REGRID_SCHEME_FULL3D), 
       or to leave in native coordinates (ESMF_REGRID_SCHEME_NATIVE). 
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040271100000000000000">
17.7.11 ESMF_FieldBundleSMM - Execute an FieldBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleSMM(srcFieldBundle, dstFieldBundle, routehandle, zeroflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(in),   optional  :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout),optional  :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         type(ESMF_RegionFlag),  intent(in),   optional  :: zeroflag
         logical,                intent(in),   optional  :: checkflag
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed FieldBundle sparse matrix multiplication from <TT>srcFieldBundle</TT> to
     <TT>dstFieldBundle</TT>. Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must be
     congruent and typekind conform with the respective FieldBundles used during 
     <TT>ESMF_FieldBundleSMMStore()</TT>. Congruent FieldBundles possess
     matching DistGrids and the shape of the local array tiles matches between
     the FieldBundles for every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions. 

<P>
It is erroneous to specify the identical FieldBundle object for <TT>srcFieldBundle</TT> and
     <TT>dstFieldBundle</TT> arguments.

<P>
See <TT>ESMF_FieldBundleSMMStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentations using this method see Section  
     <A HREF="node4.html#sec:fieldbundle:usage:smm_1dptr">17.3.5</A>. 

<P>
<DL>
<DT><STRONG>[srcFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroflag]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstFieldBundle</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstFieldBundle</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroflag</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination FieldBundle that will be updated by the sparse matrix
       multiplication. See section <A HREF="node2.html#opt:regionflag">9.2.13</A> for a complete list of
       valid settings.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040271200000000000000">
17.7.12 ESMF_FieldBundleSMMRelease - Release resources associated with FieldBundle </A>
</H3>

<P>
sparse matrix multiplication

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleSMMRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an FieldBundle sparse matrix multiplication. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040271300000000000000">
17.7.13 ESMF_FieldBundleSMMStore - Precompute FieldBundle sparse matrix multiplication </A>
</H3>

<P>
with local factor argument 

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleSMMStore() 
   subroutine ESMF_FieldBundleSMMStore&lt;type&gt;&lt;kind&gt;(srcFieldBundle, dstFieldBundle, &amp; 
          routehandle, factorList, factorIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle),   intent(in)            :: srcFieldBundle  
     type(ESMF_FieldBundle),   intent(inout)         :: dstFieldBundle  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)            :: factorList(:) 
     integer,                  intent(in),           :: factorIndexList(:,:) 
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an FieldBundle sparse matrix multiplication operation from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   patches within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source FieldBundle vector to 
   the destination FieldBundle vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle 
   and dstFieldBundle arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
   <TT>ESMF_FieldBundleSMM()</TT> on any pair of FieldBundles that are congruent and typekind 
   conform with the srcFieldBundle, dstFieldBundle pair. Congruent FieldBundles possess matching 
   DistGrids and the shape of the local array tiles matches between the FieldBundles for 
   every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions. 

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node4.html#sec:fieldbundle:usage:smm_1dptr">17.3.5</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data. 
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. 
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.
   
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the <TT>srcFieldBundle</TT> while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in <TT>dstFieldBundle</TT>. For this format to be a valid
       option source and destination FieldBundles must have matching number of
       tensor elements (the product of the sizes of all Field tensor dimensions).
       Under this condition an identiy matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the <TT>srcFieldBundle</TT>. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the <TT>dstFieldBundle</TT>.

<P>
See section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition of 
       <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040271400000000000000">
17.7.14 ESMF_FieldBundleSMMStore - Precompute FieldBundle sparse matrix multiplication with local factor argument </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleSMMStore() 
   subroutine ESMF_FieldBundleSMMStoreNF(srcFieldBundle, dstFieldBundle, &amp; 
          routehandle, factorList, factorIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle),   intent(in)            :: srcFieldBundle  
     type(ESMF_FieldBundle),   intent(inout)         :: dstFieldBundle  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an FieldBundle sparse matrix multiplication operation from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   patches within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source FieldBundle vector to 
   the destination FieldBundle vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle and dstFieldBundle 
   arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
   <TT>ESMF_FieldBundleSMM()</TT> on any pair of FieldBundles that are congruent and typekind 
   conform with the srcFieldBundle, dstFieldBundle pair. Congruent FieldBundles possess matching 
   DistGrids and the shape of the local array tiles matches between the FieldBundles for 
   every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions. 

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node4.html#sec:fieldbundle:usage:smm_1dptr">17.3.5</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data. 
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. 
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<H1><A NAME="SECTION04030000000000000000">
18 Field Class</A>
</H1>

<P>

<H2><A NAME="SECTION04031000000000000000">
18.1 Description</A>
</H2>

<P>
An ESMF Field represents a physical field, such as temperature.
The motivation for including Fields in ESMF is that bundles of 
Fields are the entities that are normally exchanged when coupling
Components.  

<P>
The ESMF Field class contains distributed, discretized field data, a reference 
to its associated grid, and metadata.  The Field class maintains the
relationship of how a data array maps onto a grid (e.g. one item per
cell located at the cell center, one item per cell located at the NW
corner,  one item per cell vertex, ...).  This means that different Fields
which are on the same underlying ESMF Grid but have different
staggerings can share the same Grid object without needing to replicate
it multiple times. 

<P>
Fields can be added to States for use in inter-Component
data communications.  Fields can also be added to FieldBundles,
which are currently defined as groups of Fields on the same underlying
grid.  One motivation for FieldBundles is convenience; another is the
ability to perform optimized collective data transfers.  

<P>
Field communications, including data redistribution, regriding, scatter,
and gather, are enabled in this release.  Field halo update operation is
not enabled in this release and will be enabled in subsequent releases.

<P>
ESMF does not currently support vector fields, so the components of 
a vector field must be stored as separate Field objects.  

<P>

<P>

<H2><A NAME="SECTION04032000000000000000">
18.2 Use and Examples</A>
</H2>

<P>
A Field serves as an annotator of data, since it carries 
a description of the grid it is associated with and metadata 
such as name and units.  Fields can be used in this capacity
alone, as convenient, descriptive containers into which arrays 
can be placed and retrieved.  However, for most codes the primary 
use of Fields is in the context of import and export States,
which are the objects that carry coupling information between 
Components.  Fields enable data to be self-describing, and a
State holding ESMF Fields contains data in a standard format
that can be queried and manipulated.  

<P>
The sections below go into more detail about Field usage.

<P>

<H3><A NAME="SECTION04032100000000000000">
18.2.1 Field Creation and Destruction</A>
</H3>

<P>
Fields can be created and destroyed at any time during 
application execution.  However, these Field methods require 
some time to complete.  We do not recommend that the user
create or destroy Fields inside performance-critical 
computational loops.

<P>
All versions of the <TT>ESMF_FieldCreate()</TT> 
routines require a Grid object as input, or require a Grid
be added before most operations involving Fields can be performed.
The Grid contains the information needed to know which 
Decomposition Elements (DEs) are participating in 
the processing of this Field, and which subsets of the data
are local to a particular DE.

<P>
The details of how the create process happens depends 
on which of the variants of the <TT>ESMF_FieldCreate()</TT> 
call is used.  Some of the variants are discussed below.

<P>
There are versions of the <TT>ESMF_FieldCreate()</TT> interface
which create the Field based on the input Grid.  The ESMF
can allocate the proper amount of 
space but not assign initial values.  The user code
can then get the pointer to the uninitialized buffer and 
set the initial data values.

<P>
Other versions of the <TT>ESMF_FieldCreate()</TT> interface
allow user code to attach arrays that have already been
allocated by the user.  Empty Fields can also be created in
which case the data can be added at some later time.

<P>
For versions of Create which do not specify data values,
user code can create an ArraySpec object, which
contains information about the typekind and rank of the
data values in the array.  Then at Field create time, the
appropriate amount of memory is allocated to contain the
data which is local to each DE.

<P>
When finished with a <TT>ESMF_Field</TT>, the <TT>ESMF_FieldDestroy</TT> method
removes it.  However, the objects inside the <TT>ESMF_Field</TT>
created externally should be destroyed separately, 
since objects can be added to
more than one <TT>ESMF_Field</TT>.  For example, the same <TT>ESMF_Grid</TT>
can be referenced by multiple <TT>ESMF_Field</TT>s.  In this case the
internal Grid is not deleted by the <TT>ESMF_FieldDestroy</TT> call.

<P>

<P>

<P>

<H3><A NAME="SECTION04032200000000000000"></A>
  <A NAME="sec:field:usage:field_get_dataptr"></A>
<BR>
18.2.2 Get Fortran data pointer, bounds, and counts information from a Field
</H3>

<P>
A user can get bounds and counts information from an <TT>ESMF_Field</TT>
    through the <TT>ESMF_FieldGet()</TT> interface.  Also available through this interface
    is the intrinsic
    Fortran data pointer contained in the internal <TT>ESMF_Array</TT> object
    of an <TT>ESMF_Field</TT>. The bounds and counts information are DE specific
    for the associated Fortran data pointer.

<P>
For a better discussion of the terminologies, bounds and widths in ESMF
    e.g. exclusive, computational, total bounds
    for the lower and upper corner of data region, etc.., user can refer to 
    the explanation of these concepts for Grid and Array in their respective sections 
    in the <I>Reference Manual</I>, e.g. Section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A> on Array
    and Section <A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> on Grid.

<P>
In this example, we first create a 3D Field based on a 3D Grid and Array.
    Then we use the <TT>ESMF_FieldGet()</TT> interface to retrieve the data pointer,
    potentially updating or verifying its values. We also retrieve the bounds and counts
    information of the 3D Field to assist in data element iteration.

<P>
<PRE>
    xdim = 180
    ydim = 90
    zdim = 50

    ! create a 3D data Field from a Grid and Array.
    ! first create a Grid 
    grid3d = ESMF_GridCreateShapeTile(minIndex=(/1,1,1/), maxIndex=(/xdim,ydim,zdim/), &amp;
                            regDecomp=(/2,2,1/), name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_GridGet(grid=grid3d, staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
           staggerDistgrid=distgrid3d, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(grid=grid3d, localDe=0, staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
        totalCount=fa_shape, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    allocate(farray(fa_shape(1), fa_shape(2), fa_shape(3)) )

    ! create an Array 
    array3d = ESMF_ArrayCreate(farray, distgrid=distgrid3d, indexflag=ESMF_INDEX_DELOCAL, &amp;
                 rc=rc) 
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create a Field
    field = ESMF_FieldCreate(grid=grid3d, array=array3d, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
  
    ! retrieve the Fortran data pointer from the Field
    call ESMF_FieldGet(field=field, localDe=0, farrayPtr=farray1, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! retrieve the Fortran data pointer from the Field and bounds
    call ESMF_FieldGet(field=field, localDe=0, farrayPtr=farray1, &amp;
        computationalLBound=compLBnd, computationalUBound=compUBnd, &amp;
        exclusiveLBound=exclLBnd, exclusiveUBound=exclUBnd, &amp;
        totalLBound=totalLBnd, totalUBound=totalUBnd, &amp;
        computationalCount=comp_count, &amp;
        exclusiveCount=excl_count, &amp;
        totalCount=total_count, &amp;
        rc=rc)   

    ! iterate through the total bounds of the field data pointer
    do k = totalLBnd(3), totalUBnd(3)
        do j = totalLBnd(2), totalUBnd(2)
            do i = totalLBnd(1), totalUBnd(1)
                farray1(i, j, k) = sin(2*i/total_count(1)*PI) + &amp;
                    sin(4*j/total_count(2)*PI) + &amp;
                    sin(8*k/total_count(2)*PI)
            enddo
        enddo
    enddo
</PRE>

<P>

<H3><A NAME="SECTION04032300000000000000"></A>
  <A NAME="sec:field:usage:field_get_default"></A>
<BR>
18.2.3 Get Grid and Array and other information from a Field
</H3>

<P>
A user can get the internal <TT>ESMF_Grid</TT> and <TT>ESMF_Array</TT> 
    from a <TT>ESMF_Field</TT>.  Note that the user should not issue any destroy command
    on the retrieved grid or array object since they are referenced
    from within the <TT>ESMF_Field</TT>. The retrieved objects should be used
    in a read-only fashion to query additional information not directly
    available through the <TT>ESMF_FieldGet()</TT> interface.

<P>
<PRE>
    call ESMF_FieldGet(field, grid=grid, array=array, &amp;
        typekind=typekind, dimCount=dimCount, staggerloc=staggerloc, &amp;
        gridToFieldMap=gridToFieldMap, &amp;
        ungriddedLBound=ungriddedLBound, ungriddedUBound=ungriddedUBound, &amp;
        maxHaloLWidth=maxHaloLWidth, maxHaloUWidth=maxHaloUWidth, &amp; 
        name=name, &amp;
        rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04032400000000000000"></A>
  <A NAME="sec:field:usage:create_grid_arrayspec"></A>
<BR>
18.2.4 Create Field with Grid and Arrayspec
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> from an <TT>ESMF_Grid</TT> and a
    <TT>ESMF_Arrayspec</TT> with corresponding rank and type.  
    This create method associates the two objects.  

<P>
We first create a Grid with a regular distribution that is
    10x20 index in 2x2 DEs.  This version of Field create simply
    associates the data with the Grid.  The data is referenced
    explicitly on a regular 2x2 uniform grid. 
    Then we create an ArraySpec.  Finally we create a Field from
    the Grid, ArraySpec, and a user specified StaggerLoc.

<P>
This example also illustrates a typical use of this Field creation
    method. By creating a Field from a Grid and an ArraySpec, the
    user allows the ESMF library to create a internal Array in the Field.
    Then the user can use <TT>ESMF_FieldGet()</TT> to retrieve the Fortran
    data array
    and necessary bounds information to assign initial values to it. 

<P>
<PRE>
    ! create a grid
    grid = ESMF_GridCreateShapeTile(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
          regDecomp=(/2,2/), name="atmgrid", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! setup arrayspec
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R4, rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create a Field from the Grid and arrayspec
    field1 = ESMF_FieldCreate(grid, arrayspec, ESMF_INDEX_DELOCAL, &amp;
         staggerloc=ESMF_STAGGERLOC_CENTER, name="pressure", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(field1, localDe=0, farrayPtr=farray2dd, &amp;
        totalLBound=ftlb, totalUBound=ftub, totalCount=ftc, rc=rc)

    do i = ftlb(1), ftub(1)
        do j = ftlb(2), ftub(2)
            farray2dd(i, j) = sin(i/ftc(1)*PI) * cos(j/ftc(2)*PI) 
        enddo
    enddo

    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
A user can also create an ArraySpec that has a different rank
     from the Grid, For example, the following code shows creation of 
     of 3D Field from a 2D Grid using a 3D ArraySpec.

<P>
This example also demonstrates the technique to create a typical
     3D data Field that has 2 gridded dimensions and 1 ungridded
     dimension. 

<P>
First we create a 2D grid with an index space of 180x360 equivalent to
     180x360 Grid cells (note that for a distributed memory computer, this
     means each 
     grid cell will be on a separate PE!). In the FieldCreate call, we use gridToFieldMap
     to indicate the mapping between Grid dimension and Field dimension.
     For the ungridded dimension (typically the altitude), we use
     ungriddedLBound and ungriddedUBound to describe its bounds. Internally
     the ungridded dimension has a stride of 1, so the number of elements
     of the ungridded dimension is ungriddedUBound - ungriddedLBound + 1.

<P>
Note that gridToFieldMap in this specific example is (/1,2/) which
     is the default value
     so the user can neglect this argument for the FieldCreate call. 

<P>
<PRE>
    grid2d = ESMF_GridCreateShapeTile(minIndex=(/1,1/), maxIndex=(/180,360/), &amp;
          regDecomp=(/2,2/), name="atmgrid", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_ArraySpecSet(arrayspec, 3, ESMF_TYPEKIND_R4, rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    field1 = ESMF_FieldCreate(grid2d, arrayspec, ESMF_INDEX_DELOCAL, &amp;
         staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
         gridToFieldMap=(/1,2/), &amp;
         ungriddedLBound=(/1/), ungriddedUBound=(/50/), &amp;
         name="pressure", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION04032500000000000000"></A>
  <A NAME="sec:field:usage:create_grid_array"></A>
<BR>
18.2.5 Create Field with Grid and Array
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> from an <TT>ESMF_Grid</TT> and a 
    <TT>ESMF_Array</TT>. The Grid was created in the previous example.

<P>
This example creates a 2D <TT>ESMF_Field</TT> from a 2D <TT>ESMF_Grid</TT>
    and a 2D <TT>ESMF_Array</TT>. 

<P>
<PRE>
    ! Get necessary information from the Grid
    call ESMF_GridGet(grid, staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
        staggerDistgrid=distgrid, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Create a 2D ESMF_TYPEKIND_R4 arrayspec
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R4, rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Create a ESMF_Array from the arrayspec and distgrid
    array2d = ESMF_ArrayCreate(arrayspec=arrayspec, &amp;
            distgrid=distgrid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Create a ESMF_Field from the grid and array
    field4 = ESMF_FieldCreate(grid, array2d, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION04032600000000000000"></A>
  <A NAME="sec:field:usage:create_empty_setcommit"></A>
<BR>
18.2.6 Create an empty Field and finish it with FieldSetCommit
</H3>

<P>
A user can create an empty <TT>ESMF_Field</TT>.
    Then the user can finalize the empty <TT>ESMF_Field</TT> from a <TT>ESMF_Grid</TT> 
    and a intrinsic 
    Fortran data array. This interface is overloaded for typekind and rank
    of the Fortran data array.

<P>
In this example, both grid and Fortran array pointer are 2 dimensional
    and each dimension index maps in order, i.e. 1st dimension of grid maps to
    1st dimension of Fortran array pointer, 2nd dimension of grid maps to 2nd dimension of
    Fortran array pointer, so on and so forth. 

<P>
In order to create or finish a Field from a Grid and a Fortran array pointer, 
    certain rules of the Fortran array bounds must be obeyed. We will discuss these
    rules as we progress in Field creation examples.  We will make
    frequent reference to the terminologies for bounds and widths in ESMF. 
    For a better discussion of
    these terminologies and concepts behind them, 
    e.g. exclusive, computational, total bounds
    for the lower and upper corner of data region, etc.., users can refer to 
    the explanation of these concepts for Grid and Array in their respective sections 
    in the <I>Reference Manual</I>, e.g. Section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A> on Array
    and Section <A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> on Grid.
    The examples here are designed to help a user to get up to speed with
    creating Fields for typical use.

<P>
This example introduces a helper method, part of the <TT>ESMF_FieldGet</TT>
    interface that facilitates the computation of Fortran data array bounds
    and shape to assist <TT>ESMF_FieldSetCommit</TT> finalizing a Field from a
    instrinsic Fortran data array and a Grid.

<P>
<PRE>
    ! create an empty Field
    field3 = ESMF_FieldCreateEmpty("precip", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! use FieldGet to retrieve total counts 
    call ESMF_FieldGet(grid2d, localDe=0, staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
        totalCount=ftc, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! allocate the 2d Fortran array based on retrieved total counts
    allocate(farray2d(ftc(1), ftc(2)))

    ! finalize the Field
    call ESMF_FieldSetCommit(field3, grid2d, farray2d, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04032700000000000000"></A>
  <A NAME="sec:field:usage:create_5dgrid_7dptr_2dungridded"></A>
<BR>
18.2.7 Create 7D Field with 5D Grid and 2D ungridded bounds
   from Fortran data array
</H3>

<P>
In this example, we will show how to create a 7D Field from a 5D <TT>   ESMF_Grid</TT> and 2D ungridded bounds with arbitrary halo widths and 
   gridToFieldMap.

<P>
We first create a 5D DistGrid and a 5D Grid based on the DistGrid; then
   <TT>ESMF_FieldGet</TT> computes the shape of a 7D array in fsize. We can then
   create a 7D Field from the 5D Grid and the 7D Fortran data array with
   other assimilating parameters. 

<P>
<PRE>
    ! create a 5d distgrid
    distgrid5d = ESMF_DistGridCreate(minIndex=(/1,1,1,1,1/), maxIndex=(/10,4,10,4,6/), &amp;
        regDecomp=(/2,1,2,1,1/), rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Create a 5d Grid
    grid5d = ESMF_GridCreate(distgrid=distgrid5d, name="grid", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! use FieldGet to retrieve total counts 
    call ESMF_FieldGet(grid5d, localDe=0, ungriddedLBound=(/1,2/), &amp;
        ungriddedUBound=(/4,5/), &amp;
        maxHaloLWidth=(/1,1,1,2,2/), maxHaloUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        totalCount=fsize, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! allocate the 7d Fortran array based on retrieved total counts
    allocate(farray7d(fsize(1), fsize(2), fsize(3), fsize(4), fsize(5), fsize(6), fsize(7)))

    ! create the Field
    field7d = ESMF_FieldCreate(grid5d, farray7d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/1,2/), ungriddedUBound=(/4,5/), &amp;
        maxHaloLWidth=(/1,1,1,2,2/), maxHaloUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
A user can allocate the Fortran array in a different manner using the lower and
    upper bounds returned from FieldGet through the optional totalLBound and totalUBound
    arguments. In the following example, we create another 7D Field by retrieving the bounds
    and allocate the Fortran array with this approach. In this scheme, indexing the
    Fortran array is sometimes more convenient than using the shape directly. 

<P>
<PRE>
    call ESMF_FieldGet(grid5d, localDe=0, ungriddedLBound=(/1,2/), &amp;
        ungriddedUBound=(/4,5/), &amp;
        maxHaloLWidth=(/1,1,1,2,2/), maxHaloUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        totalLBound=flbound, totalUBound=fubound, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    allocate(farray7d2(flbound(1):fubound(1), flbound(2):fubound(2), flbound(3):fubound(3), &amp;
                       flbound(4):fubound(4), flbound(5):fubound(5), flbound(6):fubound(6), &amp;
                       flbound(7):fubound(7)) )

    field7d2 = ESMF_FieldCreate(grid5d, farray7d2, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/1,2/), ungriddedUBound=(/4,5/), &amp;
        maxHaloLWidth=(/1,1,1,2,2/), maxHaloUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04032800000000000000"></A>
  <A NAME="sec:field:usage:create_2darray"></A>
<BR>
18.2.8 Create 2D Field with 2D Grid and Fortran data array
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> directly from an <TT>ESMF_Grid</TT> and an intrinsic 
    Fortran data array. This interface is overloaded for typekind and rank
    of the Fortran data array.  

<P>
In the following example, each dimension size of the Fortran array is equal to the 
    exclusive bounds of its corresponding 
    Grid dimension queried from the Grid through <TT>ESMF_GridGet()</TT> public interface.

<P>
Formally let fa_shape(i) be the shape of i-th dimension of user supplied Fortran array,
    then rule 1 states:  
    <PRE>
   
    (1) fa_shape(i) = exclusiveCount(i)         
                  i = 1...GridDimCount
</PRE>

<P>
fa_shape(i) defines the shape of i-th dimension of the Fortran array.
    ExclusiveCount are the number of data elements of i-th dimension in the exclusive region queried
    from <TT>ESMF_GridGet</TT> interface. <EM>Rule 1 assumes that the Grid and the Fortran intrinsic
    array have same number of dimensions; and optional arguments
    of FieldCreate from Fortran array are left unspecified using default setup</EM>. These assumptions 
    are true for most typical use of FieldCreate from Fortran data array. This is the easiest way
    to create a Field from a Grid and Fortran intrinsic data array.

<P>
Fortran array dimension sizes (called shape in most Fortran language books) are equivalent
    to the bounds and counts used in this manual.  The following equation holds: 
    <PRE>
   
    fa_shape(i) = shape(i) = counts(i) = upper_bound(i) - lower_bound(i) + 1
</PRE>

<P>
These typically mean the same concept unless specifically explained to mean something else.
    For example, ESMF uses DimCount very often to mean number of dimensions instead of its meaning
    implied in the above equation. We'll clarify the meaning of a word when ambiguity could occur.

<P>
Rule 1 is most useful for a user working with Field creation from a Grid and a Fortran
    data array in most scenarios. It extends to higher dimension count, 3D, 4D, etc...
    Typically, as the code example demonstrates, a user first creates a Grid 
    , then uses <TT>ESMF_GridGet()</TT>
    to retrieve the exclusive counts.  Next the user calculates the shape
    of each Fortran array dimension according to rule 1. The Fortran data array is allocated
    and initialized based on the computed shape.  A Field can either be created in one shot
    created empty and finished using <TT>ESMF_FieldSetCommit</TT>.

<P>
There are important details that can be skipped but are good to know for <TT>ESMF_FieldSetCommit</TT>
    and <TT>ESMF_FieldCreate</TT> from a Fortran data array. 1) these methods require <EM>each PET contains
    exactly one DE</EM>. This implies that a code using FieldCreate from a data array or FieldSetCommit must
    have the same number of DEs and PETs, formally <!-- MATH
 $n_{DE} = n_{PET}$
 -->
<IMG
 WIDTH="98" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img21.png"
 ALT="$n_{DE} = n_{PET}$">. Violation of this condition
    will cause run time failures. 2) the bounds and counts retrieved from GridGet are DE specific
    or equivalently PET specific, which means that <EM>the Fortran array shape could be different from one
    PET to another</EM>. 

<P>
<PRE>
    grid = ESMF_GridCreateShapeTile(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
          regDecomp=(/2,2/), name="atmgrid", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_GridGet(grid, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
        exclusiveCount=gec, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    allocate(farray(gec(1), gec(2)) )

    field = ESMF_FieldCreate(grid, farray, ESMF_INDEX_DELOCAL, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION04032900000000000000"></A>
  <A NAME="sec:field:usage:create_2dptr"></A>
<BR>
18.2.9 Create 2D Field with 2D Grid and Fortran data pointer
</H3>

<P>
The setup of this example is similar to the previous section except 
   that the Field is created from a data pointer instead of a data array.
   We highlight the ability to deallocate the internal fortran data
   pointer queried from the Field. This gives a user more flexibility with
   memory management.

<P>
<PRE>
    allocate(farrayPtr(gec(1), gec(2)) )

    field = ESMF_FieldCreate(grid, farrayPtr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_FieldGet(field, farrayPtr=farrayPtr2, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    ! deallocate the retrieved fortran array pointer
    deallocate(farrayPtr2)
</PRE>

<P>

<H3><A NAME="SECTION040321000000000000000"></A>
  <A NAME="sec:field:usage:create_2dgrid_3dptr"></A>
<BR>
18.2.10 Create 3D Field with 2D Grid and 3D Fortran data array
</H3>

<P>
This example demonstrates a typical use of <TT>ESMF_Field</TT> combining
    a 2D grid and a 3D Fortran native data array. One immediate problem follows: 
    how does one define the bounds of the ungridded dimension? This is
    solved by the optional arguments <TT>ungriddedLBound</TT> and <TT>ungriddedUBound</TT>
    of the <TT>ESMF_FieldCreate</TT> interface. By definition, <TT>ungriddedLBound</TT>
    and <TT>ungriddedUBound</TT>
    are both 1 dimensional integer Fortran arrays.

<P>
Formally, let fa_shape(j=1...FieldDimCount-GridDimCount) be the shape of the
    ungridded dimensions of a Field relative to the Grid used in Field creation.
    The Field dimension count is equal to the number of dimensions of the Fortran array, which
    equals the number of dimensions of the resultant Field. GridDimCount is
    the number of dimensions of the Grid. 

<P>
fa_shape(j) is computed as:
    <PRE>
   
    fa_shape(j) = ungriddedUBound(j) - ungriddedLBound(j) + 1
</PRE>

<P>
fa_shape is easy to compute when the gridded and ungridded dimensions do not
    mix. However, it's conceivable that at higher dimension count, gridded and ungridded
    dimensions can interleave. To aid the computation of ungridded dimension shape
    we formally introduce the mapping concept.

<P>
Let <!-- MATH
 $map_{A,B}(i=1...n_A) = i_B$
 -->
<IMG
 WIDTH="179" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img22.png"
 ALT="$map_{A,B}(i=1...n_A) = i_B$">, and <!-- MATH
 $i_B \in [\phi, 1...n_B]$
 -->
<IMG
 WIDTH="109" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img23.png"
 ALT="$i_B \in [\phi, 1...n_B]$">. <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$n_A$"> is the number
    of elements in set A, <IMG
 WIDTH="27" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img25.png"
 ALT="$n_B$"> is the number of elements in set B. <IMG
 WIDTH="79" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img26.png"
 ALT="$map_{A,B}(i)$"> defines
    a mapping from i-th element of set A to <IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img27.png"
 ALT="$i_B$">-th element in set B. <IMG
 WIDTH="53" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img28.png"
 ALT="$i_B = \phi$"> 
    indicates there does not exist a mapping from i-th element of set A to set B.

<P>
Suppose we have a mapping from dimension index of ungriddedLBound (or
    ungriddedUBound) to Fortran array dimension index, called ugb2fa. 
    By definition, <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$n_A$"> equals to the dimension count of
    ungriddedLBound (or ungriddedUBound), <IMG
 WIDTH="27" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img25.png"
 ALT="$n_B$"> equals to the dimension count of
    the Fortran array. We can now formulate the computation of ungridded
    dimension shape as rule 2:
    <PRE>
   
    (2) fa_shape(ugb2fa(j)) = ungriddedUBound(j) - ungriddedLBound(j) + 1 
                          j = 1..FortranArrayDimCount - GridDimCount
</PRE>

<P>
The mapping can be computed in linear time proportional to the
    Fortran array dimension count (or rank) using the following algorithm in pseudocode:
    <PRE>
  
    map_index = 1
    do i = 1, farray_rank
        if i-th dimension of farray is ungridded
            ugb2fa(map_index) = i
            map_index = map_index + 1
        endif
    enddo
</PRE>

<P>
Here we use rank and dimension count interchangably. These 2 terminologies are typically
    equivalent. But there are subtle differences
    under certain conditions. Rank is the total number of dimensions of a tensor object.
    Dimension count allows a finer description of the heterogeneous dimensions in that object.
    For example, A Field of rank 5 can have 3 gridded dimensions and 2 ungridded dimensions.
    Rank is precisely the summation of dimension count of all types of dimensions. 

<P>
For example, if a 5D array is used with a 3D Grid, there are 2 ungridded dimensions:
    ungriddedLBound=(/1,2/) and ungriddedUBound=(/5,7/).
    Suppose the distribution of dimensions look like (O, X, O, X, O), O means gridded,
    X means ungridded. Then the mapping from ungridded bounds to Fortran array is
    ugb2fa=(/2, 4/). The shape of 2nd and 4th dimension of Fortran array should equal
    (5, 8).

<P>
Back to our 3D Field created from a 2D Grid and 3D Fortran array example, suppose the 3rd
    Field dimension is ungridded, ungriddedLBound=(/3/), ungriddedUBound=(/9/).
    First we use rule 1 to compute shapes of the gridded Fortran array dimension,
    then we use rule 2 to compute shapes of the ungridded Fortran array dimension.
    In this example, we used the exclusive bounds obtained in the previous
    example. 

<P>
<PRE>
    fa_shape(1) = gec(1) ! rule 1
    fa_shape(2) = gec(2)
    fa_shape(3) = 7 ! rule 2 9-3+1
    allocate(farray3d(fa_shape(1), fa_shape(2), fa_shape(3)))
    field = ESMF_FieldCreate(grid, farray3d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/3/), ungriddedUBound=(/9/), &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION040321100000000000000"></A>
  <A NAME="sec:field:usage:create_2dgrid_3dptr_map"></A>
<BR>
18.2.11 Create 3D Field with 2D Grid and 3D Fortran data array with gridToFieldMap
</H3>

<P>
Building upon the previous example, we will create a 3D Field from
    a 2D grid and 3D array but with a slight twist. In this example, we
    introduce the gridToFieldMap argument that allows a user to map Grid 
    dimension index to Field dimension index.

<P>
In this example, both dimensions of the Grid are distributed and the
    mapping from DistGrid to Grid is (/1,2/). We will introduce rule 3
    assuming distgridToGridMap=(/1,2,3...gridDimCount/), and distgridDimCount equals
    to gridDimCount. This is a reasonable assumption in typical Field use.

<P>
We apply the mapping gridToFieldMap on rule 1 to create rule 3:
    <PRE>
   
    (3) fa_shape(gridToFieldMap(i)) = exclusiveCount(i)        
                                  i = 1,..GridDimCount.
</PRE>

<P>
Back to our example, suppose the 2nd
    Field dimension is ungridded, ungriddedLBound=(/3/), ungriddedUBound=(/9/).
    gridToFieldMap=(/3,1/), meaning the 1st Grid dimension maps to 3rd Field dimension,
    and 2nd Grid dimension maps to 1st Field dimension.

<P>
First we use rule 3 to compute shapes of the gridded Fortran array dimension,
    then we use rule 2 to compute shapes of the ungridded Fortran array dimension.
    In this example, we use the exclusive bounds obtained in the previous
    example. 

<P>
<PRE>
    gridToFieldMap2d(1) = 3
    gridToFieldMap2d(2) = 1
    do i = 1, 2
        fa_shape(gridToFieldMap2d(i)) = gec(i)
    end do
    fa_shape(2) = 7
    allocate(farray3d(fa_shape(1), fa_shape(2), fa_shape(3)))
    field = ESMF_FieldCreate(grid, farray3d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/3/), ungriddedUBound=(/9/), &amp;
        gridToFieldMap=gridToFieldMap2d, &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION040321200000000000000"></A>
  <A NAME="sec:field:usage:create_2dgrid_3dptr_map_halo"></A>
<BR>
18.2.12 Create 3D Field with 2D Grid and 3D Fortran data array with halos
</H3>

<P>
This example is similar to example <A HREF="node4.html#sec:field:usage:create_2dgrid_3dptr_map">18.2.11</A>, 
    in addition we will show
    a user can associate different halo width to a Fortran array to create
    a Field through the maxHaloLWidth and maxHaloUWdith optional arguments.
    A diagram of the dimension configuration from Grid, halos, and Fortran data array
    is shown here.
  <DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:fieldparameter"></A><A NAME="11505"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 11:</STRONG>
Field dimension configuration from Grid, halos, and Fortran data array.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{FieldParameterSetup}}$
 -->
<IMG
 WIDTH="683" HEIGHT="736" ALIGN="BOTTOM" BORDER="0"
 SRC="img29.png"
 ALT="\scalebox{0.75}{\includegraphics{FieldParameterSetup}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The <TT>ESMF_FieldCreate()</TT> interface supports creating a Field from a Grid and a
    Fortran array padded with halos on the distributed dimensions of the Fortran
    array. Using this technique one can avoid passing non-contiguous Fortran array
    slice to FieldCreate. It guarantees the same exclusive region,
    and by using halos, it also defines a bigger total region to contain 
    the entire contiguous memory block of the Fortran array.

<P>
The elements of maxHaloLWidth and maxHaloUWidth are applied in the order
    distributed dimensions appear in the Fortran array. By definition, 
    maxHaloLWidth and maxHaloUWdith are 1 dimensional arrays of non-negative 
    integer values. The size of haloWidth arrays is equal to the number of distributed
    dimensions of the Fortran array, which is also equal to the number of
    distributed dimensions of the Grid used in the Field creation.

<P>
Because the order of maxHaloWidth (representing both maxHaloLWidth and
    maxHaloUWdith) element is applied to the order distributed dimensions
    appear in the Fortran array dimensions, it's quite simple to compute
    the shape of distributed dimensions of the Fortran array. They are done
    in a similar manner when applying ungriddedLBound and ungriddedUBound 
    to ungridded dimensions of the Fortran array defined by rule 2.

<P>
Assume we have the mapping from the dimension index of maxHaloWidth
    to the dimension index of Fortran array, called mhw2fa; and we also
    have the mapping from dimension index of Fortran array to dimension
    index of the Grid, called fa2g. The shape of
    distributed dimensions of a Fortran array can be computed by rule 4: 

<P>
<PRE>
  
    (4) fa_shape(mhw2fa(k)) = exclusiveCount(fa2g(mhw2fa(k)) + 
                              maxHaloUWidth(k) + maxHaloLWidth(k)
                          k = 1...size(maxHaloWidth)
</PRE>

<P>
This rule may seem confusing but algorithmically the computation
    can be done by the following pseudocode:

<P>
<PRE>
  
    fa_index = 1
    do i = 1, farray_rank
       if i-th dimension of Fortran array is distributed
           fa_shape(i) = exclusiveCount(fa2g(i)) + 
                         maxHaloUWidth(fa_index) + maxHaloLWidth(fa_index)
           fa_index = fa_index + 1
       endif
    enddo
</PRE>

<P>
The only complication then is to figure out the mapping from Fortran
    array dimension index to Grid dimension index. This process can
    be done by computing the reverse mapping from Field to Grid.

<P>
Typically, we don't have to consider these complications if the following
    conditions are met: 1) All Grid dimensions are distributed. 2) DistGrid
    in the Grid has a dimension index mapping to the Grid in the form of 
    natural order (/1,2,3,.../). This natural order mapping is the
    default mapping between various objects throughout ESMF. 3) Grid to Field
    mapping is in the form of natural order, i.e. default mapping. These
    seem like a lot of conditions but they are the default case in the interaction
    among DistGrid, Grid, and Field. When these conditions are met, which
    is typically true, the shape of distributed dimensions of Fortran array
    follows rule 5 in a simple form:

<P>
<PRE>
  
    (5) fa_shape(k) = exclusiveCount(k) + 
                      maxHaloUWidth(k) + maxHaloLWidth(k) 
                  k = 1...size(maxHaloWidth)
</PRE>

<P>
Let's examine an example on how to apply rule 5. Suppose we have a
    5D array and a 3D Grid that has its first 3 dimensions mapped to the first
    3 dimensions of the Fortran array. maxHaloLWidth=(/1,2,3/), 
    maxHaloUWdith=(/7,9,10/), then by rule 5, the following pseudo code
    can be used to compute the shape of the first 3 dimensions of the Fortran
    array. The shape of the remaining two ungridded dimensions can be
    computed according to rule 2.

<P>
<PRE>
  
    do k = 1, 3
        fa_shape(k) = exclusiveCount(k) + 
                      maxHaloUWidth(k) + maxHaloLWidth(k)) 
    enddo
</PRE>

<P>
Suppose now gridToFieldMap=(/2,3,4/) instead which says
    the first dimension of Grid maps to the 2nd dimension of Field (or 
    Fortran array) and so on and so forth, we can obtain a more general form 
    of rule 5 by introducing first_distdim_index shift when Grid to Field
    map (gridToFieldMap) is in the form of (/a,a+1,a+2.../).

<P>
<PRE>
  
    (6) fa_shape(k+first_distdim_index-1) = exclusiveCount(k) +
                                            maxHaloUWidth(k) + maxHaloLWidth(k)
                                        k = 1...size(maxHaloWidth)
</PRE>

<P>
It's obvious that first_distdim_index=a. If the first dimension of the Fortran
    array is distributed, then rule 6 degenerates into rule 5, which is
    the typical case.

<P>
Back to our example creating a 3D Field from a 2D Grid and a 3D intrinsic
    Fortran array, we will use the Grid created from previous example
    that satisfies condition 1 and 2. We'll also use a simple gridToFieldMap
    (1,2) which is the default mapping that satisfies condition 3. 
    First we use rule 5 to compute
    the shape of distributed dimensions then we use rule 2 to compute the shape
    of the ungridded dimensions. 

<P>
<PRE>
    gridToFieldMap2d(1) = 1
    gridToFieldMap2d(2) = 2
    maxHaloLWidth2d(1) = 3
    maxHaloLWidth2d(2) = 4
    maxHaloUWidth2d(1) = 3
    maxHaloUWidth2d(2) = 5
    do k = 1, 2
        fa_shape(k) = gec(k) + maxHaloLWidth2d(k) + maxHaloUWidth2d(k)
    end do
    fa_shape(3) = 7          ! 9-3+1
    allocate(farray3d(fa_shape(1), fa_shape(2), fa_shape(3)))
    field = ESMF_FieldCreate(grid, farray3d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/3/), ungriddedUBound=(/9/), &amp;
        maxHaloLWidth=maxHaloLWidth2d, maxHaloUWidth=maxHaloUWidth2d, &amp;
        gridToFieldMap=gridToFieldMap2d, &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION040321300000000000000"></A>
  <A NAME="sec:field:usage:create_locs_arrayspec"></A>
<BR>
18.2.13 Create a Field from a LocStream
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_LocStream</TT> 
   and an <TT>ESMF_Arrayspec</TT>.
   The location stream object is uniformly distributed
   in a 1 dimensional space on 4 DEs. The arrayspec is 1 dimensional. 
   Please refer to LocStream examples section for more information on LocStream creation.

<P>
<PRE>
    locs = ESMF_LocStreamCreate(minIndex=1, maxIndex=16, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_I4, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    field = ESMF_FieldCreate(locs, arrayspec, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION040321400000000000000"></A>
  <A NAME="sec:field:usage:create_mesh_arrayspec"></A>
<BR>
18.2.14 Create a Field from a Mesh
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_Mesh</TT> 
   and an <TT>ESMF_Arrayspec</TT>.
   The mesh object is on a Euclidean surface that is partitioned to a 2x2 rectangular
   space with 4 elements and 9 nodes. The nodal space is represented by
   a distgrid with 9 indices. Field is created on locally owned nodes on each PET.
   Therefore, the created Field has 9 data points globally.
   The mesh object can be represented by the picture
   below. For more information on Mesh creation, please see Section&nbsp;<A HREF="node4.html#sec:mesh:usage:meshCreation">25.2.1</A>.
   <PRE>
                Mesh Ids
  
    2.0   7 ------- 8 -------- 9
          |         |          |
          |    3    |    4     |
          |         |          |
    1.0   4 ------- 5 -------- 6
          |         |          |
          |    1    |    2     |
          |         |          |
    0.0   1 ------- 2 -------- 3
  
         0.0       1.0        2.0 
  
        Node Ids at corners
        Element Ids in centers
   
  
               Mesh Owners
  
    2.0   2 ------- 2 -------- 3
          |         |          |
          |    2    |    3     |
          |         |          |
    1.0   0 ------- 0 -------- 1
          |         |          |
          |    0    |    1     |
          |         |          |
    0.0   0 ------- 0 -------- 1
  
         0.0       1.0        2.0 
  
        Node Owners at corners
        Element Owners in centers
</PRE> 

<P>
<PRE>
      ! Create Mesh structure in 1 step
      mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
             nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
             nodeOwners=nodeOwners, elementIds=elemIds,&amp;
             elementTypes=elemTypes, elementConn=elemConn, &amp;
             rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

      call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_I4, rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

      ! Field is created on the 1 dimensinonal nodal distgrid. On
      ! each PET, Field is created on the locally owned nodes.
      field = ESMF_FieldCreate(mesh, arrayspec, rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION040321500000000000000"></A>
  <A NAME="sec:field:usage:create_mesh_array"></A>
<BR>
18.2.15 Create a Field from a Mesh and an Array
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_Mesh</TT> 
   and an <TT>ESMF_Array</TT>. The mesh object is created in the previous example and
   the array object is retrieved from the field created in the previous example too.

<P>
<PRE>
    call ESMF_MeshGet(mesh, nodalDistgrid=distgrid, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
    array = ESMF_ArrayCreate(distgrid=distgrid, arrayspec=arrayspec, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
    ! query the array from the previous example
    call ESMF_FieldGet(field, array=array, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
    ! create a Field from a mesh and an array
    field1 = ESMF_FieldCreate(mesh, array, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION040321600000000000000"></A>
  <A NAME="sec:field:usage:createMeshArrayspecOpt"></A>
<BR>
18.2.16 Create a Field from a Mesh and an ArraySpec with optional features
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_Mesh</TT>
   and an <TT>ESMF_ArraySpec</TT>. The mesh object is created in the previous example.
   The Field is also created with optional arguments such as ungridded dimensions
   and dimension mapping.

<P>
In this example, the mesh is mapped to the 2nd dimension of the
   <TT>ESMF_Field</TT>, with its first dimension being the ungridded dimension with bounds 1,3.

<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_I4, rc=rc)
    field = ESMF_FieldCreate(mesh, arrayspec=arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/3/), rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040321700000000000000"></A>
  <A NAME="sec:field:usage:create_repdim"></A>
<BR>
18.2.17 Field with replicated dimension
</H3>

<P>
In this example an <TT>ESMF_Field</TT> with replicated dimension is created from an <TT>ESMF_Grid</TT> and 
    an <TT>ESMF_Arrayspec</TT>. A user can also use other <TT>ESMF_FieldCreate()</TT> methods to create replicated
    dimension Field, this example illustrates the key concepts and use of a replicated dimension Field.

<P>
Normally gridToFieldMap argument in <TT>ESMF_FieldCreate()</TT> should not contain
    0 value entries. However, for Field with replicated dimension, a 0 entry in gridToFieldMap
    indicates the corresponding Grid dimension is replicated in the Field. In such a Field,
    the rank of the Field is no longer necessarily greater than its Grid rank.
    An example will make this clear. We will start by creating Distgrid and Grid.

<P>
<PRE>
    ! create 4D distgrid
    distgrid = ESMF_DistGridCreate(minIndex=(/1,1,1,1/), maxIndex=(/6,4,6,4/), &amp;
        regDecomp=(/2,1,2,1/), rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create 4D grid on top of the 4D distgrid
    grid = ESMF_GridCreate(distgrid=distgrid, name="grid", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create 3D arrayspec
    call ESMF_ArraySpecSet(arrayspec, 3, ESMF_TYPEKIND_R8, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
In this example, a user creates a 3D Field with replicated dimension
   replicated along the 2nd and 4th dimension of its underlying 4D Grid. 
   In addition, the 2nd dimension of the Field is ungridded (why?). The 1st and
   3rd dimensions of the Field have halos. 

<P>
<PRE>
    ! create field, 2nd and 4th dimensions of the Grid are replicated
    field = ESMF_FieldCreate(grid, arrayspec, ESMF_INDEX_DELOCAL, &amp;
        gridToFieldMap=(/1,0,2,0/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/4/), &amp;
        maxHaloLWidth=(/1,1/), maxHaloUWidth=(/4,5/), &amp;
        staggerloc=ESMF_STAGGERLOC_CORNER, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! get basic information from the field
    call ESMF_FieldGet(field, grid=grid1, array=array, typekind=typekind, &amp;
        dimCount=dimCount, staggerloc=lstaggerloc, gridToFieldMap=lgridToFieldMap, &amp;
        ungriddedLBound=lungriddedLBound, ungriddedUBound=lungriddedUBound, &amp;
        maxHaloLWidth=lmaxHaloLWidth, maxHaloUWidth=lmaxHaloUWidth, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! get bounds information from the field
    call ESMF_FieldGet(field, localDe=0, farrayPtr=farray, &amp;
        exclusiveLBound=felb, exclusiveUBound=feub, exclusiveCount=fec, &amp;
        computationalLBound=fclb, computationalUBound=fcub, computationalCount=fcc, &amp;
        totalLBound=ftlb, totalUBound=ftub, totalCount=ftc, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
Next we verify that the field and array bounds agree with each other 

<P>
<PRE>
    call ESMF_ArrayGet(array, rank=arank, dimCount=adimCount, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    gridrank_repdim = 0
    do i = 1, size(gridToFieldMap)
        if(gridToFieldMap(i) == 0) gridrank_repdim = gridrank_repdim + 1
    enddo
</PRE>

<P>
Number of undistributed dimension of the array <I>X</I> is computed from
   total rank of the array <I>A</I>, the dimension count of its underlying distgrid
   <I>B</I> and number of replicated dimension in the distgrid <I>C</I>. 
   We have the following formula: X = A - (B - C) 

<P>
<PRE>
    allocate(audlb(arank-adimCount+gridrank_repdim), audub(arank-adimCount+gridrank_repdim))
    call ESMF_ArrayGet(array, exclusiveLBound=aelb, exclusiveUBound=aeub, &amp;
        computationalLBound=aclb, computationalUBound=acub, &amp;
        totalLBound=atlb, totalUBound=atub, &amp;
        undistLBound=audlb, undistUBound=audub, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
    
    ! verify the ungridded bounds from field match 
    ! undistributed bounds from its underlying array
    do i = 1, arank-adimCount
        if(lungriddedLBound(i) .ne. audlb(i) ) &amp;
            rc = ESMF_FAILURE
    enddo
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    do i = 1, arank-adimCount
        if(lungriddedUBound(i) .ne. audub(i) ) &amp;
            rc = ESMF_FAILURE
    enddo
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
We then verify the data in the replicated dimension Field can be updated and accessed. 

<P>
<PRE>
    do ik = ftlb(3), ftub(3)
     do ij = ftlb(2), ftub(2)
      do ii = ftlb(1), ftub(1)
        farray(ii,ij,ik) = ii+ij*2+ik
      enddo
     enddo
    enddo
    ! access and verify
    call ESMF_FieldGet(field, localDe=0, farrayPtr=farray1, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
    do ik = ftlb(3), ftub(3)
     do ij = ftlb(2), ftub(2)
      do ii = ftlb(1), ftub(1)
        n = ii+ij*2+ik
        if(farray1(ii,ij,ik) .ne. n ) rc = ESMF_FAILURE
      enddo
     enddo
    enddo
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! release resources
    call ESMF_FieldDestroy(field)
    call ESMF_GridDestroy(grid)
    call ESMF_DistGridDestroy(distgrid)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040321800000000000000"></A>
  <A NAME="sec:field:usage:createArbGrid"></A>
<BR>
18.2.18 Field on arbitrarily distributed Grid
</H3>

<P>
With the introduction of Field on arbitrarily distributed Grid, Field has two kinds of dimension
    count: one associated geometrical (or physical) dimensionality, the other one associated with its
    memory index space representation. Field and Grid dimCount reflect the physical index 
    space of the objects. A new type of dimCount  memDimCount should be added to both of these entities. 
    memDimCount gives the number of dimensions of the memory index space of the objects.
    This would be the dimension of the pointer pulled out of Field and the
    size of the bounds vector, for example. 

<P>
For non-arbitrary Grids memDimCount=dimCount, but for grids and fields with
    arbitrary dimensions memDimCount = dimCount - (number of Arb dims) + 1
    (Internally Field can use the Arb info from the grid to create the mapping
    from the Field Array to the DistGrid)

<P>
When creating a Field size(GridToFieldMap)=dimCount for both Arb and Non-arb grids
    This array specifies the mapping of Field to Grid identically for both Arb and Nonarb grids 
    If a zero occurs in an entry corresponding to any arbitrary dimension, then
    a zero must occur in every entry corresponding to an arbitrary dimension (i.e.
    all arbitrary dimensions must either be all replicated or all not replicated,
    they can't be broken apart).

<P>
In this example an <TT>ESMF_Field</TT> is created from an arbitrarily distributed <TT>ESMF_Grid</TT> and 
    an <TT>ESMF_Arrayspec</TT>. A user can also use other <TT>ESMF_FieldCreate()</TT> methods to create 
    such a Field, this example illustrates the key concepts and use of Field on arbitrary distributed Grid.

<P>
The Grid is 3 dimensional in physics index space but the first two dimension are collapsed into
    a single memory index space. Thus the result Field is 3D in physics index space and 2D in memory index
    space. This is made obvious with the 2D arrayspec used to create this Field.

<P>
<PRE>
    ! create a 3D grid with the first 2 dimensions collapsed and arbitrarily distributed
    grid3d = ESMF_GridCreateShapeTile("arb3dgrid", coordTypeKind=ESMF_TYPEKIND_R8, &amp;
      minIndex=(/1,1,1/), maxIndex=(/xdim, ydim,zdim/), &amp;
      localArbIndex=localArbIndex,localArbIndexCount=localArbIndexCount,rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create a 2D arrayspec
    call ESMF_ArraySpecSet(arrayspec2D, rank=2, typekind=ESMF_TYPEKIND_R4, &amp;
         rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create a 2D Field using the Grid and the arrayspec
    field = ESMF_FieldCreate(grid3d, arrayspec2D, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
  
    call ESMF_FieldGet(field, memDimCount=memDimCount, dimCount=dimCount, rc=rc)
    if (myPet .eq. 0) print *, 'Field memDimCount, dimCount', memDimCount, dimCount
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
  
    ! verify that the dimension counts are correct
    if (memDimCount .ne. 2) correct = .false.
    if (dimCount .ne. 3) correct = .false.
</PRE>

<P>

<H3><A NAME="SECTION040321900000000000000"></A>
  <A NAME="sec:field:usage:createArbGridRep"></A>
<BR>
18.2.19 Field on arbitrarily distributed Grid with replicated dimension and ungridded bounds
</H3>

<P>
The next example is slightly more complicated in
    that the Field also contains ungridded dimension and its gridded dimension
    is replicated on the arbitrarily distributed dimension of the Grid.

<P>
The same 3D Grid and 2D arrayspec in the previous example
    are used but a gridToFieldMap argument
    is supplied to the <TT>ESMF_FieldCreate()</TT> call. The first 2 entries of
    the map are 0, the last (3rd) entry is 1. The 3rd dimension of the Grid is
    mapped to the first dimension of the Field, this dimension is then replicated
    on the arbitrarily distributed dimensions of the Grid. In addition, the
    Field also has one ungridded dimension. Thus the final dimension count of the
    Field is 2 in both physics and memory index space.

<P>
<PRE>
    field = ESMF_FieldCreate(grid3d, arrayspec2D,gridToFieldMap=(/0,0,1/), &amp;
            ungriddedLBound=(/1/), ungriddedUBound=(/10/),rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
  
    call ESMF_FieldGet(field, memDimCount=memDimCount, dimCount=dimCount, rc=rc)
    if (myPet .eq. 0) print *, 'Field memDimCount, dimCount', memDimCount, dimCount
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
  
    if (memDimCount .ne. 2) correct = .false.
    if (dimCount .ne. 2) correct = .false.
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040322000000000000000">
18.2.20 Field Regrid</A>
</H3>

<P>
The Field regrid operation moves data between Fields which lie on different Grids. In order to do this the data in
   the source Field is interpolated to the destination Grid and then put into the destination Field. In ESMF the regrid operation
   is implemented as a sparse matrix multiply. The <TT>ESMF_FieldRegridStore()</TT> call generates the sparse matrix for
   the regrid operation. This matrix may be either retrieved in a factor and index raw form, or may be retrieved in the form
   of a routeHandle which contains an internal representation of the communication and mathermatical operations necessary to 
   perform the regrid. The routeHandle can then be used in an <TT>ESMF_FieldRegrid()</TT> call to perform the interpolation
   between the two Fields. Note that the routeHandle depends just on the coordinates in the Grids upon which the Fields are built, so 
   as long as the coordinates stay the same, the operation can be performed multiple times using the same routeHandle. This is true
   even if the Field data changes. The same routeHandle may also be used to interpolate between any source and destination Field 
   which lie on the same stagger location and Grid as the original Fields. 
   When it's no longer needed the routeHandle should be destroyed by using <TT>ESMF_FieldRegridRelease()</TT> to free the memory it's using.  

<P>
There are two options for accessing ESMF regridding functionality: online and offline.  Online regridding means that the 
   weights are generated via subroutine calls during the execution of the users code. This is the method described in the following 
   sections. Offline regridding means that the weights are generated by a seperate application from the user code. Please see 
   Section&nbsp;<A HREF="node4.html#sec:regrid:offline">29.6</A> for a description of the offline regridding application and the options it supports.

<P>
ESMF currently supports regridding only on a subset of the full range of Grids and Meshes it supports. 

<P>
In 2D ESMF supports regridding between any combination of the following:
   
<UL>
<LI>Structured Grids composed of a single logically rectangular patch
</LI>
<LI>Unstructured Meshes composed of any combination of triangles and quadralaterals (e.g. rectangles)
   
</LI>
</UL>
   In addition the user may use the <TT>ESMF_REGRID_SCHEME_FULL3D</TT>  option in <TT>ESMF_FieldRegridStore()</TT> to
   map two single patch logically rectangular Grids onto the sphere and regrid between them in that representation. 

<P>
In 3D ESMF supports regridding between any combination of the following:
   
<UL>
<LI>Structured Grids composed of a single logically rectangular patch
</LI>
<LI>Unstructured Meshes composed of hexahedrons (e.g. cubes). 
   
</LI>
</UL>
   Note that regridding involving tetrahedra is currently NOT supported. 

<P>
In terms of masking, ESMF regrid currently supports masking for Fields built on structured Grids. The user may mask out points in 
   the source Field or destination Field or both. The user also has the option to return an error for unmapped destination points or
   to ignore them. At this point ESMF does not support extrapolation to destination points outside the unmasked source Field. 

<P>
ESMF currently supports two options for interpolation: bilinear and patch. Bilinear interpolation calculates the value for the 
   destination point as a combination of multiple linear interpolations, one for each dimension of the Grid. Note that for ease of 
   use, the term bilinear interpolation is used for 3D interpolation in ESMF as well, although it should more properly be referred 
   to as trilinear interpolation.

<P>
Patch (or higher-order) interpolation is the ESMF version of a techique called ``patch recovery'' commonly
   used in finite element modeling&nbsp;[<A
 HREF="node6.html#PatchInterp1">3</A>]&nbsp;[<A
 HREF="node6.html#PatchInterp2">14</A>]. It typically results in better approximations to 
   values and derivatives when compared to bilinear interpolation.
   Patch interpolation works by constructing multiple polynomial patches to represent
   the data in a source cell. For 2D grids, these polynomials
   are currently 2nd degree 2D polynomials. One patch is constructed for each corner of the source cell, and the patch is constructed 
   by doing a least squared fit through the data in the cells surrounding the corner. The interpolated value at the destination point is 
   then a weighted average of the values of the patches at that point.

<P>
The conservative regridding is applied as a modification to the original interpolation
   matrix.  The conservative modification is computed using L2 projection.  The ESMF version
   of the L2 projection method is based on a finite element method to constrain the 
   interpolation for global first order conservation of mass.  The conservative option can be 
   applied as a modification to either the patch or bilinear interpolation by setting the 
   optional <TT>ESMF_REGRID_CONSERVE_ON</TT> flag in the <TT>ESMF_FieldRegridStore()</TT> call. 

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="12063"></A>
<TABLE>
<CAPTION><STRONG>Table 1:</STRONG>
Comparison of the offline vs. online regridding capabilities of ESMF</CAPTION>
<TR><TD>  <DIV ALIGN="CENTER">  <BR>
  <TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="CENTER">Online</TD>
<TD ALIGN="CENTER">Offline</TD>
</TR>
<TR><TD ALIGN="LEFT">2D Polygons</TD>
<TD ALIGN="LEFT">Triangles</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Quadrilaterals</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">3D Polygons</TD>
<TD ALIGN="LEFT">Hexahedrons</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">Regridding</TD>
<TD ALIGN="LEFT">Bilinear</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Patch</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">Conservative</TD>
<TD ALIGN="LEFT">L2</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">Masking</TD>
<TD ALIGN="LEFT">Destination</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Source</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Unmapped points</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">Pole Options</TD>
<TD ALIGN="LEFT">Full circle average</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">N-point average</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\surd$"></TD>
</TR>
</TABLE>
  <A NAME="Regriddingcapabilities"></A>  </DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
The following sections give examples of using the regridding functionality.

<P>

<H3><A NAME="SECTION040322100000000000000">
18.2.21 Creating a Regrid Operator from two Fields</A>
</H3>
   To create the sparse matrix regrid operator we call the
   <TT>ESMF_FieldRegridStore()</TT> routine.  In this example we
   choose the <TT>ESMF_REGRID_METHOD_BILINEAR</TT> regridding method.  Other
   methods are available and more we will be added in the future.
   This method creates two meshes, and a Rendezvous decomposition of these
   meshes is computed.  An octree search is performed, followed by a determination
   of which source cell each destination gridpoint is in.  Bilinear weights
   are then computed locally on each cell.  This matrix of weights is, finally,
   sent back to the destination grid's row decomposition and declared as a 
   sparse matrix.  This matrix is embedded in the routeHandle object. 

<P>
<PRE>
  call ESMF_FieldRegridStore(srcField=srcField, dstField=dstField, &amp;
                  routeHandle=routeHandle, &amp;
                  indicies=indicies, weights=weights, &amp;
                  regridMethod=ESMF_REGRID_METHOD_BILINEAR, rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION040322200000000000000">
18.2.22 Applying the Regrid Operator to a pair of Fields</A>
</H3>
   The <TT>ESMF_FieldRegrid</TT> subroutine calls <TT>ESMF_ArraySparseMatMul</TT>
   and performs a regrid from source to destination field. 

<P>
<PRE>
  call ESMF_FieldRegrid(srcField, dstField, routeHandle, rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION040322300000000000000">
18.2.23 Release a Regrid Operator</A>
</H3> 

<P>
<PRE>
  call ESMF_FieldRegridRelease(routeHandle, rc=localrc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040322400000000000000">
18.2.24 Creating a Regrid Operator Using Masks</A>
</H3>
   As before, to create the sparse matrix regrid operator we call the
   <TT>ESMF_FieldRegridStore()</TT> routine. 
   However, in this case we apply masking to the regrid operation. 
   The mask value for each index location in the Grids may be set using
   the <TT>ESMF_GridAddItem()</TT> call (see Section&nbsp;<A HREF="node4.html#sec:usage:items">23.2.12</A>
   and Section&nbsp;<A HREF="node4.html#sec:usage:items:accessing">23.2.13</A>). Mask values may be set independantly 
   for the source and destination Grids. If no mask values have been set in a Grid, then it is 
   assumed no masking should be used for that Grid. The <TT>srcMaskValues</TT>
   parameter allows the user to set the list of values which indicate
   that a source location should be masked out. The <TT>dstMaskValues</TT>
   parameter allows the user to set the list of values which indicate
   that a destination location should be masked out. The absence of 
   one of these parameters indicates that no masking should be used
   for that Field (e.g no <TT>srcMaskValue</TT> parameter indicates that source
   masking shouldn't occur). The <TT>unmappedDstAction</TT> flag may be
   used with or without masking and indicates what should occur
   if destination points can not be mapped to a source cell. 
   Here the <TT>ESMF_UNMAPPEDACTION_IGNORE</TT> value indicates that unmapped
   destination points are to be ignored and no sparse matrix entries should be
    generated for them.  

<P>
<PRE>
  call ESMF_FieldRegridStore(srcField=srcField, srcMaskValues=(/1/),       &amp;
                             dstField=dstField, dstMaskValues=(/1/),       &amp;
                             unmappedDstAction=ESMF_UNMAPPEDACTION_IGNORE, &amp;
                             routeHandle=routeHandle,                      &amp;
                             indicies=indicies, weights=weights,           &amp;
                             regridMethod=ESMF_REGRID_METHOD_BILINEAR,     &amp;
                             rc=localrc)
</PRE>

<P>
The <TT>ESMF_FieldRegrid</TT> and <TT>ESMF_FieldRegridRelease</TT> calls
   may then be applied as in the previous example. 

<P>

<H3><A NAME="SECTION040322500000000000000">
18.2.25 Regrid Troubleshooting Guide</A>
</H3>

<P>
The below is a list of problems users commonly encounter with regridding and potential solutions. 
   This is by no means an exhaustive list, so if none of these problems fit your case, or if the solutions
   don't fix your problem, please feel free to email esmf support (esmf_support@list.woc.noaa.gov).

<P>

<P><P>
<BR>

<P>
<B>Problem:</B> Regridding is too slow.

<P>

<P>
<BR>

<P>
<B>Possible Cause:</B> The <TT>ESMF_FieldRegridStore()</TT> method is called more than is necessary. 
   The <TT>ESMF_FieldRegridStore()</TT> operation is a complex one and can be 
   relatively slow for some cases (large Grids, 3D grids, etc.) 

<P>

<P></P>

<P>
<B>Solution:</B> Reduce the number of <TT>ESMF_FieldRegridStore()</TT> calls to the minimum necessary. The
   routeHandle generated by the <TT>ESMF_FieldRegridStore()</TT> call depends on only four factors: the 
   stagger locations that the input Fields are created on, the coordinates in the Grids the input Fields
   are built on at those stagger locations, the padding of the input Fields 
   (specified by the <TT>maxHaloWidth</TT> arguments in <TT>FieldCreate</TT>) and the size of the tensor
   dimensions in the input Fields (specified by the <TT>ungridded</TT> arguments in <TT>FieldCreate</TT>). 
   For any pair of Fields which share these attributes with the Fields used in the
   <TT>ESMF_FieldRegridStore</TT> call  the same routeHandle can be used. Note, that the data in the 
   Fields does NOT matter, the same routeHandle can be used no matter how the data in the Fields changes.

<P>

<P></P>

<P>
In particular:
   
<UL>
<LI>If Grid coordinates do not change during a run, then the <TT>ESMF_FieldRegridStore()</TT> call can be
   done once between a pair of Fields at the beginning and the resulting routeHandle used for each 
   timestep during the run. 

<P>
</LI>
<LI>If a pair of Fields was created with exactly the same arguments to <TT>ESMF_FieldCreate()</TT> as the 
   pair of Fields used during an <TT>ESMF_FieldRegridStore()</TT> call, then the resulting routeHandle can 
   also be used between that pair of Fields. 
   
</LI>
</UL>

<P>

<P><P>
<BR>

<P>
<B>Problem:</B> Distortions in destination Field at periodic boundary.

<P>

<P>
<BR>

<P>
<B>Possible Cause:</B> The Grid overlaps itself. With a periodic Grid, the regrid system expects
    the first point to not be a repeat of the last point. In other words,
    regrid constructs its own connection and overlap between the first and last points of the
    periodic dimension and so the Grid doesn't need to contain these. If the Grid does, then this
    can cause problems. 

<P>

<P></P>

<P>
<B>Solution:</B> Define the Grid so that it doesn't contain the overlap point. This typically means simply making
   the Grid one point smaller in the periodic dimension.  If a Field 
   constructuted on the Grid needs to contain these overlap points then the user can use the
   <TT>maxHaloWidth</TT> arguments to include this extra padding in the Field. Note, however, 
   that the regrid won't update these extra points, so the user will have to do a copy to fill the points
   in the overlap region in the Field.  

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040322600000000000000">
18.2.26 Field Regrid Example: Mesh to Mesh</A>
</H3>
   This example demonstrates the regridding process between Fields created on Meshes. First
   the Meshes are created. This example omits the setup of the arrays describing the Mesh, but please see
   Section&nbsp;<A HREF="node4.html#sec:mesh:usage:meshCreation">25.2.1</A> for examples of this. After creation Fields are constructed on the Meshes, 
   and then ESMF_FieldRegridStore() is called to construct a RouteHandle implementing the regrid operation. Finally, ESMF_FieldRegrid() is
   called with the Fields and the RouteHandle to do the interpolation between the source Field and 
   destination Field.

<P>
<PRE>
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create Source Mesh
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Create the Mesh structure.
  ! For brevity's sake, the code to fill the Mesh creation 
  ! arrays is omitted from this example. However, here
  ! is a brief description of the arrays:
  ! srcNodeIds    - the global ids for the src nodes
  ! srcNodeCoords - the coordinates for the src nodes
  ! srcNodeOwners - which PET owns each src node
  ! srcElemIds    - the global ids of the src elements
  ! srcElemTypes  - the topological shape of each src element
  ! srcElemConn   - how to connect the nodes to form the elements
  !                 in the source mesh
  ! Several examples of setting up these arrays can be seen in
  ! the Mesh Section "Mesh Creation". 
  srcMesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
         nodeIds=srcNodeIds, nodeCoords=srcNodeCoords, &amp;
         nodeOwners=srcNodeOwners, elementIds=srcElemIds,&amp;
         elementTypes=srcElemTypes, elementConn=srcElemConn, rc=rc)



  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create and Fill Source Field
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Set description of source Field
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc=rc)

  ! Create source Field
  srcField = ESMF_FieldCreate(srcMesh, arrayspec, &amp;
                        name="source", rc=rc)

  ! Get source Field data pointer to put data into
  call ESMF_FieldGet(srcField, 0, fptr1D,  rc=rc)

  ! Get number of local nodes to allocate space
  ! to hold local node coordinates
  call ESMF_MeshGet(srcMesh, &amp;
         numOwnedNodes=numOwnedNodes, rc=rc)

  ! Allocate space to hold local node coordinates
  ! (spatial dimension of Mesh*number of local nodes)
  allocate(ownedNodeCoords(2*numOwnedNodes))

  ! Get local node coordinates
  call ESMF_MeshGet(srcMesh, &amp;
         ownedNodeCoords=ownedNodeCoords, rc=rc)

  ! Set the source Field to the function 20.0+x+y
  do i=1,numOwnedNodes
    ! Get coordinates
    x=ownedNodeCoords(2*i-1)
    y=ownedNodeCoords(2*i)

   ! Set source function
   fptr1D(i) = 20.0+x+y
  enddo

  ! Deallocate local node coordinates
  deallocate(ownedNodeCoords)


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create Destination Mesh
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Create the Mesh structure.
  ! For brevity's sake, the code to fill the Mesh creation 
  ! arrays is omitted from this example. However, here
  ! is a brief description of the arrays:
  ! dstNodeIds    - the global ids for the dst nodes
  ! dstNodeCoords - the coordinates for the dst nodes
  ! dstNodeOwners - which PET owns each dst node
  ! dstElemIds    - the global ids of the dst elements
  ! dstElemTypes  - the topological shape of each dst element
  ! dstElemConn   - how to connect the nodes to form the elements
  !                 in the destination mesh
  ! Several examples of setting up these arrays can be seen in
  ! the Mesh Section "Mesh Creation". 
  dstMesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
         nodeIds=dstNodeIds, nodeCoords=dstNodeCoords, &amp;
         nodeOwners=dstNodeOwners, elementIds=dstElemIds,&amp;
         elementTypes=dstElemTypes, elementConn=dstElemConn, rc=rc)


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create Destination Field
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Set description of source Field
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc)

  ! Create destination Field
  dstField = ESMF_FieldCreate(dstMesh, arrayspec, &amp;
                        name="destination", rc=rc)

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Do Regrid
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Compute RouteHandle which contains the regrid operation
  call ESMF_FieldRegridStore( &amp;
          srcField, &amp;
          dstField=dstField, &amp;
          routeHandle=routeHandle, &amp;
          regridMethod=ESMF_REGRID_METHOD_BILINEAR, &amp;
          rc=rc)

  ! Perform Regrid operation moving data from srcField to dstField
  call ESMF_FieldRegrid(srcField, dstField, routeHandle, rc=rc)


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! dstField now contains the interpolated data.
  ! If the Meshes don't change, then routeHandle
  ! may be used repeatedly to interpolate from 
  ! srcField to dstField.  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   
  ! User code to use the routeHandle, Fields, and
  ! Meshes goes here before they are freed below.


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Free the objects created in the example.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Free the RouteHandle
  call ESMF_FieldRegridRelease(routeHandle, rc=rc)

  ! Free the Fields
  call ESMF_FieldDestroy(srcField, rc=rc)

  call ESMF_FieldDestroy(dstField, rc=rc)

  ! Free the Meshes
  call ESMF_MeshDestroy(dstMesh, rc=rc)

  call ESMF_MeshDestroy(srcMesh, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040322700000000000000"></A>
   <A NAME="sec:field:usage:gather_2dptr"></A>
<BR>
18.2.27 Gather Field data onto root PET
</H3>

<P>
User can use <TT>ESMF_FieldGather</TT> interface to gather Field data from multiple
   PETS onto a single root PET. This interface is overloaded by type, kind, and rank.

<P>
In this example, we first create a 2D Field, then use <TT>ESMF_FieldGather</TT> to
   collect all the data in this Field into a data pointer on PET 0. 

<P>
<PRE>
    ! Get current VM and pet number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_VMGet(vm, localPet=lpe, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Create a 2D Grid and use this grid to create a Field
    ! farray is the Fortran data array that contains data on each PET.
    grid = ESMF_GridCreateShapeTile(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
        regDecomp=(/2,2/), &amp;
        gridEdgeLWidth=(/0,0/), gridEdgeUWidth=(/0,0/), &amp;
        name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_GridGet(grid, distgrid=distgrid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(grid, localDe=0, totalCount=fa_shape, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    allocate(farray(fa_shape(1), fa_shape(2)))
    farray = lpe
    array = ESMF_ArrayCreate(farray, distgrid=distgrid, indexflag=ESMF_INDEX_DELOCAL, &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    field = ESMF_FieldCreate(grid, array, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! allocate the Fortran data array on PET 0 to store gathered data
    if(lpe .eq. 0) allocate(farrayDst(10,20))
    call ESMF_FieldGather(field, farrayDst, rootPet=0, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! check that the values gathered on rootPet are correct
    !    1        5         10
    ! 1  +--------+---------+
    !    |        |         |
    !    |   0    |    1    |
    !    |        |         |
    ! 10 +--------+---------+
    !    |        |         |
    !    |   2    |    3    |
    !    |        |         |
    ! 20 +--------+---------+
    if(lpe .eq. 0) then
        do i = 1, 2
            do j = 1, 2
                if(farrayDst(i, j) .ne. (i-1)+(j-1)*2) localrc=ESMF_FAILURE
                if(farrayDst(i*5, j*10) .ne. (i-1)+(j-1)*2) localrc=ESMF_FAILURE
            enddo
        enddo
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    endif

    ! destroy all objects created in this example to prevent memory leak
    call ESMF_FieldDestroy(field, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_GridDestroy(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_ArrayDestroy(array, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    deallocate(farray)
    if(lpe .eq. 0) deallocate(farrayDst)
</PRE>

<P>

<H3><A NAME="SECTION040322800000000000000"></A>
   <A NAME="sec:field:usage:scatter_2dptr"></A>
<BR>
18.2.28 Scatter Field data from root PET onto its set of joint PETs
</H3>

<P>
User can use <TT>ESMF_FieldScatter</TT> interface to scatter Field data from root
   PET onto its set of joint PETs. This interface is overloaded by type, kind, and rank.

<P>
In this example, we first create a 2D Field, then use <TT>ESMF_FieldScatter</TT> to
   scatter the data from a data array located on PET 0 onto this Field. 

<P>
<PRE>
    ! Create a 2D Grid and use this grid to create a Field
    ! farray is the Fortran data array that contains data on each PET.
    grid = ESMF_GridCreateShapeTile(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
        regDecomp=(/2,2/), &amp;
        gridEdgeLWidth=(/0,0/), gridEdgeUWidth=(/0,0/), &amp;
        name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_GridGet(grid, distgrid=distgrid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(grid, localDe=0, totalCount=fa_shape, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    allocate(farray(fa_shape(1), fa_shape(2)))
    farray = lpe
    array = ESMF_ArrayCreate(farray, distgrid=distgrid, indexflag=ESMF_INDEX_DELOCAL, &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    field = ESMF_FieldCreate(grid, array, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! initialize values to be scattered
    !    1        5         10
    ! 1  +--------+---------+
    !    |        |         |
    !    |   0    |    1    |
    !    |        |         |
    ! 10 +--------+---------+
    !    |        |         |
    !    |   2    |    3    |
    !    |        |         |
    ! 20 +--------+---------+
    if(lpe .eq. 0) then
        allocate(farraySrc(10,20))
        farraySrc(1:5,1:10) = 0
        farraySrc(6:10,1:10) = 1
        farraySrc(1:5,11:20) = 2
        farraySrc(6:10,11:20) = 3
    endif

    ! scatter the data onto individual PETs of the Field
    call ESMF_FieldScatter(field, farraySrc, rootPet=0, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(field, localDe=0, farrayPtr=fptr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! verify that the scattered data is properly distributed
    do i = lbound(fptr, 1), ubound(fptr, 1)
        do j = lbound(fptr, 2), ubound(fptr, 2)
            if(fptr(i, j) .ne. lpe) localrc = ESMF_FAILURE
        enddo
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! destroy all objects created in this example to prevent memory leak
    call ESMF_FieldDestroy(field, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_GridDestroy(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_ArrayDestroy(array, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    deallocate(farray)
    if(lpe .eq. 0) deallocate(farraySrc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040322900000000000000"></A>
   <A NAME="sec:field:usage:redist_1dptr"></A>
<BR>
18.2.29 Redistribute data from source Field to destination Field
</H3>

<P>
User can use <TT>ESMF_FieldRedist</TT> interface to redistribute data from 
   source Field to destination Field. This interface is overloaded by type and kind;
   In the version of <TT>ESMF_FieldRedist</TT> without factor argument, a default value
   of 1 is used.

<P>
In this example, we first create two 1D Fields, a source Field and a destination
   Field. Then we use <TT>ESMF_FieldRedist</TT> to
   redistribute data from source Field to destination Field. 

<P>
<PRE>
    ! Get current VM and pet number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_VMGet(vm, localPet=localPet, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create distgrid and grid
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/16/), &amp;
        regDecomp=(/4/), &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        gridEdgeLWidth=(/0/), gridEdgeUWidth=(/0/), &amp;
        name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(grid, localDe=0, totalCount=fa_shape, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create src_farray, srcArray, and srcField
    ! +--------+--------+--------+--------+
    !      0        1        2        3            ! value
    ! 1        4        8        12       16       ! bounds
    allocate(src_farray(fa_shape(1)) )
    src_farray = localPet
    srcArray = ESMF_ArrayCreate(src_farray, distgrid=distgrid, indexflag=ESMF_INDEX_DELOCAL, &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    srcField = ESMF_FieldCreate(grid, srcArray, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create dst_farray, dstArray, and dstField
    ! +--------+--------+--------+--------+
    !      0        0        0        0            ! value
    ! 1        4        8        12       16       ! bounds
    allocate(dst_farray(fa_shape(1)) )
    dst_farray = 0
    dstArray = ESMF_ArrayCreate(dst_farray, distgrid=distgrid, indexflag=ESMF_INDEX_DELOCAL, &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    dstField = ESMF_FieldCreate(grid, dstArray, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! perform redist
    ! 1. setup routehandle from source Field to destination Field
    call ESMF_FieldRedistStore(srcField, dstField, routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! 2. use precomputed routehandle to redistribute data
    call ESMF_FieldRedist(srcfield, dstField, routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! verify redist
    call ESMF_FieldGet(dstField, localDe=0, farrayPtr=fptr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Verify that the redistributed data in dstField is correct.
    ! Before the redist op, the dst Field contains all 0. 
    ! The redist op reset the values to the PE value, verify this is the case.
    do i = lbound(fptr, 1), ubound(fptr, 1)
        if(fptr(i) .ne. localPet) localrc = ESMF_FAILURE
    enddo
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
Field redistribution can also be performed between weakly congruent Fields.
   In this case, source and destination Fields can have ungridded dimensions
   with size different from the Field pair used to compute the routehandle.  

<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=2, rc=rc)
</PRE>

<P>
Create two fields with ungridded dimensions using the Grid created previously.
   The new Field pair has matching number of elements. The ungridded dimension
   is mapped to the first dimension of either Field. 

<P>
<PRE>
    srcFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
    dstFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
Using the previously computed routehandle, weakly congruent Fields can be
   redistributed. 

<P>
<PRE>
    call ESMF_FieldRedist(srcfieldA, dstFieldA, routehandle, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldRedistRelease(routehandle, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040323000000000000000"></A>
   <A NAME="sec:field:usage:redist_scattering"></A>
<BR>
18.2.30 Field redistribution as a form of scattering on arbitrarily distributed structures
</H3>

<P>
User can use <TT>ESMF_FieldRedist</TT> interface to redistribute data from 
   source Field to destination Field, where the destination Field is built on
   an arbitrarily distributed structure, e.g. <TT>ESMF_Mesh</TT>. The underlying mechanism is explained
   in section <A HREF="node4.html#Array:ScatterGatherRevisited">20.2.17</A>.

<P>
In this example, we will create 2 one dimensional Fields, the src Field has a regular decomposition
   and holds all its data on a single PET, in this case PET 0. The destination Field is built on a Mesh
   which is itself built on an arbitrarily distributed distgrid. Then we use <TT>ESMF_FieldRedist</TT> to
   redistribute data from source Field to destination Field, similar to a traditional scatter operation.

<P>
The src Field only has data on PET 0 where it is sequentially initialized, i.e. 1,2,3...This data
   will be redistributed (or scattered) from PET 0 to the destination Field arbitrarily distributed on 
   all the PETs. 

<P>
<PRE>
    ! a one dimensional grid whose elements are all located on PET 0
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/9/), &amp;
        regDecomp=(/1/), rc=rc)
    grid = ESMF_GridCreate(distgrid=distgrid, indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_I4, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    srcField = ESMF_FieldCreate(grid, arrayspec, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! initialize the source data
    if (localPet == 0) then
        call ESMF_FieldGet(srcField, farrayPtr=srcfptr, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
        do i = 1, 9
            srcfptr(i) = i
        enddo
    endif
</PRE>

<P>
For more information on Mesh creation, user can refer to Mesh examples section or Field creation
   on Mesh example for more details. 

<P>
<PRE>
      ! Create Mesh structure
      mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
             nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
             nodeOwners=nodeOwners, elementIds=elemIds,&amp;
             elementTypes=elemTypes, elementConn=elemConn, &amp;
             rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
Create the destination Field on the Mesh that is arbitrarily distributed on 
   all the PETs. 

<P>
<PRE>
      call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_I4, rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

      dstField = ESMF_FieldCreate(mesh, arrayspec, rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
Perform the redistribution from source Field to destination Field. 

<P>
<PRE>
     call ESMF_FieldRedistStore(srcField, dstField, routehandle=routehandle, rc=rc)
     if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
     call ESMF_FieldRedist(srcField, dstField, routehandle=routehandle, rc=rc)
     if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
We can now verify that the sequentially intialized source data is scattered
   on to the destination Field. The data has been scattered onto the destination
   Field with the following distribution.
  <PRE>
  
   4 elements on PET 0:  1 2 4 5
   2 elements on PET 1:  3 6
   2 elements on PET 2:  7 8
   1 element  on PET 3:  9
</PRE>
   Because the redistribution is index based, the elements also corresponds to the
   index space of Mesh in the destination Field. 

<P>
<PRE>
    call ESMF_FieldGet(dstField, farrayPtr=dstfptr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
The scatter operation is successful. Since the routehandle computed with
   <TT>ESMF_FieldRedistStore</TT> can be reused, user can use the same routehandle
   to scatter multiple source Fields from a single PET to multiple destination
   Fields distributed on all PETs. The <TT>gathering</TT> operation is just the 
   opposite of the demonstrated <TT>scattering</TT> operation, where a user would
   redist from a source Field distributed on multiple PETs to a destination Field
   that only has data storage on a single PET.

<P>
Now it's time to release all the resources. 

<P>
<PRE>
    call ESMF_FieldRedistRelease(routehandle=routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_FieldDestroy(srcField, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_FieldDestroy(dstField, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_MeshDestroy(mesh, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040323100000000000000"></A>
   <A NAME="sec:field:usage:smm_1dptr"></A>
<BR>
18.2.31 Sparse matrix multiplication from source Field to destination Field
</H3>

<P>
A user can use <TT>ESMF_FieldSMM()</TT> interface to perform sparse matrix multiplication 
   from 
   source Field to destination Field. This interface is overloaded by type and kind;

<P>
In this example, we first create two 1D Fields, a source Field and a destination
   Field. Then we use <TT>ESMF_FieldSMM</TT> to
   perform sparse matrix multiplication from source Field to destination Field.

<P>
The source and destination Field data are arranged such that each of the 4 PETs has 4
   data elements. Moreover, the source Field has all its data elements initialized to a linear
   function based on local PET number. 
   Then collectively on each PET, a SMM according to the following formula
   is preformed: <BR>
   <!-- MATH
 $dstField(i) = i * srcField(i), i = 1 ... 4$
 -->
<IMG
 WIDTH="267" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$dstField(i) = i * srcField(i), i = 1 ... 4$"> <BR>
   <BR>

<P>
Because source Field data are initialized to a linear function based on local PET number, 
   the formula predicts that
   the result destination Field data on each PET is 1,2,3,4. This is verified in the
   example.

<P>
Section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> provides a detailed discussion of the 
   sparse matrix mulitiplication operation implemented in ESMF.

<P>
<PRE>
    ! Get current VM and pet number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_VMGet(vm, localPet=lpe, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create distgrid and grid
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/16/), &amp;
        regDecomp=(/4/), &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        gridEdgeLWidth=(/0/), gridEdgeUWidth=(/0/), &amp;
        name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(grid, localDe=0, totalCount=fa_shape, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create src_farray, srcArray, and srcField
    ! +--------+--------+--------+--------+
    !      1        2        3        4            ! value
    ! 1        4        8        12       16       ! bounds
    allocate(src_farray(fa_shape(1)) )
    src_farray = lpe+1
    srcArray = ESMF_ArrayCreate(src_farray, distgrid=distgrid, indexflag=ESMF_INDEX_DELOCAL, &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    srcField = ESMF_FieldCreate(grid, srcArray, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create dst_farray, dstArray, and dstField
    ! +--------+--------+--------+--------+
    !      0        0        0        0            ! value
    ! 1        4        8        12       16       ! bounds
    allocate(dst_farray(fa_shape(1)) )
    dst_farray = 0
    dstArray = ESMF_ArrayCreate(dst_farray, distgrid=distgrid, indexflag=ESMF_INDEX_DELOCAL, &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    dstField = ESMF_FieldCreate(grid, dstArray, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! perform sparse matrix multiplication
    ! 1. setup routehandle from source Field to destination Field
    ! initialize factorList and factorIndexList
    allocate(factorList(4))
    allocate(factorIndexList(2,4))
    factorList = (/1,2,3,4/)
    factorIndexList(1,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)
    factorIndexList(2,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)

    call ESMF_FieldSMMStore(srcField, dstField, routehandle, &amp;
        factorList, factorIndexList, rc=localrc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! 2. use precomputed routehandle to perform SMM
    call ESMF_FieldSMM(srcfield, dstField, routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! verify sparse matrix multiplication
    call ESMF_FieldGet(dstField, localDe=0, farrayPtr=fptr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Verify that the result data in dstField is correct.
    ! Before the SMM op, the dst Field contains all 0. 
    ! The SMM op reset the values to the index value, verify this is the case.
    ! +--------+--------+--------+--------+
    !  1 2 3 4  2 4 6 8  3 6 9 12  4 8 12 16       ! value
    ! 1        4        8        12       16       ! bounds
    do i = lbound(fptr, 1), ubound(fptr, 1)
        if(fptr(i) /= i*(lpe+1)) rc = ESMF_FAILURE
    enddo
</PRE>

<P>
Field sparse matrix matmul can also be performed between weakly congruent Fields.
   In this case, source and destination Fields can have ungridded dimensions
   with size different from the Field pair used to compute the routehandle.  

<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=2, rc=rc)
</PRE>

<P>
Create two fields with ungridded dimensions using the Grid created previously.
   The new Field pair has matching number of elements. The ungridded dimension
   is mapped to the first dimension of either Field. 

<P>
<PRE>
    srcFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
    dstFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
Using the previously computed routehandle, weakly congruent Fields can perform
   sparse matrix matmul. 

<P>
<PRE>
    call ESMF_FieldSMM(srcfieldA, dstFieldA, routehandle, rc=rc)
</PRE>

<P>
<PRE>
    ! release route handle
    call ESMF_FieldSMMRelease(routehandle, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040323200000000000000"></A>
   <A NAME="sec:field:usage:halo"></A>
<BR>
18.2.32 Field Halo solving a domain decomposed heat transfer problem
</H3>

<P>
<TT>ESMF_FieldHalo()</TT> interface can be used to perform halo update of a Field. This
   eases communication programming from a user perspective. By definition, user
   program only needs to update locally owned exclusive region in each domain, then call
   FieldHalo to communicate the values in the halo region from/to neighboring domain elements.
   In this example, we solve a 1D heat transfer problem: <!-- MATH
 $u_t = \alpha^2 u_{xx}$
 -->
<IMG
 WIDTH="84" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img32.png"
 ALT="$u_t = \alpha^2 u_{xx}$"> with the
   initial condition <IMG
 WIDTH="89" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.png"
 ALT="$u(0, x) = 20$"> and boundary conditions <!-- MATH
 $u(t, 0) = 10, u(t, 1) = 40$
 -->
<IMG
 WIDTH="172" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$u(t, 0) = 10, u(t, 1) = 40$">.
   The temperature field <IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img19.png"
 ALT="$u$">
   is represented by a <TT>ESMF_Field</TT>. A finite difference explicit time steping scheme is employed.
   During each time step, FieldHalo update is called to communicate values in the halo region
   to neighboring domain elements. The steady state (as <!-- MATH
 $t \rightarrow \infty$
 -->
<IMG
 WIDTH="53" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img35.png"
 ALT="$t \rightarrow \infty$">) solution 
   is a linear temperature profile along <IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img36.png"
 ALT="$x$">. The numerical solution is an approximation of
   the steady state solution. It can be verified to represent a linear temperature profile.

<P>
Section <A HREF="node4.html#Array:Halo">20.2.14</A> provides a discussion of the 
   halo operation implemented in <TT>ESMF_Array</TT>.

<P>
<PRE>
    ! create 1D distgrid and grid decomposed according to the following diagram:
    ! +----------------+   +-------------------+   +-------------------+   +----------------+
    ! |     DE 0    |  |   |  |     DE 1    |  |   |  |     DE 2    |  |   |  |     DE 3    |
    ! |    1 x 16   |  |   |  |    1 x 16   |  |   |  |    1 x 16   |  |   |  |    1 x 16   |
    ! |             | 1|&lt;-&gt;|1 |             | 1|&lt;-&gt;|1 |             | 1|&lt;-&gt;|1 |             |
    ! |             |  |   |  |             |  |   |  |             |  |   |  |             |
    ! +----------------+   +-------------------+   +-------------------+   +----------------+
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/npx/), &amp;
        regDecomp=(/4/), rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! set up initial condition and boundary conditions of the temperature Field
    if(lpe == 0) then
        allocate(fptr(17), tmp_farray(17))
        fptr = 20.
        fptr(1) = 10.
        tmp_farray(1) = 10.
        startx = 2
        endx = 16

        field = ESMF_FieldCreate(grid, fptr, maxHaloUWidth=(/1/), name="temperature", rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    else if(lpe == 3) then
        allocate(fptr(17), tmp_farray(17))
        fptr = 20.
        fptr(17) = 40.
        tmp_farray(17) = 40.
        startx = 2
        endx = 16

        field = ESMF_FieldCreate(grid, fptr, maxHaloLWidth=(/1/), name="temperature", rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    else
        allocate(fptr(18), tmp_farray(18))
        fptr = 20.
        startx = 2
        endx = 17

        field = ESMF_FieldCreate(grid, fptr, &amp;
            maxHaloLWidth=(/1/), maxHaloUWidth=(/1/), name="temperature", rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    endif

    ! compute the halo update routehandle of the decomposed temperature Field
    call ESMF_FieldHaloStore(field, routehandle=routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    dt = 0.01
    dx = 1./npx
    alpha = 0.1

    ! Employ explicit time steping
    ! Solution converges after about 9000 steps based on apriori knowledge.
    ! The result is a linear temperature profile stored in field.
    do iter = 1, 9000
        ! only elements in the exclusive region are updated locally in each domain
        do i = startx, endx
            tmp_farray(i) = fptr(i)+alpha*alpha*dt/dx/dx*(fptr(i+1)-2.*fptr(i)+fptr(i-1))
        enddo
        fptr = tmp_farray
        ! call halo update to communicate the values in the halo region to neighboring domains
        call ESMF_FieldHalo(field, routehandle=routehandle, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! release the halo routehandle
    call ESMF_FieldHaloRelease(routehandle, rc=rc)
</PRE>

<P>

<P>

<H2><A NAME="SECTION04033000000000000000">
18.3 Restrictions and Future Work</A>
</H2>

<P>

<A NAME="Field:rest"></A>

<OL>
<LI><B>CAUTION:</B> It depends on the specific entry point of <TT>ESMF_FieldCreate()</TT> used during Field creation, which Fortran operations are supported on the Fortran array pointer <TT>farrayPtr</TT>, returned by <TT>ESMF_FieldGet()</TT>. Only if the <TT>ESMF_FieldCreate()</TT> <EM>from pointer</EM> variant was used, will the returned <TT>farrayPtr</TT> variable contain the original bounds information, and be suitable for the Fortran <TT>deallocate()</TT> call. This limitation is a direct consequence of the Fortran 95 standard relating to the passing of array arguments.

<P>
</LI>
<LI><B>No mathematical operators.</B>  The Fields class does not 
currently support advanced
operations on fields, such as differential or other
mathematical operators.

<P>
</LI>
<LI><B>No vector Fields.</B>  ESMF does not currently  support storage of 
multiple vector Field components in the same Field component, although
that support is planned.  At this time users need to create a 
separate Field object to represent each vector component.

<P>
</LI>
<LI><B>Conservative Regridding</B> 
The conservative regridding is not designed to 
prevent diffusion of mass.  The L2 projection method is <I>globally</I> constrained
for conservation of mass.  This means that the mass will be conserved to high precision
over the entire regridding domain, but this conservation will not be restricted
in a local sense, and mass may be diffused across a large stencil.  

<P>
The conservative regridding can also have problems 
with high interpolation error in regions where the destination grid is of higher 
resolution than the source grid.  It is expected that this effect is seen in select
sub domains of the regridding where the
grid resolution difference is not constant throughout the entire domain.  In domains
where the destination grid resolution is higher than the source grid resolution some
points can be left out of the mapping or not mapped with the expected source point 
contributions.  This is because the destination points depend on the source points 
which lie in the <I>neighboring</I> destination cells.  Therefore, if there are 
several destination cells contained within a single source cell, cases will arise
where the destination points are incorrectly mapped, if they are mapped at all.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION04034000000000000000">
18.4 Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>Some methods which have a Field interface are actually 
implemented at the underlying Grid or Array level; they
are inherited by the Field class.  This allows the user
API (Application Programming Interface) to present functions at
the level which is most consistent to the application without
restricting where inside the ESMF the actual implementation
is done.

<P>
</LI>
<LI>The Field class is implemented in Fortran, and as such is
defined inside the framework by a Field derived type and a set of 
subprograms (functions and subroutines) which operate on that derived type.  
The Field class itself is very thin; it is a container class which
groups a Grid and an Array object together.

<P>
</LI>
<LI>Fields follow the framework-wide convention of the
<I>unison</I> creation and operation rule: All PETs which are
part of the currently executing VM must create the
same Fields at the same point in their execution.  Since an early
user request was that global object creation not impose the overhead of
a barrier or synchronization point, Field creation does no inter-PET
communication.  For this to work, each PET must query the total number
of PETs in this VM, and which local PET number it is.  It can then
compute which DE(s) are part of the local decomposition, and any
global information can be computed in unison by all PETs independently
of the others.  In this way the overhead of communication is avoided,
at the cost of more difficulty in diagnosing program bugs which result
from not all PETs executing the same create calls.

<P>
</LI>
<LI>Related to the item above, the user request to not impose
inter-PET communication at object creation time means that requirement
FLD 1.5.1, that all Fields will have unique names, and if not specified, 
the framework will generate a unique name for it, is difficult or
impossible to support.  A part of this requirement has been implememted;
a unique object counter is maintained in the Base object class, and if
a name is not given at create time a name such as "Field003" is generated
which is guarenteed to not be repeated by the framework.   However, it
is impossible to error check that the user has not replicated a name,
and it is possible under certain conditions that if not all PETs have
created the same number of objects, that the counters on different PETs
may not stay synchronized.   This remains an open issue.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION04035000000000000000">
18.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04035100000000000000">
18.5.1 ESMF_FieldCreateEmpty - Create an empty Field (no Grid)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_FieldCreateEmpty(name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateEmpty
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character (len = *), intent(in), optional :: name
     type(ESMF_IOSpec), intent(in), optional :: iospec
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This version of <TT>ESMF_FieldCreate</TT> builds an empty <TT>ESMF_Field</TT>
   and depends on later calls to add an <TT>ESMF_Grid</TT> and <TT>ESMF_Array</TT> to
   it. Attributes can be added to an empty Field object. For an example and
   associated documentation using this method see Section
   <A HREF="node4.html#sec:field:usage:create_empty_setcommit">18.2.6</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. ! NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04035200000000000000">
18.5.2 ESMF_FieldDestroy - Free all resources associated with a Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldDestroy(field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field) :: field
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Releases all resources associated with the <TT>ESMF_Field</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04035300000000000000">
18.5.3 ESMF_FieldCreate - Create a Field from Grid and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGridArraySpec(grid, arrayspec, indexflag, &amp;
     staggerloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     maxHaloLWidth, maxHaloUWidth, name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateGridArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid) :: grid
     type(ESMF_ArraySpec), intent(inout) :: arrayspec
     type(ESMF_IndexFlag), intent(in), optional :: indexflag
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: maxHaloLWidth(:)
     integer, intent(in), optional :: maxHaloUWidth(:)
     character (len=*), intent(in), optional :: name
     type(ESMF_IOSpec), intent(in), optional :: iospec
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see Section
   <A HREF="node4.html#sec:field:usage:create_grid_arrayspec">18.2.4</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default each DE's
   exclusive region is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated Grid. See section <A HREF="node2.html#opt:indexflag">9.2.8</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see Section <A HREF="node4.html#sec:opt:staggerloc">23.5.4</A>.
   To create a custom stagger location see Section
   <A HREF="node4.html#sec:usage:staggerloc:adv">23.2.20</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[maxHaloLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for maxHaloLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not
   implemented, the <TT>minHaloLWidth</TT> is checked for validity and stored
   in preparation for the implementation of the halo method.
   HALO OPERATION NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[maxHaloUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for maxHaloUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not
   implemented, the <TT>maxHaloUWidth</TT> is checked for validity and stored
   in preparation for the implementation of the halo method.
   HALO OPERATION NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. ! NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04035400000000000000">
18.5.4 ESMF_FieldCreate - Create a Field from Grid and Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGridArray(grid, array, copyflag, staggerloc, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, maxHaloLWidth, &amp;
     maxHaloUWidth, name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateGridArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in) :: grid
     type(ESMF_Array), intent(in) :: array
     type(ESMF_CopyFlag), intent(in), optional :: copyflag
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: maxHaloLWidth(:)
     integer, intent(in), optional :: maxHaloUWidth(:)
     character (len = *), intent(in), optional :: name
     type(ESMF_IOSpec), intent(in), optional :: iospec
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT>. This version of creation
   assumes the data exists already and is being
   passed in through an <TT>ESMF_Array</TT>. For an example and
   associated documentation using this method see Section
   <A HREF="node4.html#sec:field:usage:create_grid_array">18.2.5</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Indicates whether to copy the contents of the <TT>array</TT> or reference it directly.
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is
   <TT>ESMF_DATA_REF</TT>.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see Section <A HREF="node4.html#sec:opt:staggerloc">23.5.4</A>.
   To create a custom stagger location see Section
   <A HREF="node4.html#sec:usage:staggerloc:adv">23.2.20</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[maxHaloLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for maxHaloLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not
   implemented, the <TT>minHaloLWidth</TT> is checked for validity and stored
   in preparation for the implementation of the halo method.
   HALO OPERATION NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[maxHaloUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for maxHaloUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not
   implemented, the <TT>maxHaloUWidth</TT> is checked for validity and stored
   in preparation for the implementation of the halo method.
   HALO OPERATION NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04035500000000000000">
18.5.5 ESMF_FieldCreate - Create a Field from Grid and Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateGridData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(grid, &amp; 
   farray, indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, &amp; 
   ungriddedUBound, maxHaloLWidth, maxHaloUWidth, name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateGridData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Grid) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), target :: farray 
   type(ESMF_IndexFlag), intent(in) :: indexflag 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(in), optional :: maxHaloLWidth(:) 
   integer, intent(in), optional :: maxHaloUWidth(:) 
   character (len=*), intent(in), optional :: name 
   type(ESMF_IOSpec), intent(in), optional :: iospec 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data array and <TT>ESMF_Grid</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 
   For examples and 
   associated documentations using this method see Section 
   <A HREF="node4.html#sec:field:usage:create_2darray">18.2.8</A>, 
   <A HREF="node4.html#sec:field:usage:create_2dgrid_3dptr">18.2.10</A>, 
   <A HREF="node4.html#sec:field:usage:create_2dgrid_3dptr_map">18.2.11</A>, 
   <A HREF="node4.html#sec:field:usage:create_2dgrid_3dptr_map_halo">18.2.12</A>, and 
   <A HREF="node4.html#sec:field:usage:create_5dgrid_7dptr_2dungridded">18.2.7</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#opt:indexflag">9.2.8</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see Section <A HREF="node4.html#sec:opt:staggerloc">23.5.4</A>. 
   To create a custom stagger location see Section 
   <A HREF="node4.html#sec:usage:staggerloc:adv">23.2.20</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[maxHaloLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farray</TT>. Values default 
   to 0. If values for maxHaloLWidth are specified they must be reflected in 
   the size of the <TT>farray</TT>. That is, for each gridded dimension the 
   <TT>farray</TT> size should be max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not 
   implemented, the <TT>minHaloLWidth</TT> is checked for validity and stored 
   in preparation for the implementation of the halo method. 
   HALO OPERATION NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[maxHaloUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farray</TT>. Values default 
   to 0. If values for maxHaloUWidth are specified they must be reflected in 
   the size of the <TT>farray</TT>. That is, for each gridded dimension the 
   <TT>farray</TT> size should max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not 
   implemented, the <TT>maxHaloUWidth</TT> is checked for validity and stored 
   in preparation for the implementation of the halo method. 
   HALO OPERATION NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04035600000000000000">
18.5.6 ESMF_FieldCreate - Create a Field from Grid and Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateGridDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(grid, &amp; 
   farrayPtr, copyflag, staggerloc, gridToFieldMap, &amp; 
   maxHaloLWidth, maxHaloUWidth, name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateGridDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Grid) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: maxHaloLWidth(:) 
   integer, intent(in), optional :: maxHaloUWidth(:) 
   character (len=*), intent(in), optional :: name 
   type(ESMF_IOSpec), intent(in), optional :: iospec 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data pointer and <TT>ESMF_Grid</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   copyflag is <TT>ESMF_DATA_REF</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
For examples and 
   associated documentations using this method see Section 
   <A HREF="node4.html#sec:field:usage:create_2dptr">18.2.9</A>, 
   <A HREF="node4.html#sec:field:usage:create_2dgrid_3dptr">18.2.10</A>, 
   <A HREF="node4.html#sec:field:usage:create_2dgrid_3dptr_map">18.2.11</A>, 
   <A HREF="node4.html#sec:field:usage:create_2dgrid_3dptr_map_halo">18.2.12</A>, and 
   <A HREF="node4.html#sec:field:usage:create_5dgrid_7dptr_2dungridded">18.2.7</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see Section <A HREF="node4.html#sec:opt:staggerloc">23.5.4</A>. 
   To create a custom stagger location see Section 
   <A HREF="node4.html#sec:usage:staggerloc:adv">23.2.20</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[maxHaloLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farrayPtr</TT>. Values default 
   to 0. If values for maxHaloLWidth are specified they must be reflected in 
   the size of the <TT>farrayPtr</TT>. That is, for each gridded dimension the 
   <TT>farrayPtr</TT> size should be max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not 
   implemented, the <TT>minHaloLWidth</TT> is checked for validity and stored 
   in preparation for the implementation of the halo method. 
   HALO OPERATION NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[maxHaloUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farrayPtr</TT>. Values default 
   to 0. If values for maxHaloUWidth are specified they must be reflected in 
   the size of the <TT>farrayPtr</TT>. That is, for each gridded dimension the 
   <TT>farrayPtr</TT> size should max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not 
   implemented, the <TT>maxHaloUWidth</TT> is checked for validity and stored 
   in preparation for the implementation of the halo method. 
   HALO OPERATION NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04035700000000000000">
18.5.7 ESMF_FieldCreate - Create a Field from LocStream and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateLSArraySpec(locstream, arrayspec, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateLSArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream) :: locstream
     type(ESMF_ArraySpec), intent(inout) :: arrayspec
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     type(ESMF_IOSpec), intent(in), optional :: iospec
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see Section
   <A HREF="node4.html#sec:field:usage:create_locs_arrayspec">18.2.13</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the LocStream dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   LocStream dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. ! NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04035800000000000000">
18.5.8 ESMF_FieldCreate - Create a Field from LocStream and Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateLSArray(locstream, array, copyflag, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateLSArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in) :: locstream
     type(ESMF_Array), intent(in) :: array
     type(ESMF_CopyFlag), intent(in), optional :: copyflag
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len = *), intent(in), optional :: name
     type(ESMF_IOSpec), intent(in), optional :: iospec
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT>. This version of creation
   assumes the data exists already and is being
   passed in through an <TT>ESMF_Array</TT>. For an example and
   associated documentation using this method see Section
   <A HREF="node4.html#sec:field:usage:create_grid_array">18.2.5</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Indicates whether to copy the contents of the <TT>array</TT> or reference it directly.
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is
   <TT>ESMF_DATA_REF</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the LocStream dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   LocStream dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04035900000000000000">
18.5.9 ESMF_FieldCreate - Create a Field from LocStream and Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateLSData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(locstream, &amp; 
   farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, &amp; 
   ungriddedUBound, name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateLSData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocStream) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), target :: farray 
   type(ESMF_IndexFlag), intent(in) :: indexflag 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   character (len=*), intent(in), optional :: name 
   type(ESMF_IOSpec), intent(in), optional :: iospec 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data array and <TT>ESMF_LocStream</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#opt:indexflag">9.2.8</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>locstream</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>locstream</TT>. Unlocstreamded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040351000000000000000">
18.5.10 ESMF_FieldCreate - Create a Field from LocStream and Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateLSDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(locstream, &amp; 
   farrayPtr, copyflag, gridToFieldMap, &amp; 
   name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateLSDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocStream) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   character (len=*), intent(in), optional :: name 
   type(ESMF_IOSpec), intent(in), optional :: iospec 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data pointer and <TT>ESMF_LocStream</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   copyflag is <TT>ESMF_DATA_REF</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>locstream</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>locstream</TT>. Unlocstreamded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040351100000000000000">
18.5.11 ESMF_FieldCreate - Create a Field from Mesh and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateMeshArraySpec(mesh, arrayspec, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateMeshArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh) :: mesh
     type(ESMF_ArraySpec), intent(inout) :: arrayspec
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     type(ESMF_IOSpec), intent(in), optional :: iospec
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see Section
   <A HREF="node4.html#sec:field:usage:create_grid_arrayspec">18.2.4</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Mesh dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Mesh dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. ! NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040351200000000000000">
18.5.12 ESMF_FieldCreate - Create a Field from Mesh and Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateMeshArray(mesh, array, copyflag, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateMeshArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in) :: mesh
     type(ESMF_Array), intent(in) :: array
     type(ESMF_CopyFlag), intent(in), optional :: copyflag
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len = *), intent(in), optional :: name
     type(ESMF_IOSpec), intent(in), optional :: iospec
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT>. This version of creation
   assumes the data exists already and is being
   passed in through an <TT>ESMF_Array</TT>. For an example and
   associated documentation using this method see Section
   <A HREF="node4.html#sec:field:usage:create_grid_array">18.2.5</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Indicates whether to copy the contents of the <TT>array</TT> or reference it directly.
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is
   <TT>ESMF_DATA_REF</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Mesh dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Mesh dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040351300000000000000">
18.5.13 ESMF_FieldCreate - Create a Field from Mesh and Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateMeshData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(mesh, &amp; 
   farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, &amp; 
   ungriddedUBound, name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateMeshData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Mesh) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), target :: farray 
   type(ESMF_IndexFlag), intent(in) :: indexflag 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   character (len=*), intent(in), optional :: name 
   type(ESMF_IOSpec), intent(in), optional :: iospec 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data array and <TT>ESMF_Mesh</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#opt:indexflag">9.2.8</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>mesh</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>mesh</TT>. Unmeshded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040351400000000000000">
18.5.14 ESMF_FieldCreate - Create a Field from Mesh and Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateMeshDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(mesh, &amp; 
   farrayPtr, copyflag, gridToFieldMap, &amp; 
   name, iospec, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateMeshDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Mesh) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   character (len=*), intent(in), optional :: name 
   type(ESMF_IOSpec), intent(in), optional :: iospec 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data pointer and <TT>ESMF_Mesh</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   copyflag is <TT>ESMF_DATA_REF</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>mesh</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>mesh</TT>. Unmeshded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD>I/O specification. NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040351500000000000000">
18.5.15 ESMF_FieldGet - Return info associated with a Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGet()
   subroutine ESMF_FieldGetDefault(field, isCommitted, geomtype, grid, mesh, locstream, &amp;
     array, typekind, dimCount, memDimCount, &amp;
     staggerloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     maxHaloLWidth, maxHaloUWidth, localDeCount, name, iospec, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(inout) :: field
     logical, intent(out), optional :: isCommitted
     type(ESMF_GeomType), intent(out), optional :: geomtype
     type(ESMF_Grid), intent(out), optional :: grid
     type(ESMF_Mesh), intent(out), optional :: mesh
     type(ESMF_LocStream), intent(out), optional :: locstream
     type(ESMF_Array), intent(out), optional :: array
     type(ESMF_TypeKind), intent(out), optional :: typekind
     integer, intent(out), optional :: dimCount
     integer, intent(out), optional :: memDimCount
     type(ESMF_StaggerLoc), intent(out), optional :: staggerloc
     integer, intent(out), optional :: gridToFieldMap(:)
     integer, intent(out), optional :: ungriddedLBound(:)
     integer, intent(out), optional :: ungriddedUBound(:)
     integer, intent(out), optional :: maxHaloLWidth(:)
     integer, intent(out), optional :: maxHaloUWidth(:)
     integer, intent(out), optional :: localDeCount
     character(len=*), intent(out), optional :: name
     type(ESMF_IOSpec), intent(out), optional :: iospec ! NOT IMPLEMENTED
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Query an <TT>ESMF_Field</TT> for various things. All arguments after
   the <TT>field</TT> are optional. To select individual items use the
   named_argument=value syntax. For an example and
   associated documentation using this method see Section
   <A HREF="node4.html#sec:field:usage:field_get_default">18.2.3</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> object to query.
   
</DD>
<DT><STRONG>[isCommitted]</STRONG></DT>
<DD>Indicates if the Field is fully committed and ready.
   
</DD>
<DT><STRONG>[geomtype]</STRONG></DT>
<DD>Specifies the type of geometry on which the Field is built. Please see Section&nbsp;<A HREF="node2.html#opt:geomtype">9.3.4</A> for
   the range of values.
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD><TT>ESMF_Grid</TT>.
   
</DD>
<DT><STRONG>[mesh]</STRONG></DT>
<DD><TT>ESMF_Mesh</TT>.
   
</DD>
<DT><STRONG>[locstream]</STRONG></DT>
<DD><TT>ESMF_LocStream</TT>.
   
</DD>
<DT><STRONG>[array]</STRONG></DT>
<DD><TT>ESMF_Array</TT>.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>TypeKind specifier for Field.
   
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>Number of geometrical dimensions in <TT>field</TT>.
   For an detailed discussion of this parameter, please see
   Section <A HREF="node4.html#sec:field:usage:createArbGrid">18.2.18</A> and
   Section <A HREF="node4.html#sec:field:usage:createArbGridRep">18.2.19</A>.
   
</DD>
<DT><STRONG>[memDimCount]</STRONG></DT>
<DD>Number of dimensions in the physical memory of the <TT>field</TT> data. It is
   identical to dimCount when the corresponding grid is a non-arbitrary grid.
   It is less than dimCount when the grid is arbitrarily distributed.
   For an detailed discussion of this parameter, please see
   Section <A HREF="node4.html#sec:field:usage:createArbGrid">18.2.18</A> and
   Section <A HREF="node4.html#sec:field:usage:createArbGridRep">18.2.19</A>.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values and interpretation of results see
   Section <A HREF="node4.html#sec:opt:staggerloc">23.5.4</A>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[maxHaloLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for maxHaloLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not
   implemented, the <TT>minHaloLWidth</TT> is checked for validity and stored
   in preparation for the implementation of the halo method.
   HALO OPERATION NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[maxHaloUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for maxHaloUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not
   implemented, the <TT>maxHaloUWidth</TT> is checked for validity and stored
   in preparation for the implementation of the halo method.
   HALO OPERATION NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[localDeCount]</STRONG></DT>
<DD>Upon return this holds the number of PET-local DEs defined in
   the DELayout associated with the Field object.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of queried item.
   
</DD>
<DT><STRONG>[iospec]</STRONG></DT>
<DD><TT>ESMF_IOSpec</TT> object which contains settings for options. NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040351600000000000000">
18.5.16 ESMF_FieldGet - Get Fortran data pointer from a Field </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGet() 
   subroutine ESMF_FieldGetDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, localDe, farrayPtr, &amp; 
   exclusiveLBound, exclusiveUBound, exclusiveCount, &amp; 
   computationalLBound, computationalUBound, computationalCount, &amp; 
   totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(in) :: field 
   integer, intent(in), optional :: localDe 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
   integer, intent(out), optional :: exclusiveLBound(:) 
   integer, intent(out), optional :: exclusiveUBound(:) 
   integer, intent(out), optional :: exclusiveCount(:) 
   integer, intent(out), optional :: computationalLBound(:) 
   integer, intent(out), optional :: computationalUBound(:) 
   integer, intent(out), optional :: computationalCount(:) 
   integer, intent(out), optional :: totalLBound(:) 
   integer, intent(out), optional :: totalUBound(:) 
   integer, intent(out), optional :: totalCount(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get a Fortran pointer to DE-local memory allocation within <TT>field</TT>. 
   For convenience DE-local bounds can be queried at the same time. 
   For an example and 
   associated documentation using this method see Section 
   <A HREF="node4.html#sec:field:usage:field_get_dataptr">18.2.2</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> object. 
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>. 
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted, 
   in which case it will default to <TT>localDe=0</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Fortran array pointer which will be pointed at DE-local memory allocation. 
   It depends on the specific entry point 
   of <TT>ESMF_FieldCreate()</TT> used during <TT>field</TT> creation, which 
   Fortran operations are supported on the returned <TT>farrayPtr</TT>. See 
   <A HREF="node4.html#Field:rest">18.3</A> for more details. 
   
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region. 
   <TT>exclusiveLBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region. 
   <TT>exclusiveUBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region per dimension 
   (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT> must 
   be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region. 
   <TT>computationalLBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region. 
   <TT>computationalLBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension 
   (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT> must 
   be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region. 
   <TT>totalLBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region. 
   <TT>totalUBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension 
   (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>computationalCount</TT> must 
   be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040351700000000000000">
18.5.17 ESMF_FieldGetBounds - Get Field data bounds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGetBounds()
   subroutine ESMF_FieldGetBounds(field, localDe, exclusiveLBound, &amp;
     exclusiveUBound, exclusiveCount, computationalLBound, computationalUBound, &amp;
     computationalCount, totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in) :: field
     integer, intent(in), optional :: localDe
     integer, intent(out), optional :: exclusiveLBound(:)
     integer, intent(out), optional :: exclusiveUBound(:)
     integer, intent(out), optional :: exclusiveCount(:)
     integer, intent(out), optional :: computationalLBound(:)
     integer, intent(out), optional :: computationalUBound(:)
     integer, intent(out), optional :: computationalCount(:)
     integer, intent(out), optional :: totalLBound(:)
     integer, intent(out), optional :: totalUBound(:)
     integer, intent(out), optional :: totalCount(:)
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method returns the bounds information of a field that consists of a
   internal grid and a internal array. The exclusive and computational bounds
   are shared between the grid and the array but the total bounds are the array
   bounds plus the halo width. The count is the number of elements between each
   bound pair.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Field to get the information from.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
   in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
   <TT>exclusiveLBound</TT> must be allocated to be of size equal to the field rank.
   Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
   <TT>exclusiveUBound</TT> must be allocated to be of size equal to the field rank.
   Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region per dimension
   (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT> must
   be allocated to be of size equal to the field rank.
   Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
   <TT>computationalLBound</TT> must be allocated to be of size equal to the field rank.
   Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
   <TT>computationalUBound</TT> must be allocated to be of size equal to the field rank.
   Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
   (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
   must be allocated to be of size equal to the field rank.
   Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
   <TT>totalLBound</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
   <TT>totalUBound</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
   (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
   be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040351800000000000000">
18.5.18 ESMF_FieldGet - Get precomputed Fortran data array bounds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGet()
     subroutine ESMF_FieldGetGridAllocBounds(grid, localDe, staggerloc, &amp;
         gridToFieldMap, &amp;
         ungriddedLBound, ungriddedUBound, &amp;
         maxHaloLWidth, maxHaloUWidth, &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(inout) :: grid
     integer, intent(in), optional :: localDe
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: maxHaloLWidth(:)
     integer, intent(in), optional :: maxHaloUWidth(:)
     integer, intent(out), optional :: totalLBound(:)
     integer, intent(out), optional :: totalUBound(:)
     integer, intent(out), optional :: totalCount(:)
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Compute the lower and upper bounds of Fortran data array that can later
   be used in FieldCreate interface to create a <TT>ESMF_Field</TT> from a
   <TT>ESMF_Grid</TT> and the Fortran data array. For an example and
   associated documentation using this method see Section
   <A HREF="node4.html#sec:field:usage:create_5dgrid_7dptr_2dungridded">18.2.7</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT>.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
   in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values and interpretation of results see
   Section <A HREF="node4.html#sec:opt:staggerloc">23.5.4</A>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[maxHaloLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of dimensions in the <TT>grid</TT>. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for maxHaloLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not
   implemented, the <TT>minHaloLWidth</TT> is checked for validity and stored
   in preparation for the implementation of the halo method.
   HALO OPERATION NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[maxHaloUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of dimensions in the <TT>grid</TT>. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for maxHaloUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not
   implemented, the <TT>maxHaloUWidth</TT> is checked for validity and stored
   in preparation for the implementation of the halo method.
   HALO OPERATION NOT IMPLEMENTED
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>The relative lower bounds of Fortran data array to be used
   later in tt ESMF_FieldCreate from <TT>ESMF_Grid</TT> and Fortran data array.
   This is an output variable from this user interface.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>The relative upper bounds of Fortran data array to be used
   later in tt ESMF_FieldCreate from <TT>ESMF_Grid</TT> and Fortran data array.
   This is an output variable from this user interface.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Number of elements need to be allocated for Fortran data array to be used
   later in tt ESMF_FieldCreate from <TT>ESMF_Grid</TT> and Fortran data array.
   This is an output variable from this user interface.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040351900000000000000">
18.5.19 ESMF_FieldGet - Get precomputed Fortran data array bounds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGet()
     subroutine ESMF_FieldGetLSAllocBounds(locstream, localDe, &amp;
         gridToFieldMap, &amp;
         ungriddedLBound, ungriddedUBound, &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(inout) :: locstream
     integer, intent(in), optional :: localDe
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(out), optional :: totalLBound(:)
     integer, intent(out), optional :: totalUBound(:)
     integer, intent(out), optional :: totalCount(:)
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Compute the lower and upper bounds of Fortran data array that can later
   be used in FieldCreate interface to create a <TT>ESMF_Field</TT> from a
   <TT>ESMF_LocStream</TT> and the Fortran data array. For an example and
   associated documentation using this method see Section
   <A HREF="node4.html#sec:field:usage:create_5dgrid_7dptr_2dungridded">18.2.7</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT>.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
   in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to 1.
   The list elements map the dimension
   of the <TT>locstream</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map the <TT>locstream</TT>'s dimension against the lowest dimension of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1/).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than 1, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than 1, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>The relative lower bounds of Fortran data array to be used
   later in tt ESMF_FieldCreate from <TT>ESMF_LocStream</TT> and Fortran data array.
   This is an output variable from this user interface.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>The relative upper bounds of Fortran data array to be used
   later in tt ESMF_FieldCreate from <TT>ESMF_LocStream</TT> and Fortran data array.
   This is an output variable from this user interface.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Number of elements need to be allocated for Fortran data array to be used
   later in tt ESMF_FieldCreate from <TT>ESMF_LocStream</TT> and Fortran data array.
   This is an output variable from this user interface.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040352000000000000000">
18.5.20 ESMF_FieldGet - Get precomputed Fortran data array bounds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGet()
     subroutine ESMF_FieldGetMeshAllocBounds(mesh, localDe, &amp;
         gridToFieldMap, &amp;
         ungriddedLBound, ungriddedUBound, &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(inout) :: mesh
     integer, intent(in), optional :: localDe
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(out), optional :: totalLBound(:)
     integer, intent(out), optional :: totalUBound(:)
     integer, intent(out), optional :: totalCount(:)
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Compute the lower and upper bounds of Fortran data array that can later
   be used in FieldCreate interface to create a <TT>ESMF_Field</TT> from a
   <TT>ESMF_Mesh</TT> and the Fortran data array. For an example and
   associated documentation using this method see Section
   <A HREF="node4.html#sec:field:usage:create_5dgrid_7dptr_2dungridded">18.2.7</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT>.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
   in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>The relative lower bounds of Fortran data array to be used
   later in tt ESMF_FieldCreate from <TT>ESMF_Mesh</TT> and Fortran data array.
   This is an output variable from this user interface.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>The relative upper bounds of Fortran data array to be used
   later in tt ESMF_FieldCreate from <TT>ESMF_Mesh</TT> and Fortran data array.
   This is an output variable from this user interface.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Number of elements need to be allocated for Fortran data array to be used
   later in tt ESMF_FieldCreate from <TT>ESMF_Mesh</TT> and Fortran data array.
   This is an output variable from this user interface.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<H3><A NAME="SECTION040352100000000000000">
18.5.21 ESMF_FieldPrint - Print the contents of a Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldPrint(field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field), intent(inout) :: field 
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints information about the <TT>field</TT> to <TT>stdout</TT>.
       This subroutine goes through the internal data members of a field
       data type and prints information of each data member. 
<BR>
<P>
Note:  Many <TT>ESMF_&lt;class&gt;Print</TT> methods are implemented in C++.
       On some platforms/compilers there is a potential issue with interleaving
       Fortran and C++ output to <TT>stdout</TT> such that it doesn't appear in
       the expected order.  If this occurs, the <TT>ESMF_IOUnitFlush()</TT> method
       may be used on unit 6 to get coherent output.  
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>field</STRONG></DT>
<DD>An <TT>ESMF_Field</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040352200000000000000">
18.5.22 ESMF_FieldSetCommit - Finishes creating Field from Grid started with FieldCreateEmpty </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSetCommit() 
   subroutine ESMF_FieldSetCommitGrid&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, grid, &amp; 
   farray, indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, &amp; 
   ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Grid), intent(in) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), target :: farray 
   type(ESMF_IndexFlag), intent(in) :: indexflag 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   type(ESMF_STAGGERLOC), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(in), optional :: maxHaloLWidth(:) 
   integer, intent(in), optional :: maxHaloUWidth(:) 
   integer, intent(inout), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldCreateEmpty()</TT> call. For an example and 
   associated documentation using this method see Section 
   <A HREF="node4.html#sec:field:usage:create_empty_setcommit">18.2.6</A>. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object to finish the Field. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#opt:indexflag">9.2.8</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see Section <A HREF="node4.html#sec:opt:staggerloc">23.5.4</A>. 
   To create a custom stagger location see Section 
   <A HREF="node4.html#sec:usage:staggerloc:adv">23.2.20</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>grid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[maxHaloLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for maxHaloLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not 
   implemented, the <TT>minHaloLWidth</TT> is checked for validity and stored 
   in preparation for the implementation of the halo method. 
   HALO OPERATION NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[maxHaloUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for maxHaloUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not 
   implemented, the <TT>maxHaloUWidth</TT> is checked for validity and stored 
   in preparation for the implementation of the halo method. 
   HALO OPERATION NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040352300000000000000">
18.5.23 ESMF_FieldSetCommit - Finishes creating Field from Grid started with FieldCreateEmpty </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSetCommit() 
   subroutine ESMF_FieldSetCommitGridPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, grid, &amp; 
   farrayPtr, copyflag, staggerloc, gridToFieldMap, &amp; 
   maxHaloLWidth, maxHaloUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Grid), intent(in) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   type(ESMF_STAGGERLOC), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: maxHaloLWidth(:) 
   integer, intent(in), optional :: maxHaloUWidth(:) 
   integer, intent(inout), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldCreateEmpty()</TT> call. For an example and 
   associated documentation using this method see Section 
   <A HREF="node4.html#sec:field:usage:create_empty_setcommit">18.2.6</A>. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   copyflag is <TT>ESMF_DATA_REF</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object to finish the Field. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see Section <A HREF="node4.html#sec:opt:staggerloc">23.5.4</A>. 
   To create a custom stagger location see Section 
   <A HREF="node4.html#sec:usage:staggerloc:adv">23.2.20</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>grid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[maxHaloLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for maxHaloLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not 
   implemented, the <TT>minHaloLWidth</TT> is checked for validity and stored 
   in preparation for the implementation of the halo method. 
   HALO OPERATION NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[maxHaloUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for maxHaloUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>maxHaloLWidth</TT> + <TT>maxHaloUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). Although the halo operation is not 
   implemented, the <TT>maxHaloUWidth</TT> is checked for validity and stored 
   in preparation for the implementation of the halo method. 
   HALO OPERATION NOT IMPLEMENTED 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040352400000000000000">
18.5.24 ESMF_FieldSetCommit - Finishes creating Field from LocStream started with FieldCreateEmpty </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSetCommit() 
   subroutine ESMF_FieldSetCommitLS&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, locstream, &amp; 
   farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, &amp; 
   ungriddedUBound, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_LocStream), intent(in) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), target :: farray 
   type(ESMF_IndexFlag), intent(in) :: indexflag 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(inout), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldCreateEmpty()</TT> call. For an example and 
   associated documentation using this method see Section 
   <A HREF="node4.html#sec:field:usage:create_empty_setcommit">18.2.6</A>. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to finish the Field. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#opt:indexflag">9.2.8</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>locstream</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040352500000000000000">
18.5.25 ESMF_FieldSetCommit - Finishes creating Field from LocStream started with FieldCreateEmpty </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSetCommit() 
   subroutine ESMF_FieldSetCommitLSPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, locstream, &amp; 
   farrayPtr, copyflag, gridToFieldMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_LocStream), intent(in) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(inout), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldCreateEmpty()</TT> call. For an example and 
   associated documentation using this method see Section 
   <A HREF="node4.html#sec:field:usage:create_empty_setcommit">18.2.6</A>. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   copyflag is <TT>ESMF_DATA_REF</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to finish the Field. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>locstream</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040352600000000000000">
18.5.26 ESMF_FieldSetCommit - Finishes creating Field from Mesh started with FieldCreateEmpty </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSetCommit() 
   subroutine ESMF_FieldSetCommitMesh&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, mesh, &amp; 
   farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, &amp; 
   ungriddedUBound, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Mesh), intent(in) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), target :: farray 
   type(ESMF_IndexFlag), intent(in) :: indexflag 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(inout), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldCreateEmpty()</TT> call. For an example and 
   associated documentation using this method see Section 
   <A HREF="node4.html#sec:field:usage:create_empty_setcommit">18.2.6</A>. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object to finish the Field. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#opt:indexflag">9.2.8</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>mesh</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than Mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than Mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040352700000000000000">
18.5.27 ESMF_FieldSetCommit - Finishes creating Field from Mesh started with FieldCreateEmpty </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSetCommit() 
   subroutine ESMF_FieldSetCommitMeshPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, mesh, &amp; 
   farrayPtr, indexflag, copyflag, gridToFieldMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Mesh), intent(in) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(inout), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldCreateEmpty()</TT> call. For an example and 
   associated documentation using this method see Section 
   <A HREF="node4.html#sec:field:usage:create_empty_setcommit">18.2.6</A>. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   copyflag is <TT>ESMF_DATA_REF</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object to finish the Field. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#opt:copyflag">9.2.5</A>. The default is 
   <TT>ESMF_DATA_REF</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>mesh</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040352800000000000000">
18.5.28 ESMF_FieldValidate - Check validity of a Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldValidate(field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field), intent(inout) :: field 
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>field</TT> is internally consistent.
        Currently this method determines if the <TT>field</TT> is uninitialized 
        or already destroyed. It validates the contained array and grid objects.
        The code also checks if the array and grid sizes agree.
        This check compares the distgrid contained in array and grid; 
        then it proceeds to compare the computational bounds contained 
        in array and grid. 

<P>
The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> to validate.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if the <TT>field</TT> 
             is valid.
       
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION04036000000000000000">
18.6 Class API: Field Communications</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04036100000000000000">
18.6.1 ESMF_FieldGather - Gather a Fortran array from an ESMF_Field </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldGather&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, farray, patch, &amp; 
   rootPet, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   mtype (ESMF_KIND_mtypekind),dimension(mdim),intent(in),target :: farray 
   integer, intent(in), optional :: patch 
   integer, intent(in) :: rootPet 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Gather the data of an ESMF_Field object into the <TT>farray</TT> located on 
   <TT>rootPET</TT>. A single DistGrid patch of <TT>array</TT> must be 
   gathered into <TT>farray</TT>. The optional <TT>patch</TT> 
   argument allows selection of the patch. For Fields defined on a single 
   patch DistGrid the default selection (patch 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the patch in Field. 

<P>
If the Field contains replicating DistGrid dimensions data will be 
   gathered from the numerically higher DEs. Replicated data elements in 
   numericaly lower DEs will be ignored. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
For examples and associated documentations using this method see Section 
   <A HREF="node4.html#sec:field:usage:gather_2dptr">18.2.27</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object from which data will be gathered. 
   
</DD>
<DT><STRONG>[farray]</STRONG></DT>
<DD>The Fortran array into which to gather data. Only root 
   must provide a valid <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[patch]</STRONG></DT>
<DD>The DistGrid patch in <TT>field</TT> from which to gather <TT>farray</TT>. 
   By default <TT>farray</TT> will be gathered from patch 1. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid destination array, i.e. <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04036200000000000000">
18.6.2 ESMF_FieldHalo - Execute an FieldHalo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldHalo(field, routehandle, commflag, &amp;
     finishedflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),       intent(inout)           :: field
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     type(ESMF_CommFlag),    intent(in),   optional  :: commflag
     logical,                intent(out),  optional  :: finishedflag
     logical,                intent(in),   optional  :: checkflag
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Field halo operation for <TT>field</TT>. The <TT>field</TT>
     argument must be weakly congruent and typekind conform to the Field used
     during <TT>ESMF_FieldHaloStore()</TT>.
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions.

<P>
See <TT>ESMF_FieldHaloStore()</TT> on how to precompute <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[commflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_COMM_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node2.html#opt:commflag">9.2.3</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>commflag = ESMF_COMM_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>commflag = ESMF_COMM_NBTESTFINISH</TT>, or a final call with
       <TT>commflag = ESMF_COMM_NBWAITFINISH</TT>. For all other <TT>commflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Field pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04036300000000000000">
18.6.3 ESMF_FieldHaloRelease - Release resources associated with Field halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldHaloRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an Field halo operation.
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04036400000000000000">
18.6.4 ESMF_FieldHaloStore - Store an FieldHalo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_FieldHaloStore(field, routehandle, halostartregionflag, &amp;
       haloLDepth, haloUDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),       intent(inout)                :: field
     type(ESMF_RouteHandle), intent(inout)                :: routehandle
     type(ESMF_HaloStartRegionFlag), intent(in), optional :: halostartregionflag
     integer,                intent(in),         optional :: haloLDepth(:)
     integer,                intent(in),         optional :: haloUDepth(:)
     integer,                intent(out),        optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an Field halo operation over the data in <TT>field</TT>. By default,
     i.e. without specifying <TT>halostartregionflag</TT>, <TT>haloLDepth</TT> and
     <TT>haloUDepth</TT>, all elements in the total Field region that lie outside
     the exclusive region will be considered potential destination elements for
     halo. However, only those elements that have a corresponding halo source
     element, i.e. an exclusive element on one of the DEs, will be updated under
     the halo operation. Elements that have no associated source remain 
     unchanged under halo.

<P>
Specifying <TT>halostartregionflag</TT> allows to change the shape of the 
     effective halo region from the inside. Setting this flag to
     <TT>ESMF_REGION_COMPUTATIONAL</TT> means that only elements outside 
     the computational region of the Field are considered for potential
     destination elements for halo. The default is <TT>ESMF_REGION_EXCLUSIVE</TT>.

<P>
The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> arguments allow to reduce
     the extent of the effective halo region. Starting at the region specified
     by <TT>halostartregionflag</TT>, the <TT>haloLDepth</TT> and <TT>haloUDepth</TT>
     define a halo depth in each direction. Note that the maximum halo region is
     limited by the total Field region, independent of the actual
     <TT>haloLDepth</TT> and <TT>haloUDepth</TT> setting. The total Field region is
     local DE specific. The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> are interpreted
     as the maximum desired extent, reducing the potentially larger region
     available for halo.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldHalo()</TT> on any Field that is weakly congruent
     and typekind conform to <TT>field</TT>.
     Congruent Fields possess matching DistGrids, and the shape of the local
     field tiles matches between the Fieldss for every DE. For weakly congruent
     Fieldss the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fieldss that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[halostartregionflag]</STRONG></DT>
<DD>The start of the effective halo region on every DE. The default
       setting is <TT>ESMF_REGION_EXCLUSIVE</TT>, rendering all non-exclusive
       elements potential halo destination elments.
       See section <A HREF="node2.html#opt:halostartregionflag">9.2.12</A> for a complete list of
       valid settings.
     
</DD>
<DT><STRONG>[haloLDepth]</STRONG></DT>
<DD>This vector specifies the lower corner of the effective halo
       region with respect to the lower corner of <TT>halostartregionflag</TT>.
       The size of <TT>haloLDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[haloUDepth]</STRONG></DT>
<DD>This vector specifies the upper corner of the effective halo
       region with respect to the upper corner of <TT>halostartregionflag</TT>.
       The size of <TT>haloUDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04036500000000000000">
18.6.5 ESMF_FieldRedist - Execute an Field redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldRedist(srcField, dstField, routehandle, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_Field),       intent(inout),optional  :: srcField
         type(ESMF_Field),       intent(inout),optional  :: dstField
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         logical,                intent(in),   optional  :: checkflag
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Field redistribution from <TT>srcField</TT> to
     <TT>dstField</TT>. Both <TT>srcField</TT> and <TT>dstField</TT> must be
     congruent and typekind conform with the respective Fields used during 
     <TT>ESMF_FieldRedistStore()</TT>. Congruent Fields possess
     matching DistGrids and the shape of the local array tiles matches between
     the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field redist feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
     <TT>dstField</TT> arguments.

<P>
See <TT>ESMF_FieldRedistStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentations using this method see Section  
     <A HREF="node4.html#sec:field:usage:redist_1dptr">18.2.29</A>. 

<P>
<DL>
<DT><STRONG>[srcField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.
     
</DD>
<DT><STRONG>[dstField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Field pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04036600000000000000">
18.6.6 ESMF_FieldRedistRelease - Release resources associated with Field redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldRedistRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an Field redistribution. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04036700000000000000">
18.6.7 ESMF_FieldRedistStore - Precompute Field redistribution with local factor argument </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldRedistStore() 
   subroutine ESMF_FieldRedistStore&lt;type&gt;&lt;kind&gt;(srcField, dstField, &amp; 
          routehandle, factor, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(inout)         :: srcField  
     type(ESMF_Field),         intent(inout)         :: dstField  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)            :: factor 
     integer,                  intent(in),  optional :: srcToDstTransposeMap(:) 
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="FieldRedistStoreTK"></A>   <TT>ESMF_FieldRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_FieldRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_FieldRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node4.html#FieldRedistStoreTK">18.6.7</A> and
   <A HREF="node4.html#FieldRedistStoreNF">18.6.8</A>, is described in the following paragraphs as a whole.

<P>
Store a Field redistribution operation from <TT>srcField</TT> to <TT>dstField</TT>.
   Interface <A HREF="node4.html#FieldRedistStoreTK">18.6.7</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="node4.html#FieldRedistStoreNF">18.6.8</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of patches within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Field, destination Field, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Fields may differ in shape,
   however, the number of elements must match. 

<P>
If <TT>srcToDstTransposeMap</TT> is not specified the redistribution corresponds
   to an identity mapping of the sequentialized source Field to the
   sequentialized destination Field. If the <TT>srcToDstTransposeMap</TT>
   argument is provided it must be identical on all PETs. The
   <TT>srcToDstTransposeMap</TT> allows source and destination Field dimensions to
   be transposed during the redistribution. The number of source and destination
   Field dimensions must be equal under this condition and the size of mapped
   dimensions must match.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
   <TT>dstField</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldRedist()</TT> on any pair of Fields that are weakly congruent
     and typekind conform with the <TT>srcField</TT>, <TT>dstField</TT> pair. 
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field redist feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node4.html#sec:field:usage:redist_1dptr">18.2.29</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. 
   
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. 
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>Factor by which to multiply data. Default is 1. See full method
     description above for details on the interplay with other PETs.
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcField</TT>. Each
     entry maps the corresponding <TT>srcField</TT> dimension against the specified
     <TT>dstField</TT> dimension. Mixing of distributed and undistributed
     dimensions is supported.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04036800000000000000">
18.6.8 ESMF_FieldRedistStore - Precompute Field redistribution without local factor argument </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldRedistStore() 
   subroutine ESMF_FieldRedistStoreNF(srcField, dstField, &amp; 
          routehandle, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(inout)         :: srcField  
     type(ESMF_Field),         intent(inout)         :: dstField  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     integer,                  intent(in),  optional :: srcToDstTransposeMap(:) 
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="FieldRedistStoreNF"></A>   <TT>ESMF_FieldRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_FieldRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_FieldRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node4.html#FieldRedistStoreTK">18.6.7</A> and
   <A HREF="node4.html#FieldRedistStoreNF">18.6.8</A>, is described in the following paragraphs as a whole.

<P>
Store a Field redistribution operation from <TT>srcField</TT> to <TT>dstField</TT>.
   Interface <A HREF="node4.html#FieldRedistStoreTK">18.6.7</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="node4.html#FieldRedistStoreNF">18.6.8</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of patches within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Field, destination Field, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Fields may differ in shape,
   however, the number of elements must match. 

<P>
If <TT>srcToDstTransposeMap</TT> is not specified the redistribution corresponds
   to an identity mapping of the sequentialized source Field to the
   sequentialized destination Field. If the <TT>srcToDstTransposeMap</TT>
   argument is provided it must be identical on all PETs. The
   <TT>srcToDstTransposeMap</TT> allows source and destination Field dimensions to
   be transposed during the redistribution. The number of source and destination
   Field dimensions must be equal under this condition and the size of mapped
   dimensions must match.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
   <TT>dstField</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldRedist()</TT> on any pair of Fields that are weakly congruent
     and typekind conform with the <TT>srcField</TT>, <TT>dstField</TT> pair. 
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field redist feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node4.html#sec:field:usage:redist_1dptr">18.2.29</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. 
   
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. 
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcField</TT>. Each
     entry maps the corresponding <TT>srcField</TT> dimension against the specified
     <TT>dstField</TT> dimension. Mixing of distributed and undistributed
     dimensions is supported.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04036900000000000000">
18.6.9 ESMF_FieldRegrid - Apply the regrid operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   !   Private name; call using ESMF_FieldRegrid()
       subroutine ESMF_FieldRegridRun(srcField, dstField, &amp;
                    routehandle, zeroflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field), intent(inout)                 :: srcField
       type(ESMF_Field), intent(inout)                 :: dstField
       type(ESMF_RouteHandle), intent(inout)           :: routeHandle
       type(ESMF_RegionFlag),  intent(in),    optional :: zeroflag
       logical,                intent(in),    optional :: checkflag
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute the precomputed regrid operation stored in <TT>routeHandle</TT> to 
     interpolate from <TT>srcField</TT> to <TT>dstField</TT>.  See <TT>ESMF_FieldRegridStore()</TT> on how to 
     precompute the <TT>routehandle</TT>. 

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> must be
     congruent with the respective Fields used during 
     <TT>ESMF_FieldRegridStore()</TT>. In the case of the Regrid operation congruent 
     Fields are built upon the same stagger location and on the same Grid. The routeHandle represents
     the interpolation between the Grids as they were during the <TT>ESMF_FieldRegridStore()</TT> call.  
     So if the coordinates at the stagger location in the Grids change, a new call to <TT>ESMF_FieldRegridStore()</TT> 
     is necessary to compute the interpolation between that new set of coordinates.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
     <TT>dstField</TT> arguments.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.
     
</DD>
<DT><STRONG>[dstField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroflag]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstField</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstField</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroflag</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination Array that will be updated by the sparse matrix
       multiplication. See section <A HREF="node2.html#opt:regionflag">9.2.13</A> for a complete list of
       valid settings.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040361000000000000000">
18.6.10 ESMF_FieldRegridRelease - Free resources used by regrid object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldRegridRelease(routeHandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_RouteHandle), intent(inout)  :: routeHandle
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Free resources used by regrid objec

<P>
The arguments are:
       <DL>
<DT><STRONG>routeHandle</STRONG></DT>
<DD>Handle carrying the sparse matrix
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040361100000000000000">
18.6.11 ESMF_FieldRegridStore - Store regrid and return RouteHandle and weights</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   !   Private name; call using ESMF_FieldRegridStore()
       subroutine ESMF_FieldRegridStore(srcField, srcMaskValues,        &amp;
                                        dstField, dstMaskValues,        &amp;
                                        unmappedDstAction,              &amp;
                                        routeHandle, indicies, weights, &amp; 
                                        regridMethod, regridConserve,   &amp;
                                        regridScheme, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field), intent(inout)                 :: srcField
       integer(ESMF_KIND_I4), intent(in), optional     :: srcMaskValues(:)
       type(ESMF_Field), intent(inout)                 :: dstField
       integer(ESMF_KIND_I4), intent(in), optional     :: dstMaskValues(:)
       type(ESMF_UnmappedAction), intent(in), optional :: unmappedDstAction
       type(ESMF_RouteHandle), intent(inout), optional :: routeHandle
       integer(ESMF_KIND_I4), pointer, optional        :: indicies(:,:)
       real(ESMF_KIND_R8), pointer, optional           :: weights(:)
       type(ESMF_RegridMethod), intent(in), optional   :: regridMethod
       type(ESMF_RegridConserve), intent(in), optional :: regridConserve
       integer, intent(in), optional                   :: regridScheme
       integer, intent(out), optional                  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a sparse matrix operation (stored in <TT>routeHandle</TT>) that contains the calculations and 
         communications necessary to interpolate from <TT>srcField</TT> to <TT>dstField</TT>. The routeHandle can then be used in the call
         <TT>ESMF_FieldRegrid()</TT> to interpolate between the Fields. The user may also get the
         interpolation matrix in sparse matrix form via the optional arguments <TT>indices</TT> and <TT>weights</TT>. 

<P>
The routeHandle generated by this call is based just on the coordinates at the 
         Fields' stagger locations in the Grids contained in the Fields.  
         If those coordinates don't change the routehandle can be used repeatedly to interpolate from the source Field to the destination Field. 
         This is true even if the data in the Fields changes. The routeHandle may also be used to interpolate between any source and 
         destination Field which are created on the same stagger location and Grid as the original Fields.        

<P>
When it's no longer needed the routeHandle should be destroyed by using <TT>ESMF_FieldRegridRelease()</TT> to free the memory it's using. 

<P>
The arguments are:
       <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD>Source Field.
       
</DD>
<DT><STRONG>[srcMaskValues]</STRONG></DT>
<DD>List of values that indicate a source point should be masked out. 
             If not specified, no masking will occur. 
       
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD>Destination Field.
       
</DD>
<DT><STRONG>[dstMaskValues]</STRONG></DT>
<DD>List of values that indicate a destination point should be masked out. 
             If not specified, no masking will occur.
       
</DD>
<DT><STRONG>[unmappedDstAction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Options are 
             <TT>ESMF_UNMAPPEDACTION_ERROR</TT> or 
             <TT>ESMF_UNMAPPEDACTION_IGNORE</TT>. If not specified, defaults 
             to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>. 
       
</DD>
<DT><STRONG>[routeHandle]</STRONG></DT>
<DD>The handle that implements the regrid and that can be used in later 
             <TT>ESMF_FieldRegrid</TT>.
       
</DD>
<DT><STRONG>[indices]</STRONG></DT>
<DD>The indices for the sparse matrix.
       
</DD>
<DT><STRONG>[weights]</STRONG></DT>
<DD>The weights for the sparse matrix.
       
</DD>
<DT><STRONG>[regridMethod]</STRONG></DT>
<DD>The type of regrid. Options are 
             <TT>ESMF_REGRID_METHOD_BILINEAR</TT> or 
             <TT>ESMF_REGRID_METHOD_PATCH</TT>. If not specified, defaults 
             to <TT>ESMF_REGRID_METHOD_BILINEAR</TT>.
       
</DD>
<DT><STRONG>[regridConserve]</STRONG></DT>
<DD>The mass conservation correction, options are 
             <TT>ESMF_REGRID_CONSERVE_OFF</TT> or 
             <TT>ESMF_REGRID_CONSERVE_ON</TT>. If not specified, defaults 
             to <TT>ESMF_REGRID_CONSERVE_OFF</TT>. 
       
</DD>
<DT><STRONG>[regridScheme]</STRONG></DT>
<DD>Whether to convert to spherical coordinates 
             (<TT>ESMF_REGRID_SCHEME_FULL3D</TT>), 
             or to leave in native coordinates 
             (<TT>ESMF_REGRID_SCHEME_NATIVE</TT>). 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040361200000000000000">
18.6.12 ESMF_FieldScatter - Scatter a Fortran array across the ESMF_Field </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldScatter&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, farray, patch, &amp; 
   rootPet, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   mtype (ESMF_KIND_mtypekind),dimension(mdim),intent(in),target :: farray 
   integer, intent(in), optional :: patch 
   integer, intent(in) :: rootPet 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Scatter the data of <TT>farray</TT> located on <TT>rootPET</TT> 
   across an ESMF_Field object. A single <TT>farray</TT> must be 
   scattered across a single DistGrid patch in Field. The optional <TT>patch</TT> 
   argument allows selection of the patch. For Fields defined on a single 
   patch DistGrid the default selection (patch 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the patch in Field. 

<P>
If the Field contains replicating DistGrid dimensions data will be 
   scattered across all of the replicated pieces. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
For examples and associated documentations using this method see Section 
   <A HREF="node4.html#sec:field:usage:scatter_2dptr">18.2.28</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object across which data will be scattered. 
   
</DD>
<DT><STRONG>[farray]</STRONG></DT>
<DD>The Fortran array that is to be scattered. Only root 
   must provide a valid <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[patch]</STRONG></DT>
<DD>The DistGrid patch in <TT>field</TT> into which to scatter <TT>farray</TT>. 
   By default <TT>farray</TT> will be scattered into patch 1. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid data in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040361300000000000000">
18.6.13 ESMF_FieldSMM - Execute an Field sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldSMM(srcField, dstField, routehandle, zeroflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_Field),       intent(inout),optional  :: srcField
         type(ESMF_Field),       intent(inout),optional  :: dstField
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         type(ESMF_RegionFlag),  intent(in),   optional  :: zeroflag
         logical,                intent(in),   optional  :: checkflag
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Field sparse matrix multiplication from <TT>srcField</TT> to
     <TT>dstField</TT>. Both <TT>srcField</TT> and <TT>dstField</TT> must be
     congruent and typekind conform with the respective Fields used during 
     <TT>ESMF_FieldSMMStore()</TT>. Congruent Fields possess
     matching DistGrids and the shape of the local array tiles matches between
     the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field SMM feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
     <TT>dstField</TT> arguments.

<P>
See <TT>ESMF_FieldSMMStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentations using this method see Section  
     <A HREF="node4.html#sec:field:usage:smm_1dptr">18.2.31</A>. 

<P>
<DL>
<DT><STRONG>[srcField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.
     
</DD>
<DT><STRONG>[dstField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroflag]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstField</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstField</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroflag</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination Field that will be updated by the sparse matrix
       multiplication. See section <A HREF="node2.html#opt:regionflag">9.2.13</A> for a complete list of
       valid settings.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Field pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040361400000000000000">
18.6.14 ESMF_FieldSMMRelease - Release resources associated with Field </A>
</H3>

<P>
sparse matrix multiplication

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldSMMRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an Field sparse matrix multiplication. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040361500000000000000">
18.6.15 ESMF_FieldSMMStore - Precompute Field sparse matrix multiplication </A>
</H3>

<P>
with local factor argument 

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSMMStore() 
   subroutine ESMF_FieldSMMStore&lt;type&gt;&lt;kind&gt;(srcField, dstField, &amp; 
          routehandle, factorList, factorIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(inout)         :: srcField  
     type(ESMF_Field),         intent(inout)         :: dstField  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)            :: factorList(:) 
     integer,                  intent(in),           :: factorIndexList(:,:) 
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an Field sparse matrix multiplication operation from <TT>srcField</TT>
   to <TT>dstField</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   patches within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source Field vector to 
   the destination Field vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical Field object for srcField and dstField 
   arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldSMM()</TT> on any pair of Fields that are weakly congruent
     and typekind conform with the <TT>srcField</TT>, <TT>dstField</TT> pair. 
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field SMM feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node4.html#sec:field:usage:smm_1dptr">18.2.31</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. 
   
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. 
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.
   
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the <TT>srcField</TT> while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in <TT>dstField</TT>. For this format to be a valid
       option source and destination Fields must have matching number of
       tensor elements (the product of the sizes of all Field tensor dimensions).
       Under this condition an identiy matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the <TT>srcField</TT>. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the <TT>dstField</TT>.

<P>
See section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition of 
       Field <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040361600000000000000">
18.6.16 ESMF_FieldSMMStore - Precompute Field sparse matrix multiplication with local factor argument </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSMMStore() 
   subroutine ESMF_FieldSMMStoreNF(srcField, dstField, &amp; 
          routehandle, factorList, factorIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(inout)         :: srcField  
     type(ESMF_Field),         intent(inout)         :: dstField  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an Field sparse matrix multiplication operation from <TT>srcField</TT>
   to <TT>dstField</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   patches within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source Field vector to 
   the destination Field vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical Field object for srcField and dstField 
   arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldSMM()</TT> on any pair of Fields that are weakly congruent
     and typekind conform with the <TT>srcField</TT>, <TT>dstField</TT> pair. 
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field SMM feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node4.html#sec:field:usage:smm_1dptr">18.2.31</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. 
   
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. 
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<H1><A NAME="SECTION04040000000000000000">
19 ArrayBundle Class</A>
</H1>

<P>

<H2><A NAME="SECTION04041000000000000000">
19.1 Description</A>
</H2>

<P>
The <TT>ESMF_ArrayBundle</TT> class allows a set of Arrays to be bundled into a
single object. The Arrays in an ArrayBundle may be of different type, kind,
rank and distribution. Besides ease of use resulting from bundeling the
ArrayBundle class offers the opportunity for performance optimization when
operating on a bundle of Arrays as a single entity. Especially communication
methods are good candidates for performance optimization. Best optimization
results are expected for ArrayBundles that contain Arrays that share a common
distribution, i.e. DistGrid, and are of same type, kind and rank.

<P>
ArrayBundles are one of the data objects that can be added to States,
which are used for providing to or consuming data from other components.

<P>

<H2><A NAME="SECTION04042000000000000000">
19.2 Use and Examples</A>
</H2>

<P>
Examples of creating, destroying and accessing ArrayBundles and their
constituent Arrays are provided in this section, along with some
notes on ArrayBundle methods.

<P>

<P>

<P>

<H3><A NAME="SECTION04042100000000000000">
19.2.1 ArrayBundle creation from a list of Arrays</A>
</H3>

<P>
First create a Fortran array of two <TT>ESMF_Array</TT> objects. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
<PRE>
  allocate(arrayList(2))
  arrayList(1) = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
<PRE>
  arrayList(2) = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
Now the <TT>arrayList</TT> of Arrays can be used to create an ArrayBundle object. 

<P>
<PRE>
  arraybundle = ESMF_ArrayBundleCreate(arrayList=arrayList, &amp;
    name="MyArrayBundle", rc=rc)
</PRE>

<P>
The temporary <TT>arrayList</TT> can be deallocated now. This will not affect
   the ESMF Array objects. The Array objects must not be deallocated while 
   the ArrayBundle refers to them! 

<P>
<PRE>
  deallocate(arrayList)
</PRE>

<P>
The ArrayBundle object can be printed. 

<P>
<PRE>
  call ESMF_ArrayBundlePrint(arraybundle, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04042200000000000000">
19.2.2 Access Arrays inside the ArrayBundle</A>
</H3>

<P>
Use <TT>ESMF_ArrayBundleGet()</TT> to determine how many Arrays are stored
   in an ArrayBundle. 

<P>
<PRE>
  call ESMF_ArrayBundleGet(arraybundle, arrayCount=arrayCount, rc=rc)
</PRE>

<P>
The <TT>arrayCount</TT> can be used to correctly allocate the <TT>arrayList</TT>
   variable for a second call to <TT>ESMF_ArrayBundleGet()</TT> to gain access
   to the bundled Array objects. 

<P>
<PRE>
  allocate(arrayList(arrayCount))
  call ESMF_ArrayBundleGet(arraybundle, arrayList=arraylist, rc=rc)
</PRE>

<P>
The <TT>arrayList</TT> variable can be used to access the individual Arrays,
   e.g. to print them. 

<P>
<PRE>
  do i=1, arrayCount
    call ESMF_ArrayPrint(arrayList(i), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT)
  enddo
</PRE>

<P>

<H3><A NAME="SECTION04042300000000000000">
19.2.3 Destroy an ArrayBundle and its constituents</A>
</H3>

<P>
The ArrayBundle object can be destroyed. 

<P>
<PRE>
  call ESMF_ArrayBundleDestroy(arraybundle, rc=rc)
</PRE>

<P>
After the ArrayBundle object has been destroyed it is safe to destroy its
   constituents. 

<P>
<PRE>
  call ESMF_ArrayDestroy(arrayList(1), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(arrayList(2), rc=rc)
</PRE>

<P>
<PRE>
  deallocate(arrayList)
  
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04042400000000000000">
19.2.4 Communication - Halo</A>
</H3>

<P>
One of the most fundamental communication pattern in domain decomposition
   codes is the <EM>halo</EM> operation. The ESMF Array class supports halos
   by allowing memory for extra elements to be allocated on each DE. See
   section <A HREF="node4.html#Array:Halo">20.2.14</A> for a discussion of the Array level halo operation.
   The ArrayBundle level extents the Array halo operation to bundles of Arrays.

<P>
First create an <TT>ESMF_ArrayBundle</TT> object containing a set of ESMF
   Arrays. 

<P>
<PRE>
  arraybundle = ESMF_ArrayBundleCreate(arrayList=arrayList, &amp;
    name="MyArrayBundle", rc=rc)
</PRE>

<P>
The ArrayBundle object can be treated as a single entity. The
   <TT>ESMF_ArrayBundleHaloStore()</TT> call determines the most efficient
   halo exchange pattern for <EM>all</EM> Arrays that are part of
   <TT>arraybundle</TT>. 

<P>
<PRE>
  call ESMF_ArrayBundleHaloStore(arraybundle=arraybundle, &amp;
    routehandle=haloHandle, rc=rc)
</PRE>

<P>
The halo exchange pattern stored in <TT>haloHandle</TT> can now be applied to
   the <TT>arraybundle</TT> object, or any other ArrayBundle that is weakly
   congruent to the one used during the <TT>ESMF_ArrayBundleHaloStore()</TT> call. 

<P>
<PRE>
  call ESMF_ArrayBundleHalo(arraybundle=arraybundle, routehandle=haloHandle, &amp;
    rc=rc)
</PRE>

<P>
Finally, when no longer needed, the resources held by <TT>haloHandle</TT> need
   to be returned to the system by calling <TT>ESMF_ArrayBundleHaloRelease()</TT>. 

<P>
<PRE>
  call ESMF_ArrayBundleHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
Finally the ArrayBundle object can be destroyed. 

<P>
<PRE>
  call ESMF_ArrayBundleDestroy(arraybundle, rc=rc)
</PRE>

<P>

<P>

<H2><A NAME="SECTION04043000000000000000">
19.3 Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Adding Arrays</B> to an existing ArrayBundle is currently not supported. In the future this functionality will be provided via the
<TT>ESMF_ArrayBundleAdd()</TT> method.

<P>
</LI>
<LI><B>Removing Arrays</B> from an existing ArrayBundle is currently not supported. In the future this functionality will be provided via the
<TT>ESMF_ArrayBundleRemove()</TT> method.

<P>
</LI>
<LI><B>Non-blocking</B> ArrayBundle communications option is not yet implemented. In the future this functionality will be provided via the
<TT>commflag</TT> option.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION04044000000000000000">
19.4 Design and Implementation Notes</A>
</H2>

<P>
The following is a list of implementation specific details about the current ESMF ArrayBundle.

<P>

<UL>
<LI>Implementation language is C++.
</LI>
<LI>All precomputed communication methods are based on sparse matrix
multiplication.
</LI>
</UL>

<P>

<H2><A NAME="SECTION04045000000000000000">
19.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04045100000000000000">
19.5.1 ESMF_ArrayBundleCreate - Create an ArrayBundle from a list of Arrays</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleCreate()
   function ESMF_ArrayBundleCreate(arrayList, arrayCount, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in)            :: arrayList(:)
     integer,          intent(in),  optional :: arrayCount
     character (len=*),intent(in),  optional :: name
     integer,          intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_ArrayBundle) :: ESMF_ArrayBundleCreate
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_ArrayBundle</TT> object from a list of Arrays.

<P>
The creation of an ArrayBundle leaves the bundled Arrays unchanged, they
   remain valid individual objects. An ArrayBundle is a light weight container
   of Array references. The actual data remains in place, there are no
   data movements or duplications associated with the creation of an 
   ArrayBundle.

<P>
<DL>
<DT><STRONG>arrayList</STRONG></DT>
<DD>List of <TT>ESMF_Array</TT> objects to be bundled.
   
</DD>
<DT><STRONG>[arrayCount]</STRONG></DT>
<DD>If provided specifies that only first <TT>arrayCount</TT> Arrays in the
         <TT>arrayList</TT> argument are to be included in the ArrayBundle. By
         default <TT>arrayCount</TT> is equal to <TT>size(arrayList)</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04045200000000000000">
19.5.2 ESMF_ArrayBundleDestroy - Destroy ArrayBundle object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleDestroy(arraybundle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)           :: arraybundle
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMF_ArrayBundle</TT> object. The member Arrays are not
   touched by this operation and remain valid objects that need to be 
   destroyed individually if necessary.

<P>
The arguments are:
   <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04045300000000000000">
19.5.3 ESMF_ArrayBundleGet - Get list of Arrays out of an ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_ArrayBundleGet()
     subroutine ESMF_ArrayBundleGet(arraybundle, arrayCount, arrayList, &amp;
       name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)               :: arraybundle
     integer,                intent(out),    optional :: arrayCount
     type(ESMF_Array),       intent(inout),  optional :: arrayList(:)
     character(len=*),       intent(out),    optional :: name
     integer,                intent(out),    optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get the list of Arrays bundled in an ArrayBundle.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> to be queried.
     
</DD>
<DT><STRONG>[arrayCount]</STRONG></DT>
<DD>Upon return holds the number of Arrays bundled in the ArrayBundle.
     
</DD>
<DT><STRONG>[arrayList]</STRONG></DT>
<DD>Upon return holds a List of Arrays bundled in ArrayBundle. The
           argument must be allocated to be at least of size <TT>arrayCount</TT>.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the ArrayBundle object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04045400000000000000">
19.5.4 ESMF_ArrayBundleHalo - Execute an ArrayBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleHalo(arraybundle, routehandle, &amp;
     checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)           :: arraybundle
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     logical,                intent(in),   optional  :: checkflag
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed ArrayBundle halo operation for the Arrays in
     <TT>arrayBundle</TT>.

<P>
See <TT>ESMF_ArrayBundleHaloStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pairs will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04045500000000000000">
19.5.5 ESMF_ArrayBundleHaloRelease - Release resources associated with ArrayBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleHaloRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an ArrayBundle halo operation.
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04045600000000000000">
19.5.6 ESMF_ArrayBundleHaloStore - Precompute an ArrayBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayBundleHaloStore(arraybundle, routehandle, &amp;
       halostartregionflag, haloLDepth, haloUDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)                :: arraybundle
     type(ESMF_RouteHandle), intent(inout)                :: routehandle
     type(ESMF_HaloStartRegionFlag), intent(in), optional :: halostartregionflag
     integer,                intent(in),         optional :: haloLDepth(:)
     integer,                intent(in),         optional :: haloUDepth(:)
     integer,                intent(out),        optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle halo operation over the data in <TT>arraybundle</TT>. By 
     default, i.e. without specifying <TT>halostartregionflag</TT>, <TT>haloLDepth</TT>
     and <TT>haloUDepth</TT>, all elements in the total Array regions that lie
     outside the exclusive regions will be considered potential destination
     elements for halo. However, only those elements that have a corresponding
     halo source element, i.e. an exclusive element on one of the DEs, will be
     updated under the halo operation. Elements that have no associated source
     remain unchanged under halo.

<P>
Specifying <TT>halostartregionflag</TT> allows to change the shape of the 
     effective halo region from the inside. Setting this flag to
     <TT>ESMF_REGION_COMPUTATIONAL</TT> means that only elements outside 
     the computational region for each Array are considered for potential
     destination elements for halo. The default is <TT>ESMF_REGION_EXCLUSIVE</TT>.

<P>
The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> arguments allow to reduce
     the extent of the effective halo region. Starting at the region specified
     by <TT>halostartregionflag</TT>, the <TT>haloLDepth</TT> and <TT>haloUDepth</TT>
     define a halo depth in each direction. Note that the maximum halo region is
     limited by the total region for each Array, independent of the actual
     <TT>haloLDepth</TT> and <TT>haloUDepth</TT> setting. The total Array regions are
     local DE specific. The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> are interpreted
     as the maximum desired extent, reducing the potentially larger region
     available for halo.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleHalo()</TT> on any ArrayBundle that is weakly congruent
     and typekind conform to <TT>arraybundle</TT>. Congruency for ArrayBundles is
     given by the congruency of its constituents.
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[halostartregionflag]</STRONG></DT>
<DD>The start of the effective halo region on every DE. The default
       setting is <TT>ESMF_REGION_EXCLUSIVE</TT>, rendering all non-exclusive
       elements potential halo destination elments.
       See section <A HREF="node2.html#opt:halostartregionflag">9.2.12</A> for a complete list of
       valid settings.
     
</DD>
<DT><STRONG>[haloLDepth]</STRONG></DT>
<DD>This vector specifies the lower corner of the effective halo
       region with respect to the lower corner of <TT>halostartregionflag</TT>.
       The size of <TT>haloLDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[haloUDepth]</STRONG></DT>
<DD>This vector specifies the upper corner of the effective halo
       region with respect to the upper corner of <TT>halostartregionflag</TT>.
       The size of <TT>haloUDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04045700000000000000">
19.5.7 ESMF_ArrayBundlePrint - Print ArrayBundle internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundlePrint(arraybundle, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)        :: arraybundle
     character(len=*), intent(in),   optional  :: options
     integer,          intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>ESMF_ArrayBundle</TT> object. 
<BR>
<P>
Note:  Many <TT>ESMF_&lt;class&gt;Print</TT> methods are implemented in C++.
     On some platforms/compilers there is a potential issue with interleaving
     Fortran and C++ output to <TT>stdout</TT> such that it doesn't appear in
     the expected order.  If this occurs, the <TT>ESMF_IOUnitFlush()</TT> method
     may be used on unit 6 to get coherent output.  
<BR>
<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> object.
     
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options are not yet supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04045800000000000000">
19.5.8 ESMF_ArrayBundleRedist - Execute an ArrayBundle redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleRedist(srcArrayBundle, dstArrayBundle, &amp;
     routehandle, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in),     optional  :: srcArrayBundle
     type(ESMF_ArrayBundle), intent(inout),  optional  :: dstArrayBundle
     type(ESMF_RouteHandle), intent(inout)             :: routehandle
     logical,                intent(in),     optional  :: checkflag
     integer,                intent(out),    optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed ArrayBundle redistribution from the Arrays in
     <TT>srcArrayBundle</TT> to the Arrays in <TT>dstArrayBundle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pairs will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04045900000000000000">
19.5.9 ESMF_ArrayBundleRedistRelease - Release resources associated with ArrayBundle redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleRedistRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an ArrayBundle redistribution.
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040451000000000000000">
19.5.10 ESMF_ArrayBundleRedistStore - Precompute an ArrayBundle redistribution with local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleRedistStore()
   subroutine ESMF_ArrayBundleRedistStore&lt;type&gt;&lt;kind&gt;(srcArrayBundle, &amp;
     dstArrayBundle, routehandle, factor, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),   intent(in)              :: srcArrayBundle
     type(ESMF_ArrayBundle),   intent(inout)           :: dstArrayBundle
     type(ESMF_RouteHandle),   intent(inout)           :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)              :: factor
     integer,                  intent(in),   optional  :: srcToDstTransposeMap(:)
     integer,                  intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle redistribution operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The redistribution
     between ArrayBundles is defined as the sequence of
     individual Array redistributions over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify a <TT>factor</TT> argument must use the
     &lt;type&gt;&lt;kind&gt; overloaded interface. Other PETs call into the interface
     without <TT>factor</TT> argument. If multiple PETs specify the <TT>factor</TT>
     argument its type and kind as well as its value must match across all
     PETs. If none of the PETs specifies a <TT>factor</TT> argument the default
     will be a factor of 1.

<P>
See the description of method <TT>ESMF_ArrayRedistStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleRedist()</TT> on any pair of ArrayBundles that 
     are weakly congruent and typekind conform with the Arrays contained in
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT>. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This method is overloaded for:
<BR>
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[factor]</STRONG></DT>
<DD>Factor by which to multipy source data. Default is 1.
     
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in the Arrays in
       <TT>srcArrayBundle</TT>. Each
       entry maps the corresponding source Array dimension against the 
       specified destination Array dimension. Mixing of distributed and
       undistributed dimensions is supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040451100000000000000">
19.5.11 ESMF_ArrayBundleRedistStore - Precompute an ArrayBundle redistribution without local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleRedistStore()
   subroutine ESMF_ArrayBundleRedistStoreNF(srcArrayBundle, dstArrayBundle, &amp;
     routehandle, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)              :: srcArrayBundle
     type(ESMF_ArrayBundle), intent(inout)           :: dstArrayBundle
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     integer,                intent(in),   optional  :: srcToDstTransposeMap(:)
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle redistribution operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The redistribution
     between ArrayBundles is defined as the sequence of
     individual Array redistributions over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify a <TT>factor</TT> argument must use the
     &lt;type&gt;&lt;kind&gt; overloaded interface. Other PETs call into the interface
     without <TT>factor</TT> argument. If multiple PETs specify the <TT>factor</TT>
     argument its type and kind as well as its value must match across all
     PETs. If none of the PETs specifies a <TT>factor</TT> argument the default
     will be a factor of 1.

<P>
See the description of method <TT>ESMF_ArrayRedistStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleRedist()</TT> on any pair of ArrayBundles that 
     are weakly congruent and typekind conform with the Arrays contained in
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT>. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in the Arrays in
       <TT>srcArrayBundle</TT>. Each
       entry maps the corresponding source Array dimension against the 
       specified destination Array dimension. Mixing of distributed and
       undistributed dimensions is supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040451200000000000000">
19.5.12 ESMF_ArrayBundleSMM - Execute an ArrayBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleSMM(srcArrayBundle, dstArrayBundle, routehandle, &amp;
     zeroflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in),   optional  :: srcArrayBundle
     type(ESMF_ArrayBundle), intent(inout),optional  :: dstArrayBundle
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     type(ESMF_RegionFlag),  intent(in),   optional  :: zeroflag
     logical,                intent(in),   optional  :: checkflag
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed ArrayBundle sparse matrix multiplication from the
     Arrays in <TT>srcArrayBundle</TT> to the Arrays in <TT>dstArrayBundle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroflag]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of 
       all DEs in all Arrays in <TT>dstArrayBundle</TT> will be initialized to zero 
       before updating the elements with the results of the sparse matrix 
       multiplication. If set to <TT>ESMF_REGION_EMPTY</TT> the elements in the
       Arrays in <TT>dstArrayBundle</TT> will not be modified prior to the sparse
       matrix multiplication and results will be added to the incoming element
       values. Setting <TT>zeroflag</TT> to <TT>ESMF_REGION_SELECT</TT> will only
       zero out those elements in the destination Arrays that will be updated
       by the sparse matrix multiplication. See section <A HREF="node2.html#opt:regionflag">9.2.13</A>
       for a complete list of valid settings.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pairs will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040451300000000000000">
19.5.13 ESMF_ArrayBundleSMMRelease - Release resources associated with ArrayBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleSMMRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an ArrayBundle sparse matrix multiplication. 
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040451400000000000000">
19.5.14 ESMF_ArrayBundleSMMStore - Precompute an ArrayBundle sparse matrix multiplication with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleSMMStore()
   subroutine ESMF_ArrayBundleSMMStore&lt;type&gt;&lt;kind&gt;(srcArrayBundle, &amp;
     dstArrayBundle, routehandle, factorList, factorIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),     intent(in)              :: srcArrayBundle
     type(ESMF_ArrayBundle),     intent(inout)           :: dstArrayBundle
     type(ESMF_RouteHandle),     intent(inout)           :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)        :: factorList(:)
     integer,                    intent(in)              :: factorIndexList(:,:)
     integer,                    intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle sparse matrix multiplication operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The sparse matrix
     multiplication between ArrayBundles is defined as the sequence of
     individual Array sparse matrix multiplications over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
See the description of method <TT>ESMF_ArraySMMStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleSMM()</TT> on any pair of ArrayBundles that 
     are weakly congruent and typekind conform with the Arrays contained in
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT>. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This method is overloaded for:
<BR>
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.
     
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the source Array while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in the destination Array. For this format to be a
       valid option source and destination Arrays must have matching number of
       tensor elements (the product of the sizes of all Array tensor dimensions).
       Under this condition an identiy matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the source Array. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the destination Array.

<P>
See section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition of 
       Array <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040451500000000000000">
19.5.15 ESMF_ArrayBundleSMMStore - Precompute an ArrayBundle sparse matrix multiplication without local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleSMMStore()
   subroutine ESMF_ArrayBundleSMMStoreNF(srcArrayBundle, dstArrayBundle, &amp;
     routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),     intent(in)              :: srcArrayBundle
     type(ESMF_ArrayBundle),     intent(inout)           :: dstArrayBundle
     type(ESMF_RouteHandle),     intent(inout)           :: routehandle
     integer,                    intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle sparse matrix multiplication operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The sparse matrix
     multiplication between ArrayBundles is defined as the sequence of
     individual Array sparse matrix multiplications over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
See the description of method <TT>ESMF_ArraySMMStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleSMM()</TT> on any pair of ArrayBundles that 
     are weakly congruent and typekind conform with the Arrays contained in
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT>. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION04050000000000000000">
20 Array Class</A>
</H1>

<P>

<H2><A NAME="SECTION04051000000000000000">
20.1 Description</A>
</H2>

<P>
The Array class is an alternative to the Field class for representing distributed, structured data.  Unlike Fields, which are built to carry grid coordinate information, Arrays can only carry information about the <I>indices</I> associated with grid cells.  Since they do not have coordinate information, Arrays cannot be used to calculate interpolation weights.  However, if the user can supply interpolation weights (using a package such as SCRIP), the Array sparse matrix multiply operation can be used to apply the weights and transfer data to the new grid.  Arrays can also perform redistribution, scatter, and gather operations.

<P>
Like Fields, Arrays can be added to a State and used in inter-component data communications.  Arrays can also be grouped together into ArrayBundles so that collective operations can be performed on the whole group.  One motivation for this is convenience; another is the ability to schedule optimized, collective data transfers.   

<P>
From a technical standpoint, the <TT>ESMF_Array</TT> class is an index space based, distributed data storage class. It provides DE-local memory allocations within DE-centric index regions and defines the relationship to the index space described by DistGrid. The Array class offers common communication patterns within the index space formalism. As part of the ESMF index space layer Array has close relationship to the DistGrid and DELayout classes.

<P>

<H2><A NAME="SECTION04052000000000000000">
20.2 Use and Examples</A>
</H2>

<P>
An <TT>ESMF_Array</TT> is a distributed object that must exist on all PETs of the current context. Each PET-local instance of an Array object contains memory allocations for all PET-local DEs. There may be 0, 1, or more DEs per PET and the number of DEs per PET can differ between PETs for the same Array object. Memory allocations may be provided for each PET by the user during Array creation or can be allocated as part of the Array create call. Many of the concepts of the proposed <TT>ESMF_Array</TT> class are illustrated by the following examples.

<P>

<P>

<P>

<H3><A NAME="SECTION04052100000000000000">
20.2.1 Array from native Fortran array with 1 DE per PET</A>
</H3>

<P>
The create call of the <TT>ESMF_Array</TT> class has been overloaded
   extensively to facilitate the need for generality while keeping simple
   cases simple. The following program demonstrates one of the simpler
   cases, where existing local Fortran arrays are to be used to provide
   the PET-local memory allocations for the Array object.

<P>
<PRE>
program ESMF_ArrayFarrayEx

  use ESMF_Mod
  
  implicit none
</PRE>

<P>
The Fortran language provides a variety of ways to define and allocate
   an array. Actual Fortran array objects must either be explicit-shape or
   deferred-shape. In the first case the memory allocation and deallocation is 
   automatic from the user's perspective and the details of the allocation 
   (static or dynamic, heap or stack) are left to the compiler. (Compiler flags
   may be used to control some of the details). In the second case, i.e. for 
   deferred-shape actual objects, the array definition must include the pointer 
   or allocatable attribute and it is the user's responsibility to allocate 
   memory. While it is also the user's responsibility to deallocate memory for
   arrays with pointer attribute the compiler will automatically deallocate
   allocatable arrays under certain circumstances defined by the Fortran
   standard.

<P>
The <TT>ESMF_ArrayCreate()</TT> interface has been written to accept native
   Fortran arrays of any flavor as a means to allow user-controlled memory
   management. The Array create call will check on each PET if sufficient 
   memory has been provided by the specified Fortran arrays and will indicate 
   an error if a problem is detected. However, the Array create call cannot
   validate the lifetime of the provided memory allocations. If, for instance,
   an Array object was created in a subroutine from an automatic explicit-shape
   array or an allocatable array, the memory allocations referenced by the Array 
   object will be automatically deallocated on return from the subroutine unless
   provisions are made by the application writer to prevent such behavior. The
   Array object cannot control when memory that has been provided by the user
   during Array creation becomes deallocated, however, the Array will indicate
   an error if its memory references have been invalidated. 

<P>
The easiest, portable way to provide safe native Fortran memory allocations
   to Array create is to use arrays with the pointer attribute. Memory allocated
   for an array pointer will not be deallocated automatically. However, in this
   case the possibility of memory leaks becomes an issue of concern. The 
   deallocation of memory provided to an Array in form of a native Fortran
   allocation will remain the users responsibility.

<P>
None of the concerns discussed above are an issue in this example where the
   native Fortran array <TT>farray</TT> is defined in the main program. All
   different types of array memory allocation are demonstrated in this example.
   First <TT>farrayE</TT> is defined as a 2D explicit-shape array on each PET which 
   will automatically provide memory for <IMG
 WIDTH="57" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.png"
 ALT="$10\times 10$"> elements. 

<P>
<PRE>
  ! local variables
  real(ESMF_KIND_R8)          :: farrayE(10,10)     ! explicit shape Fortran array
</PRE>

<P>
Then an allocatable array <TT>farrayA</TT> is declared which will be used
   to show user-controlled dynamic memory allocation. 

<P>
<PRE>
  real(ESMF_KIND_R8), allocatable :: farrayA(:,:)   ! allocatable Fortran array
</PRE>

<P>
Finally an array with pointer attribute <TT>farrayP</TT> is declared, also used
   for user-controlled dynamic memory allocation. 

<P>
<PRE>
  real(ESMF_KIND_R8), pointer :: farrayP(:,:)       ! Fortran array pointer
</PRE>

<P>
A matching array pointer must also be available to gain access to the arrays
   held by an Array object. 

<P>
<PRE>
  real(ESMF_KIND_R8), pointer :: farrayPtr(:,:)     ! matching Fortran array pointer 
  type(ESMF_DistGrid)         :: distgrid           ! DistGrid object
  type(ESMF_Array)            :: array              ! Array object
  integer                     :: rc
</PRE>

<P>
<PRE>
  call ESMF_Initialize(rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT)
</PRE>

<P>
On each PET <TT>farrayE</TT> can be accessed directly to initialize the entire
   PET-local array. 

<P>
<PRE>
  farrayE = 12.45d0 ! initialize to some value
</PRE>

<P>
In order to create an Array object a DistGrid must first be created that 
   describes the total index space and how it is decomposed and distributed.
   In the simplest case only the <TT>minIndex</TT> and <TT>maxIndex</TT> of the 
   total space must be provided. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
This example is assumed to run on 4 PETs. The default 2D decomposition will 
   then be into 4 x 1 DEs as to ensure 1 DE per PET. 

<P>
Now the Array object can be created using the <TT>farrayE</TT> and the DistGrid
   just created. 

<P>
<PRE>
  array = ESMF_ArrayCreate(farray=farrayE, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
The 40 x 10 index space defined by the <TT>minIndex</TT> and <TT>maxIndex</TT> 
   arguments paired with the default decomposition will result in the following
   distributed Array.

<P>
<PRE>
  
         +---------------------------&gt; 2nd dimension
         |   (1,1)-------+
         |     |         |
         |     |   DE 0  |   &lt;--- farray on PET 0
         |     |         |
         |     +------(10,10)
         |  (11,1)-------+
         |     |         |
         |     |   DE 1  |   &lt;--- farray on PET 1
         |     |         |
         |     +------(20,10)
         |  (21,1)-------+
         |     |         |
         |     |   DE 2  |   &lt;--- farray on PET 2
         |     |         |
         |     +------(30,10)
         |  (31,1)-------+
         |     |         |
         |     |   DE 3  |   &lt;--- farray on PET 3
         |     |         |
         |     +------(40,10)
         v
       1st dimension
</PRE>

<P>
Providing <TT>farrayE</TT> during Array creation does not change anything about
   the actual <TT>farrayE</TT> object. This means that each PET can use its
   local <TT>farrayE</TT> directly to access the memory referenced by the Array 
   object. 

<P>
<PRE>
  print *, farrayE
</PRE>

<P>
Another way of accessing the memory associated with an Array object is to 
   use <TT>ArrayGet()</TT> to obtain an Fortran pointer that references the
   PET-local array. 

<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
  print *, farrayPtr
</PRE>

<P>
Finally the Array object must be destroyed. The PET-local memory of the
   <TT>farrayE</TT>s will remain in user control and will not be altered by 
   <TT>ArrayDestroy()</TT>. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
Since the memory allocation for each <TT>farrayE</TT> is automatic there is
   nothing more to do.

<P>
The interaction between <TT>farrayE</TT> and the Array class is representative
   also for the two other cases <TT>farrayA</TT> and <TT>farrayP</TT>. The only
   difference is in the handling of memory allocations. 

<P>
<PRE>
  allocate(farrayA(10,10))    ! user controlled allocation
  farrayA = 23.67d0           ! initialize to some value
  array = ESMF_ArrayCreate(farray=farrayA, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
<PRE>
  print *, farrayA            ! print PET-local farrayA directly
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)! obtain array pointer
  print *, farrayPtr          ! print PET-local piece of Array through pointer
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the Array
  deallocate(farrayA)         ! user controlled de-allocation
</PRE>

<P>
The <TT>farrayP</TT> case is identical. 

<P>
<PRE>
  allocate(farrayP(10,10))    ! user controlled allocation
  farrayP = 56.81d0           ! initialize to some value
  array = ESMF_ArrayCreate(farray=farrayP, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
<PRE>
  print *, farrayP            ! print PET-local farrayA directly
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)! obtain array pointer
  print *, farrayPtr          ! print PET-local piece of Array through pointer
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the Array
  deallocate(farrayP)         ! user controlled de-allocation
</PRE>

<P>
To wrap things up the DistGrid object is destroyed and ESMF can be finalized. 

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc) ! destroy the DistGrid
</PRE>

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04052200000000000000"></A>
   <A NAME="Array:fpadding"></A>
<BR>
20.2.2 Array from native Fortran array with extra elements for halo or padding
</H3>

<P>
The example of the previous section showed how easy it is to create an Array
   object from existing PET-local Fortran arrays. The example did, however, not
   define any halo elements around the DE-local regions. The following code
   demonstrates how an Array object with space for a halo can be set up. 

<P>
<PRE>
program ESMF_ArrayFarrayHaloEx

  use ESMF_Mod
  
  implicit none
</PRE>

<P>
The allocatable array <TT>farrayA</TT> will be used to provide the PET-local
   Fortran array for this example. 

<P>
<PRE>
  ! local variables
  real(ESMF_KIND_R8), allocatable :: farrayA(:,:)   ! allocatable Fortran array
  real(ESMF_KIND_R8), pointer :: farrayPtr(:,:)     ! matching Fortran array pointer
  type(ESMF_DistGrid)         :: distgrid           ! DistGrid object
  type(ESMF_Array)            :: array              ! Array object
  integer                     :: rc, i, j
  real                        :: localSum
</PRE>

<P>
<PRE>
  call ESMF_Initialize(rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT)
</PRE>

<P>
The Array is to cover the exact same index space as in the previous
   example. Furthermore decomposition and distribution are also kept the same.
   Hence the same DistGrid object will be created and it is expected to 
   execute this example with 4 PETs.

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
This DistGrid describes a 40 x 10 index space that will be decomposed into 
   4 DEs when executed on 4 PETs, associating 1 DE per PET. Each DE-local 
   exclusive region contains 10 x 10 elements. The DistGrid also stores and provides
   information about the relationship between DEs in index space, however,
   DistGrid does not contain information about halos. Arrays contain halo 
   information and it is possible to create multiple Arrays covering the same
   index space with identical decomposition and distribution using the same
   DistGrid object, while defining different, Array-specific halo regions.

<P>
The extra memory required to cover the halo in the Array object must be 
   taken into account when allocating the PET-local <TT>farrayA</TT> arrays. For
   a halo of 2 elements in each direction the following allocation will suffice. 

<P>
<PRE>
  allocate(farrayA(14,14))    ! Fortran array with halo: 14 = 10 + 2 * 2
</PRE>

<P>
The <TT>farrayA</TT> can now be used to create an Array object with enough space
   for a two element halo in each direction. The Array creation method checks for 
   each PET that the local Fortran array can accommodate the requested regions.

<P>
The default behavior of ArrayCreate() is to center the exclusive region within
   the total region. Consequently the following call will provide the 2 extra 
   elements on each side of the exclusive 10 x 10 region without having to specify
   any additional arguments. 

<P>
<PRE>
  array = ESMF_ArrayCreate(farray=farrayA, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
The exclusive Array region on each PET can be accessed through a suitable
   Fortran array pointer. See section <A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A>
   for more details on Array regions. 

<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
Following Array bounds convention, which by default puts the beginning of 
   the exclusive region at (1, 1, ...), the following loop will add up the 
   values of the local exclusive region for each DE, regardless of how the bounds
   were chosen for the original PET-local <TT>farrayA</TT> arrays. 

<P>
<PRE>
  localSum = 0.
  do j=1, 10
    do i=1, 10
      localSum = localSum + farrayPtr(i, j)
    enddo
  enddo
</PRE>

<P>
Elements with <IMG
 WIDTH="12" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img38.png"
 ALT="$i$"> or <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.png"
 ALT="$j$"> in the [-1,0] or [11,12] ranges are located outside the
   exclusive region and may be used to define extra computational points or 
   halo operations.

<P>
Cleanup and shut down ESMF. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
  deallocate(farrayA)
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04052300000000000000"></A>
   <A NAME="Array:LocalArray"></A>
<BR>
20.2.3 Array from <TT>ESMF_LocalArray</TT>
</H3>

<P>
Alternative to the direct usage of Fortran arrays during Array creation
   it is also possible to first create an <TT>ESMF_LocalArray</TT> and create the
   Array from it. While this may seem more burdensome for the 1 DE per PET cases
   discussed in the previous sections it allows a straight forward 
   generalization to the multiple DE per PET case. The following example first
   recaptures the previous example using an <TT>ESMF_LocalArray</TT> and then
   expands to the multiple DE per PET case. 

<P>
<PRE>
program ESMF_ArrayLarrayEx

  use ESMF_Mod
  
  implicit none
</PRE>

<P>
The current <TT>ESMF_LocalArray</TT> interface requires Fortran arrays to be 
   defined with pointer attribute. 

<P>
<PRE>
  ! local variables
  real(ESMF_KIND_R8), pointer :: farrayP(:,:)       ! Fortran array pointer
  real(ESMF_KIND_R8), pointer :: farrayPtr(:,:)     ! matching Fortran array pointer 
  type(ESMF_LocalArray)       :: larray             ! ESMF_LocalArray object
  type(ESMF_LocalArray)       :: larrayRef          ! ESMF_LocalArray object
  type(ESMF_DistGrid)         :: distgrid           ! DistGrid object
  type(ESMF_Array)            :: array              ! Array object
  integer                     :: rc, i, j, de
  real                        :: localSum
  type(ESMF_LocalArray), allocatable :: larrayList(:)      ! ESMF_LocalArray object list
  type(ESMF_LocalArray), allocatable :: larrayRefList(:)   ! ESMF_LocalArray object list
  
  type(ESMF_VM):: vm
  integer:: localPet, petCount
</PRE>

<P>
<PRE>
  call ESMF_Initialize(vm=vm, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT)
  call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT)
  
  if (petCount /= 4) then
    finalrc = ESMF_FAILURE
    goto 10
  endif
</PRE>

<P>
DistGrid and array allocation remains unchanged.

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
<PRE>
  allocate(farrayP(14,14))    ! allocate Fortran array on each PET with halo
</PRE>

<P>
Now instead of directly creating an Array object using the PET-local 
   <TT>farrayP</TT>s an <TT>ESMF_LocalArray</TT> object will be created on each PET. 

<P>
<PRE>
  larray = ESMF_LocalArrayCreate(farrayP, ESMF_DATA_REF, rc=rc)
</PRE>

<P>
The Array object can now be created from <TT>larray</TT>. The Array 
   creation method checks for each PET that the LocalArray can 
   accommodate the requested regions. 

<P>
<PRE>
  array = ESMF_ArrayCreate(larrayList=(/larray/), distgrid=distgrid, rc=rc)
</PRE>

<P>
Once created there is no difference in how the Array object can be used.
   The exclusive Array region on each PET can be accessed through a suitable
   Fortran array pointer as before. 

<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
Alternatively it is also possible (independent of how the Array object was
   created) to obtain the reference to the array allocation held by Array in 
   form of an <TT>ESMF_LocalArray</TT> object. The <TT>farrayPtr</TT> can then be
   extracted using LocalArray methods. 

<P>
<PRE>
  call ESMF_ArrayGet(array, larray=larrayRef, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_LocalArrayGet(larrayRef, farrayPtr, rc=rc)
</PRE>

<P>
Either way the <TT>farrayPtr</TT> reference can be used now to add up the values
   of the local exclusive region for each DE. The following loop 
   works regardless of how the bounds were chosen for the original PET-local 
   <TT>farrayP</TT> arrays and consequently the PET-local <TT>larray</TT> objects. 

<P>
<PRE>
  localSum = 0.
  do j=1, 10
    do i=1, 10
      localSum = localSum + farrayPtr(i, j)
    enddo
  enddo
  print *, "localSum=", localSum
</PRE>

<P>
Cleanup. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
  call ESMF_LocalArrayDestroy(larray, rc=rc)
  deallocate(farrayP)   ! use the pointer that was used in allocate statement
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
While the usage of LocalArrays is unnecessarily cumbersome for 1 DE per PET
   Arrays, it provides a straight forward path for extending the interfaces 
   to multiple DEs per PET. 

<P>
In the following example a 8 x 8 index space will be decomposed into
   2 x 4 = 8 DEs. The situation is captured by the following DistGrid object. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/8,8/), &amp;
    regDecomp=(/2,4/), rc=rc)
</PRE>

<P>
The <TT>distgrid</TT> object created in this manner will contain 8 DEs no 
   matter how many PETs are available during execution. Assuming an execution
   on 4 PETs will result in the following distribution of the decomposition.

<P>
<PRE>
   
    +---------------------------------------&gt; 2nd dimension
    |  (1,1)
    |    +-----------+-----------+-----------+-----------+
    |    | DE0, PET0 | DE2, PET1 | DE4, PET2 | DE6, PET3 |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    +-----------+-----------+-----------+-----------+
    |    | DE1, PET0 | DE3, PET1 | DE5, PET2 | DE7, PET3 |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    +-----------+-----------+-----------+-----------+
    |                                                    (8,8)
    v 
   1st dimension
</PRE>

<P>
Obviously each PET is associated with 2 DEs. Each PET must allocate enough
   space for <EM>all</EM> its DEs. This is done by allocating 
   as many DE-local arrays as there are DEs on the PET. The reference to these
   array allocations is passed into ArrayCreate via a LocalArray list argument
   that holds as many elements as there are DEs on the PET. Here each PET must
   allocate for two DEs.

<P>
<PRE>
  allocate(larrayList(2))   ! 2 DEs per PET
  allocate(farrayP(4, 2))   ! without halo each DE is of size 4 x 2 
  farrayP = 123.456d0
  larrayList(1) = ESMF_LocalArrayCreate(farrayP, ESMF_DATA_REF, rc=rc)  ! 1st DE
  allocate(farrayP(4, 2))   ! without halo each DE is of size 4 x 2 
  farrayP = 456.789d0
  larrayList(2) = ESMF_LocalArrayCreate(farrayP, ESMF_DATA_REF, rc=rc)  ! 2nd DE
</PRE>

<P>
Notice that it is perfectly fine to <EM>re</EM>-use <TT>farrayP</TT> for all
   allocations of DE-local Fortran arrays. The allocated memory can be 
   deallocated at the end using the array pointer contained in the 
   <TT>larrayList</TT>.

<P>
With this information an Array object can be created. The <TT>distgrid</TT>
   object indicates 2 DEs for each PET and ArrayCreate() expects to find two
   LocalArray elements in <TT>larrayList</TT>. 

<P>
<PRE>
  array = ESMF_ArrayCreate(larrayList=larrayList, distgrid=distgrid, rc=rc)
</PRE>

<P>
Usage of a LocalArray list is the only way to provide a list of variable 
   length of Fortran array allocations to ArrayCreate() for each PET. The 
   <TT>array</TT> object created by the above call is an ESMF distributed 
   object. As such it must follow the ESMF convention that requires that 
   the call to <TT>ESMF_ArrayCreate()</TT> must be issued in unison by all 
   PETs of the current context. Each PET only calls ArrayCreate() once, even if
   there are multiple DEs per PET.

<P>
The ArrayGet() method provides access to the list of LocalArrays on each PET. 

<P>
<PRE>
  allocate(larrayRefList(2))
  call ESMF_ArrayGet(array, larrayList=larrayRefList, rc=rc)
</PRE>

<P>
Finally, access to the actual Fortran pointers is done on a per DE basis.
   Generally each PET will loop over its DEs. 

<P>
<PRE>
  do de=1, 2
    call ESMF_LocalArrayGet(larrayRefList(de), farrayPtr, rc=rc)
    localSum = 0.
    do j=1, 2
      do i=1, 4
        localSum = localSum + farrayPtr(i, j)
      enddo
    enddo
    print *, "localSum=", localSum
  enddo
</PRE>

<P>
Note: If the VM associates multiple PEs with a PET the application writer 
   may decide to use OpenMP loop parallelization on the <TT>de</TT> loop.

<P>
Cleanup requires that the PET-local deallocations are done before the 
   pointers to the actual Fortran arrays are lost. Notice that <TT>larrayList</TT>
   is used to obtain the pointers used in the deallocate statement. Pointers
   obtained from the <TT>larrayRefList</TT>, while pointing to the same data, 
   <EM>cannot</EM> be used to deallocated the array allocations! 

<P>
<PRE>
  do de=1, 2
    call ESMF_LocalArrayGet(larrayList(de), farrayPtr, rc=rc)
    deallocate(farrayPtr)
    call ESMF_LocalArrayDestroy(larrayList(de), rc=rc)
  enddo
  deallocate(larrayList)
  deallocate(larrayRefList)
  call ESMF_ArrayDestroy(array, rc=rc)
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
With that ESMF can be shut down cleanly. 

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04052400000000000000">
20.2.4 Array creation with automatic memory allocation</A>
</H3>

<P>
The examples of the previous sections made the user responsible for 
   providing memory allocations for the PET-local regions of the Array object.
   The user was able to use any of the Fortran array methods or go through the
   <TT>ESMF_LocalArray</TT> interfaces to obtain memory allocations before
   passing them into ArrayCreate(). Alternatively, users may wish for ESMF to
   handle memory allocation of an Array object directly. The following example
   shows the interfaces that are available to the user to do just this.

<P>
To create an <TT>ESMF_Array</TT> object without providing an existing
   Fortran array or <TT>ESMF_LocalArray</TT> the <EM>type, kind and rank</EM>
   (tkr) of the Array must be specified in form of an <TT>ESMF_ArraySpec</TT>
   argument. Here a 2D Array of double precision real numbers is to be created: 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
Further an <TT>ESMF_DistGrid</TT> argument must be constructed that holds
   information about the entire domain (patchwork) and the decomposition into 
   DE-local exclusive
   regions. The following line creates a DistGrid for a 5x5 global LR domain 
   that is decomposed into 2 x 3 = 6 DEs. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
This is enough information to create a Array object with default settings. 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
The <TT>array</TT> object created by the above call is an ESMF distributed 
   object. As such it must follow the ESMF convention that requires that 
   the call to <TT>ESMF_ArrayCreate()</TT> must be issued in unison by all 
   PETs of the current context.

<P>
The index space covered by the Array object and the decomposition into 
   DE-local exclusive regions, as it is described by the DistGrid object,
   is illustrated in the following diagram. Each asterix (*) represents a single
   element.

<P>
<PRE>
   
    +---------------------------------------&gt; 2nd dimension
    |  (1,1)
    |    +-----------+-----------+------+
    |    | DE 0      | DE 2      | DE 4 |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    +-----------+-----------+------+
    |    |           |           |      |
    |    | DE 1      | DE 3      | DE 5 |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    +-----------+-----------+------+
    |                                 (5,5)
    v 
   1st dimension
</PRE>

<P>

<H3><A NAME="SECTION04052500000000000000">
20.2.5 Native language memory access</A>
</H3>

<P>
Access to the data held inside an ESMF Array object is provided through
   native language objects. Specifically, the <TT>farrayPtr</TT> argument returned
   by the <TT>ESMF_ArrayGet()</TT> method is a Fortran array pointer that can be
   used do access the PET-local data inside the Array object.

<P>
Many applications work in the 1 DE per PET mode, i.e. there is only
   a single DE on each PET. The Array class does not assume this special
   case, instead it supports multiple separate memory allocations on each PET.
   The number of such PET-local allocations is given by the <TT>localDeCount</TT>
   of the underlying DistGrid. Access to the DE-local memory allocations in this
   general case requires a loop over <TT>localDeCount</TT>. 

<P>
<PRE>
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
</PRE>

<P>
<PRE>
  do de=0, localDeCount-1
    call ESMF_ArrayGet(array, farrayPtr=myFarray, localDe=de, rc=rc)
</PRE>

<P>
<PRE>
    ! use myFarray to access local DE data
  enddo
</PRE>

<P>
The 1 DE per PET case is so common that the ESMF Array provides simplified
   support for it. In this case the <TT>ESMF_ArrayGet()</TT> can be called 
   without specifying <TT>localDe</TT> to access the unique PET-local
   <TT>farrayPtr</TT>. An error will be returned if <TT>localDe</TT> was omitted
   for an Array that holds multiple DEs per PET.

<P>
Besides direct access to the DE-local memory allocation through the 
   Fortran array pointer, the Array can also be queried for a list of PET-local
   LocalArray objects. See section <A HREF="node4.html#Array:LocalArray">20.2.3</A> for more on LocalArray
   usage in Array. In most cases this approach is less convenient than the direct
   <TT>farrayPtr</TT> method, because it adds an extra object level between the
   Array and the native language array. Further, the 1 DE per PET case is not
   treated in a simplified manner. 

<P>
<PRE>
  allocate(larrayList(localDeCount))
  call ESMF_ArrayGet(array, larrayList=larrayList, rc=rc)
</PRE>

<P>
<PRE>
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray, ESMF_DATA_REF, rc=rc)
</PRE>

<P>
<PRE>
    ! use myFarray to access local DE data
  enddo
</PRE>

<P>

<H3><A NAME="SECTION04052600000000000000"></A>
   <A NAME="Array_regions_and_default_bounds"></A>
<BR>
20.2.6 Regions and default bounds
</H3>

<P>
Each <TT>ESMF_Array</TT> object is decomposed into DEs as specified by the
   associated <TT>ESMF_DistGrid</TT> object. Each piece of this decomposition, i.e.
   each DE, holds a chunk of the Array data in its own local piece of memory.
   The details of the Array decomposition are described in the following 
   paragraphs.

<P>
At the center of the Array decomposition is the <TT>ESMF_DistGrid</TT> class.
   The DistGrid object specified during Array creation contains three essential
   pieces of information:
   
<UL>
<LI>The extent and topology of the global domain covered by the Array object
         in terms of indexed elements. The total extent may be a composition or 
         patchwork of smaller logically rectangular (LR) domain pieces or patches.
</LI>
<LI>The decomposition of the entire domain into "element exclusive" DE-local
         LR chunks. <EM>Element exclusive</EM> means that there is no element overlap
         between DE-local chunks. This, however, does not exclude degeneracies 
         on edge boundaries for certain topologies (e.g. bipolar).
</LI>
<LI>The layout of DEs over the available PETs and thus the distribution of
         the Array data.
   
</LI>
</UL>

<P>
Each element of an Array is associated with a <EM>single</EM> DE. The union of
   elements associated with a DE, as defined by the DistGrid above, corresponds
   to a LR chunk of index space, called the <EM>exclusive region</EM> of the DE.

<P>
There is a hierarchy of four regions that can be identified for each DE in an
   Array object. Their definition and relationship to each other is as follows:
   
<UL>
<LI><EM>Interior Region</EM>: Region that only contains local elements that are
         <EM>not</EM> mapped into the halo of any other DE. The shape and size of 
         this region for a particular DE depends non-locally on the halos defined
         by other DEs and may change during computation as halo operations are
         precomputed and released. Knowledge of the interior elements may be used
         to improve performance by overlapping communications with ongoing 
         computation for a DE.
</LI>
<LI><EM>Exclusive Region</EM>: Elements for which a DE claims exclusive
         ownership. Practically this means that the DE will be the sole source
         for these elements in halo and reduce operations. There are exceptions
         to this in some topologies. The exclusive region includes all elements
         of the interior region.
</LI>
<LI><EM>Computational Region</EM>: Region that can be set arbitrarily within
         the bounds of the total region (defined next). The typical use of the
         computation region is to define bounds that only include elements that
         are updated by a DE-local computation kernel. The computational region
         does not need to include all exclusive elements and it may also contain
         elements that lie outside the exclusive region.
</LI>
<LI><EM>Total (Memory) Region</EM>: Total of all DE-locally allocated elements.
         The size and shape of the total memory region must accommodate the
         union of exclusive and computational region but may contain 
         additional elements. Elements outside the exclusive region may overlap
         with the exclusive region of another DE which makes them potential 
         receivers for Array halo operations. Elements outside the exclusive
         region that do not overlap with the exclusive region of another DE
         can be used to set boundary conditions and/or serve as extra memory 
         padding.
   
</LI>
</UL>

<P>
<PRE>
  
     +-totalLBound(:)----------------------------------+
     |\                                                |
     | \ &lt;--- totalLWidth(:)                           |
     |  \                                              |
     |   +-computationalLBound(:)------------------+   |
     |   |\                                        |   |
     |   | \ &lt;--- computationalLWidth(:)           |   |
     |   |  \                                      |   |
     |   |   +-exclusiveLBound(:)-------------+    |   |
     |   |   |                                |    |   |
     |   |   |     +------+      +-----+      |    |   |
     |   |   |     |      |      |     |      |    |   |
     |   |   |     |      +------+     |      |    |   |
     |   |   |     | "Interior Region" |      |    |   |
     |   |   |     +-----+             |      |    |   |
     |   |   |           |             |      |    |   |
     |   |   |           +-------------+      |    |   |
     |   |   |                                |    |   |
     |   |   | "Exclusive Region"             |    |   |
     |   |   +-------------exclusiveUBound(:)-+    |   |
     |   |                                     \   |   |
     |   |           computationalUWidth(:) --&gt; \  |   |
     |   |                                       \ |   |
     |   | "Computational Region"                 \|   |
     |   +------------------computationalUBound(:)-+   |
     |                                              \  | 
     |                             totalUWidth(:) -&gt; \ | 
     | "Total Region"                                 \| 
     +--------------------------------- totalUBound(:)-+
</PRE>

<P>
With the following definitions:
   <PRE>
  
   computationalLWidth(:) = exclusiveLBound(:) - computationalLBound(:)
   computationalUWidth(:) = computationalUBound(:) - exclusiveUBound(:)
</PRE>
   and
   <PRE>
  
   totalLWidth(:) = exclusiveLBound(:) - totalLBound(:)
   totalUWidth(:) = totalUBound(:) - exclusiveUBound(:)
</PRE>

<P>
The <EM>exclusive region</EM> is determined during Array creation by the 
   DistGrid argument. Optional arguments may be used to specify the 
   <EM>computational region</EM> when the Array is created, by default it will be
   set equal to the exclusive region. The <EM>total region</EM>, i.e. the actual
   memory allocation for each DE, is also determined during Array creation. When
   creating the Array object from existing Fortran arrays the total region is
   set equal to the memory provided by the Fortran arrays. Otherwise the 
   default is to allocate as much memory as is needed to accommodate the union
   of the DE-local exclusive and computational region. Finally it is also
   possible to use optional arguments to the ArrayCreate() call to specify the
   total region of the object explicitly.

<P>
The <TT>ESMF_ArrayCreate()</TT> call checks that the input parameters are
   consistent and will result in an Array that fulfills all of the above 
   mentioned requirements for its DE-local regions.

<P>
Once an Array object has been created the exclusive and total regions are
   fixed. The computational region, however, may be adjusted within the limits
   of the total region using the <TT>ArraySet()</TT> call.

<P>
The <EM>interior region</EM> is very different from the other regions in that
   it cannot be specified. The <EM>interior region</EM> for each DE is a <EM>   consequence</EM> of the choices made for the other regions collectively across
   all DEs into which an Array object is decomposed. An Array object can be
   queried for its DE-local <EM>interior regions</EM> as to offer additional
   information to the user necessary to write more efficient code.
   
<P>
By default the bounds of each DE-local <EM>total region</EM> are defined as
   to put the start of the DE-local <EM>exclusive region</EM> at the "origin" of 
   the local index space, i.e. at <TT>(1, 1, ..., 1)</TT>. With that definition the
   following loop will access each element of the DE-local memory segment for
   each PET-local DE of the Array object used in the previous sections and
   print its content. 

<P>
<PRE>
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray, ESMF_DATA_REF, rc=rc)
    do i=1, size(myFarray, 1)
      do j=1, size(myFarray, 2)
        print *, "PET-local DE=", de, ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo
  enddo
</PRE>

<P>

<H3><A NAME="SECTION04052700000000000000">
20.2.7 Array bounds</A>
</H3>

<P>
The loop over Array elements at the end of the last section only works
   correctly because of the default definition of the <EM>computational</EM> and
   <EM>total regions</EM> used in the example. In general, without such specific
   knowledge about an Array object, it is necessary to use a more formal approach
   to access its regions with DE-local indices.

<P>
The DE-local <EM>exclusive region</EM> takes a central role in the definition
   of Array bounds. Even as the <EM>computational region</EM> may adjust during 
   the course of execution the <EM>exclusive region</EM> remains unchanged.
   The <EM>exclusive region</EM> provides a unique reference frame
   for the index space of all Arrays associated with the same DistGrid.

<P>
There is a choice between two indexing options that needs to be made during 
   Array creation. By default each DE-local exclusive region starts at 
   <TT>(1, 1, ..., 1)</TT>. However, for some computational kernels it may be more
   convenient to choose the index bounds of the DE-local exclusive regions to 
   match the index space coordinates as they are defined in the corresponding
   DistGrid object. The second option is only available if the DistGrid object 
   does not contain any non-contiguous decompositions (such as cyclically
   decomposed dimensions).

<P>
The following example code demonstrates the safe way of dereferencing the
   DE-local exclusive regions of the previously created <TT>array</TT> object.

<P>
<PRE>
  allocate(exclusiveUBound(2, localDeCount))  ! dimCount=2
  allocate(exclusiveLBound(2, localDeCount))  ! dimCount=2
  call ESMF_ArrayGet(array, indexflag=indexflag, &amp;
    exclusiveLBound=exclusiveLBound, exclusiveUBound=exclusiveUBound, rc=rc)
  if (indexflag == ESMF_INDEX_DELOCAL) then
    ! this is the default
!    print *, "DE-local exclusive regions start at (1,1)"
    do de=1, localDeCount
      call ESMF_LocalArrayGet(larrayList(de), myFarray, ESMF_DATA_REF, rc=rc)
      do i=1, exclusiveUBound(1, de)
        do j=1, exclusiveUBound(2, de)
!          print *, "DE-local exclusive region for PET-local DE=", de, &amp;
!            ": array(",i,",",j,")=", myFarray(i,j)
        enddo
      enddo
    enddo
  else if (indexflag == ESMF_INDEX_GLOBAL) then
    ! only if set during ESMF_ArrayCreate()
!    print *, "DE-local exclusive regions of this Array have global bounds"
    do de=1, localDeCount
      call ESMF_LocalArrayGet(larrayList(de), myFarray, ESMF_DATA_REF, rc=rc)
      do i=exclusiveLBound(1, de), exclusiveUBound(1, de)
        do j=exclusiveLBound(2, de), exclusiveUBound(2, de)
!          print *, "DE-local exclusive region for PET-local DE=", de, &amp;
!            ": array(",i,",",j,")=", myFarray(i,j)
        enddo
      enddo
    enddo
  endif
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the array object
</PRE>

<P>
Obviously the second branch of this simple code will work for either case, 
   however, if a complex computational kernel was written assuming 
   <TT>ESMF_INDEX_DELOCAL</TT> type bounds the second branch would simply be 
   used to indicate the problem and bail out.

<P>
The advantage of the <TT>ESMF_INDEX_GLOBAL</TT> index option is that
   the Array bounds directly contain information on where the DE-local
   Array piece is located in a global index space sense. When the
   <TT>ESMF_INDEX_DELOCAL</TT> option is used the correspondence between local
   and global index space must be made by querying the associated DistGrid for
   the DE-local <TT>indexList</TT> arguments.

<P>

<H3><A NAME="SECTION04052800000000000000"></A>
   <A NAME="Array:padding"></A>
<BR>
20.2.8 Computational region and extra elements for halo or padding
</H3>

<P>
In the previous examples the computational region of <TT>array</TT> was chosen 
   by default to be identical to the exclusive region defined by the DistGrid
   argument during Array creation. In the following the same <TT>arrayspec</TT> and
   <TT>distgrid</TT> objects as before will be used to create an Array but now a 
   larger computational region shall be defined around each DE-local exclusive 
   region. Furthermore, extra space will be defined around the computational
   region of each DE to accommodate a halo and/or serve as memory padding.

<P>
In this example the <TT>indexflag</TT> argument is set to 
   <TT>ESMF_INDEX_GLOBAL</TT> indicating that the bounds of the exclusive region
   correspond to the index space coordinates as they are defined by the DistGrid
   object.

<P>
The same <TT>arrayspec</TT> and <TT>distgrid</TT> objects as before are used
   which also allows the reuse of the already allocated <TT>larrayList</TT>
   variable. 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    computationalLWidth=(/0,3/), computationalUWidth=(/1,1/), &amp;
    totalLWidth=(/1,4/), totalUWidth=(/3,1/), &amp;
    indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
Obtain the <TT>larrayList</TT> on every PET. 

<P>
<PRE>
  allocate(localDeList(localDeCount))
  call ESMF_ArrayGet(array, larrayList=larrayList, localDeList=localDeList, &amp;
    rc=rc)
</PRE>

<P>
The bounds of DE 1 for <TT>array</TT> are shown in the following 
   diagram to illustrate the situation. Notice that the <TT>totalLWidth</TT> and
   <TT>totalUWidth</TT> arguments in the ArrayCreate() call define the total region 
   with respect to the exclusive region given for each DE by the <TT>distgrid</TT> 
   argument.

<P>
<PRE>
        +-(3,-3)---------------------------------+ 
        |\                                       | 
        | +-(4,-2)-+-(4,1)--------------------+--+ 
        | |        |                          |  | 
        | |        |                          |  | 
        | |        |          DE 1            |  | 
        | |        |                          |  | 
        | |        |                          |  | 
        | |        | Exclusive Region         |  | 
        | |        +--------------------(5,2)-+  | 
        | | Computational Region                 | 
        | +-------------------------------(6,3)--+ 
        |                                        | 
        | Total Region                           | 
        +---------------------------------(8,3)--+
</PRE>

<P>
When working with this <TT>array</TT> it is possible for the computational
   kernel to overstep the exclusive region for both read/write access 
   (computational region) and potentially read-only access into the total region
   outside of the computational region, if a halo operation provides valid 
   entries for these elements. 

<P>
The Array object can be queried for absolute <EM>bounds</EM> 

<P>
<PRE>
  allocate(computationalLBound(2, localDeCount))  ! dimCount=2
  allocate(computationalUBound(2, localDeCount))  ! dimCount=2
  allocate(totalLBound(2, localDeCount))          ! dimCount=2
  allocate(totalUBound(2, localDeCount))          ! dimCount=2
  call ESMF_ArrayGet(array, exclusiveLBound=exclusiveLBound, &amp;
    exclusiveUBound=exclusiveUBound, computationalLBound=computationalLBound, &amp;
    computationalUBound=computationalUBound, totalLBound=totalLBound, &amp;
    totalUBound=totalUBound, rc=rc)
</PRE>

<P>
or for the relative <EM>widths</EM>. 

<P>
<PRE>
  allocate(computationalLWidth(2, localDeCount))  ! dimCount=2
  allocate(computationalUWidth(2, localDeCount))  ! dimCount=2
  allocate(totalLWidth(2, localDeCount))          ! dimCount=2
  allocate(totalUWidth(2, localDeCount))          ! dimCount=2
  call ESMF_ArrayGet(array, computationalLWidth=computationalLWidth, &amp;
    computationalUWidth=computationalUWidth, totalLWidth=totalLWidth, &amp;
    totalUWidth=totalUWidth, rc=rc)
</PRE>

<P>
Either way the dereferencing of Array data is centered around the DE-local
   exclusive region: 

<P>
<PRE>
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray, ESMF_DATA_REF, rc=rc)
    ! initialize the DE-local array
    myFarray = 0.1d0 * localDeList(de)
    ! first time through the total region of array    
!    print *, "myFarray bounds for DE=", localDeList(de), lbound(myFarray), &amp;
!      ubound(myFarray)
    do j=exclusiveLBound(2, de), exclusiveUBound(2, de)
      do i=exclusiveLBound(1, de), exclusiveUBound(1, de)
!        print *, "Excl region DE=", localDeList(de), ": array(",i,",",j,")=", &amp;
!          myFarray(i,j)
      enddo
    enddo
    do j=computationalLBound(2, de), computationalUBound(2, de)
      do i=computationalLBound(1, de), computationalUBound(1, de)
!        print *, "Excl region DE=", localDeList(de), ": array(",i,",",j,")=", &amp;
!          myFarray(i,j)
      enddo
    enddo
    do j=totalLBound(2, de), totalUBound(2, de)
      do i=totalLBound(1, de), totalUBound(1, de)
!        print *, "Total region DE=", localDeList(de), ": array(",i,",",j,")=", &amp;
!          myFarray(i,j)
      enddo
    enddo

    ! second time through the total region of array    
    do j=exclusiveLBound(2, de)-totalLWidth(2, de), &amp;
      exclusiveUBound(2, de)+totalUWidth(2, de)
      do i=exclusiveLBound(1, de)-totalLWidth(1, de), &amp;
        exclusiveUBound(1, de)+totalUWidth(1, de)
!        print *, "Excl region DE=", localDeList(de), ": array(",i,",",j,")=", &amp;
!          myFarray(i,j)
      enddo
    enddo
  enddo
</PRE>

<P>

<H3><A NAME="SECTION04052900000000000000">
20.2.9 1D and 3D Arrays</A>
</H3>

<P>
All previous examples were written for the 2D case. There is, however, no
   restriction within the Array or DistGrid class that limits the dimensionality
   of Array objects beyond the language specific limitations (7D for Fortran). 

<P>
In order to create an <TT>n</TT>-dimensional Array the rank indicated by both
   the <TT>arrayspec</TT> and the <TT>distgrid</TT> arguments specified during Array
   create must be equal to <TT>n</TT>. A 1D Array of double precision real data
   hence requires the following <TT>arrayspec</TT>. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=1, rc=rc)
</PRE>

<P>
The index space covered by the Array and the decomposition description is
   provided to the Array create method by the <TT>distgrid</TT> argument. The index
   space in this example has 16 elements and covers the interval <IMG
 WIDTH="58" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img40.png"
 ALT="$[-10, 5]$">. It is 
   decomposed into as many DEs as there are PETs in the current context. 

<P>
<PRE>
  distgrid1D = ESMF_DistGridCreate(minIndex=(/-10/), maxIndex=(/5/), &amp;
    regDecomp=(/petCount/), rc=rc)
</PRE>

<P>
A 1D Array object with default regions can now be created. 

<P>
<PRE>
  array1D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid1D, rc=rc)
</PRE>

<P>
The creation of a 3D Array proceeds analogous to the 1D case. The rank of the
   <TT>arrayspec</TT> must be changed to 3 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
</PRE>

<P>
and an appropriate 3D DistGrid object must be created 

<P>
<PRE>
  distgrid3D = ESMF_DistGridCreate(minIndex=(/1,1,1/), maxIndex=(/16,16,16/), &amp;
    regDecomp=(/4,4,4/), rc=rc)
</PRE>

<P>
before an Array object can be created. 

<P>
<PRE>
  array3D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid3D, rc=rc)
</PRE>

<P>
The <TT>distgrid3D</TT> object decomposes the 3-dimensional index space into
   <!-- MATH
 $4\times 4\times 4 = 64$
 -->
<IMG
 WIDTH="106" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$4\times 4\times 4 = 64$"> DEs. These DEs are laid out across the computational
   resources (PETs) of the current component according to a default DELayout that
   is created during the DistGrid create call. Notice that in the index space 
   proposal a DELayout does not have a sense of dimensionality. The DELayout
   function is simply to map DEs to PETs. The DistGrid maps chunks of index space
   against DEs and thus its rank is equal to the number of index space 
   dimensions.

<P>
The previously defined DistGrid and the derived Array object decompose 
   the index space along all three dimension. It is, however, not a requirement
   that the decomposition be along all dimensions. An Array with the same 3D
   index space could as well be decomposed along just one or along two of the
   dimensions. The following example shows how for the same index space only the
   last two dimensions are decomposed while the first Array dimension has full
   extent on all DEs. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array3D, rc=rc)
  call ESMF_DistGridDestroy(distgrid3D, rc=rc)
  distgrid3D = ESMF_DistGridCreate(minIndex=(/1,1,1/), maxIndex=(/16,16,16/), &amp;
    regDecomp=(/1,4,4/), rc=rc)
  array3D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid3D, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040521000000000000000">
20.2.10 Working with Arrays of different rank</A>
</H3>
   Assume a computational kernel that involves the <TT>array3D</TT> object as it was
   created at the end of the previous section. Assume further that the kernel 
   also involves a 2D Array on a 16x16 index space where each point (j,k) was
   interacting with each (i,j,k) column of the 3D Array. An efficient formulation
   would require that the decomposition of the 2D Array must match that of the 3D
   Array and further the DELayout be identical. The following code shows how this
   can be accomplished. 

<P>
<PRE>
  call ESMF_DistGridGet(distgrid3D, delayout=delayout, rc=rc) ! get DELayout
  distgrid2D = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/16,16/), &amp;
    regDecomp=(/4,4/), delayout=delayout, rc=rc)
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
  array2D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid2D, rc=rc)
</PRE>

<P>
Now the following kernel is sure to work with <TT>array3D</TT> and <TT>array2D</TT>. 

<P>
<PRE>
  call ESMF_DELayoutGet(delayout, localDeCount=localDeCount, rc=rc)
  allocate(larrayList1(localDeCount))
  call ESMF_ArrayGet(array3D, larrayList=larrayList1, rc=rc)
  allocate(larrayList2(localDeCount))
  call ESMF_ArrayGet(array2D, larrayList=larrayList2, rc=rc)
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList1(de), myFarray3D, ESMF_DATA_REF, &amp;
      rc=rc)
    myFarray3D = 0.1d0 * de ! initialize
    call ESMF_LocalArrayGet(larrayList2(de), myFarray2D, ESMF_DATA_REF, &amp;
      rc=rc)
    myFarray2D = 0.5d0 * de ! initialize
    do k=1, 4
      do j=1, 4
        dummySum = 0.d0
        do i=1, 16
          dummySum = dummySum + myFarray3D(i,j,k) ! sum up the (j,k) column
        enddo
        dummySum = dummySum * myFarray2D(j,k) ! multiply with local 2D element
!        print *, "dummySum(",j,k,")=",dummySum
      enddo
    enddo
  enddo
</PRE>

<P>

<H3><A NAME="SECTION040521100000000000000">
20.2.11 Array and DistGrid rank - 2D+1 Arrays</A>
</H3>

<P>
Except for the special Array create interface that implements a copy from
   an existing Array object all other Array create interfaces require the 
   specification of at least two arguments: <TT>farray</TT> and <TT>distgrid</TT>,
   <TT>larrayList</TT> and <TT>distgrid</TT>, or <TT>arrayspec</TT> and <TT>distgrid</TT>.
   In all these cases both required arguments contain a sense of dimensionality.
   The relationship between these two arguments deserves extra attention.

<P>
The first argument, <TT>farray</TT>, <TT>larrayList</TT> or <TT>arrayspec</TT>, 
   determines the rank of the created Array object, i.e. the dimensionality
   of the actual data storage. The rank of a native language array, extracted 
   from an Array object, is equal to the rank specified by either of these
   arguments. So is the <TT>rank</TT> that is returned by the <TT>ESMF_ArrayGet()</TT>
   call.

<P>
The rank specification contained in the <TT>distgrid</TT> argument, which is of 
   type <TT>ESMF_DistGrid</TT>, on the other hand has no affect on the 
   rank of the Array. The <TT>dimCount</TT> specified by the DistGrid object,
   which may be equal, greater or less than the Array rank, determines the 
   dimensionality of the <EM>decomposition</EM>.

<P>
While there is no constraint between DistGrid <TT>dimCount</TT> and Array
   <TT>rank</TT>, there is an important relationship between the two, resulting in
   the concept of index space dimensionality. Array dimensions can be
   arbitrarily mapped against DistGrid dimension, rendering them <EM>decomposed</EM>
   dimensions. The index space dimensionality is equal to the number of 
   decomposed Array dimensions.

<P>
Array dimensions that are not mapped to DistGrid dimensions are the 
   <EM>undistributed</EM> dimensions of the Array. They are not part
   of the index space. The mapping is specified during <TT>ESMF_ArrayCreate()</TT>
   via the <TT>distgridToArrayMap</TT> argument. DistGrid dimensions that have
   not been associated with Array dimensions are <EM>replicating</EM> dimensions.
   The Array will be replicated across the DEs that lie along replication
   DistGrid dimensions.

<P>
Undistributed Array dimensions can be used to store multi-dimensional data for
   each Array index space element. One application of this is to store the 
   components of a vector quantity in a single Array. The same 2D <TT>distgrid</TT>
   object as before will be used. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
The rank in the <TT>arrayspec</TT> argument, however, must change from 2 to 3 in
   order to provide for the extra Array dimension. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
</PRE>

<P>
During Array creation with extra dimension(s) it is necessary to specify the
   bounds of these undistributed dimension(s). This requires two additional
   arguments, <TT>undistLBound</TT> and <TT>undistUBound</TT>, which are vectors in 
   order to accommodate multiple undistributed dimensions. The other arguments
   remain unchanged and apply across all undistributed components. 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    totalLWidth=(/0,1/), totalUWidth=(/0,1/), &amp;
    undistLBound=(/1/), undistUBound=(/2/), rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT)
</PRE>

<P>
This will create <TT>array</TT> with 2+1 dimensions. The 2D DistGrid is used
   to describe decomposition into DEs with 2 Array dimensions mapped to the 
   DistGrid dimensions resulting in a 2D index space. The extra Array dimension
   provides storage for multi component user data within the Array object.

<P>
By default the <TT>distgrid</TT> dimensions are associated
   with the first Array dimensions in sequence. For the example above this means
   that the first 2 Array dimensions are decomposed according to the provided 2D
   DistGrid. The 3rd Array dimension does not have an associated DistGrid
   dimension, rendering it an undistributed Array dimension.

<P>
Native language access to an Array with undistributed dimensions is in
   principle the same as without extra dimensions. 

<P>
<PRE>
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
  allocate(larrayList(localDeCount))
  call ESMF_ArrayGet(array, larrayList=larrayList, rc=rc)
</PRE>

<P>
The following loop shows how a Fortran pointer to the DE-local data chunks
   can be obtained and used to set data values in the exclusive regions. The
   <TT>myFarray3D</TT> variable must be of rank 3 to match the Array rank of
   <TT>array</TT>. However, variables such as <TT>exclusiveUBound</TT> that store the
   information about the decomposition, remain to be allocated for the 2D 
   index space. 

<P>
<PRE>
  call ESMF_ArrayGet(array, exclusiveLBound=exclusiveLBound, &amp;
    exclusiveUBound=exclusiveUBound, rc=rc)
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray3D, ESMF_DATA_REF, rc=rc)
    myFarray3D = 0.0 ! initialize
    myFarray3D(exclusiveLBound(1,de):exclusiveUBound(1,de), &amp;
      exclusiveLBound(2,de):exclusiveUBound(2,de), 1) = 5.1 ! dummy assignment
    myFarray3D(exclusiveLBound(1,de):exclusiveUBound(1,de), &amp;
      exclusiveLBound(2,de):exclusiveUBound(2,de), 2) = 2.5 ! dummy assignment
  enddo
  deallocate(larrayList)
</PRE>

<P>
For some applications the default association rules between DistGrid and Array
   dimensions may not satisfy the user's needs. The optional <TT>distgridToArrayMap</TT> 
   argument can be used during Array creation to explicitly specify the mapping 
   between DistGrid and Array dimensions. To demonstrate this the following lines
   of code reproduce the above example but with rearranged dimensions. Here the
   <TT>distgridToArrayMap</TT> argument is a list with two elements corresponding to
   the DistGrid <TT>dimCount</TT> of 2. The first element indicates which Array
   dimension the first DistGrid dimension is mapped against. Here the
   1st DistGrid dimension maps against the 3rd Array dimension and the 2nd 
   DistGrid dimension maps against the 1st Array dimension. This leaves the 2nd
   Array dimension to be the extra and undistributed dimension in the resulting
   Array object. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/3, 1/), totalLWidth=(/0,1/), totalUWidth=(/0,1/), &amp;
    undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
Operations on the Array object as a whole are unchanged by the different
   mapping of dimensions.

<P>
When working with Arrays that contain explicitly mapped Array and DistGrid 
   dimensions it is critical to know the order in which the entries of
   <EM>width</EM> and <EM>bound</EM> arguments that are associated with distributed
   Array dimensions are specified. The size of these arguments is equal to the
   DistGrid <TT>dimCount</TT>, because the maximum number of distributed Array
   dimensions is given by the dimensionality of the index space.

<P>
The order of dimensions in these arguments, however, is <EM>not</EM> that of
   the associated DistGrid. Instead each entry corresponds to the distributed
   Array dimensions in sequence. In the example above the entries in 
   <TT>totalLWidth</TT> and <TT>totalUWidth</TT> correspond to Array dimensions 1 and
   3 in this sequence. 

<P>
The <TT>distgridToArrrayMap</TT> argument optionally provided during Array create
   indicates how the DistGrid dimensions map to Array dimensions. The inverse
   mapping, i.e. Array to DistGrid dimensions, is just as important. The 
   <TT>ESMF_ArrayGet()</TT> call offers both mappings as <TT>distgridToArrrayMap</TT>
   and <TT>arrayToDistGridMap</TT>, respectively. The number of elements in 
   <TT>arrayToDistGridMap</TT> is equal to the rank of the Array. Each element
   corresponds to an Array dimension and indicates the associated DistGrid
   dimension by an integer number. An entry of "0" in <TT>arrayToDistGridMap</TT>
   indicates that the corresponding Array dimension is undistributed.

<P>
Correct understanding about the association between Array and DistGrid
   dimensions becomes critical for correct data access into the Array. 

<P>
<PRE>
  allocate(arrayToDistGridMap(3))  ! arrayRank = 3
  call ESMF_ArrayGet(array, arrayToDistGridMap=arrayToDistGridMap, &amp;
    exclusiveLBound=exclusiveLBound, exclusiveUBound=exclusiveUBound, &amp;
    localDeCount=localDeCount, rc=rc)  
  if (arrayToDistGridMap(2) /= 0) then   ! check if extra dimension at expected index
    ! indicate problem and bail out
  endif
  ! obtain larrayList for local DEs
  allocate(larrayList(localDeCount))
  call ESMF_ArrayGet(array, larrayList=larrayList, rc=rc)
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray3D, ESMF_DATA_REF, rc=rc)
    myFarray3D(exclusiveLBound(1,de):exclusiveUBound(1,de), &amp;
      1, exclusiveLBound(2,de):exclusiveUBound(2,de)) = 10.5 ! dummy assignment
    myFarray3D(exclusiveLBound(1,de):exclusiveUBound(1,de), &amp;
      2, exclusiveLBound(2,de):exclusiveUBound(2,de)) = 23.3 ! dummy assignment
  enddo
  deallocate(exclusiveLBound, exclusiveUBound)
  deallocate(arrayToDistGridMap)
  deallocate(larrayList)
  call ESMF_ArrayDestroy(array, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION040521200000000000000">
20.2.12 Arrays with replicated dimensions</A>
</H3>

<P>
Thus far most examples demonstrated cases where the DistGrid <TT>dimCount</TT>
   was equal to the Array <TT>rank</TT>. The previous section introduced the
   concept of Array <EM>tensor</EM> dimensions when <TT>dimCount &lt; rank</TT>. In this
   section <TT>dimCount</TT> and <TT>rank</TT> are assumed completely unconstrained and
   the relationship to <TT>distgridToArrayMap</TT> and <TT>arrayToDistGridMap</TT> will
   be discussed.

<P>
The Array class allows completely arbitrary mapping between Array and
   DistGrid dimensions. Most cases considered in the previous sections used
   the default mapping which assigns the DistGrid dimensions in sequence to the
   lower Array dimensions. Extra Array dimensions, if present, are considered
   non-distributed tensor dimensions for which the optional <TT>undistLBound</TT>
   and <TT>undistUBound</TT> arguments must be specified.

<P>
The optional <TT>distgridToArrayMap</TT> argument provides the option to override
   the default DistGrid to Array dimension mapping. The entries of the
   <TT>distgridToArrayMap</TT> array correspond to the DistGrid dimensions in
   sequence and assign a unique Array dimension to each DistGrid dimension.
   DistGrid and Array dimensions are indexed starting at <TT>1</TT> for the lowest
   dimension. A value of <TT>"0"</TT> in the <TT>distgridToArrayMap</TT> array 
   indicates that the respective DistGrid dimension is <EM>not</EM> mapped against
   any Array dimension. What this means is that the Array will be replicated 
   along this DistGrid dimension.

<P>
As a first example consider the case where a 1D Array 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=1, rc=rc)
</PRE>

<P>
is created on the 2D DistGrid used during the previous section. 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
Here the default DistGrid to Array dimension mapping is used which assigns
   the Array dimensions in sequence to the DistGrid dimensions starting with
   dimension "1". Extra DistGrid dimensions are considered replicator dimensions
   because the Array will be replicated along those dimensions. In the above
   example the 2nd DistGrid dimension will cause 1D Array pieces to be
   replicated along the DEs of the 2nd DistGrid dimension. Replication in the
   context of <TT>ESMF_ArrayCreate()</TT> does not mean that data values are
   communicated and replicated between different DEs, but it means that different
   DEs provide memory allocations for <EM>identical</EM> exclusive elements.

<P>
Access to the data storage of an Array that has been replicated along 
   DistGrid dimensions is the same as for Arrays without replication. 

<P>
<PRE>
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
</PRE>

<P>
<PRE>
  allocate(larrayList(localDeCount))
  allocate(localDeList(localDeCount))
  call ESMF_ArrayGet(array, larrayList=larrayList, localDeList=localDeList, &amp;
    rc=rc)
</PRE>

<P>
The <TT>array</TT> object was created without additional padding which means
   that the bounds of the Fortran array pointer correspond to the bounds of
   the exclusive region. The following loop will cycle through all local DEs, 
   print the DE number as well as the Fortran array pointer bounds. The bounds
   should be:
   <PRE>
            lbound       ubound
  
   DE 0:      1            3         --+
   DE 2:      1            3         --|  1st replication set
   DE 4:      1            3         --+
  
   DE 1:      1            2         --+
   DE 3:      1            2         --|  2nd replication set
   DE 5:      1            2         --+
</PRE> 

<P>
<PRE>
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray1D, ESMF_DATA_REF, &amp;
      rc=rc)
</PRE>

<P>
<PRE>
    print *, "DE ",localDeList(de)," [", lbound(myFarray1D), &amp;
      ubound(myFarray1D),"]"
  enddo
  deallocate(larrayList)
  deallocate(localDeList)
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
The Fortran array pointer in the above loop was of rank 1 because the
   Array object was of rank 1. However, the <TT>distgrid</TT> object associated
   with <TT>array</TT> is 2-dimensional! Consequently DistGrid based information
   queried from <TT>array</TT> will be 2D. The <TT>distgridToArrayMap</TT> and
   <TT>arrayToDistGridMap</TT>
   arrays provide the necessary mapping to correctly associate DistGrid based 
   information with Array dimensions.

<P>
The next example creates a 2D Array 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
on the previously used 2D DistGrid. By default, i.e. without the
   <TT>distgridToArrayMap</TT>
   argument, both DistGrid dimensions would be associated with the two Array
   dimensions. However, the <TT>distgridToArrayMap</TT> specified in the following
   call will only associate the second DistGrid dimension with the first Array 
   dimension. This will render the first DistGrid dimension a replicator
   dimension and the second Array dimension a tensor dimension for which 1D
   <TT>undistLBound</TT> and <TT>undistUBound</TT> arguments must be supplied. 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/0,1/), undistLBound=(/11/), undistUBound=(/14/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
Finally, the same <TT>arrayspec</TT> and <TT>distgrid</TT> arguments are used to
   create a 2D Array that is fully replicated in both dimensions of the DistGrid.
   Both Array dimensions are now tensor dimensions and both DistGrid dimensions
   are replicator dimensions. 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/0,0/), undistLBound=(/11,21/), undistUBound=(/14,22/), &amp;
    rc=rc)
</PRE>

<P>
The result will be an Array with local lower bound (/11,21/) and upper bound
   (/14,22/) on all 6 DEs of the DistGrid. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
Replicated Arrays can also be created from existing local Fortran arrays.
   The following Fortran array allocation will provide a 3 x 10 array on each
   PET.  

<P>
<PRE>
  allocate(myFarray2D(3,10))
</PRE>

<P>
Assuming a petCount of 4 the following DistGrid defines a 2D index space
   that is distributed across the PETs along the first dimension. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
The following call creates an Array object on the above distgrid using
   the locally existing <TT>myFarray2D</TT> Fortran arrays. The difference 
   compared to the case with automatic memory allocation is that instead of
   <TT>arrayspec</TT> the Fortran array is provided as argument. Furthermore,
   the <TT>undistLBound</TT> and <TT>undistUBound</TT> arguments can be omitted,
   defaulting into Array tensor dimension lower bound of 1 and an upper
   bound equal to the size of the respective Fortran array dimension. 

<P>
<PRE>
  array = ESMF_ArrayCreate(farray=myFarray2D, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, distgridToArrayMap=(/0,2/), rc=rc)
</PRE>

<P>
The <TT>array</TT> object associates the 2nd DistGrid dimension with the 2nd
   Array dimension. The first DistGrid dimension is not associated with any
   Array dimension and will lead to replication of the Array along the DEs of
   this direction. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040521300000000000000"></A>
   <A NAME="Array:ScatterGather"></A>
<BR>
20.2.13 Communication - Scatter and Gather
</H3>

<P>
It is a common situation, particularly in legacy code, that an ESMF Array
   object must be filled with data originating from a large Fortran array stored
   on a single PET. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(farray(10,20,30))
    do k=1, 30
      do j=1, 20
        do i=1, 10
          farray(i, j, k) = k*1000 + j*100 +  i
        enddo
      enddo
    enddo
  endif
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1,1/), maxIndex=(/10,20,30/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=3, rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
The <TT>ESMF_ArrayScatter()</TT> method provides a convenient way of scattering
   array data from a single root PET across the DEs of an ESMF Array object. 

<P>
<PRE>
  call ESMF_ArrayScatter(array, farray=farray, rootPet=0, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    deallocate(farray)
  endif
</PRE>

<P>
The destination of the ArrayScatter() operation are all the DEs of a single
   patch. For multi-patch Arrays the destination patch can be specified. The 
   shape of the scattered Fortran array must match the shape of the destination
   patch in the ESMF Array.

<P>
Gathering data decomposed and distributed across the DEs of an ESMF Array
   object into a single Fortran array on root PET is accomplished by calling
   <TT>ESMF_ArrayGather()</TT>. 

<P>
<PRE>
  if (localPet == 3) then
    allocate(farray(10,20,30))
  endif
  
  call ESMF_ArrayGather(array, farray=farray, rootPet=3, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 3) then
    deallocate(farray)
  endif
</PRE>

<P>
The source of the ArrayGather() operation are all the DEs of a single
   patch. For multi-patch Arrays the source patch can be specified. The 
   shape of the gathered Fortran array must match the shape of the source
   patch in the ESMF Array. 

<P>
The <TT>ESMF_ArrayScatter()</TT> operation allows to fill entire replicated
   Array objects with data coming from a single root PET. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/0,0/), undistLBound=(/11,21/), undistUBound=(/14,22/), &amp;
    rc=rc)
</PRE>

<P>
The shape of the Fortran source array used in the Scatter() call must be
   that of the contracted Array, i.e. contracted DistGrid dimensions do not
   count. For the <TT>array</TT> just created this means that the source array
   on <TT>rootPet</TT> must be of shape 4 x 2. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(myFarray2D(4,2))
    do j=1,2
      do i=1,4
        myFarray2D(i,j) = i * 100.d0 + j * 1.2345d0 ! initialize
      enddo
    enddo
  endif
  
  call ESMF_ArrayScatter(array, farray=myFarray2D, rootPet=0, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    deallocate(myFarray2D)
  endif
</PRE>

<P>
This will have filled each local 4 x 2 Array piece with the replicated
   data of <TT>myFarray2D</TT>. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
As a second example for the use of Scatter() and Gather() consider the
   following replicated Array created from existing local Fortran arrays. 

<P>
<PRE>
  allocate(myFarray2D(3,10))
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(farray=myFarray2D, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, distgridToArrayMap=(/0,2/), rc=rc)
</PRE>

<P>
The <TT>array</TT> object associates the 2nd DistGrid dimension with the 2nd
   Array dimension. The first DistGrid dimension is not associated with any
   Array dimension and will lead to replication of the Array along the DEs of
   this direction. Still, the local arrays that comprise the <TT>array</TT> 
   object refer to independent pieces of memory and can be initialized 
   independently. 

<P>
<PRE>
  myFarray2D = localPet ! initialize
</PRE>

<P>
However, the notion of replication becomes visible when an array of shape
   3 x 10 on root PET 0 is scattered across the Array object. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(myFarray2D2(5:7,11:20))
  
    do j=11,20
      do i=5,7
        myFarray2D2(i,j) = i * 100.d0 + j * 1.2345d0 ! initialize
      enddo
    enddo
  endif
  
  call ESMF_ArrayScatter(array, farray=myFarray2D2, rootPet=0, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    deallocate(myFarray2D2)
  endif
</PRE>

<P>
The Array pieces on every DE will receive the same source data, resulting
   in a replication of data along DistGrid dimension 1. 

<P>
When the inverse operation, i.e. <TT>ESMF_ArrayGather()</TT>, is applied to
   a replicated Array an intrinsic ambiguity needs to be considered. ESMF 
   defines the gathering of data of a replicated Array as the collection of data
   originating from the numerically higher DEs. This means that data in
   replicated elements associated with numerically lower DEs will be ignored
   during <TT>ESMF_ArrayGather()</TT>. For the current example this means that
   changing the Array contents on PET 1, which here corresponds to DE 1, 

<P>
<PRE>
  if (localPet == 1) then
    myFarray2D = real(1.2345, ESMF_KIND_R8)
  endif
</PRE>

<P>
will <EM>not</EM> affect the result of 

<P>
<PRE>
  allocate(myFarray2D2(3,10))
  myFarray2D2 = 0.d0    ! initialize to a known value
  call ESMF_ArrayGather(array, farray=myFarray2D2, rootPet=0, rc=rc)
</PRE>

<P>
The result remains completely defined by the unmodified values of Array in 
   DE 3, the numerically highest DE. However, overriding the DE-local Array
   piece on DE 3 

<P>
<PRE>
  if (localPet==3) then
    myFarray2D = real(5.4321, ESMF_KIND_R8)
  endif
</PRE>

<P>
will change the outcome of 

<P>
<PRE>
  call ESMF_ArrayGather(array, farray=myFarray2D2, rootPet=0, rc=rc)
</PRE>

<P>
as expected. 

<P>
<PRE>
  deallocate(myFarray2D2)

  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040521400000000000000"></A>
   <A NAME="Array:Halo"></A>
<BR>
20.2.14 Communication - Halo
</H3>

<P>
One of the most fundamental communication pattern in domain decomposition
   codes is the <EM>halo</EM> operation. The ESMF Array class supports halos
   by allowing memory for extra elements to be allocated on each DE. See
   sections <A HREF="node4.html#Array:fpadding">20.2.2</A> and <A HREF="node4.html#Array:padding">20.2.8</A> for examples and
   details on how to create an Array with extra DE-local elements.

<P>
Here we consider an Array object that is created on a DistGrid that 
   defines a 10 x 20 index space, decomposed into 4 DEs using a regular
   2 x 2 decomposition. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/2,2/), rc=rc)
</PRE>

<P>
The Array holds 2D double precision float data. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
The <TT>totalLWidth</TT> and <TT>totalUWidth</TT> arguments are used during Array
   creation to allocate 2 extra elements along every direction outside the 
   exclusive region defined by the DistGrid for every DE. (The <TT>indexflag</TT>
   set to <TT>ESMF_INDEX_GLOBAL</TT> in this example does not affect the halo
   behavior of Array. The setting is simply more convenient for the following
   code.) 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    totalLWidth=(/2,2/), totalUWidth=(/2,2/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    rc=rc)
</PRE>

<P>
Without the explicit definition of boundary conditions in the DistGrid
   the following inner connections are defined.

<P>
<PRE>
   
            +-------------------+       +-------------------+
            | \       2       / |       | \       2       / |
            |  +-------------+  |       |  +-------------+  |
            |  |     DE 0    |  |       |  |     DE 2    |  |
            |  |             |  |       |  |             |  |
            |2 |    5 x 10   | 2|  &lt;-&gt;  |2 |    5 x 10   | 2|
            |  |             |  |       |  |             |  |
            |  |             |  |       |  |             |  |
            |  +-------------+  |       |  +-------------+  |
            | /       2       \ |       | /       2       \ |
            +-------------------+       +-------------------+
  
                      ^            \/             ^
                      |            /\             |
                      v                           v
  
            +-------------------+       +-------------------+
            | \       2       / |       | \       2       / |
            |  +-------------+  |       |  +-------------+  |
            |  |     DE 1    |  |       |  |     DE 3    |  |
            |  |             |  |       |  |             |  |
            |2 |    5 x 10   | 2|  &lt;-&gt;  |2 |    5 x 10   | 2|
            |  |             |  |       |  |             |  |
            |  |             |  |       |  |             |  |
            |  +-------------+  |       |  +-------------+  |
            | /       2       \ |       | /       2       \ |
            +-------------------+       +-------------------+
</PRE>

<P>
The exclusive region on each DE is of shape 5 x 10, while the total region
   on each DE is of shape (5+2+2) x (10+2+2) = 9 x 14. In a typical application
   the elements in the exclusive region are updated exclusively by the PET that
   owns the DE. In this example the exclusive elements on every DE are
   initialized to the value <IMG
 WIDTH="48" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$f(i,j)$"> of the geometric function
   <BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
f(i,j) = \sin(\alpha i)\cos(\beta j),
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="365" HEIGHT="28" BORDER="0"
 SRC="img43.png"
 ALT="\begin{displaymath}
f(i,j) = \sin(\alpha i)\cos(\beta j),
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(1)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
where
   <BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\alpha = 2\pi/N_i, i=1,...N_i
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="358" HEIGHT="28" BORDER="0"
 SRC="img44.png"
 ALT="\begin{displaymath}
\alpha = 2\pi/N_i, i=1,...N_i
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(2)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
and
   <BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\beta = 2\pi/N_j, j=1,...N_j,
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="362" HEIGHT="29" BORDER="0"
 SRC="img45.png"
 ALT="\begin{displaymath}
\beta = 2\pi/N_j, j=1,...N_j,
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(3)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
with <IMG
 WIDTH="61" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img46.png"
 ALT="$N_i = 10$"> and <IMG
 WIDTH="63" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.png"
 ALT="$N_j = 20$">. 

<P>
<PRE>
  a = 2. * 3.14159 / 10.
  b = 2. * 3.14159 / 20.
  
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
  
  call ESMF_ArrayGet(array, exclusiveLBound=eLB, exclusiveUBound=eUB, rc=rc)
</PRE>

<P>
<PRE>
  
  do j=eLB(2,1), eUB(2,1)
    do i=eLB(1,1), eUB(1,1)
      farrayPtr(i,j) = sin(a*i) * cos(b*j)  ! test function
    enddo
  enddo
</PRE>

<P>
The above loop only initializes the exclusive elements on each DE. The extra
   elements, outside the exclusive region, are left untouched, holding undefined
   values. Elements outside the exclusive region that correspond to 
   exclusive elements in neighboring DEs can be filled with the data values 
   in those neighboring elements. This is the definition of the halo operation.

<P>
In ESMF the halo communication pattern is first precomputed and stored in
   a RouteHandle object. This RouteHandle can then be used repeatedly to 
   perform the same halo operation in the most efficient way.

<P>
The default halo operation for an Array is precomputed by the following call. 

<P>
<PRE>
  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
The <TT>haloHandle</TT> now holds the default halo operation for <TT>array</TT>, 
   which matches as many elements as possible outside the exclusive region to 
   their corresponding halo source elements in neighboring DEs. Elements that
   could not be matched, e.g. at the edge of the global domain with open
   boundary conditions, will not be updated by the halo operation.

<P>
The <TT>haloHandle</TT> is applied through the <TT>ESMF_ArrayHalo()</TT> method. 

<P>
<PRE>
  call ESMF_ArrayHalo(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
Finally the resources held by <TT>haloHandle</TT> need to be released. 

<P>
<PRE>
  call ESMF_ArrayHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
The <TT>array</TT> object created above defines a 2 element wide rim around the
   exclusive region on each DE. Consequently the default halo operation used
   above will have resulted in updating both elements along the inside edges.
   For simple numerical kernels often a single halo element is 
   sufficient. One way to achieve this would be to reduce the size of the 
   rim surrounding the exclusive region to 1 element along each direction. 
   However, if the same Array object is also used for higher order kernels
   during a different phase of the calculation, a larger element rim is
   required. For this case <TT>ESMF_ArrayHaloStore()</TT> offers two optional
   arguments <TT>haloLDepth</TT> and <TT>haloUDepth</TT>. Using these arguments a
   reduced halo depth can be specified. 

<P>
<PRE>
  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle, &amp;
    haloLDepth=(/1,1/), haloUDepth=(/1,1/), rc=rc)
</PRE>

<P>
This halo operation with a depth of 1 is sufficient to support a simple
   quadratic differentiation kernel. 

<P>
<PRE>
  allocate(farrayTemp(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)))

  do step=1, 4
    call ESMF_ArrayHalo(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
    do j=eLB(2,1), eUB(2,1)
      do i=eLB(1,1), eUB(1,1)
        if (i==1) then
          ! global edge
          farrayTemp(i,j) = 0.5 * (-farrayPtr(i+2,j) + 4.*farrayPtr(i+1,j) &amp;
            - 3.*farrayPtr(i,j)) / a
        else if (i==10) then
          ! global edge
          farrayTemp(i,j) = 0.5 * (farrayPtr(i-2,j) - 4.*farrayPtr(i-1,j) &amp;
            + 3.*farrayPtr(i,j)) / a
        else
          farrayTemp(i,j) = 0.5 * (farrayPtr(i+1,j) - farrayPtr(i-1,j)) / a
        endif
      enddo
    enddo
    farrayPtr(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)) = farrayTemp
  enddo
  
  deallocate(farrayTemp)

  call ESMF_ArrayHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
The special treatment of the global edges in the above kernel is due to the 
   fact that the underlying DistGrid object does not define any special 
   boundary conditions. By default open global boundaries are assumed which
   means that the rim elements on the global edges are untouched during
   the halo operation, and cannot be used in the symmetric numerical derivative
   formula. The kernel can be simplified (and the calculation is more precise)
   with periodic boundary conditions along the first Array dimension.

<P>
First destroy the current Array and DistGrid objects. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
Create a DistGrid with periodic boundary condition along the first dimension. 

<P>
<PRE>
  allocate(connectionList(3*2+2, 1))  ! (3*dimCount+2, number of connections)
  call ESMF_DistGridConnection(connection=connectionList(:,1), &amp;
     patchIndexA=1, patchIndexB=1, &amp;
     positionVector=(/10, 0/), rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/2,2/), connectionList=connectionList, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(connectionList)
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    totalLWidth=(/2,2/), totalUWidth=(/2,2/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    rc=rc)
</PRE>

<P>
Initialize the exclusive elements to the same geometric function as before. 

<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
  
  call ESMF_ArrayGet(array, exclusiveLBound=eLB, exclusiveUBound=eUB, rc=rc)
</PRE>

<P>
<PRE>
  
  do j=eLB(2,1), eUB(2,1)
    do i=eLB(1,1), eUB(1,1)
      farrayPtr(i,j) = sin(a*i) * cos(b*j)  ! test function
    enddo
  enddo
</PRE>

<P>
The numerical kernel only operates along the first dimension. An
   asymmetric halo depth can be used to take this fact into account. 

<P>
<PRE>
  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle, &amp;
    haloLDepth=(/1,0/), haloUDepth=(/1,0/), rc=rc)
</PRE>

<P>
Now the same numerical kernel can be used without special treatment of
   global edge elements. The symmetric derivative formula can be used for
   all exclusive elements. 

<P>
<PRE>
  allocate(farrayTemp(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)))

  do step=1, 4
    call ESMF_ArrayHalo(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
    do j=eLB(2,1), eUB(2,1)
      do i=eLB(1,1), eUB(1,1)
        farrayTemp(i,j) = 0.5 * (farrayPtr(i+1,j) - farrayPtr(i-1,j)) / a
      enddo
    enddo
    farrayPtr(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)) = farrayTemp
  enddo
</PRE>

<P>
The precision of the above kernel can be improved by going to 
   a higher order interpolation. Doing so requires that the halo depth must be
   increased. The following code resets the exclusive Array elements
   to the test function, precomputes a RouteHandle for a halo operation
   with depth 2 along the first dimension, and finally uses the deeper halo
   in the higher order kernel. 

<P>
<PRE>
  
  do j=eLB(2,1), eUB(2,1)
    do i=eLB(1,1), eUB(1,1)
      farrayPtr(i,j) = sin(a*i) * cos(b*j)  ! test function
    enddo
  enddo

  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle2, &amp;
    haloLDepth=(/2,0/), haloUDepth=(/2,0/), rc=rc)
</PRE>

<P>
<PRE>
  do step=1, 4
    call ESMF_ArrayHalo(array=array, routehandle=haloHandle2, rc=rc)
</PRE>

<P>
<PRE>
    do j=eLB(2,1), eUB(2,1)
      do i=eLB(1,1), eUB(1,1)
        farrayTemp(i,j) = (-farrayPtr(i+2,j) + 8.*farrayPtr(i+1,j) &amp;
          - 8.*farrayPtr(i-1,j) + farrayPtr(i-2,j)) / (12.*a)
      enddo
    enddo
    farrayPtr(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)) = farrayTemp
  enddo
  
  deallocate(farrayTemp)
</PRE>

<P>
ESMF supports having multiple halo operations defined on the same Array
   object at the same time. Each operation can be accessed through its unique
   RouteHandle. The above kernel could have made <TT>ESMF_ArrayHalo()</TT> calls
   with a depth of 1 along the first dimension using the previously precomputed
   <TT>haloHandle</TT> if it needed to. Both RouteHandles need to release their
   resources when no longer used. 

<P>
<PRE>
  

  call ESMF_ArrayHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHaloRelease(routehandle=haloHandle2, rc=rc)
</PRE>

<P>
Finally the Array and DistGrid objects can be destroyed. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040521500000000000000"></A>
   <A NAME="Array:Redist"></A>
<BR>
20.2.15 Communication - Redist
</H3>

<P>
Arrays used in different models often cover the same index space region,
   however, the distribution of the Arrays may be different, e.g. the models
   run on exclusive sets of PETs. Even if the Arrays are defined on the same
   list of PETs the decomposition may be different. 

<P>
<PRE>
  srcDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/4,1/), rc=rc)
</PRE>

<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/1,4/), rc=rc)
</PRE>

<P>
The number of elements covered by <TT>srcDistgrid</TT> is identical to the number
   of elements covered by <TT>dstDistgrid</TT> - in fact the index space regions
   covered by both DistGrid objects are congruent. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, rc=rc)
</PRE>

<P>
By construction <TT>srcArray</TT> and <TT>dstArray</TT> are of identical type and
   kind. Further the number of exclusive elements matches between both Arrays.
   These are the prerequisites for the application of an Array redistribution
   in default mode. In order to increase performance of the actual 
   redistribution the communication patter must be precomputed and stored. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The <TT>redistHandle</TT> can now be used repeatedly on the <TT>srcArray</TT>, 
   <TT>dstArray</TT> pair to redistributed data from source to destination Array. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The use of the precomputed <TT>redistHandle</TT> is <EM>not</EM> restricted to
   <TT>srcArray</TT> and <TT>dstArray</TT>. The <TT>redistHandle</TT> can be used to
   redistribute data between any Array pairs that are weakly congruent to the
   Array pair used during precomputation. Arrays are congruent if they are
   defined on matching DistGrids and the shape of local array allocations match
   for all DEs. For weakly congruent Arrays the sizes of the undistributed
   dimensions, that vary faster with memory than the first distributed
   dimension, are permitted to be different. This means that the same
   <TT>redistHandle</TT> can be applied to a large class of similar Arrays that
   differ in the number of elements in the left most undistributed dimensions. 

<P>
Neither <TT>srcArray</TT> nor <TT>dstArray</TT> from above hold an undistributed
   dimension. However, the following <TT>srcArray1</TT> and <TT>dstArray1</TT> objects
   are constructed to have an undistributed dimension each, that varies fastest
   with memory. There is only one element in the undistributed dimension in each
   Array. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec3d, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
</PRE>

<P>
<PRE>
  srcArray1 = ESMF_ArrayCreate(arrayspec=arrayspec3d, distgrid=srcDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1/), undistUBound=(/1/), rc=rc)
</PRE>

<P>
<PRE>
  dstArray1 = ESMF_ArrayCreate(arrayspec=arrayspec3d, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1/), undistUBound=(/1/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray1, dstArray=dstArray1, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The weak congruency feature permits the <TT>redistHandle</TT> to be used on Array
   pairs that have the same arrangement of distributed and undistributed
   dimensions, but where the first dimension is of different size, e.g. 10
   elements instead of 1. 

<P>
<PRE>
  srcArray2 = ESMF_ArrayCreate(arrayspec=arrayspec3d, distgrid=srcDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1/), undistUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
  dstArray2 = ESMF_ArrayCreate(arrayspec=arrayspec3d, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1/), undistUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray2, dstArray=dstArray2, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
When done, the resources held by <TT>redistHandle</TT> need to be deallocated
   by the user code before the handle becomes inaccessible. 

<P>
<PRE>
  call ESMF_ArrayRedistRelease(routehandle=redistHandle, rc=rc)
</PRE>

<P>
In <EM>default</EM> mode, i.e. without providing the optional
   <TT>srcToDstTransposeMap</TT> argument, <TT>ESMF_ArrayRedistStore()</TT> does not
   require equal number of dimensions in source and destination Array. Only the
   total number of elements must match.

<P>
Specifying <TT>srcToDstTransposeMap</TT> switches <TT>ESMF_ArrayRedistStore()</TT>
   into <EM>transpose</EM> mode. In this mode each dimension of <TT>srcArray</TT>
   is uniquely associated with a dimension in <TT>dstArray</TT>. The sizes of 
   associated dimensions must match for each pair.

<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/20,10/), rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, rc=rc)
</PRE>

<P>
This <TT>dstArray</TT> object covers a 20 x 10 index space while the
   <TT>srcArray</TT>, defined further up, covers a 10 x 20 index space. Setting
   <TT>srcToDstTransposeMap = (/2,1/)</TT> will associate the first and second 
   dimension of <TT>srcArray</TT> with the second and first dimension of
   <TT>dstArray</TT>, respectively. This corresponds to a transpose of dimensions.
   Since the decomposition and distribution of dimensions may be different for
   source and destination redistribution may occur at the same time. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/2,1/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The transpose mode of <TT>ESMF_ArrayRedist()</TT> is not limited to
   distributed dimensions of Arrays. The <TT>srcToDstTransposeMap</TT> argument
   can be used to transpose undistributed dimensions in the same manner.
   Furthermore transposing distributed and undistributed dimensions between
   Arrays is also supported.

<P>
The <TT>srcArray</TT> used in the following examples is of rank 4 with 2 
   distributed and 2 undistributed dimensions. The distributed dimensions
   are the two first dimensions of the Array and are distributed according to the
   <TT>srcDistgrid</TT> which describes a total index space region of 100 x 200
   elements. The last two Array dimensions are undistributed dimensions of size
   2 and 3, respectively. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=4, rc=rc)
</PRE>

<P>
<PRE>
  srcDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/100,200/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    undistLBound=(/1,1/), undistUBound=(/2,3/), rc=rc)
</PRE>

<P>
The first <TT>dstArray</TT> to consider is defined on a DistGrid that also 
   describes a 100 x 200 index space region. The distribution indicated
   by <TT>dstDistgrid</TT> may be different from the source distribution. Again
   the first two Array dimensions are associated with the DistGrid dimensions in
   sequence. Furthermore, the last two Array dimensions are undistributed
   dimensions, however, the sizes are 3 and 2, respectively. 

<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/100,200/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    undistLBound=(/1,1/), undistUBound=(/3,2/), rc=rc)
</PRE>

<P>
The desired mapping between <TT>srcArray</TT> and <TT>dstArray</TT> dimensions
   is expressed by <TT>srcToDstTransposeMap = (/1,2,4,3/)</TT>, transposing only
   the two undistributed dimensions. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/1,2,4,3/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
Next consider a <TT>dstArray</TT> that is defined on the same <TT>dstDistgrid</TT>,
   but with a different order of Array dimensions. The desired order is
   specified during Array creation using the argument 
   <TT>distgridToArrayMap = (/2,3/)</TT>. This map associates the first and second
   DistGrid dimensions with the second and third Array dimensions, respectively,
   leaving Array dimensions one and four undistributed. 

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1,1/), undistUBound=(/3,2/), &amp;
    rc=rc)
</PRE>

<P>
Again the sizes of the undistributed dimensions are chosen in reverse order
   compared to <TT>srcArray</TT>. The desired transpose mapping in this case will
   be <TT>srcToDstTransposeMap = (/2,3,4,1/)</TT>. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/2,3,4,1/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
Finally consider the case where <TT>dstArray</TT> is constructed on a 
   200 x 3 index space and where the undistributed dimensions are of size
   100 and 2. 

<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/200,3/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    undistLBound=(/1,1/), undistUBound=(/100,2/), rc=rc)
</PRE>

<P>
By construction <TT>srcArray</TT> and <TT>dstArray</TT> hold the same number of
   elements, albeit in a very different layout. Nevertheless, with a
   <TT>srcToDstTransposeMap</TT> that maps matching dimensions from source to
   destination an Array redistribution becomes a well defined operation between
   <TT>srcArray</TT> and <TT>dstArray</TT>. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/3,1,4,2/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The default mode of Array redistribution, i.e. without providing a
   <TT>srcToDstTransposeMap</TT> to <TT>ESMF_ArrayRedistStore()</TT>, also supports
   undistributed Array dimensions. The requirement in this case is that the 
   total undistributed element count, i.e. the product of the sizes of all
   undistributed dimensions, be the same for source and destination Array.
   In this mode the number of undistributed dimensions need not match between
   source and destination. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=4, rc=rc)
</PRE>

<P>
<PRE>
  srcDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/4,1/), rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    undistLBound=(/1,1/), undistUBound=(/2,4/), rc=rc)
</PRE>

<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/1,4/), rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1,1/), undistUBound=(/2,4/), &amp;
    rc=rc)
</PRE>

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> have two undistributed dimensions and
   a total count of undistributed elements of <!-- MATH
 $2 \times 4 = 8$
 -->
<IMG
 WIDTH="71" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img48.png"
 ALT="$ 2 \times 4 = 8$">.

<P>
The Array redistribution operation is defined in terms of sequentialized
   undistributed dimensions. In the above case this means that a unique sequence
   index will be assigned to each of the 8 undistributed elements. The sequence
   indices will be 1, 2, ..., 8, where sequence index 1 is assigned to the first
   element in the first (i.e. fastest varying in memory) undistributed dimension.
   The following undistributed elements are labeled in consecutive order as they
   are stored in memory. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The redistribution operation by default applies the identity operation between
   the elements of undistributed dimensions. This means that source element with
   sequence index 1 will be mapped against destination element with sequence
   index 1 and so forth. Because of the way source and destination Arrays
   in the current example were constructed this corresponds to a mapping of
   dimensions 3 and 4 on <TT>srcArray</TT> to dimensions 1 and 4 on <TT>dstArray</TT>,
   respectively. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
Array redistribution does <EM>not</EM> require the same number of undistributed
   dimensions in source and destination Array, merely the total number of
   undistributed elements must match. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/1,3/), undistLBound=(/11/), undistUBound=(/18/), &amp;
    rc=rc)
</PRE>

<P>
This <TT>dstArray</TT> object only has a single undistributed dimension, while
   the <TT>srcArray</TT>, defined further back, has two undistributed dimensions.
   However, the total undistributed element count for both Arrays is 8. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
In this case the default identity operation between the elements of
   undistributed dimensions corresponds to a <EM>merging</EM> of dimensions
   3 and 4 on <TT>srcArray</TT> into dimension 2 on <TT>dstArray</TT>. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040521600000000000000"></A>
   <A NAME="Array:SparseMatMul"></A>
<BR>
20.2.16 Communication - SparseMatMul
</H3>

<P>
Sparse matrix multiplication is a fundamental Array communication method. One
   frequently used application of this method is the interpolation between pairs
   of Arrays. The principle is this: the value of each element in the exclusive 
   region of the destination Array is expressed as a linear combination of <EM>   potentially all</EM> the exclusive elements of the source Array. Naturally most of
   the coefficients of these linear combinations will be zero and it is more 
   efficient to store explicit information about the non-zero elements than to 
   keep track of all the coefficients.

<P>
There is a choice to be made with respect to the format in which to store the
   information about the non-zero elements. One option is to store the value
   of each coefficient together with the corresponding destination element index
   and source element index. Destination and source indices could be expressed in
   terms of the corresponding DistGrid patch index together with the coordinate
   tuple within the patch. While this format may be the most natural way to
   express elements in the source and destination Array, it has two major drawbacks.
   First the coordinate tuple is <TT>dimCount</TT> specific and second the format
   is extremely bulky. For 2D source and destination Arrays it would require 6
   integers to store the source and destination element information for each
   non-zero coefficient and matters get worse for higher dimensions.

<P>
Both problems can be circumvented by <EM>interpreting</EM> source and destination
   Arrays as sequentialized strings or <EM>vectors</EM> of elements. This is done
   by assigning a unique <EM>sequence index</EM> to each exclusive element in both
   Arrays. With that the operation of updating the elements in the destination Array
   as linear combinations of source Array elements takes the form of a <EM>sparse
   matrix multiplication</EM>.

<P>
The default sequence index rule assigns index <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="$1$"> to the <TT>minIndex</TT> corner
   element of the first patch of the DistGrid on which the Array is defined. It then
   increments the sequence index by <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="$1$"> for each element running through the
   DistGrid dimensions by order. The index space position of the DistGrid patches
   does not affect the sequence labeling of elements. The default sequence indices
   for 

<P>
<PRE>
  srcDistgrid = ESMF_DistGridCreate(minIndex=(/-1,0/), maxIndex=(/1,3/), rc=rc)
</PRE>

<P>
for each element are:
   <PRE>
     -------------------------------------&gt; 2nd dim
     |
     |   +------+------+------+------+
     |   |(-1,0)|      |      |(-1,3)|
     |   |      |      |      |      |
     |   |   1  |   4  |   7  |  10  |
     |   +------+------+------+------+
     |   |      |      |      |      |
     |   |      |      |      |      |
     |   |   2  |   5  |   8  |  11  |
     |   +------+------+------+------+
     |   | (1,0)|      |      | (1,3)|
     |   |      |      |      |      |
     |   |   3  |   6  |   9  |  12  |
     |   +------+------+------+------+
     |
     v
    1st dim
</PRE>

<P>
The assigned sequence indices are decomposition and distribution invariant by
   construction. Furthermore, when an Array is created with extra elements per DE on
   a DistGrid the sequence indices (which only cover the exclusive elements) remain
   unchanged. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    totalLWidth=(/1,1/), totalUWidth=(/1,1/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    rc=rc)
</PRE>

<P>
The extra padding of 1 element in each direction around the exclusive elements on
   each DE are "invisible" to the Array spare matrix multiplication method. These
   extra elements are either updated by the computational kernel or by Array halo
   operations (not yet implemented!).

<P>
An alternative way to assign sequence indices to all the elements in the patches
   covered by a DistGrid object is to use a special <TT>ESMF_DistGridCreate()</TT>
   call. This call has been specifically designed for 1D cases with arbitrary,
   user-supplied sequence indices. 

<P>
<PRE>
  seqIndexList(1) = localPet*10
  seqIndexList(2) = localPet*10 + 1
  dstDistgrid = ESMF_DistGridCreate(arbSeqIndexList=seqIndexList, rc=rc)
</PRE>

<P>
This call to <TT>ESMF_DistGridCreate()</TT> is collective across the current VM.
   The <TT>arbSeqIndexList</TT> argument specifies the PET-local arbitrary sequence
   indices that need to be covered by the local DE. The resulting DistGrid has
   one local DE per PET which covers the entire PET-local index range. The user
   supplied sequence indices must be unique, but the sequence may be interrupted.
   The four DEs of <TT>dstDistgrid</TT> have the following local 1D index space
   coordinates (given between "()") and sequence indices:
   <PRE>
    covered by DE 0    covered by DE 1   covered by DE 2   covered by DE 3
    on PET 0           on PET 1          on PET 2          on PET 3
    ----------------------------------------------------------------------
    (1) : 0            (1) : 10          (1) : 20          (1) : 30
    (2) : 1            (2) : 11          (2) : 21          (2) : 31
</PRE>

<P>
Again the DistGrid object provides the sequence index labeling for the
   exclusive elements of an Array created on the DistGrid regardless of extra,
   non-exclusive elements. 

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, rc=rc)
</PRE>

<P>
With the definition of sequence indices, either by the default rule or as user
   provided arbitrary sequence indices, it is now possible to uniquely identify
   each exclusive element in the source and destination Array by a single integer
   number. Specifying a pair of source and destination elements takes two integer
   number regardless of the number of dimensions.

<P>
The information required to carry out a sparse matrix multiplication are the
   pair of source and destination sequence indices and the associated
   multiplication factor for each pair. ESMF requires this information in form of
   two Fortran arrays. The factors are stored in a 1D array of the appropriate
   type and kind, e.g. <TT>real(ESMF_KIND_R8)::factorList(:)</TT>. Array sparse
   matrix multiplications are supported between Arrays of different type and
   kind. The type and kind of the factors can also be chosen freely. The 
   sequence index pairs associated with the factors provided by <TT>factorList</TT> 
   are stored in a 2D Fortran array of default integer kind of the shape <TT>   integer::factorIndexList(2,:)</TT>. The sequence indices of the source Array elements
   are stored in the first row of <TT>   factorIndexList</TT> while the sequence indices of the destination Array elements are
   stored in the second row.

<P>
Each PET in the current VM must call into <TT>ESMF_ArraySMMStore()</TT>
   to precompute and store the communication pattern for the sparse matrix
   multiplication. The multiplication factors may be provided in parallel, i.e.
   multiple PETs may specify <TT>factorList</TT> and <TT>factorIndexList</TT> arguments
   when calling into <TT>ESMF_ArraySMMStore()</TT>. PETs that do not
   provide factors either call with <TT>factorList</TT> and <TT>factorIndexList</TT>
   arguments containing zero elements or issue the call omitting both arguments. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(factorList(1))               ! PET 0 specifies 1 factor
    allocate(factorIndexList(2,1))
    factorList = (/0.2/)                  ! factors
    factorIndexList(1,:) = (/5/)          ! seq indices into srcArray
    factorIndexList(2,:) = (/30/)         ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else if (localPet == 1) then
    allocate(factorList(3))               ! PET 1 specifies 3 factor
    allocate(factorIndexList(2,3))
    factorList = (/0.5, 0.5, 0.8/)        ! factors
    factorIndexList(1,:) = (/8, 2, 12/)   ! seq indices into srcArray
    factorIndexList(2,:) = (/11, 11, 30/) ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else
    ! PETs 2 and 3 do not provide factors
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, rc=rc)
      
  endif
</PRE>

<P>
The RouteHandle object <TT>sparseMatMulHandle</TT> produced by 
   <TT>ESMF_ArraySMMStore()</TT> can now be used to call <TT>   ESMF_ArraySMM()</TT> collectively across all PETs of the current VM to
   perform
   <PRE>
     dstArray = 0.0
     do n=1, size(combinedFactorList)
         dstArray(combinedFactorIndexList(2, n)) += 
           combinedFactorList(n) * srcArray(combinedFactorIndexList(1, n))
     enddo
</PRE>
   in parallel. Here <TT>combinedFactorList</TT> and <TT>combinedFactorIndexList</TT>
   are the combined lists defined by the respective local lists provided by 
   PETs 0 and 1 in parallel. For this example 

<P>
<PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
will initialize the entire <TT>dstArray</TT> to 0.0 and then update two elements:

<P>
<PRE>
   on DE 1:
   dstArray(2) = 0.5 * srcArray(0,0)  +  0.5 * srcArray(0,2)
</PRE>

<P>
and

<P>
<PRE>
   on DE 3:
   dstArray(1) = 0.2 * srcArray(0,1)  +  0.8 * srcArray(1,3).
</PRE>

<P>
The call to <TT>ESMF_ArraySMM()</TT> does provide the option to turn
   the default <TT>dstArray</TT> initialization off. If argument <TT>zeroflag</TT>
   is set to <TT>ESMF_REGION_EMPTY</TT> 

<P>
<PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, zeroflag=ESMF_REGION_EMPTY, rc=rc)
</PRE>

<P>
skips the initialization and elements in <TT>dstArray</TT> are updated according to:

<P>
<PRE>
     do n=1, size(combinedFactorList)
         dstArray(combinedFactorIndexList(2, n)) += 
           combinedFactorList(n) * srcArray(combinedFactorIndexList(1, n)).
     enddo
</PRE>

<P>
The <TT>ESMF_RouteHandle</TT> object returned by <TT>ESMF_ArraySMMStore()</TT>
   can be applied to any src/dst Array pairs that are weakly congurent to the
   Array pair used during precomputation. Arrays are congruent if they are
   defined on matching DistGrids and the shape of local array allocations match
   for all DEs. For weakly congruent Arrays the sizes of the undistributed
   dimensions, that vary faster with memory than the first distributed
   dimension, are permitted to be different. See section <A HREF="node4.html#Array:Redist">20.2.15</A>
   for an example of this feature demonstrated for the Redist case. The exact
   same principle applies to the SMM case.

<P>
The resources held by <TT>sparseMatMulHandle</TT> need to be deallocated by the
   user code before the handle becomes inaccessible. 

<P>
<PRE>
  call ESMF_ArraySMMRelease(routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
The Array sparse matrix multiplication also applies to Arrays with
   undistributed dimensions. The undistributed dimensions are interpreted
   in a sequentialized manner, much like the distributed dimensions,
   introducing a second sequence index for source and destination elements.
   Sequence index 1 is assigned to the first element in the first 
   (i.e. fastest varying in memory) undistributed dimension. The following
   undistributed elements are labeled in consecutive order as they are stored in
   memory.

<P>
In the simplest case the Array sparse matrix multiplication will apply an
   identity matrix to the vector of sequentialized undistributed Array elements
   for every non-zero element in the sparse matrix. The requirement in this case
   is that the total undistributed element count, i.e. the product of the sizes 
   of all undistributed dimensions, be the same for source and destination Array. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    totalLWidth=(/1,1/), totalUWidth=(/1,1/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    distgridToArrayMap=(/1,2/), undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2/), undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
Setting up <TT>factorList</TT> and <TT>factorIndexList</TT> is identical to the 
   case for Arrays without undistributed dimensions. Also the call to 
   <TT>ESMF_ArraySMMStore()</TT> remains unchanged. Internally, however,
   the source and destination Arrays are checked to make sure the total
   undistributed element count matches. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(factorList(1))               ! PET 0 specifies 1 factor
    allocate(factorIndexList(2,1))
    factorList = (/0.2/)                  ! factors
    factorIndexList(1,:) = (/5/)          ! seq indices into srcArray
    factorIndexList(2,:) = (/30/)         ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else if (localPet == 1) then
    allocate(factorList(3))               ! PET 1 specifies 3 factor
    allocate(factorIndexList(2,3))
    factorList = (/0.5, 0.5, 0.8/)        ! factors
    factorIndexList(1,:) = (/8, 2, 12/)   ! seq indices into srcArray
    factorIndexList(2,:) = (/11, 11, 30/) ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else
    ! PETs 2 and 3 do not provide factors
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, rc=rc)  
  endif
</PRE>

<P>
The call into the <TT>ESMF_ArraySMM()</TT> operation is completely
   transparent with respect to whether source and/or destination Arrays contain
   undistributed dimensions. 

<P>
<PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
This operation will initialize the entire <TT>dstArray</TT> to 0.0 and then 
   update four elements:

<P>
<PRE>
   on DE 1:
   dstArray[1](2) = 0.5 * srcArray(0,0)[1]  +  0.5 * srcArray(0,2)[1],
   dstArray[2](2) = 0.5 * srcArray(0,0)[2]  +  0.5 * srcArray(0,2)[2]
</PRE>

<P>
and

<P>
<PRE>
   on DE 3:
   dstArray[1](1) = 0.2 * srcArray(0,1)[1]  +  0.8 * srcArray(1,3)[1],
   dstArray[2](1) = 0.2 * srcArray(0,1)[2]  +  0.8 * srcArray(1,3)[2].
</PRE>

<P>
Here indices between "()" refer to distributed dimensions while indices
   between "[]" correspond to undistributed dimensions. 

<P>
In a more general version of the Array sparse matrix multiplication the
   total undistributed element count, i.e. the product of the sizes 
   of all undistributed dimensions, need not be the same for source and
   destination Array. In this formulation each non-zero element of the sparse
   matrix is identified with a unique element in the source and destination
   Array. This requires a generalization of the <TT>factorIndexList</TT> argument
   which now must contain four integer numbers for each element. These numbers
   in sequence are the sequence index of the distributed dimensions and the
   sequence index of the undistributed dimensions of the element in the source
   Array, followed by the sequence index of the distributed dimensions and
   the sequence index of the undistributed dimensions of the element in the
   destination Array. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    totalLWidth=(/1,1/), totalUWidth=(/1,1/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    distgridToArrayMap=(/1,2/), undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2/), undistLBound=(/1/), undistUBound=(/4/), rc=rc)
</PRE>

<P>
Setting up <TT>factorList</TT> is identical to the previous cases since there is
   still only one value associated with each non-zero matrix element. However,
   each entry in <TT>factorIndexList</TT> now has 4 instead of just 2 components. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(factorList(1))               ! PET 0 specifies 1 factor
    allocate(factorIndexList(4,1))
    factorList = (/0.2/)                  ! factors
    factorIndexList(1,:) = (/5/)          ! seq indices into srcArray
    factorIndexList(2,:) = (/1/)          ! undistr. seq indices into srcArray
    factorIndexList(3,:) = (/30/)         ! seq indices into dstArray
    factorIndexList(4,:) = (/2/)          ! undistr. seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else if (localPet == 1) then
    allocate(factorList(3))               ! PET 1 specifies 3 factor
    allocate(factorIndexList(4,3))
    factorList = (/0.5, 0.5, 0.8/)        ! factors
    factorIndexList(1,:) = (/8, 2, 12/)   ! seq indices into srcArray
    factorIndexList(2,:) = (/2, 1, 1/)    ! undistr. seq indices into srcArray
    factorIndexList(3,:) = (/11, 11, 30/) ! seq indices into dstArray
    factorIndexList(4,:) = (/4, 4, 2/)    ! undistr. seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else
    ! PETs 2 and 3 do not provide factors
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, rc=rc)  
  endif
</PRE>

<P>
The call into the <TT>ESMF_ArraySMM()</TT> operation remains
   unchanged. 

<P>
<PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
This operation will initialize the entire <TT>dstArray</TT> to 0.0 and then 
   update two elements:

<P>
<PRE>
   on DE 1:
   dstArray[4](2) = 0.5 * srcArray(0,0)[1]  +  0.5 * srcArray(0,2)[2],
</PRE>

<P>
and

<P>
<PRE>
   on DE 3:
   dstArray[2](1) = 0.2 * srcArray(0,1)[1]  +  0.8 * srcArray(1,3)[1],
</PRE>

<P>
Here indices in <IMG
 WIDTH="18" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$()$"> refer to distributed dimensions while indices in <IMG
 WIDTH="15" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img51.png"
 ALT="$[]$">
   correspond to undistributed dimensions.

<P>

<P>

<P>

<H3><A NAME="SECTION040521700000000000000"></A>
   <A NAME="Array:ScatterGatherRevisited"></A>
<BR>
20.2.17 Communication - Scatter and Gather, revisited
</H3>

<P>
The <TT>ESMF_ArrayScatter()</TT> and <TT>ESMF_ArrayGather()</TT> calls, 
   introduced in section <A HREF="node4.html#Array:ScatterGather">20.2.13</A>, provide a convenient
   way of communicating data between a Fortran array and all of the DEs of
   a single Array patch. A key requirement of <TT>ESMF_ArrayScatter()</TT>
   and <TT>ESMF_ArrayGather()</TT> is that the <EM>shape</EM> of the Fortran array
   and the Array patch must match. This means that the <TT>dimCount</TT> must be
   equal, and that the size of each dimension must match. Element reordering
   during scatter and gather is only supported on a per dimension level,
   based on the <TT>decompflag</TT> option available during DistGrid creation.

<P>
While the <TT>ESMF_ArrayScatter()</TT> and <TT>ESMF_ArrayGather()</TT> methods
   cover a broad, and important spectrum of cases, there are situations that
   require a different set of rules to scatter and gather data between a
   Fortran array and an ESMF Array object. For instance, it is often convenient
   to create an Array on a DistGrid that was created with arbitrary,
   user-supplied sequence indices. See section <A HREF="node4.html#DistGrid:ArbitrarySeqInd">26.2.6</A>
   for more background on DistGrids with arbitrary sequence indices. 

<P>
<PRE>
  allocate(arbSeqIndexList(10))   ! each PET will have 10 elements
  
  do i=1, 10
    arbSeqIndexList(i) = (i-1)*petCount + localPet+1 ! initialize unique seq. indices
  enddo
  
  distgrid = ESMF_DistGridCreate(arbSeqIndexList=arbSeqIndexList, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(arbSeqIndexList)
  
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=1, rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
This <TT>array</TT> object holds 10 elements on each DE, and there is one DE
   per PET, for a total element count of 10 x <TT>petCount</TT>. The
   <TT>arbSeqIndexList</TT>, used during DistGrid creation, was constructed cyclic
   across all DEs. DE 0, for example, on a 4 PET run, would hold sequence
   indices 1, 5, 9, ... . DE 1 would hold 2, 6, 10, ..., and so on.

<P>
The usefulness of the user-specified arbitrary sequence indices becomes
   clear when they are interpreted as global element ids. The ArrayRedist()
   and ArraySMM() communication methods are based on sequence index mapping
   between source and destination Arrays. Other than providing a canonical
   sequence index order via the default sequence scheme, outlined in
   <A HREF="node4.html#Array:SparseMatMul">20.2.16</A>, ESMF does not place any restrictions on the
   sequence indices. Objects that were not created with user supplied
   sequence indices default to the ESMF sequence index order.

<P>
A common, and useful interpretation of the arbitrary sequence indices, 
   specified during DistGrid creation, is that of relating them to the 
   canonical ESMF sequence index order of another data object. Within this
   interpretation the <TT>array</TT> object created above could be viewed as an
   arbitrary distribution of a (<TT>petCount</TT> x 10) 2D array. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(farray(petCount,10)) ! allocate 2D Fortran array petCount x 10
    do j=1, 10
      do i=1, petCount
        farray(i,j) = 100 + (j-1)*petCount + i    ! initialize to something
      enddo
    enddo
  else
    allocate(farray(0,0)) ! must allocate an array of size 0 on all other PETs
  endif
</PRE>

<P>
For a 4 PET run, <TT>farray</TT> on PET 0 now holds the following data.
   <PRE>
     -----1----2----3------------10-----&gt; j
     |
     1   101, 105, 109, ....  , 137
     |
     2   102, 106, 110, ....  , 138
     |
     3   103, 107, 111, ....  , 139
     |
     4   104, 108, 112, ....  , 140
     |
     |
     v
    i
</PRE>

<P>
On all other PETs <TT>farray</TT> has a zero size allocation.

<P>
Following the sequence index interpretation from above, scattering the data
   contained in <TT>farray</TT> on PET 0 across the <TT>array</TT> object created
   further up, seems like a well defined operation. Looking at it a bit closer,
   it becomes clear that it is in fact more of a redistribution than a simple
   scatter operation. The general rule for such a "redist-scatter"  operation,
   of a Fortran array, located on a single PET, into an ESMF Array, is to 
   use the canonical ESMF sequence index scheme to label the elements of the
   Fortran array, and to send the data to the Array element with the same
   sequence index.

<P>
The just described "redist-scatter" operation is much more general than
   the standard <TT>ESMF_ArrayScatter()</TT> method. It does not require shape
   matching, and supports full element reordering based on the sequence indices.
   Before <TT>farray</TT> can be scattered across <TT>array</TT> in the described way,
   it must be wrapped into an ESMF Array object itself, essentially labeling the
   array elements according to the canonical sequence index scheme.

<P>
<PRE>
  distgridAux = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/petCount,10/), &amp;
    regDecomp=(/1,1/), rc=rc)  ! DistGrid with only 1 DE
</PRE>

<P>
The first step is to create a DistGrid object with only a single DE. This
   DE must be located on the PET on which the Fortran data array resides.
   In this example <TT>farray</TT> holds data on PET 0, which is where the default
   DELayout will place the single DE defined in the DistGrid. If the <TT>farray</TT>
   was setup on a different PET, an explicit DELayout would need to be created
   first, mapping the only DE to the PET on which the data is defined.

<P>
Next the Array wrapper object can be created from the <TT>farray</TT> and the
   just created DistGrid object. 

<P>
<PRE>
  arrayAux = ESMF_ArrayCreate(farray=farray, distgrid=distgridAux, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
At this point all of the pieces are in place to use <TT>ESMF_ArrayRedist()</TT>
   to do the "redist-scatter" operation. The typical store/execute/release
   pattern must be followed. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=arrayAux, dstArray=array, &amp;
    routehandle=scatterHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=arrayAux, dstArray=array, &amp;
    routehandle=scatterHandle, rc=rc)
</PRE>

<P>
In this example, after <TT>ESMF_ArrayRedist()</TT> was called, the content
   of <TT>array</TT> on a 4 PET run would look like this:
   <PRE>
    PET 0:   101, 105, 109, ....  , 137
    PET 1:   102, 106, 110, ....  , 138
    PET 2:   103, 107, 111, ....  , 139
    PET 3:   104, 108, 112, ....  , 140
</PRE>

<P>
Once set up, <TT>scatterHandle</TT> can be used repeatedly to scatter data
   from <TT>farray</TT> on PET 0 to all the DEs of <TT>array</TT>. All of the
   resources should be released once <TT>scatterHandle</TT> is no longer needed. 

<P>
<PRE>
  call ESMF_ArrayRedistRelease(routehandle=scatterHandle, rc=rc)
</PRE>

<P>
The opposite operation, i.e. <EM>gathering</EM> of the <TT>array</TT> data
   into <TT>farray</TT> on PET 0, follows a very similar setup. In fact, the
   <TT>arrayAux</TT> object already constructed for the scatter direction, can
   directly be re-used. The only thing that is different for the "redist-gather",
   are the <TT>srcArray</TT> and <TT>dstArray</TT> argument assignments, reflecting
   the opposite direction of data movement. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=array, dstArray=arrayAux, &amp;
    routehandle=gatherHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=array, dstArray=arrayAux, &amp;
    routehandle=gatherHandle, rc=rc)
</PRE>

<P>
Just as for the scatter case, the <TT>gatherHandle</TT> can be used repeatedly
   to gather data from <TT>array</TT> into <TT>farray</TT> on PET 0. All of the
   resources should be released once <TT>gatherHandle</TT> is no longer needed. 

<P>
<PRE>
  call ESMF_ArrayRedistRelease(routehandle=gatherHandle, rc=rc)
</PRE>

<P>
Finally the wrapper Array <TT>arrayAux</TT> and the associated DistGrid object
   can also be destroyed. 

<P>
<PRE>
  call ESMF_ArrayDestroy(arrayAux, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgridAux, rc=rc)
</PRE>

<P>
Further, the primary data objects of this example must be deallocated
   and destroyed. 

<P>
<PRE>
  deallocate(farray)
  
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040521800000000000000"></A>
   <A NAME="Array:CommNB"></A>
<BR>
20.2.18 Non-blocking Communications
</H3>

<P>
All <TT>ESMF_RouteHandle</TT> based communcation methods, like 
   <TT>ESMF_ArrayRedist()</TT> or <TT>ESMF_ArraySMM()</TT>, can be executed in
   blocking or non-blocking mode. The non-blocking feature is useful, for
   example, to overlap computation with communication, or to implement a more
   loosely synchronized inter-Component interaction scheme than is possible
   with the blocking communication mode.

<P>
Access to the non-blocking execution mode is provided uniformly across all
   RouteHandle based communication calls. Every such call contains the optional
   <TT>commflag</TT> argument of type <TT>ESMF_CommFlag</TT>. Section
   <A HREF="node2.html#opt:commflag">9.2.3</A> lists all of the valid settings for this flag.

<P>
It is an execution time decision to select whether to invoke a precomputed
   communication pattern, stored in a RouteHandle, in the blocking or
   non-blocking mode. Neither requires specifically precomputed RouteHandles
   - i.e. a RouteHandle is neither specifically blocking nor specifically
   non-blocking. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
The returned RouteHandle <TT>routehandle</TT> can be used in blocking or 
   non-blocking execution calls. The application is free to switch between
   both modes for the same RouteHandle.

<P>
By default <TT>commflag</TT> is set to <TT>ESMF_COMM_BLOCKING</TT> in all of the
   RouteHandle execution methods, and the behavior is that of the VM-wide
   collective communication calls described in the previous sections. In the
   blocking mode the user must assume that the communication call will not
   return until all PETs have exchanged the precomputed information. On the
   other hand, the user has no guarante about the exact synchronization 
   behavior, and it is unsafe to make specific assumtions. What is guaranteed
   in the blocking communication mode is that when the call returns on the
   local PET, all data exchanges associated with all local DEs have finished.
   This means that all in-bound data elements are valid and that all out-bound
   data elements can safely be overwritten by the user. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, commflag=ESMF_COMM_BLOCKING, rc=rc)
</PRE>

<P>
The same exchange pattern, that is encoded in <TT>routehandle</TT>, can be 
   executed in non-blocking mode, simply by setting the appropriate
   <TT>commflag</TT> when calling into <TT>ESMF_ArrayRedist()</TT>.

<P>
At first sight there are obvious similarities between the non-blocking
   RouteHandle based execution paradigm and the non-blocking message passing
   calls provided by MPI. However, there are significant differences in
   the behavior of the non-blocking point-to-point calls that MPI defines and
   the non-blocking mode of the collective exchange patterns described by ESMF
   RouteHandles.

<P>
Setting <TT>commflag</TT> to <TT>ESMF_COMM_NBSTART</TT> in any RouteHandle
   execution call returns immediatly after all out-bound data has been moved
   into ESMF internal transfer buffers and the exchange has been initiated. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, commflag=ESMF_COMM_NBSTART, rc=rc)
</PRE>

<P>
Once a call with <TT>commflag = ESMF_COMM_NBSTART</TT> returns, it is safe
   to modify the out-bound data elements in the <TT>srcArray</TT> object. However,
   no guarantees are made for the in-bound data elements in <TT>dstArray</TT> at
   this phase of the non-blocking execution. It is unsafe to access these
   elements until the exchange has finished locally.

<P>
One way to ensure that the exchange has finished locally is to call 
   with <TT>commflag</TT> set to <TT>ESMF_COMM_NBWAITFINISH</TT>. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, commflag=ESMF_COMM_NBWAITFINISH, rc=rc)
</PRE>

<P>
Calling with <TT>commflag = ESMF_COMM_NBWAITFINISH</TT> instructs the
   communication method to wait and block until the previously started
   exchange has finished, and has been processed locally according to 
   the RouteHandle. Once the call returns, it is safe to access both in-bound
   and out-bound data elements in <TT>dstArray</TT> and <TT>srcArray</TT>, 
   respectively.

<P>
Some situations require more flexibility than is provided by the 
   <TT>ESMF_COMM_NBSTART</TT> - <TT>ESMF_COMM_NBWAITFINISH</TT> pair. For
   instance, a Component that needs to interact with several other Components,
   virtually simultanously, would initiated several different exchanges with 
   <TT>ESMF_COMM_NBSTART</TT>. Calling with <TT>ESMF_COMM_NBWAITFINISH</TT> for
   any of the outstanding exchanges may potentially block for a long time, 
   lowering the throughput. In the worst case a dead lock situation may arrise.
   Calling with <TT>commflag = ESMF_COMM_NBTESTFINISH</TT> addresses this problem. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, commflag=ESMF_COMM_NBTESTFINISH, &amp;
    finishedflag=finishflag, rc=rc)
</PRE>

<P>
This call tests the locally outstanding data transfer operation in 
   <TT>routehandle</TT>, and finishes the exchange as much as currently possible.
   It does not block until the entire exchange has finished locally, instead
   it returns immediatly after one round of testing has been
   completed. The optional return argument <TT>finishedflag</TT> is set to 
   <TT>.true.</TT> if the exchange is completely finished locally, and set to 
   <TT>.false.</TT> otherwise.

<P>
The user code must decide, depending on the value of the returned
   <TT>finishedflag</TT>, whether additional calls are required to finish an
   outstanding non-blocking exchange. If so, it can be done by 
   repeatedly calling with <TT>ESMF_COMM_NBTESTFINISH</TT> until 
   <TT>finishedflag</TT> comes back with a value of <TT>.true.</TT>. Such a loop
   allows other pieces of user code to be executed between the calls. 
   Alternatively a call with <TT>ESMF_COMM_NBWAITFINISH</TT> can be used to
   block until the exchange has locally finished.

<P>
<EM>Noteworthy property.</EM>
   It is fine to invoke a RouteHandle based communication call
   with <TT>commflag</TT> set to <TT>ESMF_COMM_NBTESTFINISH</TT> or
   <TT>ESMF_COMM_NBWAITFINISH</TT> on a specific RouteHandle without there 
   being an outstanding non-blocking exchange. In fact, it is not
   required that there was ever a call made with <TT>ESMF_COMM_NBSTART</TT> for
   the RouteHandle. In these cases the calls made with
   <TT>ESMF_COMM_NBTESTFINISH</TT> or <TT>ESMF_COMM_NBWAITFINISH</TT>  will
   simply return immediatly (with <TT>finishedflag</TT> set to <TT>.true.</TT>).

<P>
<EM>Noteworthy property.</EM>
   It is fine to mix blocking and non-blocking invokations of the same 
   RouteHandle based communication call across the PETs. This means that it is
   fine for some PETs to issue the call with <TT>ESMF_COMM_BLOCKING</TT>
   (or using the default), while other PETs call the same communication call
   with <TT>ESMF_COMM_NBSTART</TT>.

<P>
<EM>Noteworthy restriction.</EM>
   A RouteHandle that is currently involved in an outstanding non-blocking
   exchange may <EM>not</EM> be used to start any further exchanges, neither
   blocking nor non-blocking. This restriction is independent of whether the
   newly started RouteHandle based exchange is made for the same or for 
   different data objects.

<P>

<P>

<H2><A NAME="SECTION04053000000000000000">
20.3 Restrictions and Future Work</A>
</H2>

<P>

<A NAME="Array:rest"></A>

<UL>
<LI><B>CAUTION:</B> It depends on the specific entry point of <TT>ESMF_ArrayCreate()</TT> used during Array creation, which Fortran operations are supported on the Fortran array pointer <TT>farrayPtr</TT>, returned by <TT>ESMF_ArrayGet()</TT>. Only if the <TT>ESMF_ArrayCreate()</TT> <EM>from pointer</EM> variant was used, will the returned <TT>farrayPtr</TT> variable contain the original bounds information, and be suitable for the Fortran <TT>deallocate()</TT> call. This limitation is a direct consequence of the Fortran 95 standard relating to the passing of array arguments.

<P>
</LI>
<LI><B>1D limit:</B> ArrayRedist() and ArraySMM() operations on Arrays based on DistGrids with arbitrary sequence indices are currently limited to 1D arbitrary DistGrids.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION04054000000000000000">
20.4 Design and Implementation Notes</A>
</H2>

<P>
The Array class is part of the ESMF index space layer and is built ontop of the DistGrid and DELayout classes. The DELayout class introduces the notion of 
<EM>decomposition elements</EM> (DEs) and their layout across the available PETs. The DistGrid describes how index space is decomposed by assigning <EM>logically rectangular index space pieces</EM> or <EM>DE-local tiles</EM> to the DEs. The Array finally associates a <EM>local memory allocation</EM> with each local DE.

<P>
The following is a list of implementation specific details about the current ESMF Array.

<P>

<UL>
<LI>Implementation language is C++.
</LI>
<LI>Local memory allocations are internally held in <TT>ESMF_LocalArray</TT>
objects.
</LI>
<LI>All precomputed communication methods are based on sparse matrix
multiplication.
</LI>
</UL>

<P>

<H2><A NAME="SECTION04055000000000000000">
20.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04055100000000000000">
20.5.1 ESMF_ArrayCreate - Create Array object from Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateFromPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(farrayPtr, &amp; 
   distgrid, copyflag, distgridToArrayMap, computationalEdgeLWidth, &amp; 
   computationalEdgeUWidth, computationalLWidth, &amp; 
   computationalUWidth, totalLWidth, &amp; 
   totalUWidth, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;),dimension(&lt;rank&gt;),pointer :: farrayPtr 
   type(ESMF_DistGrid), intent(in) :: distgrid 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   integer, intent(in), optional :: computationalEdgeLWidth(:) 
   integer, intent(in), optional :: computationalEdgeUWidth(:) 
   integer, intent(in), optional :: computationalLWidth(:) 
   integer, intent(in), optional :: computationalUWidth(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateFromPtrmrankDmtypekind
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from existing local native Fortran 
   arrays with pointer attribute, according to distgrid. Besides 
   <TT>farrayPtr</TT> each PET must issue this call with identical arguments in 
   order to create a consistent Array object. The bounds of the local arrays 
   are preserved by this call and determine the bounds of the total region of 
   the resulting Array object. Bounds of the DE-local exclusive regions are 
   set to be consistent with the total regions and the specified distgrid 
   argument. Bounds for Array dimensions that are not distributed are 
   automatically set to the bounds provided by <TT>farrayPtr</TT>. 

<P>
This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 

<P>
The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. By default all tensor elements are associated with 
   stagger location 0. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   <TT>ESMF_ArraySet()</TT> to change these default settings after the 
   Array object has been created. 

<P>
The return value is the newly created <TT>ESMF_Array</TT> object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Valid native Fortran array with pointer attribute. Memory must be 
   associated with the actual argument. The type/kind/rank information of 
   <TT>farrayPtr</TT> will be used to set <TT>Array</TT>'s properties 
   accordingly. The shape of <TT>farrayPtr</TT> will be checked against the 
   information contained in the <TT>distgrid</TT>. The bounds of 
   <TT>farrayPtr</TT> will be preserved by this call and the bounds of the 
   resulting Array object are set accordingly. 
   
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farrayPtr</TT> directly or will copy the data from 
   <TT>farrayPtr</TT> into a new memory allocation. Valid options are 
   <TT>ESMF_DATA_REF</TT> (default) or <TT>ESMF_DATA_COPY</TT>. 
   Depending on the specific situation the <TT>ESMF_DATA_REF</TT> option 
   may be unsafe when specifying an array slice for <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by 
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in <TT>farrayPtr</TT> by specifying the 
   appropriate Array dimension index. The default is to map all of 
   <TT>distgrid</TT>'s dimensions against the lower dimensions of the 
   <TT>farrayPtr</TT> argument in sequence, i.e. <TT>distgridToArrayMap = 
   (/1, 2, .../)</TT>. 
   Unmapped <TT>farrayPtr</TT> dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT> 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region for DEs 
   that are located on the edge of a patch. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region for DEs 
   that are located on the edge of a patch. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the total memory 
   region with respect to the lower corner of the computational region. 
   The default is to accommodate the union of exclusive and computational 
   region exactly. 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the total memory 
   region with respect to the upper corner of the computational region. 
   The default is a vector that contains the remaining number of elements 
   in each direction as to fit the union of exclusive and computational 
   region into the memory region provided by the <TT>farrayPtr</TT> argument. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04055200000000000000">
20.5.2 ESMF_ArrayCreate - Create Array object from Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateAssmdShape&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(farray, &amp; 
   distgrid, indexflag, copyflag, distgridToArrayMap, &amp; 
   computationalEdgeLWidth, computationalEdgeUWidth, computationalLWidth, &amp; 
   computationalUWidth, totalLWidth, &amp; 
   totalUWidth, undistLBound, undistUBound, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;),dimension(&lt;rank&gt;),intent(in),target :: farray 
   type(ESMF_DistGrid), intent(in) :: distgrid 
   type(ESMF_IndexFlag), intent(in) :: indexflag 
   type(ESMF_CopyFlag), intent(in), optional :: copyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   integer, intent(in), optional :: computationalEdgeLWidth(:) 
   integer, intent(in), optional :: computationalEdgeUWidth(:) 
   integer, intent(in), optional :: computationalLWidth(:) 
   integer, intent(in), optional :: computationalUWidth(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(in), optional :: undistLBound(:) 
   integer, intent(in), optional :: undistUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateAssmdShapemrankDmtypekind
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from an existing local native Fortran 
   array according to distgrid. Besides <TT>farray</TT> each PET must issue this 
   call with identical arguments in order to create a consistent Array object. 
   The local arrays provided must be dimensioned according to the DE-local 
   total region. Bounds of the exclusive regions are set as specified in the 
   distgrid argument. Bounds for Array dimensions that are not distributed can 
   be chosen freely using the <TT>undistLBound</TT> and <TT>undistUBound</TT> 
   arguments. 

<P>
This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 

<P>
The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. By default all tensor elements are associated with 
   stagger location 0. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   <TT>ESMF_ArraySet()</TT> to change these default settings after the 
   Array object has been created. 

<P>
The return value is the newly created <TT>ESMF_Array</TT> object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>farray</STRONG></DT>
<DD>Valid native Fortran array, i.e. memory must be associated with the 
   actual argument. The type/kind/rank information of <TT>farray</TT> will be 
   used to set <TT>Array</TT>'s properties accordingly. The shape of 
   <TT>farray</TT> will be checked against the information contained in the 
   <TT>distgrid</TT>. 
   
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of farray. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#opt:indexflag">9.2.8</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farray</TT> directly or will copy the data from 
   <TT>farray</TT> into a new memory allocation. Valid options are 
   <TT>ESMF_DATA_REF</TT> (default) or <TT>ESMF_DATA_COPY</TT>. 
   Depending on the specific situation the <TT>ESMF_DATA_REF</TT> option 
   may be unsafe when specifying an array slice for <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by 
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in <TT>farray</TT> by specifying the 
   appropriate Array dimension index. The default is to map all of 
   <TT>distgrid</TT>'s dimensions against the lower dimensions of the 
   <TT>farray</TT> argument in sequence, i.e. <TT>distgridToArrayMap = 
   (/1, 2, .../)</TT>. 
   Unmapped <TT>farray</TT> dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT> 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region for DEs 
   that are located on the edge of a patch. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region for DEs 
   that are located on the edge of a patch. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the total memory 
   region with respect to the lower corner of the computational region. 
   The default is to accommodate the union of exclusive and computational 
   region exactly. 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the total memory 
   region with respect to the upper corner of the computational region. 
   The default is a vector that contains the remaining number of elements 
   in each direction as to fit the union of exclusive and computational 
   region into the memory region provided by the <TT>farray</TT> argument. 
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed. 
   By default lbound is 1. 
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed. 
   By default ubound is equal to the extent of the corresponding 
   dimension in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04055300000000000000">
20.5.3 ESMF_ArrayCreate - Create Array object from a list of LocalArray objects</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateLocalArray(larrayList, distgrid, indexflag, &amp;
     copyflag, distgridToArrayMap, computationalEdgeLWidth, &amp;
     computationalEdgeUWidth, computationalLWidth, computationalUWidth, &amp;
     totalLWidth, totalUWidth, undistLBound, undistUBound, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_LocalArray), intent(in) :: larrayList(:)
        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_IndexFlag), intent(in), optional :: indexflag
        type(ESMF_CopyFlag), intent(in), optional :: copyflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: computationalEdgeLWidth(:)
        integer, intent(in), optional :: computationalEdgeUWidth(:)
        integer, intent(in), optional :: computationalLWidth(:)
        integer, intent(in), optional :: computationalUWidth(:)
        integer, intent(in), optional :: totalLWidth(:)
        integer, intent(in), optional :: totalUWidth(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateLocalArray
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from existing <TT>ESMF_LocalArray</TT>
   objects according to distgrid. Besides <TT>larrayList</TT> each PET must issue
   this call with identical arguments in order to create a consistent Array
   object. The local arrays provided must be dimensioned according to the
   DE-local total region. Bounds of the exclusive regions are set as specified
   in the distgrid argument. Bounds for array dimensions that are not distributed
   can be chosen freely using the <TT>undistLBound</TT> and <TT>undistUBound</TT> 
   arguments. 

<P>
This interface is able to handle multiple DEs per PET.

<P>
The not distributed Array dimensions form a tensor of rank = array.rank -
   distgrid.dimCount. By default all tensor elements are associated with
   stagger location 0. The widths of the computational region are set to
   the provided value, or zero by default, for all tensor elements. Use
   <TT>ESMF_ArraySet()</TT> to change these default settings after the
   Array object has been created.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>larrayList</STRONG></DT>
<DD>List of valid <TT>ESMF_LocalArray</TT> objects, i.e. memory must be
   associated with the actual arguments. The type/kind/rank information of
   all <TT>larrayList</TT> elements must be identical and will
   be used to set <TT>Array</TT>'s properties accordingly. The shape of each
   <TT>larrayList</TT> element will be checked against the information
   contained in the <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section <A HREF="node2.html#opt:indexflag">9.2.8</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation
   provided by <TT>farray</TT> directly or will copy the data from
   <TT>farray</TT> into a new memory allocation. Valid options are
   <TT>ESMF_DATA_REF</TT> (default) or <TT>ESMF_DATA_COPY</TT>.
   Depending on the specific situation the <TT>ESMF_DATA_REF</TT> option
   may be unsafe when specifying an array slice for <TT>farray</TT>.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by 
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in the <TT>larrayList</TT> elements 
   by specifying the appropriate Array dimension index. The default is 
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions 
   of the <TT>larrayList</TT> elements in sequence, i.e. 
   <TT>distgridToArrayMap = (/1, 2, .../)</TT>. 
   Unmapped dimensions in the <TT>larrayList</TT> elements are not 
   decomposed dimensions and form a tensor of
   rank = Array.rank - DistGrid.dimCount. 
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT> 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a patch.
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a patch.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the computational region.
   The default is to accommodate the union of exclusive and computational
   region exactly.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the exclusive region.
   The default is a vector that contains the remaining number of elements
   in each direction as to fit the union of exclusive and computational
   region into the memory region provided by the <TT>larrayList</TT> argument.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   By default lbound is 1.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   By default ubound is equal to the extent of the corresponding
   dimension in <TT>larrayList</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04055400000000000000">
20.5.4 ESMF_ArrayCreate - Create Array object from specification and allocate memory</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocate(arrayspec, distgrid, indexflag, &amp;
     distgridToArrayMap, computationalEdgeLWidth, computationalEdgeUWidth, &amp;
     computationalLWidth, computationalUWidth, totalLWidth, totalUWidth, &amp;
     undistLBound, undistUBound, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_ArraySpec), intent(inout) :: arrayspec
        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_IndexFlag), intent(in), optional :: indexflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: computationalEdgeLWidth(:)
        integer, intent(in), optional :: computationalEdgeUWidth(:)
        integer, intent(in), optional :: computationalLWidth(:)
        integer, intent(in), optional :: computationalUWidth(:)
        integer, intent(in), optional :: totalLWidth(:)
        integer, intent(in), optional :: totalUWidth(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateAllocate
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object and allocate uninitialized data space
   according to arrayspec and distgrid. Each PET must issue
   this call with identical arguments in order to create a consistent Array
   object. DE-local allocations are made according to the total region defined
   by the arguments to this call: <TT>distgrid</TT> and the optional <TT>Width</TT>
   arguments.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD><TT>ESMF_ArraySpec</TT> object containing the type/kind/rank information.
   
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section <A HREF="node2.html#opt:indexflag">9.2.8</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by 
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in the newly allocated Array object 
   by specifying the appropriate Array dimension index. The default is 
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions 
   of the Array object in sequence, i.e. <TT>distgridToArrayMap = 
   (/1, 2, .../)</TT>. 
   Unmapped dimensions in the Array object are not decomposed dimensions 
   and form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT> 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a patch.
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a patch.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the computational region.
   The default is to accommodate the union of exclusive and computational
   region.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the computational region.
   The default is to accommodate the union of exclusive and computational
   region.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04055500000000000000">
20.5.5 ESMF_ArrayCreate - Create Array object as copy of existing Array object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateCopy(array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Array), intent(in) :: array
        integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateCopy
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object as the copy of an existing Array.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object to be copied.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04055600000000000000">
20.5.6 ESMF_ArrayDestroy - Destroy Array object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayDestroy(array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(inout) :: array
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04055700000000000000">
20.5.7 ESMF_ArrayGather - Gather a Fortran array from an ESMF_Array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayGather&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(array, farray, patch, &amp; 
   rootPet, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(inout) :: array 
   mtype (ESMF_KIND_mtypekind),dimension(mdim),intent(in),target :: farray 
   integer, intent(in), optional :: patch 
   integer, intent(in) :: rootPet 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Gather the data of an ESMF_Array object into the <TT>farray</TT> located on 
   <TT>rootPET</TT>. A single DistGrid patch of <TT>array</TT> must be 
   gathered into <TT>farray</TT>. The optional <TT>patch</TT> 
   argument allows selection of the patch. For Arrays defined on a single 
   patch DistGrid the default selection (patch 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the patch in Array. 

<P>
If the Array contains replicating DistGrid dimensions data will be 
   gathered from the numerically higher DEs. Replicated data elements in 
   numericaly lower DEs will be ignored. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object from which data will be gathered. 
   
</DD>
<DT><STRONG>[farray]</STRONG></DT>
<DD>The Fortran array into which to gather data. Only root 
   must provide a valid <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[patch]</STRONG></DT>
<DD>The DistGrid patch in <TT>array</TT> from which to gather <TT>farray</TT>. 
   By default <TT>farray</TT> will be gathered from patch 1. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid destination array, i.e. <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04055800000000000000">
20.5.8 ESMF_ArrayGet - Access to Array internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet()
   subroutine ESMF_ArrayGetDefault(array, typekind, rank, larrayList, &amp;
     indexflag, distgridToArrayMap, distgridToPackedArrayMap, &amp;
     arrayToDistGridMap, undistLBound, undistUBound, exclusiveLBound, &amp;
     exclusiveUBound, computationalLBound, computationalUBound, totalLBound, &amp;
     totalUBound, computationalLWidth, computationalUWidth, totalLWidth, &amp;
     totalUWidth, name, distgrid, dimCount, patchCount, minIndexPDimPPatch, &amp;
     maxIndexPDimPPatch, patchListPDe, indexCountPDimPDe, delayout, deCount, &amp;
     localDeCount, localDeList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in) :: array
     type(ESMF_TypeKind), intent(out), optional :: typekind
     integer, intent(out), optional :: rank
     type(ESMF_LocalArray), target, intent(out), optional :: larrayList(:)
     type(ESMF_IndexFlag), intent(out), optional :: indexflag
     integer, target, intent(out), optional :: distgridToArrayMap(:)
     integer, target, intent(out), optional :: distgridToPackedArrayMap(:)
     integer, target, intent(out), optional :: arrayToDistGridMap(:)
     integer, target, intent(out), optional :: undistLBound(:)
     integer, target, intent(out), optional :: undistUBound(:)
     integer, target, intent(out), optional :: exclusiveLBound(:,:)
     integer, target, intent(out), optional :: exclusiveUBound(:,:)
     integer, target, intent(out), optional :: computationalLBound(:,:)
     integer, target, intent(out), optional :: computationalUBound(:,:)
     integer, target, intent(out), optional :: totalLBound(:,:)
     integer, target, intent(out), optional :: totalUBound(:,:)
     integer, target, intent(out), optional :: computationalLWidth(:,:)
     integer, target, intent(out), optional :: computationalUWidth(:,:)
     integer, target, intent(out), optional :: totalLWidth(:,:)
     integer, target, intent(out), optional :: totalUWidth(:,:)
     character(len=*), intent(out), optional :: name
     type(ESMF_DistGrid), intent(out), optional :: distgrid
     integer, intent(out), optional :: dimCount
     integer, intent(out), optional :: patchCount
     integer, intent(out), optional :: minIndexPDimPPatch(:,:)
     integer, intent(out), optional :: maxIndexPDimPPatch(:,:)
     integer, intent(out), optional :: patchListPDe(:)
     integer, intent(out), optional :: indexCountPDimPDe(:,:)
     type(ESMF_DELayout), intent(out), optional :: delayout
     integer, intent(out), optional :: deCount
     integer, intent(out), optional :: localDeCount
     integer, intent(out), optional :: localDeList(:)
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal information.

<P>
This interface works for any number of DEs per PET.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>TypeKind of the Array object.
   
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>Rank of the Array object.
   
</DD>
<DT><STRONG>[larrayList]</STRONG></DT>
<DD>Upon return this holds a list of the associated <TT>ESMC_LocalArray</TT>
   objects. <TT>larrayList</TT> must be allocated to be of size
   <TT>localDeCount</TT>, i.e. the number of DEs associated with the calling
   PET.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Upon return this flag indicates how the DE-local indices are defined.
   See section <A HREF="node2.html#opt:indexflag">9.2.8</A> for a list of possible return values.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>Upon return this list holds the Array dimensions against which the
   DistGrid dimensions are mapped. <TT>distgridToArrayMap</TT> must be allocated
   to be of size <TT>dimCount</TT>. An entry of zero indicates that the
   respective DistGrid dimension is replicating the Array across the DEs
   along this direction.
   
</DD>
<DT><STRONG>[distgridToPackedArrayMap]</STRONG></DT>
<DD>Upon return this list holds the indices of the Array dimensions in packed
   format against which the DistGrid dimensions are mapped.
   <TT>distgridToPackedArrayMap</TT> must be allocated to be of size
   <TT>dimCount</TT>. An entry of zero indicates that the respective DistGrid
   dimension is replicating the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[arrayToDistGridMap]</STRONG></DT>
<DD>Upon return this list holds the DistGrid dimensions against which the
   Array dimensions are mapped. <TT>arrayToDistGridMap</TT> must be allocated
   to be of size <TT>rank</TT>. An entry of zero indicates that the respective
   Array dimension is not decomposed, rendering it a tensor dimension.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Upon return this array holds the lower bounds of the undistributed
   dimensions of the Array. <TT>UndistLBound</TT> must be allocated to be
   of size <TT>rank-dimCount</TT>.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upon return this array holds the upper bounds of the undistributed
   dimensions of the Array. <TT>UndistUBound</TT> must be allocated to be
   of size <TT>rank-dimCount</TT>.
   
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive regions for
   all PET-local DEs. <TT>exclusiveLBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive regions for
   all PET-local DEs. <TT>exclusiveUBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational regions for
   all PET-local DEs. <TT>computationalLBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational regions for
   all PET-local DEs. <TT>computationalUBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total regions for
   all PET-local DEs. <TT>totalLBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total regions for
   all PET-local DEs. <TT>totalUBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>Upon return this holds the lower width of the computational regions for
   all PET-local DEs. <TT>computationalLWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>Upon return this holds the upper width of the computational regions for
   all PET-local DEs. <TT>computationalUWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Upon return this holds the lower width of the total memory regions for
   all PET-local DEs. <TT>totalLWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upon return this holds the upper width of the total memory regions for
   all PET-local DEs. <TT>totalUWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>Upon return this holds the associated <TT>ESMF_DistGrid</TT> object.
   
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>Number of dimensions (rank) of <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>[patchCount]</STRONG></DT>
<DD>Number of patches in <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>[minIndexPDimPPatch]</STRONG></DT>
<DD>Lower index space corner per <TT>dim</TT>, per <TT>patch</TT>, with
   <TT>size(minIndexPDimPPatch) == (/dimCount, patchCount/)</TT>.
   
</DD>
<DT><STRONG>[maxIndexPDimPPatch]</STRONG></DT>
<DD>Upper index space corner per <TT>dim</TT>, per <TT>patch</TT>, with
   <TT>size(maxIndexPDimPPatch) == (/dimCount, patchCount/)</TT>.
   
</DD>
<DT><STRONG>[patchListPDe]</STRONG></DT>
<DD>List of patch id numbers, one for each DE, with
   <TT>size(patchListPDe) == (/deCount/)</TT>
   
</DD>
<DT><STRONG>[indexCountPDimPDe]</STRONG></DT>
<DD>Array of extents per <TT>dim</TT>, per <TT>de</TT>, with
   <TT>size(indexCountPDimPDe) == (/dimCount, deCount/)</TT>.
   
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Upon return this holds the associated <TT>ESMF_DELayout</TT> object.
   
</DD>
<DT><STRONG>[deCount]</STRONG></DT>
<DD>Upon return this holds the total number of DEs defined in the DELayout
   associated with the Array object.
   
</DD>
<DT><STRONG>[localDeCount]</STRONG></DT>
<DD>Upon return this holds the number of PET-local DEs defined in the
   DELayout associated with the Array object.
   
</DD>
<DT><STRONG>[localDeList]</STRONG></DT>
<DD>Upon return this holds the list of DE ids for the PET-local
   DEs defined in the DELayout associated with the Array object.
   The provided argument must be of size <TT>localDeCount</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04055900000000000000">
20.5.9 ESMF_ArrayGet - Access to Array internals per dim per local DE</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet()
   subroutine ESMF_ArrayGetPLocalDePDim(array, dim, localDe, indexCount, &amp;
     indexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in) :: array
     integer, intent(in) :: dim
     integer, intent(in) :: localDe
     integer, intent(out), optional :: indexCount
     integer, intent(out), optional :: indexList(:)
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal information per local DE, per dim.

<P>
This interface works for any number of DEs per PET.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>
   
</DD>
<DT><STRONG>dim</STRONG></DT>
<DD>Dimension for which information is requested. <TT>[1,..,dimCount]</TT>
   
</DD>
<DT><STRONG>[indexCount]</STRONG></DT>
<DD>DistGrid indexCount associated with <TT>localDe, dim</TT>.
   
</DD>
<DT><STRONG>[indexList]</STRONG></DT>
<DD>List of DistGrid patch-local indices for <TT>localDe</TT> along dimension
   <TT>dim</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040551000000000000000">
20.5.10 ESMF_ArrayGet - Access to PET-local Array patch via Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet() 
   subroutine ESMF_ArrayGetFPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(array, localDe, farrayPtr, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(in) :: array 
   integer, intent(in), optional :: localDe 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;),dimension(&lt;rank&gt;),pointer :: farrayPtr 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Access Fortran array pointer to the specified DE-local memory allocation of 
   the Array object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object. 
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>. 
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted, 
   in which case it will default to <TT>localDe=0</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Upon return, <TT>farrayPtr</TT> points to the DE-local data allocation of 
   <TT>localDe</TT> in <TT>array</TT>. It depends on the specific entry point 
   of <TT>ESMF_ArrayCreate()</TT> used during <TT>array</TT> creation, which 
   Fortran operations are supported on the returned <TT>farrayPtr</TT>. See 
   <A HREF="node4.html#Array:rest">20.3</A> for more details. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040551100000000000000">
20.5.11 ESMF_ArrayGet - Access to PET-local Array patch via LocalArray object.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet()
   subroutine ESMF_ArrayGetLarray(array, localDe, larray, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in) :: array
     integer, intent(in), optional :: localDe
     type(ESMF_LocalArray), intent(inout) :: larray
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Provide access to <TT>ESMF_LocalArray</TT> object that holds data for
   the specified local DE.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
   in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>larray</STRONG></DT>
<DD>Upon return <TT>larray</TT> refers to the DE-local data allocation of
   <TT>array</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040551200000000000000">
20.5.12 ESMF_ArrayHalo - Execute an Array halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayHalo(array, routehandle, commflag, &amp;
     finishedflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(inout)           :: array
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     type(ESMF_CommFlag),    intent(in),   optional  :: commflag
     logical,                intent(out),  optional  :: finishedflag
     logical,                intent(in),   optional  :: checkflag
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Array halo operation for <TT>array</TT>. The <TT>array</TT>
     argument must be weakly congruent and typekind conform to the Array used
     during <TT>ESMF_ArrayHaloStore()</TT>.
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
See <TT>ESMF_ArrayHaloStore()</TT> on how to precompute <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[commflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_COMM_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node2.html#opt:commflag">9.2.3</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>commflag = ESMF_COMM_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>commflag = ESMF_COMM_NBTESTFINISH</TT>, or a final call with
       <TT>commflag = ESMF_COMM_NBWAITFINISH</TT>. For all other <TT>commflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040551300000000000000">
20.5.13 ESMF_ArrayHaloRelease - Release resources associated with Array halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayHaloRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an Array halo operation. 
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040551400000000000000">
20.5.14 ESMF_ArrayHaloStore - Precompute an Array halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayHaloStore(array, routehandle, halostartregionflag, &amp;
       haloLDepth, haloUDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(inout)                :: array
     type(ESMF_RouteHandle), intent(inout)                :: routehandle
     type(ESMF_HaloStartRegionFlag), intent(in), optional :: halostartregionflag
     integer,                intent(in),         optional :: haloLDepth(:)
     integer,                intent(in),         optional :: haloUDepth(:)
     integer,                intent(out),        optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Store an Array halo operation over the data in <TT>array</TT>. By default,
     i.e. without specifying <TT>halostartregionflag</TT>, <TT>haloLDepth</TT> and
     <TT>haloUDepth</TT>, all elements in the total Array region that lie outside
     the exclusive region will be considered potential destination elements for
     halo. However, only those elements that have a corresponding halo source
     element, i.e. an exclusive element on one of the DEs, will be updated under
     the halo operation. Elements that have no associated source remain 
     unchanged under halo.

<P>
Specifying <TT>halostartregionflag</TT> allows to change the shape of the 
     effective halo region from the inside. Setting this flag to
     <TT>ESMF_REGION_COMPUTATIONAL</TT> means that only elements outside 
     the computational region of the Array are considered for potential
     destination elements for halo. The default is <TT>ESMF_REGION_EXCLUSIVE</TT>.

<P>
The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> arguments allow to reduce
     the extent of the effective halo region. Starting at the region specified
     by <TT>halostartregionflag</TT>, the <TT>haloLDepth</TT> and <TT>haloUDepth</TT>
     define a halo depth in each direction. Note that the maximum halo region is
     limited by the total Array region, independent of the actual
     <TT>haloLDepth</TT> and <TT>haloUDepth</TT> setting. The total Array region is
     local DE specific. The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> are interpreted
     as the maximum desired extent, reducing the potentially larger region
     available for halo.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayHalo()</TT> on any Array that is weakly congruent
     and typekind conform to <TT>array</TT>.
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[halostartregionflag]</STRONG></DT>
<DD>The start of the effective halo region on every DE. The default
       setting is <TT>ESMF_REGION_EXCLUSIVE</TT>, rendering all non-exclusive
       elements potential halo destination elments.
       See section <A HREF="node2.html#opt:halostartregionflag">9.2.12</A> for a complete list of
       valid settings.
     
</DD>
<DT><STRONG>[haloLDepth]</STRONG></DT>
<DD>This vector specifies the lower corner of the effective halo
       region with respect to the lower corner of <TT>halostartregionflag</TT>.
       The size of <TT>haloLDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[haloUDepth]</STRONG></DT>
<DD>This vector specifies the upper corner of the effective halo
       region with respect to the upper corner of <TT>halostartregionflag</TT>.
       The size of <TT>haloUDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040551500000000000000">
20.5.15 ESMF_ArrayPrint - Print Array internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayPrint(array, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in)              :: array
     character(len=*), intent(in),   optional  :: options
     integer,          intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>ESMF_Array</TT> object. 
<BR>
<P>
Note:  Many <TT>ESMF_&lt;class&gt;Print</TT> methods are implemented in C++.
     On some platforms/compilers there is a potential issue with interleaving
     Fortran and C++ output to <TT>stdout</TT> such that it doesn't appear in
     the expected order.  If this occurs, the <TT>ESMF_IOUnitFlush()</TT> method
     may be used on unit 6 to get coherent output.  
<BR>
<P>
The arguments are:
     <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
     
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options are not yet supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040551600000000000000">
20.5.16 ESMF_ArrayRedist - Execute an Array redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayRedist(srcArray, dstArray, routehandle, commflag, &amp;
     finishedflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(in),   optional  :: srcArray
     type(ESMF_Array),       intent(inout),optional  :: dstArray
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     type(ESMF_CommFlag),    intent(in),   optional  :: commflag
     logical,                intent(out),  optional  :: finishedflag
     logical,                intent(in),   optional  :: checkflag
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Array redistribution from <TT>srcArray</TT> to
     <TT>dstArray</TT>. Both <TT>srcArray</TT> and <TT>dstArray</TT> must be
     weakly congruent and typekind conform with the respective Arrays used 
     during <TT>ESMF_ArrayRedistStore()</TT>.
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
See <TT>ESMF_ArrayRedistStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>[dstArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[commflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_COMM_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node2.html#opt:commflag">9.2.3</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>commflag = ESMF_COMM_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>commflag = ESMF_COMM_NBTESTFINISH</TT>, or a final call with
       <TT>commflag = ESMF_COMM_NBWAITFINISH</TT>. For all other <TT>commflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040551700000000000000">
20.5.17 ESMF_ArrayRedistRelease - Release resources associated with Array redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayRedistRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an Array redistribution. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040551800000000000000">
20.5.18 ESMF_ArrayRedistStore - Precompute Array redistribution with local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayRedistStore()
   subroutine ESMF_ArrayRedistStore&lt;type&gt;&lt;kind&gt;(srcArray, dstArray, routehandle, &amp;
     factor, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),           intent(in)              :: srcArray
     type(ESMF_Array),           intent(inout)           :: dstArray
     type(ESMF_RouteHandle),     intent(inout)           :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;),   intent(in)              :: factor
     integer,                    intent(in),   optional  :: srcToDstTransposeMap(:)
     integer,                    intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="ArrayRedistStoreTK"></A>   <TT>ESMF_ArrayRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArrayRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArrayRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node4.html#ArrayRedistStoreTK">20.5.18</A> and
   <A HREF="node4.html#ArrayRedistStoreNF">20.5.19</A>, is described in the following paragraphs as a whole.

<P>
Store an Array redistribution operation from <TT>srcArray</TT> to <TT>dstArray</TT>.
   Interface <A HREF="node4.html#ArrayRedistStoreTK">20.5.18</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="node4.html#ArrayRedistStoreNF">20.5.19</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of patches within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Array, destination Array, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Arrays may differ in shape,
   however, the number of elements must match. 

<P>
If <TT>srcToDstTransposeMap</TT> is not specified the redistribution corresponds
   to an identity mapping of the sequentialized source Array to the
   sequentialized destination Array. If the <TT>srcToDstTransposeMap</TT>
   argument is provided it must be identical on all PETs. The
   <TT>srcToDstTransposeMap</TT> allows source and destination Array dimensions to
   be transposed during the redistribution. The number of source and destination
   Array dimensions must be equal under this condition and the size of mapped
   dimensions must match.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
   <TT>dstArray</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayRedist()</TT> on any pair of Arrays that are weakly congruent
     and typekind conform with the <TT>srcArray</TT>, <TT>dstArray</TT> pair. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>Factor by which to multipy source data. Default is 1.
     
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcArray</TT>. Each
       entry maps the corresponding <TT>srcArray</TT> dimension against the 
       specified <TT>dstArray</TT> dimension. Mixing of distributed and
       undistributed dimensions is supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040551900000000000000">
20.5.19 ESMF_ArrayRedistStore - Precompute Array redistribution without local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayRedistStore()
   subroutine ESMF_ArrayRedistStoreNF(srcArray, dstArray, routehandle, &amp;
     srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),           intent(in)              :: srcArray
     type(ESMF_Array),           intent(inout)           :: dstArray
     type(ESMF_RouteHandle),     intent(inout)           :: routehandle
     integer,                    intent(in),   optional  :: srcToDstTransposeMap(:)
     integer,                    intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="ArrayRedistStoreNF"></A>   <TT>ESMF_ArrayRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArrayRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArrayRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node4.html#ArrayRedistStoreTK">20.5.18</A> and
   <A HREF="node4.html#ArrayRedistStoreNF">20.5.19</A>, is described in the following paragraphs as a whole.

<P>
Store an Array redistribution operation from <TT>srcArray</TT> to <TT>dstArray</TT>.
   Interface <A HREF="node4.html#ArrayRedistStoreTK">20.5.18</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="node4.html#ArrayRedistStoreNF">20.5.19</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of patches within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Array, destination Array, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Arrays may differ in shape,
   however, the number of elements must match. 

<P>
If <TT>srcToDstTransposeMap</TT> is not specified the redistribution corresponds
   to an identity mapping of the sequentialized source Array to the
   sequentialized destination Array. If the <TT>srcToDstTransposeMap</TT>
   argument is provided it must be identical on all PETs. The
   <TT>srcToDstTransposeMap</TT> allows source and destination Array dimensions to
   be transposed during the redistribution. The number of source and destination
   Array dimensions must be equal under this condition and the size of mapped
   dimensions must match.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
   <TT>dstArray</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayRedist()</TT> on any pair of Arrays that are weakly congruent
     and typekind conform with the <TT>srcArray</TT>, <TT>dstArray</TT> pair.
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcArray</TT>. Each
       entry maps the corresponding <TT>srcArray</TT> dimension against the 
       specified <TT>dstArray</TT> dimension. Mixing of distributed and
       undistributed dimensions is supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040552000000000000000">
20.5.20 ESMF_ArrayScatter - Scatter a Fortran array across the ESMF_Array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayScatter&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(array, farray, patch, &amp; 
   rootPet, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(inout) :: array 
   mtype (ESMF_KIND_mtypekind),dimension(mdim),intent(in),target :: farray 
   integer, intent(in), optional :: patch 
   integer, intent(in) :: rootPet 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Scatter the data of <TT>farray</TT> located on <TT>rootPET</TT> 
   across an ESMF_Array object. A single <TT>farray</TT> must be 
   scattered across a single DistGrid patch in Array. The optional <TT>patch</TT> 
   argument allows selection of the patch. For Arrays defined on a single 
   patch DistGrid the default selection (patch 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the patch in Array. 

<P>
If the Array contains replicating DistGrid dimensions data will be 
   scattered across all of the replicated pieces. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object across which data will be scattered. 
   
</DD>
<DT><STRONG>[farray]</STRONG></DT>
<DD>The Fortran array that is to be scattered. Only root 
   must provide a valid <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[patch]</STRONG></DT>
<DD>The DistGrid patch in <TT>array</TT> into which to scatter <TT>farray</TT>. 
   By default <TT>farray</TT> will be scattered into patch 1. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid data in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040552100000000000000">
20.5.21 ESMF_ArraySet - Set Array properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySet(array, name, computationalLWidth, &amp;
     computationalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),   intent(inout)           :: array
     character(len = *), intent(in),   optional  :: name
     integer,            intent(in),   optional  :: computationalLWidth(:,:)
     integer,            intent(in),   optional  :: computationalUWidth(:,:)
     integer,            intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets adjustable settings in an <TT>ESMF_Array</TT> object. Arrays with
       tensor dimensions will set values for <EM>all</EM> tensor components.

<P>
The arguments are:
       <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object for which to set properties.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The Array name.
       
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This argument must have of size <TT>(dimCount, localDeCount)</TT>.
         <TT>computationalLWidth</TT> specifies the lower corner of the
         computational region with respect to the lower corner of the exclusive
         region for all local DEs.
       
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This argument must have of size <TT>(dimCount, localDeCount)</TT>.
         <TT>computationalUWidth</TT> specifies the upper corner of the
         computational region with respect to the upper corner of the exclusive
         region for all local DEs.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040552200000000000000">
20.5.22 ESMF_ArraySMM - Execute an Array sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySMM(srcArray, dstArray, routehandle, commflag, &amp;
     finishedflag, zeroflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(in),   optional  :: srcArray
     type(ESMF_Array),       intent(inout),optional  :: dstArray
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     type(ESMF_CommFlag),    intent(in),   optional  :: commflag
     logical,                intent(out),  optional  :: finishedflag
     type(ESMF_RegionFlag),  intent(in),   optional  :: zeroflag
     logical,                intent(in),   optional  :: checkflag
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Array sparse matrix multiplication from <TT>srcArray</TT>
     to <TT>dstArray</TT>. Both <TT>srcArray</TT> and <TT>dstArray</TT> must be weakly
     congruent and typekind conform to the respective Arrays used during 
     <TT>ESMF_ArraySMMStore()</TT>.
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the size of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, is permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
See <TT>ESMF_ArraySMMStore()</TT> on how to precompute 
     <TT>routehandle</TT>. See section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the
     operation <TT>ESMF_ArraySMM()</TT> performs.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>[dstArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[commflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_COMM_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node2.html#opt:commflag">9.2.3</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>commflag = ESMF_COMM_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>commflag = ESMF_COMM_NBTESTFINISH</TT>, or a final call with
       <TT>commflag = ESMF_COMM_NBWAITFINISH</TT>. For all other <TT>commflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[zeroflag]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstArray</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstArray</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroflag</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination Array that will be updated by the sparse matrix
       multiplication. See section <A HREF="node2.html#opt:regionflag">9.2.13</A> for a complete list of
       valid settings.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040552300000000000000">
20.5.23 ESMF_ArraySMMRelease - Release resources associated with Array sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySMMRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an Array sparse matrix multiplication. 
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040552400000000000000">
20.5.24 ESMF_ArraySMMStore - Precompute Array sparse matrix multiplication with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStore&lt;type&gt;&lt;kind&gt;(srcArray, dstArray, &amp;
     routehandle, factorList, factorIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),           intent(in)              :: srcArray
     type(ESMF_Array),           intent(inout)           :: dstArray
     type(ESMF_RouteHandle),     intent(inout)           :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)        :: factorList(:)
     integer,                    intent(in)              :: factorIndexList(:,:)
     integer,                    intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="ArraySMMStoreTK"></A>   <TT>ESMF_ArraySMMStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArraySMMStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArraySMMStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node4.html#ArraySMMStoreTK">20.5.24</A> and
   <A HREF="node4.html#ArraySMMStoreNF">20.5.25</A>, is described in the following paragraphs as a whole.

<P>
Store an Array sparse matrix multiplication operation from <TT>srcArray</TT>
     to <TT>dstArray</TT>. PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of patches within the DistGrid or by user-supplied arbitrary
     sequence indices. See section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the
     definition of <EM>sequence indices</EM>.

<P>
Source and destination Arrays, as well as the supplied <TT>factorList</TT>
     argument, may be of different &lt;type&gt;&lt;kind&gt;. Further source and
     destination Arrays may differ in shape and number of elements.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArraySMM()</TT> on any pair of Arrays that are weakly congruent
     and typekind conform with the <TT>srcArray</TT>, <TT>dstArray</TT> pair. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the size of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, is permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This method is overloaded for:
<BR>
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.
     
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the <TT>srcArray</TT> while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in <TT>dstArray</TT>. For this format to be a valid
       option source and destination Arrays must have matching number of
       tensor elements (the product of the sizes of all Array tensor dimensions).
       Under this condition an identiy matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the <TT>srcArray</TT>. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the <TT>dstArray</TT>.

<P>
See section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the definition of 
       Array <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040552500000000000000">
20.5.25 ESMF_ArraySMMStore - Precompute Array sparse matrix multiplication without local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStoreNF(srcArray, dstArray, routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),           intent(in)              :: srcArray
     type(ESMF_Array),           intent(inout)           :: dstArray
     type(ESMF_RouteHandle),     intent(inout)           :: routehandle
     integer,                    intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="ArraySMMStoreNF"></A>   <TT>ESMF_ArraySMMStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArraySMMStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArraySMMStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node4.html#ArraySMMStoreTK">20.5.24</A> and
   <A HREF="node4.html#ArraySMMStoreNF">20.5.25</A>, is described in the following paragraphs as a whole.

<P>
Store an Array sparse matrix multiplication operation from <TT>srcArray</TT>
     to <TT>dstArray</TT>. PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of patches within the DistGrid or by user-supplied arbitrary
     sequence indices. See section <A HREF="node4.html#Array:SparseMatMul">20.2.16</A> for details on the
     definition of <EM>sequence indices</EM>.

<P>
Source and destination Arrays, as well as the supplied <TT>factorList</TT>
     argument, may be of different &lt;type&gt;&lt;kind&gt;. Further source and
     destination Arrays may differ in shape and number of elements.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArraySMM()</TT> on any pair of Arrays that are weakly congruent
     and typekind conform with the <TT>srcArray</TT>, <TT>dstArray</TT> pair. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the size of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, is permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040552600000000000000">
20.5.26 ESMF_ArrayValidate - Validate Array internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayValidate(array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in)              :: array
     integer,          intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>Array</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Specified <TT>ESMF_Array</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION04060000000000000000">
21 LocalArray Class</A>
</H1>

<P>

<H2><A NAME="SECTION04061000000000000000">
21.1 Description</A>
</H2>

<P>
The <TT>ESMF_LocalArray</TT> class provides a language independent representation of data in array format. One of the major functions of the LocalArray class is to bridge the Fortran/C/C++ language difference that exists with respect to array representation. All ESMF Field and Array data is internally stored in ESMF LocalArray objects allowing transparent access from Fortran and C/C++.

<P>
In the ESMF Fortran API the LocalArray becomes visible in those cases where a local PET may be associated with multiple pieces of an Array, e.g. if there are multiple DEs associated with a single PET. The Fortran language standard does not provide an array of arrays construct, however arrays of derived types holding arrays are possible. ESMF calls use arguments that are of type <TT>ESMF_LocalArray</TT> with <TT>dimension</TT> attribute where necessary.

<P>

<H2><A NAME="SECTION04062000000000000000">
21.2 Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI>The TKR (type/kind/rank) overloaded LocalArray interfaces declare the dummy Fortran array arguments with the pointer attribute. The advantage of doing this is that it allows ESMF to inquire information about the provided Fortran array. The disadvantage of this choice is that actual Fortran arrays passed into these interfaces <EM>must</EM> also be defined with pointer attribute in the user code.
</LI>
</UL>

<P>

<H2><A NAME="SECTION04063000000000000000">
21.3 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04063100000000000000">
21.3.1 ESMF_LocalArrayCreate - Create a LocalArray explicitly specifying TKR arguments.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate()
   function ESMF_LocalArrayCreateByTKR(rank, typekind, counts, lbounds, &amp;
     ubounds, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_LocalArray) :: ESMF_LocalArrayCreateByTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, intent(in) :: rank
     type(ESMF_TypeKind), intent(in) :: typekind
     integer, intent(in), optional :: counts(:)
     integer, intent(in), optional :: lbounds(:)
     integer, intent(in), optional :: ubounds(:)
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_LocalArray</TT> and allocate data space, which remains
   uninitialized. The return value is a new LocalArray.

<P>
The arguments are:
   <DL>
<DT><STRONG>rank</STRONG></DT>
<DD>Array rank (dimensionality, 1D, 2D, etc). Maximum allowed is 7D.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>Array typekind. See section <A HREF="node2.html#opt:typekind">9.3.1</A> for valid values.
   
</DD>
<DT><STRONG>[counts]</STRONG></DT>
<DD>The number of items in each dimension of the array. This is a 1D
   integer array the same length as the rank. The <TT>count</TT> argument may
   be omitted if both <TT>lbounds</TT> and <TT>ubounds</TT> arguments are present.
   
</DD>
<DT><STRONG>[lbounds]</STRONG></DT>
<DD>An integer array of length rank, with the lower index for each dimension.
   
</DD>
<DT><STRONG>[ubounds]</STRONG></DT>
<DD>An integer array of length rank, with the upper index for each dimension.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04063200000000000000">
21.3.2 ESMF_LocalArrayCreate - Create a LocalArray specifying an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate()
   function ESMF_LocalArrayCreateBySpec(arrayspec, counts, lbounds, ubounds, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_LocalArray) :: ESMF_LocalArrayCreateBySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(inout) :: arrayspec
     integer, intent(in), optional :: counts(:)
     integer, intent(in), optional :: lbounds(:)
     integer, intent(in), optional :: ubounds(:)
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_LocalArray</TT> and allocate data space, which remains
   uninitialized. The return value is a new LocalArray.

<P>
The arguments are:
   <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>ArraySpec object specifying typekind and rank.
   
</DD>
<DT><STRONG>[counts]</STRONG></DT>
<DD>The number of items in each dimension of the array. This is a 1D
   integer array the same length as the rank. The <TT>count</TT> argument may
   be omitted if both <TT>lbounds</TT> and <TT>ubounds</TT> arguments are present.
   
</DD>
<DT><STRONG>[lbounds]</STRONG></DT>
<DD>An integer array of length rank, with the lower index for each dimension.
   
</DD>
<DT><STRONG>[ubounds]</STRONG></DT>
<DD>An integer array of length rank, with the upper index for each dimension.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04063300000000000000">
21.3.3 ESMF_LocalArrayCreate - Create a LocalArray from existing one</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate()
   function ESMF_LocalArrayCreateCopy(larray, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_LocalArray) :: ESMF_LocalArrayCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocalArray), intent(in) :: larray
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Perform a deep copy of an existing <TT>ESMF_LocalArray</TT> object. The return
   value is a new LocalArray.

<P>
The arguments are:
   <DL>
<DT><STRONG>larray</STRONG></DT>
<DD>Existing LocalArray to be copied.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04063400000000000000">
21.3.4 ESMF_LocalArrayCreate - Create a LocalArray from a Fortran pointer (associated or unassociated) </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate() 
   function ESMF_LocalArrCreateByPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(fptr, docopy, counts, &amp; 
   lbounds, ubounds, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_LocalArray) :: ESMF_LocalArrCreateByPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: fptr 
   type(ESMF_CopyFlag), intent(in), optional :: docopy 
   integer, intent(in), optional :: counts(:) 
   integer, intent(in), optional :: lbounds(:) 
   integer, intent(in), optional :: ubounds(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates an <TT>ESMF_LocalArray</TT> based on a Fortran array pointer. 
   Two cases must be distinguished. 

<P>
First, if <TT>fptr</TT> is associated 
   the optional <TT>docopy</TT> argument may be used to indicate whether the 
   associated data is to be copied or referenced. For associated <TT>fptr</TT> 
   the optional <TT>counts</TT>, <TT>lbounds</TT> and <TT>ubounds</TT> arguments need 
   not be specified. However, all present arguments will be checked against 
   <TT>fptr</TT> for consistency. 

<P>
Second, if <TT>fptr</TT> is unassociated the optional argument <TT>docopy</TT> 
   must not be specified. However, in this case a complete set of counts and 
   bounds information must be provided. Any combination of present <TT>counts</TT> 
   <TT>lbounds</TT> and <TT>ubounds</TT> arguments that provides a complete 
   specification is valid. All input information will be checked for 
   consistency. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>fptr</STRONG></DT>
<DD>A Fortran array pointer (associated or unassociated). 
   
</DD>
<DT><STRONG>[docopy]</STRONG></DT>
<DD>Indicate copy vs. reference behavior in case of associated <TT>fptr</TT>. 
   This argument must <EM>not</EM> be present for unassociated <TT>fptr</TT>. 
   Default to <TT>ESMF_DATA_REF</TT>, makes the <TT>ESMF_LocalArray</TT> 
   reference the associated data array. If set to <TT>ESMF_DATA_COPY</TT> this 
   routine allocates new memory and copies the data from the pointer into 
   the new LocalArray allocation. 
   
</DD>
<DT><STRONG>[counts]</STRONG></DT>
<DD>The number of items in each dimension of the array. This is a 1D 
   integer array the same length as the rank. The <TT>count</TT> argument may 
   be omitted if both <TT>lbounds</TT> and <TT>ubounds</TT> arguments are present. 
   
</DD>
<DT><STRONG>[lbounds]</STRONG></DT>
<DD>An integer array of lower index values. Must be the same length as the rank. 
   
</DD>
<DT><STRONG>[ubounds]</STRONG></DT>
<DD>An integer array of upper index values. Must be the same length as the rank. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04063500000000000000">
21.3.5 ESMF_LocalArrayDestroy - Destroy a LocalArray object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_LocalArrayDestroy(larray, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocalArray), intent(inout) :: larray
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Releases all resources associated with this <TT>ESMF_LocalArray</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>larray</STRONG></DT>
<DD>Destroy contents of this <TT>ESMF_LocalArray</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04063600000000000000">
21.3.6 ESMF_LocalArrayGet - Return LocalArray information.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayGet()
   subroutine ESMF_LocalArrayGetDefault(larray, rank, typekind, counts, lbounds, &amp;
     ubounds, base, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocalArray), intent(in) :: larray
     integer, intent(out), optional :: rank
     type(ESMF_TypeKind), intent(out), optional :: typekind
     integer, intent(out), optional :: counts(:)
     integer, intent(out), optional :: lbounds(:)
     integer, intent(out), optional :: ubounds(:)
     type(ESMF_Pointer), intent(out), optional :: base
     character(len=ESMF_MAXSTR), intent(out), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns information about the <TT>ESMF_LocalArray</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>larray</STRONG></DT>
<DD>Queried <TT>ESMF_LocalArray</TT> object.
   
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>Rank of the LocalArray object.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>TypeKind of the LocalArray object.
   
</DD>
<DT><STRONG>[counts]</STRONG></DT>
<DD>Count per dimension.
   
</DD>
<DT><STRONG>[lbounds]</STRONG></DT>
<DD>Lower bound per dimension.
   
</DD>
<DT><STRONG>[ubounds]</STRONG></DT>
<DD>Upper bound per dimension.
   
</DD>
<DT><STRONG>[base]</STRONG></DT>
<DD>Base class object.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the LocalArray object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04063700000000000000">
21.3.7 ESMF_LocalArrayGet - Get access to data in LocalArray object </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayGet() 
   subroutine ESMF_LocalArrayGetData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(larray, fptr, docopy, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocalArray) :: larray 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: fptr 
   type(ESMF_CopyFlag), intent(in), optional :: docopy 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return a Fortran pointer to the data buffer, or return a Fortran pointer 
   to a new copy of the data. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>larray</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> to get the value from. 
   
</DD>
<DT><STRONG>fptr</STRONG></DT>
<DD>An unassociated or associated Fortran pointer correctly allocated.
   
</DD>
<DT><STRONG>[docopy]</STRONG></DT>
<DD>An optional copy flag which can be specified. 
   Can either make a new copy of the data or reference existing data. 
   See section <A HREF="node2.html#opt:copyflag">9.2.5</A> for a list of possible values. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<P>

<P>

<H1><A NAME="SECTION04070000000000000000">
22 ArraySpec Class</A>
</H1>

<P>

<H2><A NAME="SECTION04071000000000000000">
22.1 Description</A>
</H2>

<P>
An ArraySpec is a very simple class that contains type, kind, and
rank information about an array.  This information is stored in two
parameters.  <B>TypeKind</B> describes the data type of the elements
in the array and their precision.  <B>Rank</B> is the number of dimensions
in the array.

<P>
The only methods that are associated with the ArraySpec class are those 
that allow you to set and retrieve this information.

<P>

<P>

<H2><A NAME="SECTION04072000000000000000">
22.2 Use and Examples</A>
</H2>

<P>
The ArraySpec is passed in as an argument at Field and 
FieldBundle creation in order to describe an Array that will 
be allocated or attached at a later time.  There are any
number of situations in which this approach is useful.  
One common example is a case in which the user wants to create
a very flexible export State with many diagnostic variables 
predefined, but only a subset desired and consequently 
allocated for a particular run.  

<P>

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_ArraySpecEx - ArraySpec manipulation examples
!
! !DESCRIPTION:
!
! This program shows examples of ArraySpec set and get usage
!-----------------------------------------------------------------------------

      ! ESMF Framework module
      use ESMF_Mod
      implicit none

      ! local variables 
      type(ESMF_ArraySpec) :: arrayDS
      integer :: myrank
      type(ESMF_TypeKind) :: mytypekind


      ! return code
      integer:: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(rc=rc)
</PRE>

<P>

<P>

<H3><A NAME="SECTION04072100000000000000">
22.2.1 Setting ArraySpec Values</A>
</H3>

<P>
This example shows how to set values in an <TT>ESMF_ArraySpec</TT>. 

<P>
<PRE>
      call ESMF_ArraySpecSet(arrayDS, rank=2, &amp;
                             typekind=ESMF_TYPEKIND_R8, rc=rc)
</PRE>

<P>

<P>

<H3><A NAME="SECTION04072200000000000000">
22.2.2 Getting ArraySpec Values</A>
</H3>

<P>
This example shows how to query an <TT>ESMF_ArraySpec</TT>. 

<P>
<PRE>
      call ESMF_ArraySpecGet(arrayDS, myrank, mytypekind, rc)
      print *, "Returned values from ArraySpec:"
      print *, "rank =", myrank
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_ArraySpecEx
</PRE>

<P>

<P>

<H2><A NAME="SECTION04073000000000000000">
22.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limit on rank.</B>  The values for type, kind and rank passed 
into the ArraySpec
class are subject to the same limitations as Arrays.  The maximum
array rank is 7, which is the highest rank supported by Fortran.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION04074000000000000000">
22.4 Design and Implementation Notes</A>
</H2>

<P>
The information contained in an <TT>ESMF_ArraySpec</TT> is used to create 
<TT>ESMF_Array</TT> objects. 

<P>
<TT>ESMF_ArraySpec</TT> is a shallow class, and only set and get methods
are needed.  They do not need to be created or destroyed.

<P>

<H2><A NAME="SECTION04075000000000000000">
22.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04075100000000000000">
22.5.1 ESMF_ArraySpecGet - Get values from an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecGet(arrayspec, rank, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(inout)         :: arrayspec
     integer,              intent(out), optional :: rank
     type(ESMF_TypeKind),  intent(out), optional :: typekind
     integer,              intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns information about the contents of an <TT>ESMF_ArraySpec</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>The <TT>ESMF_ArraySpec</TT> to query.
   
</DD>
<DT><STRONG>rank</STRONG></DT>
<DD>Array rank (dimensionality - 1D, 2D, etc). Maximum possible is 7D.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>Array typekind.  See section <A HREF="node2.html#opt:typekind">9.3.1</A> for valid values.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04075200000000000000">
22.5.2 ESMF_ArraySpecSet - Set values for an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecSet(arrayspec, rank, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(inout)         :: arrayspec
     integer,              intent(in)            :: rank
     type(ESMF_TypeKind),  intent(in)            :: typekind
     integer,              intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a description of the data - the typekind, the rank,
   and the dimensionality.

<P>
The arguments are:
   <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>The <TT>ESMF_ArraySpec</TT> to set.
   
</DD>
<DT><STRONG>rank</STRONG></DT>
<DD>Array rank (dimensionality - 1D, 2D, etc). Maximum allowed is 7D.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>Array typekind.  See section <A HREF="node2.html#opt:typekind">9.3.1</A> for valid values.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04075300000000000000">
22.5.3 ESMF_ArraySpecValidate - Validate ArraySpec internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecValidate(arrayspec, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(inout)              :: arrayspec
     integer,              intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>arrayspec</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Specified <TT>ESMF_ArraySpec</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04075400000000000000">
22.5.4 ESMF_ArraySpecPrint - Print information of ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecPrint(arrayspec, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(in)              :: arrayspec
     integer, intent(out), optional                :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Print ArraySpec internals. 
<BR>
<P>
Note:  Many <TT>ESMF_&lt;class&gt;Print</TT> methods are implemented in C++.
       On some platforms/compilers there is a potential issue with interleaving
       Fortran and C++ output to <TT>stdout</TT> such that it doesn't appear in
       the expected order.  If this occurs, the <TT>ESMF_IOUnitFlush()</TT> method
       may be used on unit 6 to get coherent output.  
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Specified <TT>ESMF_ArraySpec</TT> object.
       
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION04080000000000000000">
23 Grid Class</A>
</H1>

<P>

<H2><A NAME="SECTION04081000000000000000">
23.1 Description</A>
</H2>

<P>
The ESMF Grid class is used to describe the geometry and discretization
of logically rectangular physical grids.  It also contains the
description of the grid's underlying topology and the decomposition
of the physical grid across the available computational resources.
The most frequent use of the Grid class is to describe physical grids
in user code so that sufficient information is available to perform ESMF
methods such as regridding.  

<P>
In the current release (v3.1.0)
the functionality in this class is partially implemented.  
Multi-tile grids are not supported, and edge connectivities 
are not implemented and default to aperiodic.  
Other constraints of the current
implementation are noted in the usage section and in the API
descriptions.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Representation of grids formed by logically rectangular regions,
including uniform and rectilinear grids (e.g. lat-lon grids),
curvilinear grids (e.g. displaced pole grids), and grids formed
by connected logically rectangular regions (e.g. cubed sphere grids)
[CONNECTED REGIONS ARE NOT YET SUPPORTED].</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for 1D, 2D, 3D, and higher dimension grids.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Distribution of grids across computational resources for parallel
operations - users set which grid dimensions are distributed.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Grids can be created already distributed, so that no single
resource needs global information during the creation process.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options to define periodicity and other edge connectivities either 
explicitly or implicitly via shape shortcuts [EDGE CONNECTIVITIES
CURRENTLY DEFAULT TO APERIODIC BOUNDS].</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for users to define grid coordinates themselves or call
prefabricated coordinate generation routines for standard grids
[NO GENERATION ROUTINES YET].</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for incremental construction of grids.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for using a set of pre-defined stagger locations or for setting
custom stagger locations.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION04081100000000000000">
23.1.1 Grid Representation in ESMF</A>
</H3>

<P>
ESMF Grids are based on the concepts described in <I>A Standard
Description of Grids Used in Earth System Models</I> [Balaji 2006].  In this document
Balaji introduces the mosaic concept as a means of describing
a wide variety of Earth system model grids.  A <B>mosaic</B> is
composed of grid tiles connected at their edges.  Mosaic grids
includes simple, single tile grids as a special case.  

<P>
The ESMF Grid class is a representation of a mosaic grid.  Each ESMF
Grid is constructed of one or more logically rectangular <B>Tiles</B>.
A Tile will usually have some physical significance (e.g. the region
of the world covered by one face of a cubed sphere grid).

<P>
The piece of a Tile that resides on one DE (for simple cases, a DE
can be thought of as a processor - see section on the DELayout)
is called a <B>LocalTile</B>.  For example, the six faces of a cubed
sphere grid are each Tiles, and each Tile can be divided into many
LocalTiles.  

<P>
Every ESMF Grid contains a DistGrid object, which defines the Grid's
index space, topology, distribution, and connectivities.  It enables
the user to define the complex edge relationships of tripole and other
grids.  The DistGrid can be created explicitly and passed into a Grid
creation routine, or it can be created implicitly if the user takes
a Grid creation shortcut.  Options for grid creation are described in 
more detail in section <A HREF="node4.html#sec:gridcreateoptions">23.1.8</A>. The DistGrid used
in Grid creation describes the properties of the Grid cells. In addition
to this one, the Grid internally creates DistGrids for each stagger location. 
These stagger DistGrids are related to the original DistGrid, but may 
contain extra padding to represent the extent of the index space of
the stagger. These DistGrids are what are used when a Field is created 
on a Grid. 

<P>

<H3><A NAME="SECTION04081200000000000000">
23.1.2 Supported Grids</A>
</H3>

<P>
The range of supported grids in ESMF can be defined by:

<UL>
<LI>Types of topologies and shapes supported.  ESMF supports one or
more logically rectangular grid Tiles with connectivities specified
between cells.  For more details see section <A HREF="node4.html#sec:ShapeShortcut">23.1.3</A>.
</LI>
<LI>Types of distributions supported.  ESMF supports  regular,
irregular, or arbitrary distributions of data.  
For more details see section <A HREF="node4.html#sec:desc:dist">23.1.4</A>.
</LI>
<LI>Types of coordinates supported.  ESMF supports uniform, rectilinear,
and curvilinear coordinates.  For more details see section <A HREF="node4.html#sec:coordspec">23.1.5</A>.
</LI>
</UL>

<P>

<H3><A NAME="SECTION04081300000000000000"></A>
<A NAME="sec:ShapeShortcut"></A>
<BR>
23.1.3 Grid Topologies and Periodicity
</H3>
ESMF has shortcuts for the creation of standard Grid topologies 
or <B>shapes</B> up to 3D.  In many cases, these enable the user to
bypass the step of creating a DistGrid before creating the Grid.  The basic call is 
<TT>ESMF_GridCreateShapeTile()</TT>.  With this call, the user can specify for
each dimension whether there is no connection, it is periodic, it
is a pole, or it is a bipole.  The assumed connectivities for poles and
bipoles are described in section <A HREF="node4.html#sec:opt:gridconn">23.5.1</A>.  Connectivities
are specified using the ESMF_GridConn parameter, which has values
such as ESMF_GRIDCONN_PERIODIC.

<P>
The table below shows the ESMF_GridConn settings used to create 
standard shapes in 2D using the ESMF_GridCreateShapeTile() call.  Two values
are specified for each dimension, one for the low end and one for 
the high end of the dimension's index values.  Note that connectivities
have not been implemented as of v4.0.0 and default to aperiodic bounds.

<P>

<P>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">2D Shape</TD>
<TD ALIGN="CENTER"><B>connDim1(1)</B></TD>
<TD ALIGN="CENTER"><B>connDim1(2)</B></TD>
<TD ALIGN="CENTER"><B>connDim2(1)</B></TD>
<TD ALIGN="CENTER"><B>connDim2(2)</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Rectangle</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Bipole Sphere</B></TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Tripole Sphere</B></TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">BIPOLE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Cylinder</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Torus</B></TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
</TABLE>

<P>
<BR>

<P>
If the user's grid shape is too complex for an ESMF shortcut routine,
or involves more than three dimensions, a DistGrid can be created
to specify the shape in detail.  This DistGrid is then passed
into a Grid create call.

<P>

<H3><A NAME="SECTION04081400000000000000"></A>
<A NAME="sec:desc:dist"></A>
<BR>
23.1.4 Grid Distribution
</H3>

<P>
ESMF Grids have several options for data distribution (also referred to
as decomposition).  As ESMF Grids are cell based, these 
options are all specified  in terms of how the cells in the Grid
are broken up between DEs. 

<P>
The main distribution options are regular, irregular, and arbitrary.
A <B>regular</B> distribution is one in which the same number of
contiguous grid cells are assigned to each DE in the
distributed dimension.  A <B>irregular</B> distribution is one in which
unequal numbers of contiguous grid cells are assigned to each
DE in the distributed dimension.  An <B>arbitrary</B> distribution is
one in which any grid cell can be assigned to any DE.  Any of these
distribution options can be applied to any of the grid shapes (i.e.,
rectangle) or types (i.e., rectilinear).  Support for arbitrary distribution 
is limited in v4.0.0, See section <A HREF="node4.html#example:ArbGridWithUndistDim">23.2.6</A> for
more detail descriptions.

<P>
Figure <A HREF="node4.html#fig:GridDecomps">12</A> illustrates options for distribution.

<DIV ALIGN="CENTER"><A NAME="fig:GridDecomps"></A><A NAME="28291"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 12:</STRONG>
Examples of regular and irregular decomposition of
a grid <B>a</B> that is 6x6, and an arbitrary decomposition of
a grid <B>b</B> that is 6x3.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{GridDecomps}}$
 -->
<IMG
 WIDTH="726" HEIGHT="220" ALIGN="BOTTOM" BORDER="0"
 SRC="img52.png"
 ALT="\scalebox{0.9}{\includegraphics{GridDecomps}}"></TD></TR>
</TABLE>
</DIV>

<P>
A distribution can also be specified using the DistGrid, by passing
object into a Grid create call.

<P>

<H3><A NAME="SECTION04081500000000000000"></A>
<A NAME="sec:coordspec"></A>
<BR>
23.1.5 Grid Coordinates
</H3>
Grid Tiles can have uniform, rectilinear, or curvilinear
coordinates.  The coordinates of <B>uniform</B> grids are equally spaced along
their axes, and can be fully specified by the coordinates of the two opposing points
that define the grid's physical span.  The coordinates of <B>rectilinear</B> grids
are unequally spaced along their axes, and can be fully specified by giving
the spacing of grid points along each axis.  The coordinates of <B>curvilinear 
grids</B> must be specified by giving the explicit set of coordinates for each
grid point.  Curvilinear grids are often uniform or rectilinear grids that 
have been warped; for example, to place a pole over a land mass so that it
does not affect the computations performed on an ocean model grid.  Figure
<A HREF="node4.html#fig:LogRectGrids">13</A> shows examples of each type of grid.

<P>
Any of these logically rectangular grid types can be combined through edge
connections to form a mosaic.  Cubed sphere and yin-yang grids are examples
of mosaic grids.  Note that as of v4.0.0 multi-tile grids have not yet been
implemented.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:LogRectGrids"></A><A NAME="28222"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 13:</STRONG>
Types of logically rectangular grid tiles.  Red circles show the
values needed to specify grid coordinates for each type.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{LogRectGrids}}$
 -->
<IMG
 WIDTH="726" HEIGHT="219" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.png"
 ALT="\scalebox{0.9}{\includegraphics{LogRectGrids}}"></TD></TR>
</TABLE>
</DIV>

<P>
Each of these coordinate types can be set for each of the standard grid shapes
described in section <A HREF="node4.html#sec:ShapeShortcut">23.1.3</A>.  

<P>
The table below shows how examples of common single Tile grids fall 
into this shape and coordinate taxonomy.  Note that any
of the grids in the table can have a regular or arbitrary distribution.

<P>

<P>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122><B>Uniform</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122><B>Rectilinear</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122><B>Curvilinear</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65><B>Sphere</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Global uniform lat-lon grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Gaussian grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Displaced pole grid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65><B>Rectangle</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Regional uniform lat-lon grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Gaussian grid section</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Polar stereographic grid section</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION04081600000000000000">
23.1.6 Coordinate Specification and Generation</A>
</H3>

<P>
There are two ways of specifying coordinates in ESMF.  The
first way is for the user to <B>set</B> the coordinates.  The second 
way is to take a shortcut and have the framework <B>generate</B>
the coordinates.  

<P>
No ESMF generation routines are currently available.

<P>
See Section&nbsp;<A HREF="node4.html#sec:usage:staggerloc">23.2.8</A> for more description and examples of
setting coordinates.

<P>

<H3><A NAME="SECTION04081700000000000000">
23.1.7 Staggering</A>
</H3>

<P>
<B>Staggering</B> is a finite difference technique in which the values 
of different physical quantities are placed at different locations
within a grid cell. 

<P>
The ESMF Grid class supports a variety of stagger locations, including
cell centers, corners, and edge centers. The default stagger location in 
ESMF is the cell center, and cell counts in Grid are based on this assumption.
Combinations of the 2D ESMF stagger locations are sufficient to specify any of the
Arakawa staggers.  ESMF also supports staggering in 3D and higher dimensions.
There are shortcuts for standard staggers, and interfaces through which users 
can create custom staggers.  

<P>
As a default the ESMF Grid class provides symmetric staggering, so
that cell centers are enclosed by cell perimeter (e.g. corner) 
stagger locations. This means the coordinate arrays for stagger
locations other than the center will have an additional element of 
padding in order to enclose the cell center locations.
However, to achieve other types of staggering, the user may alter 
or eliminate this padding by using the appropriate options when adding
coordinates to a Grid. 

<P>
In v4.0.0, only the cell center stagger location is supported for an
arbitrarily distributed grid. For examples and a full description of the stagger interface 
see Section&nbsp;<A HREF="node4.html#sec:usage:staggerloc">23.2.8</A>. 

<P>

<H3><A NAME="SECTION04081800000000000000"></A>
<A NAME="sec:gridcreateoptions"></A>
<BR>
23.1.8 Options for Building Grids
</H3>

<P>
ESMF Grid objects must represent a wide range of grid types 
and use cases, some of them quite complex.  As a result, multiple
ways to build Grid objects are required.  This section describes
the stages to building Grids, the options for each stage, and 
typical calling sequences.

<P>
In ESMF there are two main stages to building Grids.  The
<TT>ESMF_GridStatus</TT> value stored within the Grid object reflects
the stage the Grid has attained (see Section&nbsp;<A HREF="node4.html#sec:opt:gridstatus">23.5.2</A>).
These stages are:

<P>

<OL>
<LI>Create the Grid topology or shape.  At the completion of this
stage, the Grid has a specific topology and distribution, but
empty coordinate arrays.  The Grid can be used as the basis for
allocating a Field. Its <TT>ESMF_GridStatus</TT> parameter has 
a value of <TT>ESMF_GRIDSTATUS_SHAPE_READY</TT>.  

<P>
The options for specifying the Grid shape are:

<UL>
<LI>Use the <TT>ESMF_GridCreateShapeTile()</TT> shortcut method to 
specify the Grid size and dimension, and to select from a limited set
of edge connectivities.   
</LI>
<LI>Create a DistGrid using the <TT>ESMF_DistGridCreate()</TT>
method.  This enables the user to specify connectivities in 
greater detail than using <TT>ESMF_GridCreateShapeTile()</TT>.  Then
pass the DistGrid into a general <TT>ESMF_GridCreate()</TT> method.
</LI>
</UL>

<P>
</LI>
<LI>Specify the Grid coordinates and any other information
required for regridding (this can vary depending on the particular
regridding method).  At the completion of this stage, the Grid can
be used in a regridding operation (once Grid is connected to regrid;
as of v3.1.0, it is not).  Its <TT>ESMF_GridStatus</TT>
has a value of <TT>ESMF_GRIDSTATUS_REGRID_READY</TT>.
</LI>
</OL>

<P>
When creating the Grid shape and specifying the Grid coordinates,
the user can either specify all required information at once,
or can provide information incrementally.  The call
<TT>ESMF_GridCreateEmpty()</TT> builds a Grid object
container that can be filled in with a subsequent call to 
the <TT>ESMF_GridSetCommitShapeTile()</TT> method. 
The <TT>ESMF_GridSetCommitShapeTile()</TT> creates the 
grid and sets the appropriate flag to indicate that
its usable (the status equals <TT>ESMF_GRIDSTATUS_SHAPE_READY</TT>
after the commit). The Grid is implicitly in a valid state after being committed. 

<P>
For consistency's sake the <TT>ESMF_GridSetCommitShapeTile()</TT>
call must occur on the same or a subset of the PETs as the
<TT>ESMF_GridCreateEmpty()</TT> call. The 
<TT>ESMF_GridSetCommitShapeTile()</TT> call uses the VM for
the context in which it's executed and the "empty" Grid contains
no information about the VM in which it was run.  If the
<TT>ESMF_GridSetCommitShapeTile()</TT> call occurs
in a subset of the PETs in which the <TT>ESMF_GridCreateEmpty()</TT> was 
executed, the Grid is created only in that subset. The grid objects outside the subset will
still be "empty" and not usable. 

<P>
The following table summarizes possible call sequences
for building Grids.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><B>Create Shape</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>From shape shortcut</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>grid = ESMF_GridCreateShapeTile(...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>Using DistGrid with general create interface</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>distgrid = ESMF_DistGridCreate(...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>grid = ESMF_GridCreate(distgrid, ...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>Incremental</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>grid = ESMF_GridCreateEmpty(...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>call ESMF_GridSetCommitShapeTile(grid, ...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Set Coordinates</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>Set coordinates by copy or reference</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>call ESMF_GridSetCoord(grid, ...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>Retrieve ESMF Array of coordinates from Grid and set values</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>call ESMF_GridGetCoord(grid, esmfArray, ...), set values</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>Retrieve local bounds and native array from Grid and set values</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>call ESMF_GridGetCoord(grid, lbound, ubound, array), set values</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION04082000000000000000">
23.2 Use and Examples</A>
</H2>

<P>
This section describes the use of the ESMF Grid class. It first discusses
the more user friendly shape specific interface to the Grid. 
During this discussion it covers creation and options, 
adding stagger locations, coordinate data access, and other grid 
functionality. After this initial phase the document discusses 
the more advanced options which the user can employ should they
need more customized interaction with the Grid class.

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04082100000000000000">
23.2.1 Shortcut Creation Method for Single-Tile Grids</A>
</H3>

<P>
The method <TT>ESMF_GridCreateShapeTile()</TT> is a shortcut
   for building single tile logically rectangular Grids up to 
   three dimensions.
   It is partially implemented.  The user can specify Grid
   size, dimension and distribution, but cannot specify tile edge
   connectivities yet.  The default is that Grid edges are
   not connected.  Once completed, this method will enable users
   to create many common grid shapes, including
   rectangle, bipole sphere, and tripole sphere. 

<P>
In v4.0.0, the <TT>ESMF_GridCreateShapeTile()</TT> method supports 
   all three types of distributions described in 
   Section&nbsp;<A HREF="node4.html#sec:desc:dist">23.1.4</A>: regular, irregular and arbitrary.

<P>
The ESMF Grid is cell based and so for all distribution 
   options the methods take as input the number of cells to describe
   the total index space and the number of cells to specify distribution. 

<P>
To create a Grid 
   with a regular distribution the user specifies the global
   maximum and minimum ranges of the Grid cell index space (<TT>maxIndex</TT> and
   <TT>minIndex</TT>), and the number of pieces in which to partition
   each dimension (via a <TT>regDecomp</TT> argument).
   ESMF then divides the index space as evenly as possible 
   into the specified number of pieces. If there are cells
   left over then they are distributed one per DE starting from
   the first DE until they are gone.

<P>
If <TT>minIndex</TT> is 
   not specified, then the bottom of the Grid cell index range is assumed
   to be (1,1,...,1). If <TT>regDecomp</TT> is not specified, then
   by default ESMF creates a distribution that partitions the
   grid cells in the first dimension (e.g. NPx1x1...1) as evenly 
   as possible by  the number of processors NP.
   The remaining dimensions are not partitioned.
   The dimension of the Grid is the size of <TT>maxIndex</TT>. 
   The following is an example of creating a 10x20x30 3D grid
   where the first dimensions is broken into 2 pieces, the second
   is broken into 4 pieces, and the third is "distributed" across only one processor.  

<P>
<PRE>
  grid3D=ESMF_GridCreateShapeTile(regDecomp=(/2,4,1/), maxIndex=(/10,20,30/), &amp;
           rc=rc)
</PRE>

<P>
Irregular distribution requires the user to specify the
   exact number of Grid cells per DE in each dimension.  In the
   <TT>ESMF_GridCreateShapeTile()</TT> call the <TT>countsPerDEDim1</TT>,
   <TT>countsPerDim2</TT>, and <TT>countsPerDim3</TT>
   arguments are used to specify a rectangular distribution
   containing size(countsPerDEDim1) by size(countsPerDEDim2) by
   size(countsPerDEDim3) DEs. The entries in each of these arrays
   specify the number of grid cells per DE in that dimension.
   The dimension of the grid is determined by the presence of
   <TT>countsPerDEDim3</TT>.  If it's present the Grid
   will be 3D. If just <TT>countsPerDEDim1</TT> and 
   <TT>countsPerDEDim2</TT> are specified the Grid 
   will be 2D.

<P>
The following call illustrates the creation of 
   a 10x20 two dimensional rectangular Grid distributed across six DEs
   that are arranged 2x3.  In the first dimension there are 3 grid
   cells on the first DE and 7 cells on the second DE.  The second 
   dimension has 3 DEs with 11,2, and 7 cells, respectively. 

<P>
<PRE>
   grid2D=ESMF_GridCreateShapeTile(countsPerDEDim1=(/3,7/), &amp;
          countsPerDEDim2=(/11,2,7/), rc=rc)
</PRE>

<P>
To add a distributed third dimension of size 30, broken up into
   two groups of 15, the above call would be altered as follows.  

<P>
<PRE>
   grid3d=ESMF_GridCreateShapeTile(countsPerDEDim1=(/3,7/), &amp;
          countsPerDEDim2=(/11,2,7/), countsPerDEDim3=(/15,15/), rc=rc)
</PRE>

<P>
To make a third dimension distributed across only 1 DE, then 
   <TT>countsPerDEDim3</TT> in the call should only have a single term. 

<P>
<PRE>
   grid3D=ESMF_GridCreateShapeTile(countsPerDEDim1=(/3,7/),  &amp;
          countsPerDEDim2=(/11,2,7/), countsPerDEDim3=(/30/), rc=rc)
</PRE>

<P>
The <TT>petMap</TT> parameter may be used to specify on to which specific PETs 
   the DEs in the Grid are assigned. Note that this parameter is only available for the 
   regular and irregular distribution types. The <TT>petMap</TT> 
   array is a 3D array, for a 3D Grid each of its dimensions correspond to a
   Grid dimension. If the Grid is 2D, then the first two dimensions correspond
   to Grid dimensions and the last dimension should be of size 1. 
   The size of each <TT>petMap</TT> dimension is
   the number of DE's along that dimension in the Grid. For a 
   regular Grid, the size is equal to the number in regDecomp 
   (i.e. <TT>size(petMap,d)=regDecomp(d)</TT> for all dimensions <TT>d</TT> in the Grid). For
   an irregular Grid the size is equal to the number of items in
   the corresponding <TT>countsPerDEDim</TT> variable (i.e. 
   <TT>size(petMap,d)=size(countsPerDEDimd)</TT> for all dimensions <TT>d</TT> in the Grid).

<P>
Each entry in <TT>petMap</TT> specifies to which PET the corresponding
   DE should be assigned. For example, <TT>petMap(3,2)=4</TT> tells the Grid
   create call to put the DE located at column 3 row 2 on PET 4.

<P>
The following example demonstrates how to specify the PET to DE association 
   for an <TT>ESMF_GridCreateShapeTile()</TT> call. 

<P>
<PRE>
   ! allocate memory for petMap
   allocate( petMap(2,2,1) )

   ! Set petMap
   petMap(:,1,1) = (/3,2/) ! DE (1,1,1) on PET 3 and DE (2,1,1) on PET 2
   petMap(:,2,1) = (/1,0/) ! DE (1,2,1) on PET 1 and DE (2,2,1) on PET 0


   ! Let the 3D grid be be distributed only in the first two dimensions.
   grid2D=ESMF_GridCreateShapeTile(countsPerDEDim1=(/3,7/), &amp;
           countsPerDEDim2=(/7,6/), petMap=petMap, rc=rc)
</PRE>

<P>
To create an grid with arbitrary distribution, the user specifies the global minimum and maximum
   ranges of the index space with the
   arguments <TT>minIndex</TT> and <TT>maxIndex</TT>, the total number of cells and their index space locations 
   residing on the local PET through a <TT>localArbIndexCount</TT> and a <TT>localArbIndex</TT>
   argument. <TT>localArbIndex</TT> is a 2D array with size <TT>(localArbIndexCount, n)</TT> where n is the total number
   dimensions distributed arbitrarily.    
   Again, if <TT>minIndex</TT> is  not specified, then the bottom of the 
   index range is assumed to be (1,1,...). 
   The dimension of the Grid is equal to the size of <TT>maxIndex</TT>. 
   If n (number of arbitrarily distributed dimension) is less than the grid dimension, an optional
   argument <TT>distDim</TT> is used to specify which of the grid dimension is arbitrarily distributed.
   If not given, the first n dimensions are assumed to be distributed.

<P>
The following example creates a 2D Grid of dimensions 5x5, and places
   the diagonal elements (i.e. indices (i,i) where i goes from 1 to 5)
   on the local PET. The remaining PETs would individually declare
   the remainder of the Grid locations.  

<P>
<PRE>
   ! allocate memory for localArbIndex
   allocate( localArbIndex(5,2) )
   ! Set local indices
   localArbIndex(1,:)=(/1,1/)
   localArbIndex(2,:)=(/2,2/)
   localArbIndex(3,:)=(/3,3/)
   localArbIndex(4,:)=(/4,4/)
   localArbIndex(5,:)=(/5,5/)

   ! Create a 2D Arbitrarily distributed Grid
   grid2D=ESMF_GridCreateShapeTile(maxIndex=(/5,5/), &amp; 
         localArbIndex=localArbIndex, localArbIndexCount=5, rc=rc)
</PRE>

<P>
To create a 3D Grid of dimensions 5x6x5 with the first and the third dimensions distributed arbitrarily,
   <TT>distDim</TT> is used. 

<P>
<PRE>
   ! Create a 3D Grid with the 1st and 3rd dimension arbitrarily distributed
   grid3D=ESMF_GridCreateShapeTile(maxIndex=(/5,6,5/), &amp; 
         localArbIndex=localArbIndex, localArbIndexCount=5, distDim=(/1,3/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04082200000000000000"></A>
   <A NAME="example:2DRegUniGrid"></A>
<BR>
23.2.2 Creating a 2D Regularly Distributed Rectilinear Grid
                    With Uniformly Spaced Coordinates
</H3>

<P>
The following is an example of creating a simple rectilinear grid 
   and loading in a set of coordinates. It illustrates a straightforward use
   of the <TT>ESMF_GridCreateShapeTile()</TT> call described in the previous section. 
   This code creates a 10x20 2D grid with uniformly spaced coordinates varying from (10,10) to (100,200).
   The grid is partitioned using a regular distribution. The first dimension
   is divided into two pieces, and the second dimension is divided into 3.
   This example assumes that the code is being run with a 1-1 mapping between 
   PETs and DEs because we are only accessing the first DE on each PET (localDE=0).
   Because we have 6 DEs (2x3), this example would only work when run on 6 PETs. 
   The Grid is created with global indices. After Grid creation the
   local bounds and native Fortran arrays are retrieved and the
   coordinates are set by the user. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object, define the
   ! topology and distribution of the Grid, and specify that it 
   ! will have global indices.  Note that aperiodic bounds are
   ! specified by default - if periodic bounds were desired they
   ! would need to be specified using an additional gridConn argument
   ! (which isn't implemented yet). In this call the minIndex hasn't 
   ! been set, so it defaults to (1,1,...). The default is to 
   ! divide the index range as equally as possible among the DEs
   ! specified in regDecomp. This behavior can be changed by 
   ! specifying decompFlag. 
   !-------------------------------------------------------------------
   grid2D=ESMF_GridCreateShapeTile(          &amp;
            ! Define a regular distribution
            maxIndex=(/10,20/), &amp; ! define index space
            regDecomp=(/2,3/),  &amp; ! define how to divide among DEs
            ! Specify mapping of coords dim to Grid dim
            coordDep1=(/1/), &amp; ! 1st coord is 1D and depends on 1st Grid dim
            coordDep2=(/2/), &amp; ! 2nd coord is 1D and depends on 2nd Grid dim
            indexflag=ESMF_INDEX_GLOBAL, &amp;
            rc=rc)

   !-------------------------------------------------------------------
   ! Allocate coordinate storage and associate it with the center
   ! stagger location.  Since no coordinate values are specified in
   ! this call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D,  &amp; 
          staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)

   !-------------------------------------------------------------------
   ! Get the pointer to the first coordinate array and the bounds
   ! of its global indices on the local DE.   
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, fptr=coordX, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension [10-100].
   !-------------------------------------------------------------------
   do i=lbnd(1),ubnd(1)
        coordX(i) = i*10.0
   enddo

   !-------------------------------------------------------------------
   ! Get the pointer to the second coordinate array and the bounds of
   ! its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, fptr=coordY, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension [10-200]
   !-------------------------------------------------------------------
   do j=lbnd(1),ubnd(1)
        coordY(j) = j*10.0
   enddo
</PRE>

<P>
The remaining examples in this section will use the irregular 
   distribution because of its greater generality. To create code similar to these, but
   using a regular distribution, replace the <TT>countsPerDEDim</TT> arguments
   in the Grid create with the appropriate <TT>maxIndex</TT> and <TT>regDecomp</TT> arguments. 

<P>

<H3><A NAME="SECTION04082300000000000000"></A>
   <A NAME="example:2DIrregUniGrid"></A>
<BR>
23.2.3 Creating a 2D Irregularly Distributed Rectilinear Grid
                    With Uniformly Spaced Coordinates
</H3>

<P>
This example serves as an illustration of the difference between using
   a regular and irregular distribution. It repeats the previous example
   except using an irregular distribution to give the user more control
   over how the cells are divided between the DEs. As before, this code
   creates a 10x20 2D Grid with uniformly spaced coordinates  varying from (10,10) to (100,200).
   In this example, the Grid is partitioned using an irregular distribution. The first dimension
   is divided into two pieces, the first with 3 Grid cells per
   DE and the second with 7 Grid cells per DE. In the second dimension,
   the Grid is divided into 3 pieces, with 11, 2, and 7 cells per DE respectively.
   This example assumes that the code is being run with a 1-1 mapping between 
   PETs and DEs because we are only accessing the first DE on each PET (localDE=0).
   Because we have 6 DEs (2x3), this example would only work when run on 6 PETs. 
   The Grid is created with global indices. After Grid creation the
   local bounds and native Fortran arrays are retrieved and the
   coordinates are set by the user. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object, define the
   ! topology and distribution of the Grid, and specify that it 
   ! will have global coordinates.  Note that aperiodic bounds are
   ! specified by default - if periodic bounds were desired they
   ! would need to be specified using an additional gridConn argument
   ! (which isn't implemented yet). In this call the minIndex hasn't 
   ! been set, so it defaults to (1,1,...).
   !-------------------------------------------------------------------
   grid2D=ESMF_GridCreateShapeTile(          &amp;
            ! Define an irregular distribution
            countsPerDEDim1=(/3,7/),    &amp;
            countsPerDEDim2=(/11,2,7/), &amp;
            ! Specify mapping of coords dim to Grid dim
            coordDep1=(/1/), &amp; ! 1st coord is 1D and depends on 1st Grid dim
            coordDep2=(/2/), &amp; ! 2nd coord is 1D and depends on 2nd Grid dim
            indexflag=ESMF_INDEX_GLOBAL, &amp; 
            rc=rc)

   !-------------------------------------------------------------------
   ! Allocate coordinate storage and associate it with the center
   ! stagger location.  Since no coordinate values are specified in
   ! this call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D,  &amp; 
          staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)

   !-------------------------------------------------------------------
   ! Get the pointer to the first coordinate array and the bounds
   ! of its global indices on the local DE.   
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, fptr=coordX, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension [10-100].
   !-------------------------------------------------------------------
   do i=lbnd(1),ubnd(1)
        coordX(i) = i*10.0
   enddo

   !-------------------------------------------------------------------
   ! Get the pointer to the second coordinate array and the bounds of
   ! its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, fptr=coordY, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension [10-200]
   !-------------------------------------------------------------------
   do j=lbnd(1),ubnd(1)
        coordY(j) = j*10.0
   enddo
</PRE>

<P>

<H3><A NAME="SECTION04082400000000000000"></A>
   <A NAME="example:2DIrregCurviGrid"></A>
<BR>
23.2.4 Creating a 2D Irregularly Distributed Grid
                    With Curvilinear Coordinates
</H3>

<P>
The following is an example of creating a simple curvilinear Grid and
   loading in a set of coordinates. It creates a 10x20
   2D Grid where the coordinates vary along every dimension. 
   The Grid is partitioned using an irregular distribution. The first dimension
   is divided into two pieces, the first with 3 Grid cells per
   DE and the second with 7 Grid cells per DE. In the second dimension,
   the Grid is divided into 3 pieces, with 11, 2, and 7 cells per DE respectively.
   This example assumes that the code is being run with a 1-1 mapping between 
   PETs and DEs because we are only accessing the first DE on each PET (localDE=0).
   Because we have 6 DEs (2x3), this example would only work when run on 6 PETs. 
   The Grid is created with global indices. After Grid creation the
   local bounds and native Fortran arrays are retrieved and the
   coordinates are set by the user. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object, define the
   ! distribution of the Grid, and specify that it 
   ! will have global indices.  Note that aperiodic bounds are
   ! specified by default - if periodic bounds were desired they
   ! would need to be specified using an additional gridConn argument
   ! (which isn't implemented yet). In this call the minIndex hasn't 
   ! been set, so it defaults to (1,1,...).
   !-------------------------------------------------------------------
   grid2D=ESMF_GridCreateShapeTile(      &amp;
            ! Define an irregular distribution
            countsPerDEDim1=(/3,7/),     &amp;
            countsPerDEDim2=(/11,2,7/),   &amp;
            ! Specify mapping of coords dim to Grid dim
            coordDep1=(/1,2/), &amp; ! 1st coord is 2D and depends on both Grid dim
            coordDep2=(/1,2/), &amp; ! 2nd coord is 1D and depends on both Grid dim
            indexflag=ESMF_INDEX_GLOBAL, &amp;
            rc=rc)

   !-------------------------------------------------------------------
   ! Allocate coordinate storage and associate it with the center
   ! stagger location.  Since no coordinate values are specified in
   ! this call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D,  &amp; 
          staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)

   !-------------------------------------------------------------------
   ! Get the pointer to the first coordinate array and the bounds
   ! of its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, fptr=coordX2D, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension [10-100].
   !-------------------------------------------------------------------
   do j=lbnd(2),ubnd(2)
   do i=lbnd(1),ubnd(1)
        coordX2D(i,j) = i+j
   enddo
   enddo

   !-------------------------------------------------------------------
   ! Get the pointer to the second coordinate array and the bounds of 
   ! its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, fptr=coordY2D, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension [10-200]
   !-------------------------------------------------------------------
   do j=lbnd(2),ubnd(2)
   do i=lbnd(1),ubnd(1)
        coordY2D(i,j) = j-i/100.0
   enddo
   enddo
</PRE>

<P>

<H3><A NAME="SECTION04082500000000000000"></A>
   <A NAME="example:CurviGridWithUndistDim"></A>
<BR>
23.2.5 Creating an Irregularly Distributed Rectilinear Grid with
                  a Non-Distributed Vertical Dimension
</H3>

<P>
This example demonstrates how a user can build a rectilinear 
   horizontal Grid with a non-distributed vertical dimension. The Grid 
   contains both the center and corner stagger locations (i.e. Arakawa 
   B-Grid). In contrast to the previous examples, this example doesn't
   assume that the code is being run with a 1-1 mapping between 
   PETs and DEs. It should work when run on any number of PETs.

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object.  The
   ! Grid is defined to be 180 Grid cells in the first dimension
   ! (e.g. longitude), 90 Grid cells in the second dimension (e.g. latitude), and
   ! 40 Grid cells in the third dimension (e.g. height).  The first dimension is
   ! decomposed over 4 DEs, the second over 3 DEs, and the third is 
   ! not distributed.  The connectivities in each dimension default 
   ! to aperiodic since they are not yet implemented. In this call 
   ! the minIndex hasn't been set, so it defaults to (1,1,...). 
   !-------------------------------------------------------------------
   grid3D=ESMF_GridCreateShapeTile( &amp;
            ! Define an irregular distribution
            countsPerDEDim1=(/45,75,40,20/), &amp;
            countsPerDEDim2=(/30,40,20/),    &amp;
            countsPerDEDim3=(/40/),          &amp;
            ! Specify mapping of coords dim to Grid dim
            coordDep1=(/1/), &amp; ! 1st coord is 1D and depends on 1st Grid dim
            coordDep2=(/2/), &amp; ! 2nd coord is 1D and depends on 2nd Grid dim
            coordDep3=(/3/), &amp; ! 3rd coord is 1D and depends on 3rd Grid dim
            indexflag=ESMF_INDEX_GLOBAL,     &amp; ! Use global indices
            rc=rc)

   !-------------------------------------------------------------------
   ! Allocate coordinate storage for both center and corner stagger
   ! locations.  Since no coordinate values are specified in this
   ! call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid3D, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER, rc=rc)
   call ESMF_GridAddCoord(grid3D, &amp;
          staggerloc=ESMF_STAGGERLOC_CORNER_VCENTER, rc=rc)


   !-------------------------------------------------------------------
   ! Get the number of DEs on this PET, so that the program
   ! can loop over them when accessing data.
   !-------------------------------------------------------------------
   call ESMF_GridGet(grid3D, localDECount=localDECount, rc=rc)

   !-------------------------------------------------------------------
   ! Loop over each localDE when accessing data
   !-------------------------------------------------------------------
   do lDE=0,localDECount-1

    !------------------------------------------------------------------
    ! Fill in the coordinates for the corner stagger location first.
    !------------------------------------------------------------------
      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the first
      ! coordinate array on the local DE. If the number of PETs
      ! is less than the total number of DEs then the rest of this
      ! example would be in a loop over the local DEs.  Also get the
      ! pointer to the first coordinate array. 
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=1, localDE=lDE, &amp;
             staggerLoc=ESMF_STAGGERLOC_CORNER_VCENTER,       &amp;
             computationalLBound=lbnd_corner,                 &amp;
             computationalUBound=ubnd_corner,                 &amp;
             fptr=cornerX, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set coordinates in the first dimension.
      !----------------------------------------------------------------
      do i=lbnd_corner(1),ubnd_corner(1)
         cornerX(i) = (i-1)*(360.0/180.0)
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the second
      ! coordinate array on the local DE.  Also get the pointer to the
      ! second coordinate array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=2, localDE=lDE,   &amp;
             staggerLoc=ESMF_STAGGERLOC_CORNER_VCENTER,         &amp;
             computationalLBound=lbnd_corner,                   &amp;
             computationalUBound=ubnd_corner,                   &amp;
             fptr=cornerY, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set coordinates in the second dimension.
      !----------------------------------------------------------------
      do j=lbnd_corner(1),ubnd_corner(1)
         cornerY(j) = (j-1)*(180.0/90.0)
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the third
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=3, localDE=lDE,   &amp;
             staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,         &amp;
             computationalLBound=lbnd, computationalUBound=ubnd,&amp;
             fptr=cornerZ, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set the vertical coordinates
      !----------------------------------------------------------------
      do k=lbnd(1),ubnd(1)
         cornerZ(k) = 4000.0*( (1./39.)*(k-1)  )**2
      enddo

    !------------------------------------------------------------------
    ! Now fill the coordinates for the center stagger location with
    ! the average of the corner coordinate location values.
    !------------------------------------------------------------------
      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the first 
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=1, localDE=lDE,    &amp;
             staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,          &amp;
             computationalLBound=lbnd, computationalUBound=ubnd, &amp;
             fptr=centerX, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set coordinates in the first dimension.
      !----------------------------------------------------------------
      do i=lbnd(1),ubnd(1)
         centerX(i) = 0.5*(i-1 + i)*(360.0/180.0) 
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the second
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
       call ESMF_GridGetCoord(grid3D, coordDim=2, localDE=lDE,    &amp;
              staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,          &amp;
              computationalLBound=lbnd, computationalUBound=ubnd, &amp;
              fptr=centerY, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set coordinates in the second dimension.
      !----------------------------------------------------------------
      do j=lbnd(1),ubnd(1)
         centerY(j) = 0.5*(j-1 + j)*(180.0/90.0) 
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the third
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=3, localDE=lDE,   &amp;
             staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,         &amp;
             computationalLBound=lbnd, computationalUBound=ubnd,&amp;
             fptr=centerZ, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set the vertical coordinates
      !----------------------------------------------------------------
      do k=lbnd(1),ubnd(1)
         centerZ(k) = 4000.0*( (1./39.)*(k-1)  )**2
      enddo

   !-------------------------------------------------------------------
   ! End of loop over DEs
   !-------------------------------------------------------------------
   enddo
</PRE>

<P>

<H3><A NAME="SECTION04082600000000000000"></A>
   <A NAME="example:ArbGridWithUndistDim"></A>
<BR>
23.2.6 Creating an Arbitrarily Distributed Rectilinear Grid with
                  a Non-Distributed Vertical Dimension
</H3>

<P>
There are more restrictions in defining an arbitrarily distributed grid.  
   First, there is always one DE per PET.  Secondly, only local index (<TT>ESMF_INDEX_LOCAL</TT>)
   is supported. Third, only one stagger location, i.e. <TT>ESMF_STAGGERLOC_CENTER</TT> is allowed
   and last there is no extra paddings on the edge of the grid.  

<P>
This example demonstrates how a user can build a 3D grid with its rectilinear 
   horizontal Grid distributed arbitrarily and a non-distributed vertical dimension.

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Set up the local index array:  Assuming the grid is 360x180x10.  First
   ! calculate the localArbIndexCount and localArbIndex array for each PET based on
   ! the total number of PETS. The cells are evenly distributed in all the
   ! PETs. If the total number of cells are not divisible by the total PETs, 
   ! the remaining cells are assigned to the last PET.  The cells are card 
   ! dealed to each PET in y dimension first, i.e. (1,1) -&gt; PET 0, (1,2)-&gt;
   ! PET 1, (1,3)-&gt; PET 2, and so forth.  
   !-------------------------------------------------------------------
   xdim = 360
   ydim = 180
   zdim = 10
   localArbIndexCount = (xdim*ydim)/petCount
   remain = (xdim*ydim)-localArbIndexCount*petCount
   if (localPet == petCount-1) localArbIndexCount = localArbIndexCount+remain

   allocate(localArbIndex(localArbIndexCount,2))
   ind = localPet
   do i=1, localArbIndexCount
      localArbIndex(i,1)=mod(ind,ydim)+1
      localArbIndex(i,2)=ind/ydim + 1
      ind = ind + petCount
   enddo
   if (localPet == petCount-1) then
      ind = xdim*ydim-remain+1
      do i=localArbIndexCount-remain+1,localArbIndexCount
         localArbIndex(i,1)=mod(ind,ydim)+1
         localArbIndex(i,2)=ind/ydim+1
         ind = ind + 1
      enddo
   endif

   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object.  
   ! the minIndex hasn't been set, so it defaults to (1,1,...). The
   ! default coordDep1 and coordDep2 are (/ESMF_GRID_ARBDIM/) where 
   ! ESMF_GRID_ARBDIM represents the collapsed dimension for the 
   ! arbitrarily distributed grid dimensions.  For the undistributed
   ! grid dimension, the default value for coordDep3 is (/3/).  The
   ! default values for coordDepX in the arbitrary distribution are
   ! different from the non-arbitrary distributions.
   !-------------------------------------------------------------------
   grid3D=ESMF_GridCreateShapeTile( &amp;
	    maxIndex = (/xdim, ydim, zdim/), &amp;
            localArbIndex = localArbIndex, &amp;
            localArbIndexCount = localArbIndexCount, &amp;
            rc=rc)

   !-------------------------------------------------------------------
   ! Allocate coordinate storage for the center stagger location, the 
   ! only stagger location supported for the arbitrary distribution.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid3D, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER, rc=rc)

   !------------------------------------------------------------------
   ! Fill in the coordinates for the center stagger location. There is
   ! always one DE per PET, so localDE is always 0
   !------------------------------------------------------------------
   call ESMF_GridGetCoord(grid3D, coordDim=1, localDE=0, &amp;
          staggerLoc=ESMF_STAGGERLOC_CENTER,       &amp;
          computationalLBound=lbnd,                 &amp;
          computationalUBound=ubnd,                 &amp;
          fptr=centerX, rc=rc)


   !----------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension.
   !----------------------------------------------------------------
   do i=lbnd(1),ubnd(1)
      centerX(i) = (localArbIndex(i,1)-0.5)*(360.0/xdim)
   enddo


   !----------------------------------------------------------------
   ! Get the local bounds of the global indexing for the second
   ! coordinate array on the local DE, and the pointer to the array.
   !----------------------------------------------------------------
   call ESMF_GridGetCoord(grid3D, coordDim=2, localDE=0,    &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER,                  &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          fptr=centerY, rc=rc)

   !----------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension.
   !----------------------------------------------------------------
   do j=lbnd(1),ubnd(1)
      centerY(j) = (localArbIndex(j,2)-0.5)*(180.0/ydim)-90.0 
   enddo

   !----------------------------------------------------------------
   ! Get the local bounds of the global indexing for the third
   ! coordinate array on the local DE, and the pointer to the array.
   !----------------------------------------------------------------
   call ESMF_GridGetCoord(grid3D, coordDim=3, localDE=0,   &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER,               &amp;
          computationalLBound=lbnd, computationalUBound=ubnd,&amp;
          fptr=centerZ, rc=rc)

   !----------------------------------------------------------------
   ! Calculate and set the vertical coordinates
   !----------------------------------------------------------------
   do k=lbnd(1),ubnd(1)
      centerZ(k) = 4000.0*( (1./zdim)*(k-1))**2
   enddo
</PRE>

<P>

<H3><A NAME="SECTION04082700000000000000"></A><A NAME="sec:usage:setcommit"></A>
<BR>
23.2.7 Creating an Empty Grid in a Parent Component 
   for Completion in a Child Component
</H3>

<P>
ESMF Grids can be created incrementally. To do this,
   the user first calls <TT>ESMF_GridCreateEmpty()</TT> to allocate the shell of
   a Grid. Next, we use the <TT>ESMF_GridSetCommitShapeTile()</TT>
   call that fills in the Grid and does an internal commit to make it usable.
   For consistency's sake the <TT>ESMF_GridSetCommitShapeTile()</TT>
   call must occur on the same or a subset of the PETs as the
    <TT>ESMF_GridCreateEmpty()</TT> call. The 
   <TT>ESMF_GridSetCommitShapeTile()</TT> call uses the VM for
   the context in which it's executed and the "empty" Grid contains
   no information about the VM in which its create was run.  This
   means that if the <TT>ESMF_GridSetCommitShapeTile()</TT> call occurs
   in a subset of the PETs in which the <TT>ESMF_GridCreateEmpty()</TT> was 
   executed that the Grid is created only in that subset. Inside the subset
   the Grid will be fine, but outside the subset the Grid objects will
   still be "empty" and not usable. The following example uses the
   incremental technique to create a rectangular 10x20 Grid with coordinates at
   the center and corner stagger locations.  

<P>
<PRE>
!---------------------------------------------------------------------------
! IN THE PARENT COMPONENT:
! Create an empty Grid in the parent component for use in a child component.
! The parent may be defined on more PETs than the child component.  
! The child's [vm or pet list] is passed into the create call so that
! the Grid is defined on the appropriate subset of the parent's PETs. 
!---------------------------------------------------------------------------
   grid2D=ESMF_GridCreateEmpty(rc=rc)

!---------------------------------------------------------------------------
! IN THE CHILD COMPONENT:
! Set the Grid topology.  Here we define an irregularly distributed 
! rectangular Grid.
!---------------------------------------------------------------------------
   call ESMF_GridSetCommitShapeTile(grid2D,             &amp;
                          countsPerDEDim1=(/6,4/),      &amp;
                          countsPerDEDim2=(/10,3,7/), rc=rc)

!---------------------------------------------------------------------------
! Add Grid coordinates at the cell center location.
!---------------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D, staggerLoc=ESMF_STAGGERLOC_CENTER, rc=rc)

!---------------------------------------------------------------------------
! Add Grid coordinates at the corner stagger location.
!---------------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04082800000000000000"></A>
  <A NAME="sec:usage:staggerloc"></A>
<BR>
23.2.8 Grid Stagger Locations
</H3>

<P>
A useful finite difference technique is to place different physical 
   quantities at different locations within a grid cell. This
   <EM>staggering</EM> of the physical variables on the mesh is introduced so
   that the difference of a field is naturally defined at the location of 
   another variable. This method was first formalized by Mesinger and Arakawa 
   (1976).

<P>
To support the staggering of variables, the Grid provides
   the idea of <EM>stagger locations</EM>. 
   Stagger locations refer to the places in a Grid cell that 
   can contain coordinates or other data and once a Grid is associated with a 
   Field object, field data. Typically Grid data can be located
   at the cell center, at the cell corners, or at the cell faces, in 2D, 3D, and
   higher dimensions. (Note that any Arakawa stagger can be constructed
   of a set of Grid stagger locations.)  There are predefined stagger locations
   (see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A>), or,
   should the user wish to specify their own, there
   is also a set of methods for generating custom locations 
   (See Section&nbsp;<A HREF="node4.html#sec:usage:staggerloc:adv">23.2.20</A>).
   Users can put Grid data (e.g. coordinates) 
   at multiple stagger locations in a Grid. In addition, the user can create a Field
   at any of the stagger locations in a Grid. 

<P>
By default the Grid data array at the center stagger location
   starts at the bottom index of the Grid (default (1,1..,1)) and extends
   up to the maximum cell index in the Grid (e.g. given by the <TT>maxIndex</TT> argument).
   Other stagger locations also start at the bottom index of the Grid, however, 
   they can extend to +1 element beyond the center in some dimensions to allow
   for the extra space to surround the center elements. See Section&nbsp;<A HREF="node4.html#sec:usage:staggerloc:adv">23.2.20</A>
   for a description of this extra space and how to adjust if it necessary. 
   There are <TT>ESMF_GridGet</TT> subroutines (e.g. <TT>ESMF_GridGetCoord()</TT> or <TT>ESMF_GridGetItem()</TT>)
   which can be used to retrieve the stagger bounds for the piece of Grid data 
   on a particular DE.  

<P>

<H3><A NAME="SECTION04082900000000000000">
23.2.9 Associating Coordinates with Stagger Locations</A>
</H3>

<P>
The primary type of data the Grid is resposible for storing is coordinates. 
   The coordinate values in a Grid can be employed by the user in calculations or
   to describe the geometry of a Field. The Grid coordinate values are also used by 
   <TT>ESMF_FieldRegridStore()</TT> when calculating the interpolation
   matrix between two Fields. The user can allocate coordinate arrays without setting coordinate values 
   using the <TT>ESMF_GridAddCoord()</TT> call. (See Section&nbsp;<A HREF="node4.html#sec:usage:coords:accessing">23.2.11</A> for a discussion of
   setting/getting coordinate values.) When adding or accessing
   coordinate data, the stagger location is specified to tell the Grid method 
   where in the cell to get the data. The different stagger locations may also have slightly different
   index ranges and sizes.  Please see Section&nbsp;<A HREF="node4.html#sec:usage:staggerloc">23.2.8</A> for a discussion of 
   Grid stagger locations. 

<P>
The following example adds coordinate storage to the corner stagger location in a Grid using one 
   of the predefined stagger locations. 

<P>
<PRE>
   call ESMF_GridAddCoord(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, rc=rc)
</PRE>

<P>
Note only the center stagger location <TT>ESMF_STAGGERLOC_CENTER</TT> is supported 
   in an arbitrarily distributed Grid. 

<P>

<H3><A NAME="SECTION040821000000000000000">
23.2.10 Specifying the Relationship of Coordinate Arrays
                 to Index Space Dimensions</A>
</H3>

<P>
To specify how the coordinate arrays are mapped to the 
   index dimensions the arguments <TT>coordDep1</TT>, 
   <TT>coordDep2</TT>, and <TT>coordDep3</TT> are used, each 
   of which is a Fortran array. The values of the elements
   in a <TT>coordDep</TT> array specify which index dimension
   the corresponding coordinate dimension
   maps to.  For example, <TT>coordDep1=(/1,2/)</TT> means that
   the first dimension of coordinate 1 maps to index
   dimension 1 and the second maps to index dimension 2. 
   For a grid with non-arbitrary distribution, the default
   values for <TT>coordDep1</TT>, <TT>coordDep2</TT> and <TT>coordDep3</TT>
   are <TT>/1,2..,gridDimCount/</TT>.  This default  
   thus specifies a curvilinear grid.  

<P>
The following call demonstrates the creation of a
   10x20 2D rectilinear grid where the first coordinate
   component is mapped to the second index dimension
   (i.e. is of size 20) and the second coordinate component
   is mapped to the first index dimension (i.e. is of size
   10). 

<P>
<PRE>
   grid2D=ESMF_GridCreateShapeTile(countsPerDEDim1=(/5,5/), &amp;
          countsPerDEDim2=(/7,7,6/),                    &amp;
          coordDep1=(/2/),                              &amp;
          coordDep2=(/1/), rc=rc)
</PRE>

<P>
The following call demonstrates the creation of a
   10x20x30 2D plus 1 curvilinear grid where 
   coordinate component 1 and 2 are still 10x20, but
   coordinate component 3 is mapped just to the 
   third index dimension. 

<P>
<PRE>
   grid2D=ESMF_GridCreateShapeTile(countsPerDEDim1=(/6,4/), &amp;
          countsPerDEDim2=(/10,7,3/), countsPerDEDim3=(/30/), &amp;
          coordDep1=(/1,2/), coordDep2=(/1,2/), &amp;
          coordDep3=(/3/), rc=rc)
</PRE>

<P>
By default the local piece of the array on each PET starts at 
   (1,1,..), however, the indexing for each grid coordinate array  
   on each DE may be shifted to the global indices by using the <TT>indexflag</TT>.
   For example, the following call switches the grid to use global indices.  

<P>
<PRE>
   grid2D=ESMF_GridCreateShapeTile(countsPerDEDim1=(/6,4/), &amp;
           countsPerDEDim2=(/10,7,3/), indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
For an arbitrarily distributed grid, the default value of a coordinate
   array dimension is <TT>ESMF_GRID_ARBDIM</TT> if the index dimension is arbitrarily
   distributed and is <TT>n</TT> where <TT>n</TT> is the index dimension itself when it is not
   distributed. The following call is equivalent to the example in 
   Section <A HREF="node4.html#example:ArbGridWithUndistDim">23.2.6</A>  

<P>
<PRE>
   grid3D=ESMF_GridCreateShapeTile( &amp;
	    maxIndex = (/xdim, ydim, zdim/), &amp;
            localArbIndex = localArbIndex, &amp;
            localArbIndexCount = localArbIndexCount,	 &amp;
 	    coordDep1 = (/ESMF_GRID_ARBDIM/), &amp;
	    coordDep2 = (/ESMF_GRID_ARBDIM/), &amp;
	    coordDep3 = (/3/), &amp;
            rc=rc)
</PRE>

<P>
The following call uses non-default <TT>coordDep1</TT>, <TT>coordDep2</TT>, 
   and <TT>coordDep3</TT> to create a 3D curvilinear grid with its horizontal
   dimensions arbitrarily distributed.  

<P>
<PRE>
   grid3D=ESMF_GridCreateShapeTile( &amp;
	    maxIndex = (/xdim, ydim, zdim/), &amp;
            localArbIndex = localArbIndex, &amp;
            localArbIndexCount = localArbIndexCount,	 &amp;
 	    coordDep1 = (/ESMF_GRID_ARBDIM, 3/), &amp;
	    coordDep2 = (/ESMF_GRID_ARBDIM, 3/), &amp;
	    coordDep3 = (/ESMF_GRID_ARBDIM, 3/), &amp;
            rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040821100000000000000"></A>
  <A NAME="sec:usage:coords:accessing"></A>
<BR>
23.2.11 Accessing Coordinates
</H3>

<P>
Once a Grid has been created, the user has several options to access
   the Grid coordinate data. The first of these, <TT>ESMF_GridSetCoord()</TT>, 
   enables the user to use ESMF Arrays to set data 
   for one stagger location across the whole Grid. 
   For example, the following sets the coordinates in the first dimension 
   (e.g. x) for the corner stagger location to 
   those in the ESMF Array <TT>arrayCoordX</TT>. 

<P>
<PRE>
   call ESMF_GridSetCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          coordDim=1, array=arrayCoordX, rc=rc)
</PRE>

<P>
The method <TT>ESMF_GridGetCoord()</TT> allows the user
   to obtain a reference to an ESMF Array which
   contains the coordinate data for a stagger location in a Grid. The user
   can then employ any of the standard <TT>ESMF_Array</TT> tools to operate
   on the data. The following copies the coordinates from the second 
   component of the corner and puts it into the ESMF Array <TT>arrayCoordY</TT>.  

<P>
<PRE>
   call ESMF_GridGetCoord(grid2D,    &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER,    &amp;
          coordDim=2,                           &amp;
          array=arrayCoordY, rc=rc)
</PRE>

<P>
Alternatively, the call <TT>ESMF_GridGetCoord()</TT> gets a Fortran pointer to 
   the coordinate data. The user can then operate on this array in the usual
   manner. The following call gets a reference to the
   Fortran array which holds the data for the second coordinate (e.g. y).  

<P>
<PRE>
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CORNER, fptr=coordY2D, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040821200000000000000"></A>
  <A NAME="sec:usage:items"></A>
<BR>
23.2.12 Associating Items with Stagger Locations
</H3>

<P>
The ESMF Grids contain the ability to store other kinds of 
   data beyond coordinates. These kinds of data are referred to 
   as "items". Although the user is free to use this
   data as they see fit, the user should be aware that
   this data may also be used by other parts of ESMF (e.g. the 
   ESMF_GRIDITEM_MASK item is used in regridding). 
   Please see Section&nbsp;<A HREF="node4.html#sec:opt:griditem">23.5.3</A> for a list of valid
   items.

<P>
Like coordinates items are also created on stagger locations.
   When adding or accessing item data, the stagger location is specified to tell the Grid method 
   where in the cell to get the data. The different stagger locations may also have slightly different
   index ranges and sizes.  Please see Section&nbsp;<A HREF="node4.html#sec:usage:staggerloc">23.2.8</A> for a discussion of 
   Grid stagger locations.  The user can 
   allocate item arrays without setting item values using the <TT>ESMF_GridAddItem()</TT> call. 
   (See Section&nbsp;<A HREF="node4.html#sec:usage:items:accessing">23.2.13</A> for a discussion of setting/getting item values.) 

<P>
The following example adds mask item storage to the corner stagger location in a grid. 

<P>
<PRE>
   call ESMF_GridAddItem(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          item=ESMF_GRIDITEM_MASK, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040821300000000000000"></A>
  <A NAME="sec:usage:items:accessing"></A>
<BR>
23.2.13 Accessing Items
</H3>
   Once an item has been added to a Grid, the user has several options to access
   the data. The first of these, <TT>ESMF_GridSetItem()</TT>, 
   enables the user to use ESMF Arrays to set data for one stagger location across the whole Grid. 
   For example, the following sets the mask item in the corner stagger location to 
   those in the ESMF Array <TT>arrayMask</TT>. 

<P>
<PRE>
   call ESMF_GridSetItem(grid2D,             &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          item=ESMF_GRIDITEM_MASK, array=arrayMask, rc=rc)
</PRE>

<P>
The method <TT>ESMF_GridGetItem()</TT> allows the user
   to get a reference to the Array which
   contains item data for a stagger location on a Grid. The user
   can then employ any of the standard <TT>ESMF_Array</TT> tools to operate
   on the data. The following gets the mask data from the corner 
   and puts it into the ESMF Array <TT>arrayMask</TT>.  

<P>
<PRE>
   call ESMF_GridGetItem(grid2D,             &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          item=ESMF_GRIDITEM_MASK,           &amp;
          array=arrayMask, rc=rc)
</PRE>

<P>
Alternatively, the call <TT>ESMF_GridGetItem()</TT> gets a Fortran pointer to 
   the item data. The user can then operate on this array in the usual
   manner. The following call gets a reference to the
   Fortran array which holds the data for the mask data.  

<P>
<PRE>
   call ESMF_GridGetItem(grid2D, localDE=0,   &amp;
          staggerloc=ESMF_STAGGERLOC_CORNER,  &amp;
          item=ESMF_GRIDITEM_MASK, fptr=mask2D, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040821400000000000000"></A>
  <A NAME="sec:grid:usage:bounds"></A>
<BR>
23.2.14 Grid Regions and Bounds
</H3>

<P>
Like an Array or a Field, the index space of each 
   stagger location in the Grid contains an exclusive region, a 
   computational region and a total region. Please 
   see Section&nbsp;<A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A>
   for an in depth description of these regions. 

<P>
The exclusive region is the index space defined by the 
   distgrid of each stagger location of the Grid. This region 
   is the region which is owned by the DE and is the region 
   operated on by communication methods such as <TT>ESMF_FieldRegrid()</TT>.
   The exclusive region for a stagger location is based on the 
   exclusive region defined by the DistGrid used to create the Grid.
   The size of the stagger exclusive region is the index space for the 
   Grid cells, plus the stagger padding. 

<P>
The default stagger padding depends on the topology of the Grid. 
   For an unconnected dimension the stagger padding is a width
   of 1 on the upper side (i.e. <TT>gridEdgeUWidth=(1,1,1,1...)</TT>).
   For a periodic dimension there is no stagger padding.
   By adjusting <TT>gridEdgeLWidth</TT> and <TT>gridEdgeUWidth</TT>, the 
   user can set the stagger padding for the whole Grid and
   thus the exclusive region can be adjusted at will around the 
   index space corresponding to the cells. The user can
   also use <TT>staggerEdgeLWidth</TT> and <TT>staggerEdgeUWidth</TT> to
   adjust individual stagger location padding within the
   Grid's padding (Please see Section&nbsp;<A HREF="node4.html#sec:usage:staggerpadding:adv">23.2.21</A> for
   further discussion of customizing the stagger padding).

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridexreg"></A><A NAME="28748"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 14:</STRONG>
An example of a Grid's exclusive region for the corner stagger</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridExclusiveReg}}$
 -->
<IMG
 WIDTH="669" HEIGHT="324" ALIGN="BOTTOM" BORDER="0"
 SRC="img54.png"
 ALT="\scalebox{0.75}{\includegraphics{GridExclusiveReg}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
Figure&nbsp;<A HREF="node4.html#fig:gridexreg">14</A> shows an example of a Grid exclusive region for the
   <TT>ESMF_STAGGERLOC_CORNER</TT> stagger with default
   stagger padding. This exclusive region would be for a Grid generated by either of the
   following calls: 

<P>
<PRE>
  grid2D=ESMF_GridCreateShapeTile(regDecomp=(/2,4/), maxIndex=(/5,15/), &amp;
           indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
<PRE>
  grid2D=ESMF_GridCreateShapeTile(countsPerDEDim1=(/4,4,4,3/), &amp;
           countsPerDEDim2=(/3,2/), indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
Each rectangle in this diagram represents a DE and the numbers along the sides
   are the index values of the locations in the DE. Note that the exclusive region 
   has one extra index location in each dimension than the number of cells
   because of the padding for the larger corner stagger location. 

<P>
The computational region is a user setable region which can be used
   to distinguish a particular area for computation. The Grid doesn't
   currently contain functionality to let the user set the computational
   region so it defaults to the exclusive region, however, if the
   user sets an Array holding different computational bounds into the 
   Grid then that Array's computational bounds will be used.

<P>
The total region is the outermost boundary of the memory allocated 
   on each DE to hold the data for the stagger location on that DE. This region 
   can be as small as the exclusive region, but may be larger to 
   include space for halos, memory padding, etc. The total region is
   what is enlarged to include space for halos, and the total region 
   must be large enough to contain the maximum halo operation on the
   Grid. The Grid doesn't currently contain functionality to let the 
   user set the total region so it defaults to the exclusive region,
   however, if the
   user sets an Array holding different total bounds into the 
   Grid then that Array's total bounds will be used.

<P>
The user can retrieve a set of bounds for each index space region 
   described above: exclusive bounds, computational bounds, 
   and total bounds. Note that although some of these are similar
   to bounds provided by ESMF_Array subroutines 
   (see Section&nbsp;<A HREF="node4.html#Array_regions_and_default_bounds">20.2.6</A>) 
   the format here is different. The Array bounds are only for
   distributed dimensions and are ordered to correspond 
   to the dimension order in the associated DistGrid. The bounds
   provided by the Grid are ordered according to the order of dimensions of the data
   in question. This means that the bounds provided should be usable
   "as is" to access the data. 

<P>
Each of the three types of bounds refers to the maximum and minimum
   per dimension of the index ranges of a particular region. The paramters
   referring to the maximums contain a 'U' for upper. The parameters referring 
   to the minimums contain an 'L' for lower. The bounds and associated
   quantities are almost always given on a per DE basis. The three types of
   bounds <TT>exclusiveBounds</TT>, <TT>computationalBounds</TT>, and <TT>totalBounds</TT> refer
   to the ranges of the exlusive region, the computational region, and the
   total region. Each of these bounds also has a corresponding count parameter
   which gives the number of items across that region (on a DE) in each dimension.
   (e.g. <TT>totalCount(d)=totallUBound(i)-totalLBound(i)+1</TT>). Width parameters
   give the spacing between two different types of region. The
   <TT>computationalWidth</TT> argument gives the spacing between the exclusive
   region and the computational region. The <TT>totalWidth</TT> argument gives the 
   spacing between the total region and the computational region. Like the 
   other bound information these are typically on a per DE basis, for example
   specifying <TT>totalLWidth=(1,1)</TT> makes the bottom of the total
   region one lower in each dimension than the computational region on
   each DE. The exceptions to the per DE rule are
   <TT>staggerEdgeWidth</TT>, and <TT>gridEdgeWidth</TT>
   which give the spacing only on the DEs along the boundary of the Grid.

<P>
All the above bound discussions only apply to the grid with non-arbitrary distributions,
   i.e., regular or irregular distributions.  For an arbitrarily distributed grid, 
   only center stagger location is supported and there is no padding around the grid.
   Thus, the exclusive bounds, the total bounds and the computational bounds are identical 
   and <TT>staggerEdgeWidth</TT>, and <TT>gridEdgeWidth</TT> are all zeros. 

<P>

<H3><A NAME="SECTION040821500000000000000">
23.2.15 Getting Grid Coordinate Bounds</A>
</H3>

<P>
When operating on coordinates the user may often wish to 
   retrieve the bounds of the piece of coordinate data on
   a particular local DE. This is useful for iterating through the
   data to set coordinates, retrieve coordinates, or do calculations. 
   The method <TT>ESMF_GridGetCoord</TT> allows the user
   to retrieve bound information for a particular coordinate
   array. 

<P>
As described in the previous section there are three types of bounds the user can 
   get: exclusive bounds, computational bounds, 
   and total bounds. The bounds
   provided by <TT>ESMF_GridGetCoord</TT> are for both distributed
   and undistributed dimensions and are ordered according to the
   order of dimensions in the  coordinate. This means that the bounds
    provided should be usable
   "as is" to access data in the coordinate array. In the case
   of factorized coordinate Arrays where a coordinate may
   have a smaller dimension than its associated Grid, then
   the dimension of the coordinate's bounds are the dimension of
   the coordinate, not the Grid. 

<P>
The following is an example of retrieving the bounds for localDE 0 for the first
   coordinate array from the corner stagger location.   

<P>
<PRE>
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0,  &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER,                         &amp;
          exclusiveLBound=elbnd, exclusiveUBound=eubnd,              &amp;
          computationalLBound=clbnd, computationalUBound=cubnd,      &amp; 
          totalLBound=tlbnd, totalUBound=tubnd, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040821600000000000000">
23.2.16 Getting Grid Stagger Location Bounds</A>
</H3>

<P>
When operating on data stored at a particular stagger
   in a Grid the user may find it useful to be able
   to retrieve the bounds of the data on a particular local DE. 
   This is useful for iterating through the
   data for computations or allocating arrays to hold the data. 
   The method <TT>ESMF_GridGet</TT> allows the user
   to retrieve bound information for a particular stagger location. 

<P>
As described in Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> there are three types of bounds 
   the user can typically get, however, the Grid doesn't hold data at
   a stagger location (that is the job of the Field), and so 
   no Array is contained there and so no total region exists, so the 
   user may only retrieve exclusive and computational bounds from
   a stagger location.  The bounds
   provided by <TT>ESMF_GridGet</TT> are ordered according to the
   order of dimensions in the Grid. 

<P>
The following is an example of retrieving the bounds for localDE 0
   from the corner stagger location.  

<P>
<PRE>
   call ESMF_GridGet(grid2D, localDE=0,                         &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER,                    &amp;
          exclusiveLBound=elbnd, exclusiveUBound=eubnd,         &amp;
          computationalLBound=clbnd, computationalUBound=cubnd, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040821700000000000000">
23.2.17 Getting Grid Stagger Location Information</A>
</H3>

<P>
In addition to the per DE information that can be accessed about
   a stagger location there is some global information that can
   accessed by using <TT>ESMF_GridGet</TT> without specifying a
   localDE. One of the uses of this information is to create
   an ESMF Array to hold data for a stagger location. 

<P>
The information currently available from a stagger
   location is the <TT>staggerDistgrid</TT>  and
   <TT>minIndex</TT> and <TT>maxIndex</TT>. The <TT>staggerDistgrid</TT> gives the 
   distgrid which describes the size and distribution of the elements in the stagger location.
   The <TT>minIndex</TT> and <TT>maxIndex</TT> describe the lower and upper bounds of the stagger location.

<P>
The following is an example of retrieving information for localDE 0
   from the corner stagger location.  

<P>
<PRE>
    ! Get info about staggerloc
    call ESMF_GridGet(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER,  &amp;
           staggerDistgrid=staggerDistgrid, &amp;
           minIndex=minIndex, maxIndex=maxIndex, &amp;
           rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040821800000000000000">
23.2.18 Creating an Array at a Stagger Location</A>
</H3>

<P>
In order to create an Array to correspond to a Grid stagger location
   several pieces of information need to be obtained from both the 
   Grid and the stagger location in the Grid. 

<P>
The information that needs to be obtained from the Grid
   is the <TT>distgridToGridMap</TT> to ensure that the new Array
   has its  dimensions are mapped correctly to the Grid. These
   are obtained using the <TT>ESMF_GridGet</TT> method. 

<P>
The information that needs to be obtained from the stagger
   location is the distgrid that describes the size and distribution
   of the elements in the stagger location. This information can 
   be obtained using the stagger location specific <TT>ESMF_GridGet</TT> method. 

<P>
The following is an example of using information from a 2D Grid with non-arbitrary 
   distribution to create an Array corresponding to a stagger location.

<P>
<PRE>
    ! Get info from Grid
    call ESMF_GridGet(grid2D, distgridToGridMap=distgridToGridMap, rc=rc)

    ! Get info about staggerloc
    call ESMF_GridGet(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
           staggerDistgrid=staggerDistgrid, &amp;
           rc=rc)

    ! construct ArraySpec
    call ESMF_ArraySpecSet(arrayspec, rank=2, typekind=ESMF_TYPEKIND_R8, rc=rc)

    ! Create an Array based on info from grid
    array=ESMF_ArrayCreate(arrayspec=arrayspec, &amp;
            distgrid=staggerDistgrid, distgridToArrayMap=distgridToGridMap, &amp;
            rc=rc)
</PRE>

<P>
Creating an Array for a Grid with arbitrary distribution is different. 
   For a 2D Grid with both dimension arbitrarily distributed, the Array dimension
   is 1.  For a 3D Grid with two arbitrarily distributed dimensions and one
   undistributed dimension, the Array dimension is 2.  In general,
   if the Array does not have any ungridded dimension, the Array dimension 
   should be 1 plus the number of undistributed dimensions of the Grid.

<P>
The following is an example of creating an Array for a 3D Grid with 2 
   arbitrarily distributed dimensions such as the one defined in Section&nbsp;<A HREF="node4.html#example:ArbGridWithUndistDim">23.2.6</A>. 

<P>
<PRE>
    ! Get distGrid from Grid
    call ESMF_GridGet(grid3D, distgrid=distgrid, rc=rc)

    ! construct ArraySpec
    call ESMF_ArraySpecSet(arrayspec, rank=2, typekind=ESMF_TYPEKIND_R8, rc=rc)

    ! Create an Array based on the presence of distributed dimensions
    array=ESMF_ArrayCreate(arrayspec=arrayspec,distgrid=distgrid, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040821900000000000000"></A>
  <A NAME="sec:usage:adv:create"></A>
<BR>
23.2.19 Creating More Complex Grids Using DistGrid
</H3>

<P>
Besides the shortcut methods for creating a Grid object such as
   <TT>ESMF_GridCreateShapeTile()</TT>, there is
   a set of methods which give the user more control over the
   specifics of the grid.  The following describes the more 
   general interface, using DistGrid.
   The basic idea is to first create an ESMF DistGrid object describing
   the distribution and shape of the Grid, and then to employ that to either directly
   create the Grid or first create Arrays and then create the Grid from those. 
   This method gives the user maximum control over the topology and distribution of the Grid. 
   See the DistGrid documentation in Section&nbsp;<A HREF="node4.html#sec:DistGrid">26.1</A> for an 
   in-depth description of its interface and use. 

<P>
As an example, the following call constructs
   a 10x20 Grid with a lower bound of (1,2). 

<P>
<PRE>
   ! Create DistGrid
   distgrid2D = ESMF_DistGridCreate(minIndex=(/1,2/), maxIndex=(/11,22/), rc=rc)  

   ! Create Grid
   grid3D=ESMF_GridCreate(distGrid=distgrid2D, rc=rc)
</PRE>

<P>
To alter which dimensions are distributed, the <TT>distgridToGridMap</TT> 
   argument can be used. The <TT>distgridToGridMap</TT> is used to set
   which dimensions of the Grid are mapped to the dimensions
   described by <TT>maxIndex</TT>. In other words, it describes how the dimensions of 
   the underlying default DistGrid are mapped to the Grid. Each entry
   in <TT>distgridToGridMap</TT> contains the Grid dimension to which the cooresponding
   DistGrid dimension should be mapped. 
   The following example illustrates the creation of a Grid where the largest
   dimension is first. To accomplish this the two dimensions are swapped.  

<P>
<PRE>
   ! Create DistGrid
   distgrid2D = ESMF_DistGridCreate(minIndex=(/1,2/), maxIndex=(/11,22/), rc=rc)  

   ! Create Grid
   grid2D=ESMF_GridCreate(distGrid=distgrid2D, distgridToGridMap=(/2,1/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040822000000000000000"></A>
  <A NAME="sec:usage:staggerloc:adv"></A>
<BR>
23.2.20 Specifying Custom Stagger Locations
</H3>

<P>
Although ESMF provides a set of predefined stagger locations (See Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A>),
   the user may need one outside this set. This section describes the construction of
   custom stagger locations. 

<P>
To completely specify stagger for an arbitrary number of dimensions, we define the 
   stagger location in terms of a set of cartesian coordinates. The cell is represented
   by a n-dimensional cube with sides of length 2, and the coordinate origin located at
   the center of the cell. The geometry of the cell is for reference purposes only, 
   and does not literally represent the actual shape of the cell. Think of this method
   instead as an easy way to specify a part (e.g. center, corner, face) of a higher 
   dimensional cell which is extensible to any number of dimensions. 

<P>
To illustrate this approach, consider a 2D cell. In 2 dimensions
   the cell is represented by a square. An xy axis is placed at its center, with the 
   positive x-axis oriented <EM>East</EM> and the positive y-axis oriented <EM>North</EM>.
   The resulting coordinate for the lower left corner is at <IMG
 WIDTH="66" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$(-1,-1)$">, and upper right
   corner at <IMG
 WIDTH="41" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img56.png"
 ALT="$(1,1)$">.
   However, because our staggers are symmetric they don't need to distinguish between
   the <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img57.png"
 ALT="$-1$">, and the <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="$1$">, so we only need concern ourselves with the first quadrant of
   this cell. We only need to use the <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="$1$">, and the <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img58.png"
 ALT="$0$">, and many of the cell locations
   collapse together (e.g. we only need to represent one corner). See figure&nbsp;<A HREF="node4.html#fig:gridcuststaggerloc">15</A>
   for an illustration of these concepts.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridcuststaggerloc"></A><A NAME="28822"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 15:</STRONG>
An example of specifying 2D stagger locations using coordinates.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridCustStaggerLoc}}$
 -->
<IMG
 WIDTH="626" HEIGHT="356" ALIGN="BOTTOM" BORDER="0"
 SRC="img59.png"
 ALT="\scalebox{0.75}{\includegraphics{GridCustStaggerLoc}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The cell center is represented by the coordinate pair <IMG
 WIDTH="41" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img60.png"
 ALT="$(0,0)$"> indicating the origin.
   The cell corner is <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$+1$"> in each direction, giving a coordinate pair of <IMG
 WIDTH="41" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img56.png"
 ALT="$(1,1)$">.
   The edges are each <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$+1$"> in one dimension and <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img58.png"
 ALT="$0$"> in the other indicating that 
   they're even with the center in one dimension and offset in the other. 

<P>
For three dimensions, the vertical component of the stagger location can be added by 
   simply adding an additional coordinate. The three dimensional generalization of the
   cell center becomes <IMG
 WIDTH="56" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$(0,0,0)$"> and the cell corner becomes <IMG
 WIDTH="56" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img63.png"
 ALT="$(1,1,1)$">. The rest of
   the 3D stagger locations are combinations of <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$+1$"> offsets from the center. 

<P>
To generalize this to <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img64.png"
 ALT="$d$"> dimensions, to represent a <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img64.png"
 ALT="$d$"> dimensional stagger
   location. A set of <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img64.png"
 ALT="$d$"> <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img58.png"
 ALT="$0$"> and <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="$1$"> is used to specify for each dimension
   whether a stagger location is aligned with the cell center in that dimension (<IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img58.png"
 ALT="$0$">),
   or offset by <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$+1$"> in that dimension (<IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="$1$">). Using this scheme we can represent
   any symmetric stagger location.  

<P>
To construct a custom stagger location in ESMF the subroutine 
   <TT>ESMF_StaggerLocSet()</TT> is used to specify, 
   for each dimension, whether the stagger is located at the interior (0) 
   or on the boundary (1) of the cell. This method allows users
   to construct stagger locations for which
   there is no predefined value. In this example, it's used to 
   set the 4D center and 4D corner locations. 

<P>
<PRE>
   ! Set Center
   call ESMF_StaggerLocSet(staggerLoc,loc=(/0,0,0,0/),rc=rc)
   call ESMF_GridAddCoord(grid4D, staggerLoc=staggerLoc, rc=rc)

   ! Set Corner
   call ESMF_StaggerLocSet(staggerLoc,loc=(/1,1,1,1/),rc=rc)
   call ESMF_GridAddCoord(grid4D, staggerLoc=staggerLoc, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040822100000000000000"></A>
  <A NAME="sec:usage:staggerpadding:adv"></A>
<BR>
23.2.21 Specifying Custom Stagger Padding
</H3>

<P>
There is an added complication with the data (e.g. coordinates) stored at stagger locations in 
  that they can require different amounts of storage depending
  on the underlying Grid type. 

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridcellsandcorners"></A><A NAME="28835"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 16:</STRONG>
An example 2D Grid with cell centers and corners.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridCellsAndCorners}}$
 -->
<IMG
 WIDTH="432" HEIGHT="259" ALIGN="BOTTOM" BORDER="0"
 SRC="img65.png"
 ALT="\scalebox{0.75}{\includegraphics{GridCellsAndCorners}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
Consider the example 2D grid in figure&nbsp;<A HREF="node4.html#fig:gridcellsandcorners">16</A>, where the dots represent the cell corners
   and the ``+'' represents the cell centers. For the corners to completely
   enclose the cell centers (symmetric stagger), the number of corners in each 
   dimension needs to be one greater then the number of cell centers. In the above 
   figure, there are two rows and three columns of cell centers. To enclose the 
   cell centers, there must be three rows and four columns of cell corners.
   This is true in general for Grids without periodicity or
   other connections.  In fact, for a symmetric stagger, given that the center
   location requires n x m storage, the corresponding corner location
   requires n+1 x m+1, and the edges, depending on the side, require n+1 x m or
   m+1 x n.  In order to add the extra storage, a new DistGrid is
   created at each stagger location. This Distgrid is similar to the DistGrid
   used to create the Grid, but has an extra set of elements added to hold the 
   index locations for the stagger padding.
   By default, when the coordinate arrays are created, one extra
   layer of padding is added to the index space to create symmetric staggers 
   (i.e. the center location is surrounded). The default is to add this padding 
   on the positive side, and to only add this padding where needed 
   (e.g. no padding for the center, padding
   on both dimensions for the corner, in only one dimension for the 
   edge in 2D.) There are two ways for the user to change
   these defaults. 

<P>
One way is to use the <TT>GridEdgeWidth</TT> or <TT>GridAlign</TT> arguments
   when creating a Grid. These arguments can be used to change the default padding
   around the Grid cell index space. This extra padding is used by default
   when setting the padding for a stagger location. 

<P>
The <TT>gridEdgeLWidth</TT> and 
   <TT>gridEdgeUWidth</TT> arguments are both 1D arrays of the
   same size as the Grid dimension. The entries in the arrays
   give the extra offset from the outer boundary of
   the grid cell index space. The following example shows the
   creation of a Grid with all the extra space to hold stagger padding
   on the negative side of a Grid. This is the reverse of
   the default behavior. The resulting Grid will have
   an exclusive region which extends from <IMG
 WIDTH="66" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$(-1,-1)$"> to
   <IMG
 WIDTH="57" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img66.png"
 ALT="$(10,10)$">, however, the cell center stagger location
   will still extend from <IMG
 WIDTH="41" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img56.png"
 ALT="$(1,1)$"> to <IMG
 WIDTH="57" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img66.png"
 ALT="$(10,10)$">. 

<P>
<PRE>
   grid2D=ESMF_GridCreateShapeTile(minIndex=(/1,1/),maxIndex=(/10,10/), &amp;
            gridEdgeLWidth=(/1,1/), gridEdgeUWidth=(/0,0/), rc=rc)
</PRE>

<P>
To indicate how the data in a Grid's stagger locations are aligned with the 
   cell centers, the optional <TT>gridAlign</TT> parameter 
   may be used. This parameter indicates which stagger elements 
   in a cell share the same index values as the cell center. 
   For example, in a 2D cell, it would indicate which of the four corners has
   the same index value as the center. To set <TT>gridAlign</TT>,  
   the values -1,+1 are used to indicate the alignment in
   each dimension. This parameter is mostly 
   informational, however, if the <TT>gridEdgeWidth</TT> parameters 
   are not set then its value determines where the default padding
   is placed. If not specified, then the default is to align all 
   staggers to the most negative, so the padding is on the positive side. 
   The following code illustrates creating a Grid aligned to the reverse of
   default (with everything to the positive side). This creates a
   Grid identical to that created in the previous example.  

<P>
<PRE>
   grid2D=ESMF_GridCreateShapeTile(minIndex=(/1,1/),maxIndex=(/10,10/), &amp;
            gridAlign=(/1,1/), rc=rc)
</PRE>

<P>
The <TT>gridEdgeWidth</TT> and <TT>gridAlign</TT> arguments both
   allow the user to set the default padding to be used
   by stagger locations in a Grid. By default, stagger locations
   allocated in a Grid set their stagger padding based on these
   values.  A stagger location's padding in each dimension is
   equal to the value of <TT>gridEdgeWidth</TT> (or the value implied
   by <TT>gridAlign</TT>), unless the stagger location is centered
   in a dimension in which case the stagger padding is 0. For example,
   the cell center stagger location has 0 stagger padding in all
   dimensions, whereas the edge stagger location lower padding
   is equal to <TT>gridEdgeLWidth</TT> and the upper padding is equal
   to <TT>gridEdgeUWidth</TT> in one dimension, but both are 0 in the other,
   centered, dimension.  If the user wishes to set the stagger padding
   individually for each stagger location they may use the
   <TT>staggerEdgeWidth</TT> and <TT>staggerAlign</TT> arguments.

<P>
The <TT>staggerEdgeLWidth</TT> and 
   <TT>staggerEdgeUWidth</TT> arguments are both 1D arrays of the
   same size as the Grid dimension. The entries in the arrays
   give the extra offset from the Grid cell index space
   for a stagger location. The following example shows the
   addition of two stagger locations. The
   corner location has no extra boundary and the 
   center has a single layer of extra padding on 
   the negative side and none on the positive.  This is the reverse of
   the default behavior. 

<P>
<PRE>
   grid2D=ESMF_GridCreate(distgrid=distgrid2D, &amp;
            gridEdgeLWidth=(/1,1/), gridEdgeUWidth=(/0,0/), rc=rc)

   call ESMF_GridAddCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          staggerEdgeLWidth=(/0,0/), staggerEdgeUWidth=(/0,0/), rc=rc)

   call ESMF_GridAddCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CENTER, &amp;
          staggerEdgeLWidth=(/1,1/), staggerEdgeUWidth=(/0,0/), rc=rc)
</PRE>

<P>
To indicate how the data at a particular stagger location is aligned with the 
   cell center, the optional <TT>staggerAlign</TT> parameter 
   may be used. This parameter indicates which stagger elements 
   in a cell share the same index values as the cell center. 
   For example, in a 2D cell, it would indicate which of the four corners has
   the same index value as the center. To set <TT>staggerAlign</TT>,  
   the values -1,+1 are used to indicate the alignment in
   each dimension. If a stagger location is 
   centered in a dimension (e.g. an edge in 2D), then that
   dimension is ignored in the alignment. This parameter is mostly 
   informational, however, if the <TT>staggerEdgeWidth</TT> parameters 
   are not set then its value determines where the default padding
   is placed. If not specified, then the default is to align all 
   staggers to the most negative, so the padding is on the positive side. 
   The following code illustrates aligning the positive (northeast in 2D) 
   corner with the center.  

<P>
<PRE>
   call ESMF_GridAddCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, staggerAlign=(/1,1/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040822200000000000000"></A> 
   <A NAME="example:GridCrFromFile"></A>
<BR>
23.2.22 Creating a 2D Regularly Distributed Rectilinear Grid from File
</H3>

<P>
This example shows how to read an ESMF GridSpec Attribute Package from an
   XML file and use it to create a grid.  The XML file contains Attribute values
   filled-in by the user.  The standard GridSpec Attribute Package is supplied
   with ESMF and is defined in an XSD file, which is used to validate the
   XML file. See
   <DL>
<DT></DT>
<DD>ESMF_DIR/src/Infrastructure/Grid/etc/esmf_grid_shape_tile.xml (Attribute Package values) and
   
</DD>
<DT></DT>
<DD>ESMF_DIR/src/Infrastructure/Grid/etc/esmf_grid.xsd (Attribute Package definition).
   
</DD>
</DL>

<P>
The following XML attributes, from the file mentioned above, specifies a
   two dimensional, 10x20 single-tile rectilinear grid that is regularly
   distributed into 2 DEs in the first dimension and 3 DEs in the second
   dimension, for a total of 6 DEs (2x3):

<P>
<PRE>
  &lt;?xml version="1.0"?&gt;
  &lt;GridSpec&gt;
    &lt;Mosaic&gt;
      &lt;attribute_package convention="ESMF" purpose="General"&gt;
        &lt;NX&gt;10&lt;/NX&gt;
        &lt;NY&gt;20&lt;/NY&gt;
      &lt;/attribute_package&gt;
      &lt;RegDecompX&gt;2&lt;/RegDecompX&gt;
      &lt;RegDecompY&gt;3&lt;/RegDecompY&gt;
    &lt;/Mosaic&gt;
  &lt;/GridSpec&gt;
</PRE> 

<P>
Read the file and create the grid, 

<P>
<PRE>
   ! Read an XML file containing user-filled-in values for a GridSpec Attribute
   ! package and use it to create a grid.  The file is validated against an
   ! internal, ESMF-supplied XSD file defining the standard GridSpec Attribute
   ! package (see file pathnames above).
   grid2D=ESMF_GridCreate("esmf_grid_shape_tile.xml", rc=rc)
</PRE>

<P>
then show that the minimum and maximum global indices of the Grid are
   (1,1) <IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img67.png"
 ALT="$\sim$"> (11,21) (one extra default stagger pad in each dimension): 

<P>
<PRE>
   call ESMF_GridGet(grid2D, minIndex=minIndex, maxIndex=maxIndex, rc=rc)
   print *, "minIndex(1), minIndex(2) = ", minIndex(1), minIndex(2)
   print *, "maxIndex(1), maxIndex(2) = ", maxIndex(1), maxIndex(2)
</PRE>

<P>
Get the resulting computational bounds for each local DE within the local PET,
   for center stagger locations: 

<P>
<PRE>
   call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, rc=rc)
   print *, "localPet = ", localPet, "petCount = ", petCount

   call ESMF_GridGet(grid2D, localDECount=localDECount, rc=rc)
   print *, "localDECount = ", localDECount
</PRE>

<P>
<PRE>
   do i=0,localDECount-1
     call ESMF_GridGet(grid2D, localDE=i,  &amp;
                       staggerLoc=ESMF_STAGGERLOC_CENTER, &amp;
                       computationalLBound=clbnd, computationalUBound=cubnd, &amp; 
                       rc=rc)
       print *, "clbnd,cubnd = ", clbnd(1), ", ", clbnd(2), " ", &amp;
                                  cubnd(1), ", ", cubnd(2)
       print *, " "
   enddo
</PRE>

<P>
For a 4 PET run, this will show the following (lower) <IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img67.png"
 ALT="$\sim$"> (upper)
   computational bounds per DE, 6 DEs total (2x3):

<P>
<PRE>
    PET 0:
      local DE 0 - (1,1)  ~ (5,7)
      local DE 1 - (1,15) ~ (5,20)
    PET 1:
      local DE 0 - (6,1)  ~ (10,7)
      local DE 1 - (6,15) ~ (10,20)
    PET 2:
      local DE 0 - (1,8)  ~ (5,14)
    PET 3:
      local DE 0 - (6,8)  ~ (10,14)
</PRE>

<P>
For a 1 PET run, the distribution will be

<P>
<PRE>
      local DE 0 - (1,1)  ~ (5,7)
      local DE 1 - (6,1)  ~ (10,7)
      local DE 2 - (1,8)  ~ (5,14)
      local DE 3 - (6,8)  ~ (10,14)
      local DE 4 - (1,15) ~ (5,20)
      local DE 5 - (6,15) ~ (10,20)
</PRE>

<P>
The Grid and its distribution, represented graphically:

<P>
<PRE>
      -------------------------------------------------------&gt; 2nd dim
      |
      |  (1,1)-------(1,7)(1,8)------(1,14)(1,15)-----(1,20)
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  (5,1)-------(5,7)(5,8)------(5,14)(5,15)-----(5,20)
      |  (6,1)-------(6,7)(6,8)------(6,14)(6,15)-----(6,20)
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  (10,1)-----(10,7)(10,8)----(10,14)(10,15)---(10,20)
      |
      |
      v
     1st dim
</PRE>

<P>

<H2><A NAME="SECTION04083000000000000000">
23.3 Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>7D limit.</B>  Only grids up to 7D will be supported.

<P>
</LI>
<LI><B>During the first development phase only single
tile grids are supported.</B>  In the near future, support
for mosaic grids will be added.  The initial implementation 
will be to create mosaics that contain tiles of the same
grid type, e.g. rectilinear.

<P>
</LI>
<LI><B>Future adaptation.</B>  Currently Grids
are created and then remain unchanged. In the future, it would
be useful to provide support for the various forms of grid
adaptation. This would allow the grids to dynamically change
their resolution to more closely match what is needed at a particular
time and postion during a computation for front tracking or adaptive meshes.

<P>
</LI>
<LI><B>Future Exchange Grids.</B>  The functionality for creating an 
exchange grid between two ordinary grids will be implemented
to assist with the remapping of data during a regrid operation. 

<P>
</LI>
<LI><B>Future Grid IO.</B> Currently a grid specification can be read in to create a two dimensional, logically rectangular grid, with regular distribution.  In the future, more dimensions and other grid types and distributions will be supported. Also, other file formats, besides the current XML format, may be supported, corresponding to different group's file formats.

<P>
</LI>
<LI><B>Future Grid generation.</B> This class for now only contains
the basic functionality for operating on the grid. In the future
methods will be added to enable the automatic generation of various types of
grids. 

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION04084000000000000000">
23.4 Design and Implementation Notes</A>
</H2>

<P>

<H3><A NAME="SECTION04084100000000000000">
23.4.1 Grid Topology</A>
</H3> 

<P>
The <TT>ESMF_Grid</TT> class depends upon the <TT>ESMF_DistGrid</TT> class
for the specification of its topology. That is, when 
creating a Grid, first an <TT>ESMF_DistGrid</TT> is created to describe the 
appropriate index space topology. This decision was
made because it seemed redundant to have a system for doing this
in both classes. It also seems most appropriate for
the machinary for topology creation to be located at the lowest
level possible so that it can be used by other
classes (e.g. the <TT>ESMF_Array</TT> class). Because of this, however,
the authors recommend that as a natural part of the 
implementation of subroutines to generate standard grid shapes
(e.g. <TT>ESMF_GridGenSphere</TT>) a set of standard
topology generation subroutines be implemented (e.g. <TT>ESMF_DistGridGenSphere</TT>) for users who want to create a standard topology, but a custom geometry.

<P>

<P>

<H2><A NAME="SECTION04085000000000000000">
23.5 Grid Options</A>
</H2>

<P>

<H3><A NAME="SECTION04085100000000000000"></A>
<A NAME="sec:opt:gridconn"></A>
<BR>
23.5.1 ESMF_GridConn
</H3>
<I>DESCRIPTION:
<BR></I>
The <TT>ESMF_GridCreateShapeTile</TT> command has three specific arguments
<TT>connDim1</TT>, <TT>connDim2</TT>, and <TT>connDim3</TT>. These can be used
to setup different types of connections at the ends of each dimension
of a Tile.  Each of these parameters is a two element array. The first
element is the connection type at the minimum end of the dimension
and the second is the connection type at the maximum end. The default
value for all the connections is ESMF_GRIDCONN_NONE, specifying no
connection.

<P>

<P>
<BR>
<DL>
<DT><STRONG>ESMF_GRIDCONN_NONE</STRONG></DT>
<DD>No connection.

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_PERIODIC</STRONG></DT>
<DD>Periodic connection.

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_POLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, then element i is connected to
element i+n/2.

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_BIPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, element i is connected to element n-i-1.

<P>
</DD>
</DL>

<P>

<H3><A NAME="SECTION04085200000000000000"></A>
<A NAME="sec:opt:gridstatus"></A>
<BR>
23.5.2 ESMF_GridStatus
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
The ESMF Grid class can exist in three states. These states are
present so that the library code can detect if a Grid has been
appropriately setup for the task at hand. The following
are the valid values of ESMF_GRIDSTATUS.

<P>

<P>
<BR>
<DL>
<DT><STRONG>ESMF_GRIDSTATUS_NOT_READY:</STRONG></DT>
<DD>Status after a Grid has been created with 
      <TT>ESMF_GridCreateEmpty</TT>.  A Grid object container is allocated but
      space for internal objects is not.  Topology information and coordinate
      information is incomplete.  This object can be used in <TT>ESMF_GridSet()</TT>
      methods in which additional information is added to the Grid.
</DD>
<DT><STRONG>ESMF_GRIDSTATUS_SHAPE_READY:</STRONG></DT>
<DD>The Grid has a specific topology and
      distribution, but incomplete coordinate arrays.  The Grid can be used
      as the basis for allocating a Field.
</DD>
<DT><STRONG>ESMF_GRIDSTATUS_REGRID_READY:</STRONG></DT>
<DD>The grid contains valid coordinate
      values and is ready to be used in regrid. 
</DD>
</DL>

<P>

<H3><A NAME="SECTION04085300000000000000"></A>
<A NAME="sec:opt:griditem"></A>
<BR>
23.5.3 ESMF_GridItem
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
The ESMF Grid can contain other kinds of data besides coordinates. 
This data is referred to as Grid ``items''. Some items may be used
by ESMF for calculations involving the Grid. The following
are the valid values of ESMF_GRIDITEM.

<P>

<P>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Item Label</TD>
<TD ALIGN="CENTER"><B>Type Restriction</B></TD>
<TD ALIGN="CENTER"><B>Type Default</B></TD>
<TD ALIGN="CENTER"><B>ESMF Uses</B></TD>
<TD ALIGN="CENTER"><B>Controls</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMF_GRIDITEM_MASK</B></TD>
<TD ALIGN="CENTER">ESMF_TYPEKIND_I4</TD>
<TD ALIGN="CENTER">ESMF_TYPEKIND_I4</TD>
<TD ALIGN="CENTER">YES</TD>
<TD ALIGN="CENTER">Masking in Regrid</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMF_GRIDITEM_AREA</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">ESMF_TYPEKIND_R8</TD>
<TD ALIGN="CENTER">NO</TD>
<TD ALIGN="CENTER">N/A</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMF_GRIDITEM_AREAM</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">ESMF_TYPEKIND_R8</TD>
<TD ALIGN="CENTER">NO</TD>
<TD ALIGN="CENTER">N/A</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMF_GRIDITEM_FRAC</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">ESMF_TYPEKIND_R8</TD>
<TD ALIGN="CENTER">NO</TD>
<TD ALIGN="CENTER">N/A</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION04085400000000000000"></A><A NAME="sec:opt:staggerloc"></A>
<BR>
23.5.4 ESMF_StaggerLoc
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
 In the ESMF Grid class, data can be located at different positions in a
 Grid cell.  When setting or retrieving coordinate data the stagger location is
 specified to tell the Grid method  from where in the cell to get the data. 
 Although the user may define their own custom stagger locations, 
 ESMF provides a set of predefined locations for ease of use. The
following are the valid predefined stagger locations. 

<P>

<P>
<BR>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridstaggerloc2d"></A><A NAME="29721"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 17:</STRONG>
2D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}$
 -->
<IMG
 WIDTH="561" HEIGHT="345" ALIGN="BOTTOM" BORDER="0"
 SRC="img68.png"
 ALT="\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The 2D predefined stagger locations (illustrated in figure&nbsp;<A HREF="node4.html#fig:gridstaggerloc2d">17</A>) are:
<BR><DL>
<DT><STRONG>ESMF_STAGGERLOC_CENTER:</STRONG></DT>
<DD>The center of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER:</STRONG></DT>
<DD>The corners of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1:</STRONG></DT>
<DD>The edges offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2:</STRONG></DT>
<DD>The edges offset from the center in the 2nd dimension.
</DD>
</DL>

<P>

<P>
<BR>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridstaggerloc3d"></A><A NAME="29732"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 18:</STRONG>
3D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}$
 -->
<IMG
 WIDTH="532" HEIGHT="417" ALIGN="BOTTOM" BORDER="0"
 SRC="img69.png"
 ALT="\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The 3D predefined stagger locations (illustrated in figure&nbsp;<A HREF="node4.html#fig:gridstaggerloc3d">18</A>) are:
<BR><DL>
<DT><STRONG>ESMF_STAGGERLOC_CENTER_VCENTER:</STRONG></DT>
<DD>The center of the 3D cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER_VCENTER:</STRONG></DT>
<DD>Half way up the vertical edges of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 1 and the vertical dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 2 and the vertical dimension. 
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER_VFACE:</STRONG></DT>
<DD>The corners of the 3D cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 2nd dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CENTER_VFACE:</STRONG></DT>
<DD>The center of the top and bottom face. The face bounded by the 1st and 2nd dimensions. 
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION04086000000000000000">
23.6 Class API: General Grid Methods</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04086100000000000000">
23.6.1 ESMF_GridAddCoord - Allocate coordinate arrays but don't set their values</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridAddCoord()
      subroutine ESMF_GridAddCoordNoValues(grid, staggerloc,  &amp;
                 staggerEdgeLWidth, staggerEdgeUWidth, staggerAlign, &amp;
                 staggerMemLBound, totalLWidth, totalUWidth,rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)              :: grid 
       type (ESMF_StaggerLoc), intent(in),optional     :: staggerloc
       integer,                intent(in),optional     :: staggerEdgeLWidth(:)
       integer,                intent(in),optional     :: staggerEdgeUWidth(:)
       integer,                intent(in),optional     :: staggerAlign(:)
       integer,                intent(in),optional     :: staggerMemLBound(:)      
       integer,                intent(out), optional   :: totalLWidth(:)         ! N. IMP
       integer,                intent(out), optional   :: totalUWidth(:)         ! N. IMP
       integer,                intent(out),optional    :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
When a Grid is created all of its potential stagger locations can hold coordinate
    data, but none of them have storage allocated. This call allocates coordinate
    storage (creates internal ESMF_Arrays and associated memory) for  a particular
    stagger location. Note that this
    call doesn't assign any values to the storage, it only allocates it. The
    remaining options <TT>staggerEdgeLWidth</TT>, etc. allow the user to adjust the 
    padding on the coordinate arrays.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to allocate coordinate storage in.  
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to add. Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
   
</DD>
<DT><STRONG>[staggerEdgeLWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the lower corner of the stagger
        region with respect to the lower corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerEdgeUWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the upper corner of the stagger
        region with respect to the upper corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerAlign]</STRONG></DT>
<DD>This array is of size  grid dimCount.
        For this stagger location, it specifies which element
        has the same index value as the center. For example, 
        for a 2D cell with corner stagger it specifies which 
        of the 4 corners has the same index as the center. 
        If this is set and either staggerEdgeUWidth or staggerEdgeLWidth is not,
        this determines the default array padding for a stagger. 
        If not set, then this defaults to all negative. (e.g. 
        The most negative part of the stagger in a cell is aligned with the 
        center and the padding is all on the postive side.) 
   
</DD>
<DT><STRONG>[staggerMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this staggerloc in this Grid. 
        Only used when Grid indexflag is <TT>ESMF_INDEX_USER</TT>. 
  
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>The lower boundary of the computatational region in reference to the computational region. 
       Note, the computational region includes the extra padding specified by <TT>ccordLWidth</TT>.
       [CURRENTLY NOT IMPLEMENTED]
  
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>The lower boundary of the computatational region in reference to the computational region. 
       Note, the computational region includes the extra padding specified by <TT>staggerEdgeLWidth</TT>.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04086200000000000000">
23.6.2 ESMF_GridAddItem - Allocate item array but don't set their values</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridAddItem()
      subroutine ESMF_GridAddItemNoValues(grid, staggerloc, item, itemTypeKind, &amp;
                 staggerEdgeLWidth, staggerEdgeUWidth, staggerAlign,  &amp;
                 staggerMemLBound,  totalLWidth, totalUWidth,rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)              :: grid 
       type (ESMF_StaggerLoc), intent(in),optional     :: staggerloc
       type (ESMF_GridItem),   intent(in)              :: item
       type (ESMF_TypeKind),   intent(in),optional     :: itemTypeKind
       integer,                intent(in),optional     :: staggerEdgeLWidth(:)
       integer,                intent(in),optional     :: staggerEdgeUWidth(:)
       integer,                intent(in),optional     :: staggerAlign(:)
       integer,                intent(in),optional     :: staggerMemLBound(:)      
       integer,                intent(out), optional   :: totalLWidth(:)         ! N. IMP
       integer,                intent(out), optional   :: totalUWidth(:)         ! N. IMP
       integer,                intent(out),optional    :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
When a Grid is created all of its potential stagger locations can hold item
    data, but none of them have storage allocated. This call allocates item
    storage (creates an internal ESMF_Array and associated memory) for  a particular
    stagger location. Note that this
    call doesn't assign any values to the storage, it only allocates it. The
    remaining options <TT>staggerEdgeLWidth</TT>, etc. allow the user to adjust the 
    padding on the item array.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to allocate coordinate storage in.  
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to add. Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
   
</DD>
<DT><STRONG>item</STRONG></DT>
<DD>The grid item to add. Please see Section&nbsp;<A HREF="node4.html#sec:opt:griditem">23.5.3</A> for a list of valid items. 
   
</DD>
<DT><STRONG>itemTypeKind</STRONG></DT>
<DD>The typekind of the  item to add. 
   
</DD>
<DT><STRONG>[staggerEdgeLWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the lower corner of the stagger
        region with respect to the lower corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerEdgeUWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the upper corner of the stagger
        region with respect to the upper corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerAlign]</STRONG></DT>
<DD>This array is of size  grid dimCount.
        For this stagger location, it specifies which element
        has the same index value as the center. For example, 
        for a 2D cell with corner stagger it specifies which 
        of the 4 corners has the same index as the center. 
        If this is set and either staggerEdgeUWidth or staggerEdgeLWidth is not,
        this determines the default array padding for a stagger. 
        If not set, then this defaults to all negative. (e.g. 
        The most negative part of the stagger in a cell is aligned with the 
        center and the padding is all on the postive side.) 
   
</DD>
<DT><STRONG>[staggerMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this staggerloc in this Grid. 
        Only used when Grid indexflag is <TT>ESMF_INDEX_USER</TT>. 
  
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>The lower boundary of the computatational region in reference to the computational region. 
       Note, the computational region includes the extra padding specified by <TT>ccordLWidth</TT>.
       [CURRENTLY NOT IMPLEMENTED]
  
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>The lower boundary of the computatational region in reference to the computational region. 
       Note, the computational region includes the extra padding specified by <TT>staggerEdgeLWidth</TT>.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04086300000000000000">
23.6.3 ESMF_GridCreate - Create a Grid from a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateFromDistGrid(name,coordTypeKind,distgrid, &amp;
                          distgridToGridMap, coordDimCount, coordDimMap, &amp;
                          gridEdgeLWidth, gridEdgeUWidth, gridAlign, gridMemLBound, &amp;
                          indexflag, destroyDistGrid, destroyDELayout, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateFromDistGrid
</PRE><EM>ARGUMENTS:</EM>
<PRE>        character (len=*), intent(in), optional :: name
        type(ESMF_TypeKind),  intent(in),   optional  :: coordTypeKind
        type(ESMF_DistGrid),   intent(in)              :: distgrid
        integer,               intent(in),   optional  :: distgridToGridMap(:)
        integer,               intent(in),   optional  :: coordDimCount(:)
        integer,               intent(in),   optional  :: coordDimMap(:,:)
        integer,               intent(in),   optional  :: gridEdgeLWidth(:)
        integer,               intent(in),   optional  :: gridEdgeUWidth(:)
        integer,               intent(in),   optional  :: gridAlign(:)
        integer,               intent(in),   optional  :: gridMemLBound(:)
        type(ESMF_IndexFlag),  intent(in),   optional  :: indexflag
        logical,               intent(in),   optional  :: destroyDistGrid
        logical,               intent(in),   optional  :: destroyDELayout
        integer,               intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This is the most general form of creation for an <TT>ESMF_Grid</TT>
   object. It allows the user to fully specify the topology and index space
   using the DistGrid methods and then build a grid out
   of the resulting DistGrid. Note that since the Grid created by this call 
   uses <TT>distgrid</TT> as a description of its index space, the resulting Grid 
   will have exactly the same number of dimensions (i.e. the same dimCount) as 
   <TT>distgrid</TT>. The <TT>distgridToGridMap</TT> argument
   specifies how the Grid dimensions are mapped to the <TT>distgrid</TT>. 
   The <TT>coordDimCount</TT> and <TT>coordDimMap</TT> arguments
   allow the user to specify how the coordinate arrays should map to the grid
   dimensions. (Note, though, that creating a grid does not allocate coordinate
   storage. A method such as <TT>ESMF_GridAddCoord()</TT> must be called
   before adding coordinate values.)

<P>
The arguments are:
   <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals.  
   
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
        distributed over DEs. 
   
</DD>
<DT><STRONG>[distgridToGridMap]</STRONG></DT>
<DD>List that has dimCount elements.
        The elements map each dimension of distgrid to a dimension in the grid.
         (i.e. the values should range from 1 to dimCount). If not specified, the default
         is to map all of distgrid's dimensions against the dimensions of the
         grid in sequence. 
   
</DD>
<DT><STRONG>[coordDimCount]</STRONG></DT>
<DD>List that has dimCount elements.
        Gives the dimension of each component (e.g. x) array. This is 
        to allow factorization of the coordinate arrays. If not specified
        all arrays are the same size as the grid. 
   
</DD>
<DT><STRONG>[coordDimMap]</STRONG></DT>
<DD>2D list of size dimCount x  dimCount. This array describes the
        map of each component array's dimensions onto the grids
        dimensions. Each entry <TT>coordDimMap(i,j)</TT> tells which
        grid dimension component i's, jth dimension maps to. 
        Note that if j is bigger than <TT>coordDimCount(i)</TT> it is ignored.        
        The default for each row i is <TT>coordDimMap(i,:)=(1,2,3,4,...)</TT>.        
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#opt:indexflag">9.2.8</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[destroyDistgrid]</STRONG></DT>
<DD>If true, when the Grid is destroyed the DistGrid will be destroyed also. 
        Defaults to false. 
   
</DD>
<DT><STRONG>[destroyDELayout]</STRONG></DT>
<DD>If true, when the Grid is destroyed the DELayout will be destroyed also. 
        Defaults to false. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04086400000000000000">
23.6.4 ESMF_GridCreate - Create a Arbitrary Grid from a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateFromDistGridArb(name,coordTypeKind,distgrid, &amp;
 			 indexArray, distDim, coordDimCount, coordDimMap, &amp;
                          destroyDistGrid, destroyDELayout, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateFromDistGridArb
</PRE><EM>ARGUMENTS:</EM>
<PRE>        character (len=*), intent(in), optional :: name
        type(ESMF_TypeKind),  intent(in),   optional  :: coordTypeKind
        type(ESMF_DistGrid),   intent(in)              :: distgrid
        integer,               intent(in)              :: indexArray(:,:)
        integer,               intent(in),   optional  :: distDim(:)
        integer,               intent(in),   optional  :: coordDimCount(:)
        integer,               intent(in),   optional  :: coordDimMap(:,:)
        logical,               intent(in),   optional  :: destroyDistGrid
        logical,               intent(in),   optional  :: destroyDELayout
        integer,               intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This is the lower level function to create an arbitrailiy distributed <TT>ESMF_Grid</TT>
   object. It allows the user to fully specify the topology and index space
   (of the distributed dimensions) using the DistGrid methods and then build a grid out
   of the resulting <TT>distgrid</TT>.  The <TT>indexArray(2,dimCount)</TT>, 
   argument is required to specifies the topology of the grid.

<P>
The arguments are:
   <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals.  
   
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
        distributed over DEs. 
   
</DD>
<DT><STRONG>[indexArray]</STRONG></DT>
<DD>The minIndex and maxIndex array of size <TT>2</TT> x <TT>dimCount</TT>
        <TT>indexArray(1,:)</TT> is the minIndex and <TT>indexArray(2,:)</TT> is the maxIndex
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, the default is that all dimensions will be arbitrarily
         distributed.  
   
</DD>
<DT><STRONG>[coordDimCount]</STRONG></DT>
<DD>List that has dimCount elements.
        Gives the dimension of each component (e.g. x) array. This is 
        to allow factorization of the coordinate arrays. If not specified
        each component is assumed to be size 1. Note, the default value is different
        from the same argument for a non-arbitrarily distributed grid. 
   
</DD>
<DT><STRONG>[coordDimMap]</STRONG></DT>
<DD>2D list of size dimCount x dimCount. This array describes the
        map of each coordinate array's dimensions onto the grids
        dimensions.  <TT>coordDimMap(i,j)</TT> is the grid dimension of the jth dimension
        of the i'th coordinate array.  If not specified, the default value of
        <TT>coordDimMap(i,1)</TT> is /ESMF_GRID_ARBDIM/ if the ith dimension of the grid is
        arbitrarily distributed, or <TT>i</TT> if the ith dimension is not distributed.
        Note that if j is bigger than <TT>coordDimCount(i)</TT> then it's ignored.        
   
</DD>
<DT><STRONG>[destroyDistgrid]</STRONG></DT>
<DD>If true, when the Grid is destroyed the DistGrid will be destroyed also. 
        Defaults to false. 
   
</DD>
<DT><STRONG>[destroyDELayout]</STRONG></DT>
<DD>If true, when the Grid is destroyed the DELayout will be destroyed also. 
        Defaults to false. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04086500000000000000">
23.6.5 ESMF_GridCreate - Create a Grid from a file</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
      function ESMF_GridCreateFromFile(fileName, convention, purpose, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      type(ESMF_Grid) :: ESMF_GridCreateFromFile
</PRE><EM>ARGUMENTS:</EM>
<PRE>        character (len=*), intent(in)            :: fileName
        character (len=*), intent(in),  optional :: convention
        character (len=*), intent(in),  optional :: purpose
        integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Grid</TT> object from specifications in a file 
   containing an ESMF GridSpec Attribute package in XML format. Currently limited
   to creating a 2D regularly distributed rectilinear Grid; in the future more
   dimensions, grid types and distributions will be supported.
   See Section&nbsp;<A HREF="node4.html#example:GridCrFromFile">23.2.22</A> for an example, as well as the
   accompanying file
   ESMF_DIR/src/Infrastructure/Grid/etc/esmf_grid_shape_tile.xml.

<P>
Requires the third party Xerces C++ XML Parser library to be installed.
   For more details, see the "ESMF Users Guide",
   "Building and Installing the ESMF, Third Party Libraries, Xerces" and
   the website http://xerces.apache.org/xerces-c.

<P>
The arguments are:
   <DL>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the XML file to be read, containing ESMF GridSpec Attributes.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of a grid Attribute package. [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of a grid Attribute package.    [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        Equals <TT>ESMF_RC_LIB_NOT_PRESENT</TT> if Xerces is not present.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04086600000000000000">
23.6.6 ESMF_GridCreateEmpty - Create a Grid that has no contents</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>      function ESMF_GridCreateEmpty(rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      type(ESMF_Grid) :: ESMF_GridCreateEmpty
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,               intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Partially create an <TT>ESMF_Grid</TT> object. This function allocates 
   an <TT>ESMF_Grid</TT> object, but doesn't allocate any coordinate storage or other
   internal structures. The <TT>ESMF_GridSetCommitShapeTile</TT> calls
   can be used to set the values in the grid object and to construct the 
   internal structure. 

<P>
The arguments are:
   <DL>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04086700000000000000">
23.6.7 ESMF_GridCreateShapeTile - Create a Grid with an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreateShapeTile()
       function ESMF_GridCreateShapeTileIrreg(name,coordTypeKind, minIndex,  &amp;
                         countsPerDEDim1,countsPerDeDim2, countsPerDEDim3, &amp;
                         connDim1, connDim2, connDim3, &amp;
                         poleStaggerLoc1, poleStaggerLoc2, poleStaggerLoc3, &amp;
                         bipolePos1, bipolePos2, bipolePos3, &amp;
                         coordDep1, coordDep2, coordDep3, &amp;
                         gridEdgeLWidth, gridEdgeUWidth, gridAlign, &amp;
                         gridMemLBound, indexflag, petMap, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateShapeTileIrreg
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len=*), intent(in), optional :: name 
        type(ESMF_TypeKind),  intent(in),    optional  :: coordTypeKind
        integer,               intent(in),   optional  :: minIndex(:)
        integer,               intent(in)              :: countsPerDEDim1(:)
        integer,               intent(in)              :: countsPerDEDim2(:)
        integer,               intent(in),   optional  :: countsPerDEDim3(:)
        type(ESMF_GridConn),   intent(in),   optional  :: connDim1(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim2(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim3(:)        ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc1(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc2(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc3(2) ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos1(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos2(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos3(2)      ! N. IMP.
        integer,               intent(in),   optional  :: coordDep1(:)
        integer,               intent(in),   optional  :: coordDep2(:)
        integer,               intent(in),   optional  :: coordDep3(:)
        integer,               intent(in),   optional  :: gridEdgeLWidth(:)
        integer,               intent(in),   optional  :: gridEdgeUWidth(:)
        integer,               intent(in),   optional  :: gridAlign(:)
        integer,               intent(in),   optional  :: gridMemLBound(:)
        type(ESMF_IndexFlag),  intent(in),   optional  :: indexflag
        integer,               intent(in),   optional  :: petMap(:,:,:)
        integer,               intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, irregularly distributed grid 
   (see Figure <A HREF="node4.html#fig:GridDecomps">12</A>).
   To specify the irregular distribution, the user passes in an array 
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension.   Up to three dimensions can be specified, 
   using the countsPerDEDim1, countsPerDEDim2, countsPerDEDim3 arguments.
   The index of each array element corresponds to a DE number.  The 
   array value at the index is the number of grid cells on the DE in 
   that dimension.  The dimCount of the grid is equal to the number of 
   countsPerDEDim arrays that are specified. 

<P>
Section <A HREF="node4.html#example:2DIrregUniGrid">23.2.3</A> shows an example
   of using this method to create a 2D Grid with uniformly spaced 
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
The arguments are:
   <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location). 
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).  
       If not specified  then grid is 2D. 
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#opt:indexflag">9.2.8</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.   
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04086800000000000000">
23.6.8 ESMF_GridCreateShapeTile - Create a Grid with a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreateShapeTile()
       function ESMF_GridCreateShapeTileReg(name, coordTypeKind, &amp;
                         regDecomp, decompFlag, minIndex, maxIndex, &amp;
                         connDim1, connDim2, connDim3, &amp;
                         poleStaggerLoc1, poleStaggerLoc2, poleStaggerLoc3, &amp;
                         bipolePos1, bipolePos2, bipolePos3, &amp;
                         coordDep1, coordDep2, coordDep3, &amp;
                         gridEdgeLWidth, gridEdgeUWidth, gridAlign, &amp;
                         gridMemLBound, indexflag, petMap, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateShapeTileReg
</PRE><EM>ARGUMENTS:</EM>
<PRE>        character (len=*), intent(in), optional :: name 
        type(ESMF_TypeKind),  intent(in),    optional  :: coordTypeKind
        integer,               intent(in),   optional  :: regDecomp(:)
        type(ESMF_DecompFlag), intent(in),   optional  :: decompflag(:)
        integer,               intent(in),   optional  :: minIndex(:)
        integer,               intent(in)              :: maxIndex(:)
        type(ESMF_GridConn),   intent(in),   optional  :: connDim1(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim2(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim3(:)        ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc1(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc2(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc3(2) ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos1(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos2(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos3(2)      ! N. IMP.
        integer,               intent(in),   optional  :: coordDep1(:)
        integer,               intent(in),   optional  :: coordDep2(:)
        integer,               intent(in),   optional  :: coordDep3(:)
        integer,               intent(in),   optional  :: gridEdgeLWidth(:)
        integer,               intent(in),   optional  :: gridEdgeUWidth(:)
        integer,               intent(in),   optional  :: gridAlign(:)
        integer,               intent(in),   optional  :: gridMemLBound(:)
        type(ESMF_IndexFlag),  intent(in),   optional  :: indexflag
        integer,               intent(in),   optional  :: petMap(:,:,:)
        integer,               intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid 
   (see Figure <A HREF="node4.html#fig:GridDecomps">12</A>).
   To specify the distribution, the user passes in an array 
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each 
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.

<P>
The arguments are:
   <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
        If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1. 
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        patch is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_HOMOGEN</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node2.html#opt:decompflag">9.2.7</A> for a full description of the 
        possible options. 
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#opt:indexflag">9.2.8</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.   
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04086900000000000000">
23.6.9 ESMF_GridCreateShapeTile - Create a Grid with an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreateShapeTile()
       function ESMF_GridCreateShapeTileArb(name,coordTypeKind, minIndex,  &amp;
 			maxIndex, localArbIndex, localArbIndexCount, &amp;
                         connDim1, connDim2, connDim3, &amp;
                         poleStaggerLoc1, poleStaggerLoc2, poleStaggerLoc3, &amp;
                         bipolePos1, bipolePos2, bipolePos3, &amp;
                         coordDep1, coordDep2, coordDep3, &amp;
                         distDim, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateShapeTileArb
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len=*), intent(in), optional :: name 
        type(ESMF_TypeKind),  intent(in),    optional  :: coordTypeKind
        integer,               intent(in),   optional  :: minIndex(:)
        integer,               intent(in)              :: maxIndex(:)
        integer,               intent(in)              :: localArbIndex(:,:)
        integer,               intent(in)   	      :: localArbIndexCount
        type(ESMF_GridConn),   intent(in),   optional  :: connDim1(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim2(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim3(:)        ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc1(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc2(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc3(2) ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos1(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos2(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos3(2)      ! N. IMP.
        integer,               intent(in),   optional  :: coordDep1(:)
        integer,               intent(in),   optional  :: coordDep2(:)
        integer,               intent(in),   optional  :: coordDep3(:)
        integer,               intent(in),   optional  :: distDim(:)
        integer,               intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, arbitrarily distributed grid 
   (see Figure <A HREF="node4.html#fig:GridDecomps">12</A>).
   To specify the arbitrary distribution, the user passes in an 2D array 
   of local indices, where the first dimension is the number of local grid cells
   specified by <TT>localArbIndexCount</TT> and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The 
   size of <TT>distDim</TT> has to agree with the size of the second dimension of 
   <TT>localArbIndex</TT>. 

<P>
The arguments are:
   <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>[maxIndex]</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>[localArbIndex]</STRONG></DT>
<DD>This 2D array specifies the indices of the local grid cells.  The 
        dimensions should be localArbIndexCount * number of Distributed grid dimensions
        where localArbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>localArbIndexCount</STRONG></DT>
<DD>number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.  
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_GRID_ARBDIM/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_GRID_ARBDIM/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_GRID_ARBDIM/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040861000000000000000">
23.6.10 ESMF_GridDestroy - Free all resources associated with a Grid </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_GridDestroy(grid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid) :: grid
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_Grid</TT> object and related internal structures. This call
      does destroy internally created DistGrid and DELayout classes, for example those created by 
      <TT>ESMF_GridCreateShapeTile()</TT>. It also destroys internally created coordinate/item Arrays,
      for example those created by <TT>ESMF_GridAddCoord()</TT>. However, if the user uses an externally 
      created class, for example creating an Array and setting it using <TT>ESMF_GridSetCoord()</TT>, then
      that class is not destroyed by this method.

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> to be destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040861100000000000000">
23.6.11 ESMF_GridGet - Get information about a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetDefault(grid, name, coordTypeKind, &amp;
           dimCount, tileCount, staggerlocsCount, localDECount, distgrid, &amp;
           distgridToGridMap, coordDimCount, coordDimMap, &amp;
           localArbIndexCount, localArbIndex, arbDim, &amp;
           memDimCount, arbDimCount, &amp;
           gridEdgeLWidth, gridEdgeUWidth, gridAlign,  &amp;
           indexFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),       intent(in)            :: grid
       character (len=*),     intent(out), optional :: name
       type(ESMF_TypeKind),   intent(out), optional :: coordTypeKind
       integer,               intent(out), optional :: dimCount
       integer,               intent(out), optional :: tileCount
       integer,               intent(out), optional :: staggerlocsCount
       integer,               intent(out), optional :: localDECount
       type(ESMF_DistGrid),   intent(out), optional :: distgrid
       integer,       target, intent(out), optional :: distgridToGridMap(:)
       integer,       target, intent(out), optional :: coordDimCount(:)
       integer,       target, intent(out), optional :: coordDimMap(:,:)
       integer,               intent(out), optional :: localArbIndexCount
       integer,       target, intent(out), optional :: localArbIndex(:,:)
       integer,               intent(out), optional :: arbDim
       integer,               intent(out), optional :: memDimCount
       integer,               intent(out), optional :: arbDimCount
       integer,       target, intent(out), optional :: gridEdgeLWidth(:)
       integer,       target, intent(out), optional :: gridEdgeUWidth(:)
       integer,       target, intent(out), optional :: gridAlign(:)
       type(ESMF_IndexFlag),  intent(out), optional :: indexflag
       integer,               intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Gets various types of information about a grid. 

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
  
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
     If not specified then the type/kind will be 8 byte reals.  
  
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>DimCount of the Grid object.
  
</DD>
<DT><STRONG>[tileCount]</STRONG></DT>
<DD>The number of logically rectangular tiles in the grid. 
  
</DD>
<DT><STRONG>[staggerlocsCount]</STRONG></DT>
<DD>The number of stagger locations.
  
</DD>
<DT><STRONG>[localDECount]</STRONG></DT>
<DD>The number of DEs in this grid on this PET.
  
</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>The structure describing the distribution of the grid. 
  
</DD>
<DT><STRONG>[distgridToGridMap]</STRONG></DT>
<DD>List that has as many elements as the distgrid dimCount. This array describes
     mapping between the grids dimensions and the distgrid.
   
</DD>
<DT><STRONG>[coordDimCount]</STRONG></DT>
<DD>List that has as many elements as the grid dimCount (from arrayspec).
     Gives the dimension of each component (e.g. x) array. This is 
     to allow factorization of the coordinate arrays. If not specified
     all arrays are the same size as the grid. 
  
</DD>
<DT><STRONG>[coordDimMap]</STRONG></DT>
<DD>2D list of size grid dimCount x grid dimCount. This array describes the
     map of each component array's dimensions onto the grids
     dimensions.
   
</DD>
<DT><STRONG>[localArbIndexCount]</STRONG></DT>
<DD>The number of local cells for an arbitrarily distributed grid
   
</DD>
<DT><STRONG>[localArbIndex]</STRONG></DT>
<DD>The 2D array storing the local cell indices for an arbitrarily distributed grid. The size of the array 
     is localArbIndexCount * arbDimCount 
   
</DD>
<DT><STRONG>[arbDim]</STRONG></DT>
<DD>The distgrid dimension that is mapped by the arbitrarily distributed grid dimensions.
   
</DD>
<DT><STRONG>[memDimCount]</STRONG></DT>
<DD>The count of the memory dimensions, it is the same as dimCount for a non-arbitrarily distributed grid,
     and equal or less for a arbitrarily distributed grid.
   
</DD>
<DT><STRONG>[arbDimCount]</STRONG></DT>
<DD>The number of dimensions distributed arbitrarily for an arbitrary grid, 0 if the grid is non-arbitrary.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. The array should
     be of size greater or equal to the Grid dimCount.
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. The array should
     be of size greater or equal to the Grid dimCount. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space. The array should be of size greater or equal to the Grid dimCount. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag indicating the indexing scheme being used in the Grid. Please
      see Section&nbsp;<A HREF="node2.html#opt:indexflag">9.2.8</A> for the list of options. 
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040861200000000000000">
23.6.12 ESMF_GridGet - Get information about a particular DE in a stagger location in a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPLocalDePSloc(grid, localDe, staggerloc, &amp;
           exclusiveLBound, exclusiveUBound, exclusiveCount,  &amp;
           computationalLBound, computationalUBound, computationalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: localDe
       type (ESMF_StaggerLoc), intent(in)            :: staggerloc
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets information about the range of index space which a 
    particular stagger location occupies. This call differs from the coordinate 
    bound calls (e.g. <TT>ESMF_GridGetCoord</TT>) in that a given coordinate 
    array may only occupy a subset of the Grid's dimensions, and
    so these calls may not give all the bounds of the stagger location. 
    The bounds from this call are the full bounds, and so
    for example, give the appropriate bounds for allocating a Fortran array to hold 
    data residing on the stagger location.
    Note that unlike the output from the Array, these values also include the 
    undistributed dimensions and are
    ordered to reflect the order of the indices in the Grid. This call will 
    still give correct values even if the stagger location does not contain
    coordinate arrays (e.g. if  <TT>ESMF_GridAddCoord</TT> hasn't yet 
    been called on the stagger location).

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>The local DE from which to get the information. <TT>[0,..,localDeCount-1]</TT> 
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
       Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
       of predefined stagger locations.
  
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       <TT>exclusiveLBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       <TT>exclusiveUBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region per dimension
       (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT> must
        be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       <TT>computationalLBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       <TT>computationalUBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension.
       (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT> must
        be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040861300000000000000">
23.6.13 ESMF_GridGet - Get information about a particular stagger location in a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPSloc(grid, staggerloc, &amp;
           staggerDistgrid, minIndex, maxIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in)            :: staggerloc
       type(ESMF_DistGrid),   intent(out), optional :: staggerDistgrid
       integer,        target, intent(out), optional :: minIndex(:)
       integer,        target, intent(out), optional :: maxIndex(:)
       integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets information about a particular stagger location. 
    This information is useful for creating an ESMF Array to hold
    the data at the stagger location. 

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
       Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
       of predefined stagger locations. 
  
</DD>
<DT><STRONG>[staggerDistgrid]</STRONG></DT>
<DD>The structure describing the distribution of this staggerloc in this grid. 
  
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Upon return this holds the global lower index of this stagger location.
       <TT>minIndex</TT> must be allocated to be of size equal to the grid DimCount.
       Note that this value is only for the first Grid tile, as multigrid support
       is added, this interface will likely be changed or moved to adapt.  
  
</DD>
<DT><STRONG>[maxIndex]</STRONG></DT>
<DD>Upon return this holds the global upper index of this stagger location.
       <TT>maxIndex</TT> must be allocated to be of size equal to the grid DimCount.
       Note that this value is only for the first Grid tile, as multigrid support
       is added, this interface will likely be changed or moved to adapt.  
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040861400000000000000">
23.6.14 ESMF_GridGetCoord - Get Grid coordinate bounds and a Fortran pointer to coordinate data</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>        subroutine ESMF_GridGetCoord(grid, localDE, coordDim, staggerloc, &amp;
           exclusiveLBound, exclusiveUBound, exclusiveCount,              &amp;
           computationalLBound, computationalUBound, computationalCount,  &amp;
           totalLBound, totalUBound, totalCount,                          &amp;
           &lt;pointer argument&gt;, doCopy, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: localDE
       integer,                intent(in)            :: coordDim
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(out), optional :: exclusiveLBound(:)
       integer,                intent(out), optional :: exclusiveUBound(:)
       integer,                intent(out), optional :: exclusiveCount(:)
       integer,                intent(out), optional :: computationalLBound(:)
       integer,                intent(out), optional :: computationalUBound(:)
       integer,                intent(out), optional :: computationalCount(:)
       integer,                intent(out), optional :: totalLBound(:)
       integer,                intent(out), optional :: totalUBound(:)
       integer,                intent(out), optional :: totalCount(:)
       &lt;pointer argument&gt;, see below for supported values
       type(ESMF_CopyFlag),    intent(in), optional  :: docopy
       integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets a Fortran pointer to the piece of memory which holds the 
       coordinate data on the local DE for the given coordinate dimension and stagger
       locations. 
       This is useful, for example, for setting the coordinate values in a Grid, or
       for reading the coordinate values.  Currently this method supports up to three
       coordinate dimensions, of either R4 or R8 datatype.  See below for specific 
       supported values.  If the coordinates that you are trying to retrieve are of
       higher dimension, use the <TT>ESMF_GetCoord()</TT> interface that returns coordinate
       values in an <TT>ESMF_Array</TT> instead.  That interface supports the retrieval of
       coordinates up to 7D. 

<P>
Supported values for the &lt;pointer argument&gt; are: 
       <DL>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: fptr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: fptr(:,:)     
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: fptr(:,:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: fptr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: fptr(:,:)     
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: fptr(:,:,:)
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to get the data from (e.g. 1=x).
       
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
            Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
            <TT>exclusiveLBound</TT> must be allocated to be of size equal to the coord dimCount.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the coord dimCount.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region per dimension
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT> must
            be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
            <TT>computationalLBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
            must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
            <TT>totalLBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
            <TT>totalUBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
            (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
            be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>fptr</STRONG></DT>
<DD>The pointer to the coordinate data.
       
</DD>
<DT><STRONG>[doCopy]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATA_REF</TT>, in this case
            fptr is a reference to the data in the Grid coordinate arrays. 
            Please see Section&nbsp;<A HREF="node2.html#opt:copyflag">9.2.5</A> for further description and a
            list of valid values. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040861500000000000000">
23.6.15 ESMF_GridGetCoord - Get Grid coordinate bounds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordBounds(grid, localDE, coordDim, staggerloc, &amp;
           exclusiveLBound, exclusiveUBound, exclusiveCount,                   &amp;
           computationalLBound, computationalUBound, computationalCount,       &amp;
           totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: localDE
       integer,                intent(in)            :: coordDim
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,        target, intent(out), optional :: totalLBound(:)
       integer,        target, intent(out), optional :: totalUBound(:)
       integer,        target, intent(out), optional :: totalCount(:)
       integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets information about the range of index space which a particular
    piece of coordinate data occupies.  In other words, this method returns the 
    bounds of the coordinate arrays.  Note that unlike the output from the 
    Array, these values also include the undistributed dimensions and are
    ordered to reflect the order of the indices in the coordinate. So, for example,
    <TT>totalLBound</TT> and <TT>totalUBound</TT> should match the bounds of the Fortran array
    retrieved by <TT>ESMF_GridGetCoord</TT>. 

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE from which to get the information. <TT>[0,..,localDeCount-1]</TT>
  
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to get the information for (e.g. 1=x). 
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
       Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
       of predefined stagger locations. If not present, defaults to
       ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       <TT>exclusiveLBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       <TT>exclusiveUBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region per dimension
       (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT> must
       be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
       <TT>computationalLBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
       <TT>computationalUBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
       (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
        must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       <TT>totalLBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       <TT>totalUBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
       (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
        be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040861600000000000000">
23.6.16 ESMF_GridGetCoord - Get coordinates and put in an ESMF Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordIntoArray(grid, staggerloc,coordDim, array, &amp;
                             docopy, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid), intent(in) :: grid
       type (ESMF_StaggerLoc), intent(in),optional  :: staggerloc
       integer, intent(in)  :: coordDim
       type(ESMF_Array), intent(out) :: array
       type(ESMF_CopyFlag), intent(in), optional :: docopy ! NOT IMPLEMENTED
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method allows the user to get access to the ESMF Array holding
      coordinate data at a particular stagger location. This is useful, for example, 
      to set the coordinate values. To have an Array to access, the coordinate Arrays
      must have already been allocated, for example by <TT>ESMF_GridAddCoord</TT> or
      <TT>ESMF_GridSetCoord</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location from which to get the arrays. 
            Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to get the data from (e.g. 1=x).
       
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array into which to put the coordinate infomation. 
       
</DD>
<DT><STRONG>[doCopy]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATA_REF</TT>, in this case 
            <TT>array</TT> will contain a reference to the Grid coordinate Arrays.
             Please see Section&nbsp;<A HREF="node2.html#opt:copyflag">9.2.5</A> for
            further description and a list of valid values. 
            [THE ESMF_DATA_COPY OPTION IS CURRENTLY NOT IMPLEMENTED] 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040861700000000000000">
23.6.17 ESMF_GridGetCoord - Get coordinates from a specific index location</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordR4(grid, localDE, staggerloc, index, coord, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid), intent(in)                 :: grid
       type (ESMF_StaggerLoc), intent(in),optional :: staggerloc
       integer, intent(in)                         :: localDE
       integer, intent(in)                         :: index(:)
       real(ESMF_KIND_R4)                          :: coord(:)
       integer, intent(out), optional              :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Given a specific index location in a Grid, this method returns the full set
     of coordinates from that index location. This method will eventually be overloaded
     to support the full complement of types supported by the Grid. 

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
            Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
            of predefined stagger locations. If not present, defaults to
            ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>index</STRONG></DT>
<DD>This array holds the index location to be queried in the Grid. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>coord</STRONG></DT>
<DD>This array will be filled with the coordinate data. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040861800000000000000">
23.6.18 ESMF_GridGetCoord - Get coordinates from a specific index location</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordR8(grid, localDE, staggerloc, index, coord, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid), intent(in)                 :: grid
       type (ESMF_StaggerLoc), intent(in),optional :: staggerloc
       integer, intent(in)                         :: localDE
       integer, intent(in)                         :: index(:)
       real(ESMF_KIND_R8)                          :: coord(:)
       integer, intent(out), optional              :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Given a specific index location in a Grid, this method returns the full set
     of coordinates from that index location. This method will eventually be overloaded
     to support the full complement of types supported by the Grid. 

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
            Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
            of predefined stagger locations. If not present, defaults to
            ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>index</STRONG></DT>
<DD>This array holds the index location to be queried in the Grid. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>coord</STRONG></DT>
<DD>This array will be filled with the coordinate data. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040861900000000000000">
23.6.19 ESMF_GridGetItem - Get Grid coordinate bounds and an F90 pointer to coordinate data</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>        subroutine ESMF_GridGetItem(grid, localDE, staggerloc, item,      &amp;
           exclusiveLBound, exclusiveUBound, exclusiveCount,              &amp;
           computationalLBound, computationalUBound, computationalCount,  &amp;
           totalLBound, totalUBound, totalCount,                          &amp;
           &lt;pointer argument&gt;, doCopy, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in) :: grid
       integer,                intent(in) :: localDE
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       type (ESMF_GridItem),   intent(in)            :: item
       integer,                intent(out), optional :: exclusiveLBound(:)
       integer,                intent(out), optional :: exclusiveUBound(:)
       integer,                intent(out), optional :: exclusiveCount(:)
       integer,                intent(out), optional :: computationalLBound(:)
       integer,                intent(out), optional :: computationalUBound(:)
       integer,                intent(out), optional :: computationalCount(:)
       integer,                intent(out), optional :: totalLBound(:)
       integer,                intent(out), optional :: totalUBound(:)
       integer,                intent(out), optional :: totalCount(:)
       &lt;pointer argument&gt;, see below for supported values
       type(ESMF_CopyFlag),    intent(in), optional :: docopy
       integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets a Fortran pointer to the piece of memory which holds the 
       item data on the local DE for the given stagger locations. 
       This is useful, for example, for setting the item values in a Grid, or
       for reading the item values.  Currently this method supports up to three
       grid dimensions, but is limited to the I4 datatype.  See below for specific 
       supported values.  If the item values that you are trying to retrieve are of
       higher dimension, use the <TT>ESMF_GetItem()</TT> interface that returns coordinate
       values in an <TT>ESMF_Array</TT> instead.  That interface supports the retrieval of
       coordinates up to 7D. 

<P>
Supported values for the &lt;pointer argument&gt; are: 
       <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), pointer :: fptr(:)
       
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), pointer :: fptr(:,:)     
       
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), pointer :: fptr(:,:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: fptr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: fptr(:,:)     
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: fptr(:,:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: fptr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: fptr(:,:)     
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: fptr(:,:,:)
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
            Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>item</STRONG></DT>
<DD>The item to get the information for. Please see Section&nbsp;<A HREF="node4.html#sec:opt:griditem">23.5.3</A> for a 
            list of valid items.  
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
            <TT>exclusiveLBound</TT> must be allocated to be of size equal to the grid dimCount.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the grid dimCount.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region per dimension
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT> must
            be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
            <TT>computationalLBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
            must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
            <TT>totalLBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
            <TT>totalUBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
            (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
            be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>fptr</STRONG></DT>
<DD>The pointer to the item data.
       
</DD>
<DT><STRONG>[doCopy]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATA_REF</TT>, in this case
            fptr is a reference to the data in the Grid item arrays. 
            Please see Section&nbsp;<A HREF="node2.html#opt:copyflag">9.2.5</A> for further description and a
            list of valid values. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040862000000000000000">
23.6.20 ESMF_GridGetItem - Get Grid item bounds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetItem()
       subroutine ESMF_GridGetItemBounds(grid, localDE, staggerloc, item, &amp;
           exclusiveLBound, exclusiveUBound, exclusiveCount,                   &amp;
           computationalLBound, computationalUBound, computationalCount,       &amp;
           totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: localDE
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       type (ESMF_GridItem),   intent(in)            :: item
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,        target, intent(out), optional :: totalLBound(:)
       integer,        target, intent(out), optional :: totalUBound(:)
       integer,        target, intent(out), optional :: totalCount(:)
       integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets information about the range of index space which a particular
    piece of item data occupies.  In other words, this method returns the 
    bounds of the item arrays.  Note that unlike the output from the 
    Array, these values also include the undistributed dimensions and are
    ordered to reflect the order of the indices in the item. So, for example,
    <TT>totalLBound</TT> and <TT>totalUBound</TT> should match the bounds of the Fortran array
    retrieved by <TT>ESMF_GridGetItem</TT>. 

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE from which to get the information. <TT>[0,..,localDeCount-1]</TT>
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
       Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
       of predefined stagger locations. If not present, defaults to
       ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>item</STRONG></DT>
<DD>The item to get the information for. Please see Section&nbsp;<A HREF="node4.html#sec:opt:griditem">23.5.3</A> for a 
            list of valid items.   
  
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       <TT>exclusiveLBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       <TT>exclusiveUBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region per dimension
       (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT> must
       be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
       <TT>computationalLBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
       <TT>computationalUBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
       (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
        must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       <TT>totalLBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       <TT>totalUBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
       (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
        be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node4.html#sec:grid:usage:bounds">23.2.14</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040862100000000000000">
23.6.21 ESMF_GridGetItem - Get item and put into an ESMF Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetItem()
       subroutine ESMF_GridGetItemIntoArray(grid, staggerloc, item, array, &amp;
                             docopy, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid), intent(in) :: grid
       type (ESMF_StaggerLoc), intent(in),optional  :: staggerloc
       type (ESMF_GridItem), intent(in)   :: item
       type(ESMF_Array), intent(out) :: array
       type(ESMF_CopyFlag), intent(in), optional :: docopy ! NOT IMPLEMENTED
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method allows the user to get access to the ESMF Array holding
      item data at a particular stagger location. This is useful, for example, 
      to set the item values. To have an Array to access, the item Array
      must have already been allocated, for example by <TT>ESMF_GridAddItem</TT> or
      <TT>ESMF_GridSetItem</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location from which to get the arrays. 
            Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>item</STRONG></DT>
<DD>The item from which to get the arrays. Please see Section&nbsp;<A HREF="node4.html#sec:opt:griditem">23.5.3</A> for a 
            list of valid items.  
       
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array into which to put the item infomation. 
       
</DD>
<DT><STRONG>[doCopy]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATA_REF</TT>, in this case 
            <TT>array</TT> will contain a reference to the Grid item Arrays.
             Please see Section&nbsp;<A HREF="node2.html#opt:copyflag">9.2.5</A> for
            further description and a list of valid values. 
            [THE ESMF_DATA_COPY OPTION IS CURRENTLY NOT IMPLEMENTED] 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040862200000000000000">
23.6.22 ESMF_GridGetStatus - Return the status of the Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>      function ESMF_GridGetStatus(grid)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      type(ESMF_GridStatus) :: ESMF_GridGetStatus
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_Grid) :: grid
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the status of the passed in Grid object. 

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The grid to return the status from. 
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040862300000000000000">
23.6.23 ESMF_GridMatch - Check if two Grid objects match</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_GridMatch(grid1, grid2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_GridMatch
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid),  intent(in)              :: grid1
     type(ESMF_Grid),  intent(in)              :: grid2
     integer,          intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>grid1</TT> and <TT>grid2</TT> match. Returns .true. if 
    Grid objects match, .false. otherwise. This method considers most parts of
    the Grids when testing for a match (coordinates, items, Distgrids, Arrays, etc). The 
    parts which aren't considered for a match are the <TT>destroyDistgrid</TT> and 
    the <TT>destroyDELayout</TT> flags used in the <TT>ESMF_GridCreateFromDistgrid()</TT> call. 
    Please also note that this call returns the match for the piece of the Grids on
    the local PET only. It's entirely possible for this call to return a different match
    on different PETs for the same Grids. The user is responsible for computing the global match across
    the set of PETs. 

<P>
The arguments are:
       <DL>
<DT><STRONG>grid1</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
       
</DD>
<DT><STRONG>grid2</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040862400000000000000">
23.6.24 ESMF_GridSetCoord - Set coordinates using ESMF Arrays</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_GridSetCoordFromArray(grid, staggerloc, coordDim, &amp;
                             array, doCopy, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in), optional  :: staggerloc
       integer,                intent(in)            :: coordDim
       type(ESMF_Array),       intent(in)            :: array
       type(ESMF_CopyFlag),    intent(in), optional  :: docopy ! NOT IMPLEMENTED
       integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method sets the passed in Array as the holder of the coordinate data
     for stagger location <TT>staggerloc</TT> and coordinate <TT>coord</TT>. If the location
     already contains an Array, then this one overwrites it. 

<P>
The arguments are:
  <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location into which to copy the arrays. 
      Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
      of predefined stagger locations. If not present, defaults to
      ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to put the data in (e.g. 1=x).
  
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array to set the grid coordinate information from.
  
</DD>
<DT><STRONG>[doCopy]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATA_REF</TT>, in this case the Grid 
      coordinate Array will be set to a reference to <TT>array</TT>. Please see 
      Section&nbsp;<A HREF="node2.html#opt:copyflag">9.2.5</A> for further description and a list of
      valid values. 
      [THE ESMF_DATA_COPY OPTION IS CURRENTLY NOT IMPLEMENTED] 
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040862500000000000000">
23.6.25 ESMF_GridSetCommitShapeTile - Set and complete a Grid with an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridSetCommitShapeTile()
      subroutine ESMF_GridSetCmmitShapeTileIrreg(grid, name,coordTypeKind, minIndex,  &amp;
                         countsPerDEDim1, countsPerDeDim2, countsPerDEDim3, &amp;
                         connDim1, connDim2, connDim3, &amp;
                         poleStaggerLoc1, poleStaggerLoc2, poleStaggerLoc3, &amp;
                         bipolePos1, bipolePos2, bipolePos3, &amp;
                         coordDep1, coordDep2, coordDep3, &amp;
                         gridEdgeLWidth, gridEdgeUWidth, gridAlign, gridMemLBound, &amp;
                         indexflag, petMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> 	type (ESMF_Grid) :: grid
       character (len=*), intent(in), optional :: name 
        type(ESMF_TypeKind),  intent(in),    optional  :: coordTypeKind
        integer,               intent(in),   optional  :: minIndex(:)
        integer,               intent(in)              :: countsPerDEDim1(:)
        integer,               intent(in)              :: countsPerDEDim2(:)
        integer,               intent(in),   optional  :: countsPerDEDim3(:)
        type(ESMF_GridConn),   intent(in),   optional  :: connDim1(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim2(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim3(:)        ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc1(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc2(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc3(2) ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos1(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos2(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos3(2)      ! N. IMP.
        integer,               intent(in),   optional  :: coordDep1(:)
        integer,               intent(in),   optional  :: coordDep2(:)
        integer,               intent(in),   optional  :: coordDep3(:)
        integer,               intent(in),   optional  :: gridEdgeLWidth(:)
        integer,               intent(in),   optional  :: gridEdgeUWidth(:)
        integer,               intent(in),   optional  :: gridAlign(:)
        integer,               intent(in),   optional  :: gridMemLBound(:)
        type(ESMF_IndexFlag),  intent(in),   optional  :: indexflag
        integer,               intent(in),   optional  :: petMap(:,:,:)
        integer,               intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method sets information into an empty Grid and then commits it to 
   create a single tile, irregularly distributed grid 
   (see Figure <A HREF="node4.html#fig:GridDecomps">12</A>).
   To specify the irregular distribution, the user passes in an array 
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension.   Up to three dimensions can be specified, 
   using the countsPerDEDim1, countsPerDEDim2, countsPerDEDim3 arguments.
   The index of each array element corresponds to a DE number.  The 
   array value at the index is the number of grid cells on the DE in 
   that dimension.  The dimCount of the grid is equal to the number of 
   countsPerDEDim arrays that are specified. 

<P>
Section <A HREF="node4.html#example:2DIrregUniGrid">23.2.3</A> shows an example
   of using this method to create a 2D Grid with uniformly spaced 
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
For consistency's sake the <TT>ESMF_GridSetCommitShapeTile()</TT> call
   should be executed in the same set or a subset of the PETs in which the
   <TT>ESMF_GridCreateEmpty()</TT> call was made. If the call
   is made in a subset, the Grid objects outside that subset will
   still be "empty" and not usable. 

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The empty <TT>ESMF_Grid</TT> to set information into and then commit.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
       If the array has only one entry, then the dimension is undistributed. 
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location). 
       If the array has only one entry, then the dimension is undistributed. 
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).  
       If not specified  then grid is 2D. Also, If the array has only one entry,
       then the dimension is undistributed. 
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
        [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to
        ESMF_STAGGERLOC_CENTER.
        [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to
        ESMF_STAGGERLOC_CENTER.
        [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a pole, this describes which staggerlocation is at the pole at each end.
        If not present, the default is the edge.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to
        ESMF_STAGGERLOC_CENTER.
        [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
        [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
        [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1. 
        [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#opt:indexflag">9.2.8</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.   
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040862600000000000000">
23.6.26 ESMF_GridSetCommitShapeTile - Set and complete a Grid with a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridSetCommitShapeTile()
       subroutine ESMF_GridSetCmmitShapeTileReg(grid, name, coordTypeKind, &amp;
                         regDecomp, decompFlag, minIndex, maxIndex, &amp;
                         connDim1, connDim2, connDim3, &amp;
                         poleStaggerLoc1, poleStaggerLoc2, poleStaggerLoc3, &amp;
                         bipolePos1, bipolePos2, bipolePos3, &amp;
                         coordDep1, coordDep2, coordDep3, &amp;
                         gridEdgeLWidth, gridEdgeUWidth, gridAlign, &amp;
                         gridMemLBound, indexflag, petMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Grid),       intent(inout)              :: grid
        character (len=*),     intent(in),   optional  :: name 
        type(ESMF_TypeKind),   intent(in),   optional  :: coordTypeKind
        integer,               intent(in),   optional  :: regDecomp(:)
        type(ESMF_DecompFlag), intent(in),   optional  :: decompflag(:)
        integer,               intent(in),   optional  :: minIndex(:)
        integer,               intent(in)              :: maxIndex(:)
        type(ESMF_GridConn),   intent(in),   optional  :: connDim1(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim2(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim3(:)        ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc1(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc2(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc3(2) ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos1(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos2(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos3(2)      ! N. IMP.
        integer,               intent(in),   optional  :: coordDep1(:)
        integer,               intent(in),   optional  :: coordDep2(:)
        integer,               intent(in),   optional  :: coordDep3(:)
        integer,               intent(in),   optional  :: gridEdgeLWidth(:)
        integer,               intent(in),   optional  :: gridEdgeUWidth(:)
        integer,               intent(in),   optional  :: gridAlign(:)
        integer,               intent(in),   optional  :: gridMemLBound(:)
        type(ESMF_IndexFlag),  intent(in),   optional  :: indexflag
        integer,               intent(in),   optional  :: petMap(:,:,:)
        integer,               intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method sets information into an empty Grid and then commits it to 
   create a single tile, regularly distributed grid 
   (see Figure <A HREF="node4.html#fig:GridDecomps">12</A>).
   To specify the distribution, the user passes in an array 
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each 
   dimension into. If the number of DEs is 1 than the dimension is undistributed.
   The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.

<P>
For consistency's sake the <TT>ESMF_GridSetCommitShapeTile()</TT> call
   should be executed in the same set or a subset of the PETs in which the
   <TT>ESMF_GridCreateEmpty()</TT> call was made. If the call
   is made in a subset, the Grid objects outside that subset will
   still be "empty" and not usable. 

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> to set information into and then commit.  
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
        If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1. 
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        patch is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_HOMOGEN</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node2.html#opt:decompflag">9.2.7</A> for a full description of the 
        possible options. 
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#opt:indexflag">9.2.8</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.   
         If the Grid contains undistributed dimensions then these
         should also be of size 1. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040862700000000000000">
23.6.27 ESMF_GridSetCommitShapeTile - Create a Grid with an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridSetCommitShapeTile()
       subroutine ESMF_GridSetCmmitShapeTileArb(grid, name,coordTypeKind, &amp;
 			      minIndex, maxIndex, localArbIndex, localArbIndexCount, &amp;
                         connDim1, connDim2, connDim3, &amp;
                         poleStaggerLoc1, poleStaggerLoc2, poleStaggerLoc3, &amp;
                         bipolePos1, bipolePos2, bipolePos3, &amp;
                         coordDep1, coordDep2, coordDep3, &amp;
                         distDim, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> 
        type(ESMF_Grid),       intent(inout)           :: grid
        character (len=*),     intent(in),   optional  :: name 
        type(ESMF_TypeKind),   intent(in),   optional  :: coordTypeKind
        integer,               intent(in),   optional  :: minIndex(:)
        integer,               intent(in)              :: maxIndex(:)
        integer,               intent(in)              :: localArbIndex(:,:)
        integer,               intent(in)   	      :: localArbIndexCount
        type(ESMF_GridConn),   intent(in),   optional  :: connDim1(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim2(:)        ! N. IMP.
        type(ESMF_GridConn),   intent(in),   optional  :: connDim3(:)        ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc1(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc2(2) ! N. IMP.
        type(ESMF_StaggerLoc), intent(in),   optional  :: poleStaggerLoc3(2) ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos1(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos2(2)      ! N. IMP.
        integer,               intent(in),   optional  :: bipolePos3(2)      ! N. IMP.
        integer,               intent(in),   optional  :: coordDep1(:)
        integer,               intent(in),   optional  :: coordDep2(:)
        integer,               intent(in),   optional  :: coordDep3(:)
        integer,               intent(in),   optional  :: distDim(:)
        integer,               intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method set an empty grid as a single tile, arbitrarily distributed grid 
   (see Figure <A HREF="node4.html#fig:GridDecomps">12</A>).
   To specify the arbitrary distribution, the user passes in an 2D array 
   of local indices, where the first dimension is the number of local grid cells
   specified by localArbIndexCount and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The 
   size of <TT>distDim</TT> has to agree with the size of the second dimension of 
   <TT>localArbIndex</TT>. 

<P>
For consistency's sake the <TT>ESMF_GridSetCommitShapeTile()</TT> call
   should be executed in the same set or a subset of the PETs in which the
   <TT>ESMF_GridCreateEmpty()</TT> call was made. If the call
   is made in a subset, the Grid objects outside that subset will
   still be "empty" and not usable. 

<P>
The arguments are:
   <DL>
<DT><STRONG>[grid]</STRONG></DT>
<DD>The empty <TT>ESMF_Grid</TT> to set information into and then commit.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>[maxIndex]</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>[localArbIndex]</STRONG></DT>
<DD>This 2D array specifies the indices of the local grid cells.  The 
        dimensions should be localArbIndexCount * number of Distributed grid dimensions
        where localArbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>localArbIndexCount</STRONG></DT>
<DD>number of grid cells in the local DE
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:gridconn">23.5.1</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[poleStaggerLoc3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a pole, this describes which staggerlocation is at the pole at each end.
        Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos1]</STRONG></DT>
<DD>Two element array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos2]</STRONG></DT>
<DD>Two element array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1.
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[bipolePos3]</STRONG></DT>
<DD>Two element array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If a bipole, this gives the index position of one of the poles.
        The other is half way around. If not present, the default is 1. 
       [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_GRID_ARBDIM/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_GRID_ARBDIM/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_GRID_ARBDIM/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040862800000000000000">
23.6.28 ESMF_GridSetItem - Set item using ESMF Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_GridSetItemFromArray(grid, staggerloc, item, &amp;
                             array, doCopy, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in), optional  :: staggerloc 
       type (ESMF_GridItem),   intent(in)            :: item
       type(ESMF_Array),       intent(in)            :: array
       type(ESMF_CopyFlag),    intent(in), optional  :: docopy ! NOT IMPLEMENTED
       integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method sets the passed in Array as the holder of the item data
     for stagger location <TT>staggerloc</TT> and coordinate <TT>coord</TT>. If the location
     already contains an Array, then this one overwrites it. 

<P>
Eventually there should be an Add, Get,... like for the Coords to make things
     easy for the user (except restricted to just I4??)

<P>
The arguments are:
  <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location into which to copy the arrays. 
      Please see Section&nbsp;<A HREF="node4.html#sec:opt:staggerloc">23.5.4</A> for a list 
      of predefined stagger locations. If not present, defaults to
      ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>item</STRONG></DT>
<DD>The item into which to copy the arrays. Please see Section&nbsp;<A HREF="node4.html#sec:opt:griditem">23.5.3</A> for a 
            list of valid items.   
  
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array to set the grid item information from.
  
</DD>
<DT><STRONG>[doCopy]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATA_REF</TT>, in this case the Grid 
      coordinate Array will be set to a reference to <TT>array</TT>. Please see 
      Section&nbsp;<A HREF="node2.html#opt:copyflag">9.2.5</A> for further description and a list of
      valid values. 
      [THE ESMF_DATA_COPY OPTION IS CURRENTLY NOT IMPLEMENTED] 
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040862900000000000000">
23.6.29 ESMF_GridValidate - Validate Grid internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridValidate(grid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in)              :: grid
     integer,         intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>Grid</TT> is internally consistent.
        Note that one of the checks that the Grid validate does
        is the Grid status. Currently, the validate will return
        an error if the grid is not at least 
        <TT>ESMF_GRIDSTATUS_SHAPE_READY</TT>. This means 
        if a Grid was created with <TT>ESMF_GridCreateEmpty</TT>
        it must also have been finished with 
        <TT>ESMF_GridSetCommitShapeTile</TT>
        to be valid. If a Grid was created with another create
        call it should automatically have the correct status level
        to pass the status part of the validate. 
        The Grid validate at this time doesn't check for the presence
        or consistency of the Grid coordinates.  
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Specified <TT>ESMF_Grid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION04087000000000000000">
23.7 Class API: StaggerLoc Methods</A>
</H2>&nbsp;<A NAME="ref:stagsub"></A>
<P>

<P>

<P>

<H3><A NAME="SECTION04087100000000000000">
23.7.1 ESMF_StaggerLocSet - Set a StaggerLoc to a particular position in the cell</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_StaggerLocSet() 
      subroutine ESMF_StaggerLocSetAllDim(staggerloc,loc,rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type (ESMF_StaggerLoc), intent(inout) :: staggerloc
       integer, intent(in) :: loc(:)
       integer, optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets a custom <TT>staggerloc</TT> to a position in a cell by using the array
      <TT>loc</TT>. The values in the array should only be 0,1. If loc(i) is 0 it 
      means the position should be in the center in that dimension. If loc(i) is 1 then
      for dimension i, the position should be on the side of the cell. 
      Please see Section&nbsp;<A HREF="node4.html#sec:usage:staggerloc:adv">23.2.20</A>
      for diagrams and further discussion of custom stagger locations. 

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>Grid location to be initialized
       
</DD>
<DT><STRONG>loc</STRONG></DT>
<DD>Array holding position data. Each entry in <TT>loc</TT> should only
            be  0 or 1. note that dimensions beyond those specified are set to 0. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04087200000000000000">
23.7.2 ESMF_StaggerLocSet - Set one dimension of a StaggerLoc to a particular position</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_StaggerLocSet() 
       subroutine ESMF_StaggerLocSetDim(staggerloc,dim,loc,rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type (ESMF_StaggerLoc), intent(inout) :: staggerloc
       integer, intent(in) :: dim,loc
       integer, optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets a particular dimension of a custom <TT>staggerloc</TT> to a position in a cell 
      by using the variable <TT>loc</TT>. The variable <TT>loc</TT> should only be 0,1. 
      If <TT>loc</TT> is 0 it means the position 
      should be in the center in that dimension. If <TT>loc</TT> is +1 then
      for the dimension, the position should be on the positive side of the cell. 
      Please see Section&nbsp;<A HREF="node4.html#sec:usage:staggerloc:adv">23.2.20</A>
      for diagrams and further discussion of custom stagger locations. 

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>Stagger location to be initialized
       
</DD>
<DT><STRONG>dim</STRONG></DT>
<DD>Dimension to be changed (1-7).
       
</DD>
<DT><STRONG>loc</STRONG></DT>
<DD>Position data should be either 0,1.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04087300000000000000">
23.7.3 ESMF_StaggerLocString - Return a StaggerLoc as a string</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StaggerLocString(staggerloc, string, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_StaggerLoc), intent(in) :: staggerloc
       character (len = *), intent(out) :: string
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return an <TT>ESMF_StaggerLoc</TT> as a printable string.

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The <TT>ESMF_StaggerLoc</TT> to be turned into a string.
       
</DD>
<DT><STRONG>string</STRONG></DT>
<DD>Return string.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04087400000000000000">
23.7.4 ESMF_StaggerLocPrint - Print information of a ESMF_StaggerLoc object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StaggerLocPrint(staggerloc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type (ESMF_StaggerLoc), intent(in) :: staggerloc
       integer, intent(out), optional     :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Print the internal data members of an <TT>ESMF_StaggerLoc</TT> object. 
<BR>
<P>
Note:  Many <TT>ESMF_&lt;class&gt;Print</TT> methods are implemented in C++.
       On some platforms/compilers there is a potential issue with interleaving
       Fortran and C++ output to <TT>stdout</TT> such that it doesn't appear in
       the expected order.  If this occurs, the <TT>ESMF_IOUnitFlush()</TT> method
       may be used on unit 6 to get coherent output.  
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>ESMF_StaggerLoc object as the method input
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION04090000000000000000">
24 LocStream Class</A>
</H1>

<P>

<H2><A NAME="SECTION04091000000000000000">
24.1 Description</A>
</H2>

<P>
A location stream (LocStream) is used to represent the locations of
a set of data points.  The values of the data points are stored within
a Field or FieldBundle created using the LocStream.

<P>
In the data assimilation world, LocStreams can
be thought of as a set of observations.  Their locations are generally
described using Cartesian (x, y, z), or (lat, lon, height) coordinates.
There is no assumption of any regularity in the positions of the points.
To make the concept more general, the locations for each data point are
represented using a construct called Keys, which can include other
descriptors besides location.

<P>
Although Keys are similar in concept to ESMF Attributes they have important
differences. First, Keys always occur as vectors, never as scalars.
Second, Keys are local to the DE: each DE can have a different Key
list with a different number of of elements. Third, the local Key 
list always has the same number of elements as there are local observations
on that DE.  Finally, Keys may be used for the distribution of LocStreams.
As such, they must be defined before the LocStream is distributed.

<P>
LocStreams can be very large. Data assimilation systems might use
LocStreams with up to <IMG
 WIDTH="29" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img70.png"
 ALT="$10^{8}$"> observations, so efficiency is critical.

<P>
Common operations involving LocStreams are similar to those involving Grids.
In data assimilation, for example, there is an immediate need to:

<P>

<OL>
<LI>Create a Field or FieldBundle on a LocStream.
</LI>
<LI>Redistribute data between Fields defined on LocStreams.
</LI>
<LI>Gather a bundle of data defined on a LocStream to a root
DE (for output). Similarly, scatter from a root DE.
</LI>
<LI>Halo region exchange for a Field defined by a haloed LocStream.
</LI>
<LI>Extract Fortran array from Field which was defined by a LocStream.
</LI>
</OL>

<P>
The operations on the Fortran arrays underlyinng LocStreams are usually simple numerical ones. However,
it is necessary to sort them in place, and access only portions of the them. It would
not be efficient to continually create new LocStreams to reflect this sorting. Instead,
the sorting is managed by the application through permutation arrays while keeping
the data in place. Locations can become inactive, e.g., if the quality control asserts that
observation is invalid. This can be managed again by the application through masks.

<P>

<H3><A NAME="SECTION04091100000000000000">
24.1.1 How is a LocStream different than a Grid?</A>
</H3>
A LocStream differs from a Grid in that no topological structure is
maintained between the points
(e.g. the class contains no information about which point is the neighbor
of which other point).

<P>

<H3><A NAME="SECTION04091200000000000000">
24.1.2 How is a LocStream different than a Mesh?</A>
</H3>
A Mesh consists of irregularly positioned points, but it has connectivity
also: each data point has a set of neighboring data points. There is no requirement that the
points in a LocStream have connectivity, indeed any particular spatial relationship to
one another.
Due to their heritage from data assimilation, many of the operations on LocStreams
do not resemble typical operations on Meshes, for example in a finite-volume
or finite-element code. 

<P>

<H2><A NAME="SECTION04092000000000000000">
24.2 Use and Examples</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04092100000000000000">
24.2.1 Creating a LocStream Employing User Allocated Memory</A>
</H3>

<P>
The following is an example of creating a LocStream object.
   After creation, key data is added, and a Field is created to hold data
   (temperature) at each location. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate and set example location information
   !-------------------------------------------------------------------
   allocate(lon(numLocationsOnThisPet))
   allocate(lat(numLocationsOnThisPet))

   do i=1,numLocationsOnThisPet
      lon(i)=360.0/numLocationsOnThisPet
      lat(i)=0.0
   enddo

   !-------------------------------------------------------------------
   ! Allocate and set example Field data
   !-------------------------------------------------------------------
   allocate(temperature(numLocationsOnThisPet))

   do i=1,numLocationsOnThisPet
      temperature(i)=90.0
   enddo


   !-------------------------------------------------------------------
   ! Create the LocStream:  Allocate space for the LocStream object, 
   ! define the number and distribution of the locations. 
   !-------------------------------------------------------------------
   locstream=ESMF_LocStreamCreate(name="Equatorial Measurements",   &amp;
                                  localCount=numLocationsOnThisPet, &amp;
                                  rc=rc)

   !-------------------------------------------------------------------
   ! Add key data, referencing a user data pointer. By changing the 
   ! copyFlag to ESMF_DATA_COPY an internally allocated copy of the 
   ! user data may also be set.  
   !-------------------------------------------------------------------
   call ESMF_LocStreamAddKey(locstream,              &amp;
                             keyName="Lat",          &amp;
                             farray=lat,             &amp;
                             copyFlag=ESMF_DATA_REF, &amp;
                             keyUnits="Degrees",     &amp;
                             keyLongName="Latitude", rc=rc)

   call ESMF_LocStreamAddKey(locstream,              &amp;
                             keyName="Lon",          &amp;
                             farray=lon,             &amp;
                             copyFlag=ESMF_DATA_REF, &amp;
                             keyUnits="Degrees",     &amp;
                             keyLongName="Longitude", rc=rc)

   !-------------------------------------------------------------------
   ! Create a Field on the Location Stream. In this case the 
   ! Field is created from a user array, but any of the other
   ! Field create methods (e.g. from ArraySpec) would also apply.
   !-------------------------------------------------------------------       
   field_temperature=ESMF_FieldCreate(locstream,   &amp;
                                   temperature, &amp;
                                   name="temperature", &amp;
                                   rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04092200000000000000">
24.2.2 Creating a LocStream Employing Internally Allocated Memory</A>
</H3>

<P>
The following is an example of creating a LocStream object.
   After creation, key data is internally allocated,
   the pointer is retrieved, and the data is set.
   A Field is also created on the LocStream to hold data
   (temperature) at each location. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate and set example Field data
   !-------------------------------------------------------------------
   allocate(temperature(numLocationsOnThisPet))

   do i=1,numLocationsOnThisPet
      temperature(i)=80.0
   enddo


   !-------------------------------------------------------------------
   ! Create the LocStream:  Allocate space for the LocStream object, 
   ! define the number and distribution of the locations. 
   !-------------------------------------------------------------------
   locstream=ESMF_LocStreamCreate(name="Equatorial Measurements", &amp;
                                  localCount=numLocationsOnThisPet, &amp;
                                  rc=rc)

   !-------------------------------------------------------------------
   ! Add key data (internally allocating memory).
   !-------------------------------------------------------------------
   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="Lat",                &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Latitude", rc=rc)

   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="Lon",                &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Longitude", rc=rc)


   !-------------------------------------------------------------------
   ! Get key data. 
   !-------------------------------------------------------------------
   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             localDE=0,                    &amp;
                             keyName="Lat",                &amp;
                             farray=lat,                   &amp;
                             rc=rc)

   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             localDE=0,                    &amp;
                             keyName="Lon",                &amp;
                             farray=lon,                   &amp;
                             rc=rc)

   !-------------------------------------------------------------------
   ! Set key data. 
   !-------------------------------------------------------------------
   do i=1,numLocationsOnThisPet
      lon(i)=360.0/numLocationsOnThisPet
      lat(i)=0.0
   enddo


   !-------------------------------------------------------------------
   ! Create a Field on the Location Stream. In this case the 
   ! Field is created from a user array, but any of the other
   ! Field create methods (e.g. from ArraySpec) would also apply.
   !-------------------------------------------------------------------    
   field_temperature=ESMF_FieldCreate(locstream,   &amp;
                                 temperature, &amp;
                                 name="temperature", &amp;
                                 rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04092300000000000000">
24.2.3 Creating a LocStream from a Background Grid</A>
</H3>

<P>
The following is an example of creating a LocStream object from another LocStream object 
   using a background Grid. The new LocStream contains the data present in the old LocStream, 
   but is redistributed so that entries with a given set of coordinates are on the same PET 
   as the piece of the background Grid which contains those coordinates. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the LocStream:  Allocate space for the LocStream object, 
   ! define the number and distribution of the locations. 
   !-------------------------------------------------------------------
   locstream=ESMF_LocStreamCreate(name="Equatorial Measurements", &amp;
                                  localCount=numLocationsOnThisPet, &amp;
                                  rc=rc)
   !-------------------------------------------------------------------
   ! Add key data (internally allocating memory).
   !-------------------------------------------------------------------
   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="Lon",                &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Longitude", rc=rc)

   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="Lat",                &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Latitude", rc=rc)


   !-------------------------------------------------------------------
   ! Get Fortran arrays which hold the key data, so that it can be set. 
   ! Using localDE=0, because the locstream was created with 1 DE per PET. 
   !-------------------------------------------------------------------
   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             localDE=0,                    &amp;
                             keyName="Lon",                &amp;
                             farray=lon,                   &amp;
                             rc=rc)

   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             localDE=0,                    &amp;
                             keyName="Lat",                &amp;
                             farray=lat,                   &amp;
                             rc=rc)

   !-------------------------------------------------------------------
   ! Set the longitude and latitude coordinates of the points in the 
   ! LocStream. Each PET contains points scattered around the equator. 
   !-------------------------------------------------------------------
   do i=1,numLocationsOnThisPet
      lon(i)=0.5+REAL(i-1)*360.0/numLocationsOnThisPet
      lat(i)=0.0
   enddo

   !-------------------------------------------------------------------
   ! Create a Grid to use as the background. The Grid is 
   ! GridLonSize by GridLatSize with the default distribution 
   ! (The first dimension split across the PETs). The coordinate range
   ! is  0 to 360 in longitude and -90 to 90 in latitude. Note that we 
   ! use indexflag=ESMF_INDEX_GLOBAL for the Grid creation. At this time 
   ! this is required for a Grid to be usable as a background Grid.
   !-------------------------------------------------------------------
   grid=ESMF_GridCreateShapeTile(maxIndex=(/GridLonSize,GridLatSize/),          &amp;
                                 indexflag=ESMF_INDEX_GLOBAL, &amp;
                                 rc=rc)

   !-------------------------------------------------------------------
   ! Allocate the corner stagger location in which to put the coordinates. 
   ! (The corner stagger must be used for the Grid to be usable as a
   !  background Grid.)
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid, staggerloc=ESMF_STAGGERLOC_CORNER, rc=rc)


   !-------------------------------------------------------------------
   ! Get access to the Fortran array pointers that hold the Grid 
   ! coordinate information and then set the coordinates to be uniformly 
   ! distributed around the globe. 
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid, localDE=0, staggerLoc=ESMF_STAGGERLOC_CORNER,   &amp;
                          coordDim=1,                                           &amp;
                          computationalLBound=clbnd, computationalUBound=cubnd, &amp; 
                          fptr=fptrLonC, rc=rc)

   call ESMF_GridGetCoord(grid, localDE=0, staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
                          coordDim=2,                                         &amp;
                          fptr=fptrLatC, rc=rc)

   do i1=clbnd(1),cubnd(1)
   do i2=clbnd(2),cubnd(2)
      ! Set Grid longitude coordinates as 0 to 360
      fptrLonC(i1,i2) = REAL(i1-1)*360.0/REAL(GridLonSize)

      ! Set Grid latitude coordinates as -90 to 90
      fptrLatC(i1,i2) = -90. + REAL(i2-1)*180.0/REAL(GridLatSize) + &amp;
                                      0.5*180.0/REAL(GridLatSize)
   enddo
   enddo


   !-------------------------------------------------------------------
   ! Create newLocstream on the background Grid using the 
   ! "Lon" and "Lat" keys as the coordinates for the entries in 
   ! locstream. The entries in newLocstream with coordinates (lon,lat)
   ! are on the same PET as the piece of grid which contains (lon,lat). 
   !-------------------------------------------------------------------
   newLocstream=ESMF_LocStreamCreate(locstream, coordKeyNames="Lon:Lat", &amp;
                  background=grid, rc=rc)

   !-------------------------------------------------------------------
   ! A Field can now be created on newLocstream and 
   ! ESMF_FieldRedist() can be used to move data between Fields built 
   ! on locstream and Fields built on newLocstream.
   !-------------------------------------------------------------------
</PRE>

<P>

<P>

<H2><A NAME="SECTION04093000000000000000">
24.3 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04093100000000000000">
24.3.1 ESMF_LocStreamAddKey - Add a key Array and allocate the internal memory</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamAddKey()
   subroutine ESMF_LocStreamAddKeyAlloc(locstream, keyName, keyTypeKind, &amp;
                keyUnits, keyLongName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)            :: locstream
     character (len=*),    intent(in)            :: keyName
     type(ESMF_TypeKind),  intent(in), optional  :: keyTypeKind
     character (len=*),    intent(in), optional  :: keyUnits 
     character (len=*),    intent(in), optional  :: keyLongName 
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a key to a locstream. Once a key has been added its internal data
   can be retrieved and used to set key values. 

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to add key to.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to add. 
   
</DD>
<DT><STRONG>[keyTypeKind]</STRONG></DT>
<DD>The type/kind of the key data. 
   If not specified then the type/kind will default to 8 byte reals.  
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04093200000000000000">
24.3.2 ESMF_LocStreamAddKey - Add a key ESMF Array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamAddKey()
   subroutine ESMF_LocStreamAddKeyArray(locstream, keyName, keyArray, destroyKey, &amp;
                keyUnits, keyLongName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)             :: locstream
     character (len=*),    intent(in)             :: keyName
     type(ESMF_Array),     intent(in)             :: keyArray
     logical,              intent(in),  optional  :: destroyKey
     character (len=*),    intent(in),  optional  :: keyUnits 
     character (len=*),    intent(in),  optional  :: keyLongName 
     integer,              intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a key to a locstream. Once a key has been added its internal data
   can be retrieved and used to set key values. 

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to add key to.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to add. 
   
</DD>
<DT><STRONG>keyArray</STRONG></DT>
<DD>An ESMF Array which contains the key data
   
</DD>
<DT><STRONG>[destroyKey]</STRONG></DT>
<DD>if .true. destroy this key array when the locstream is destroyed.
   Defaults to .false.
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04093300000000000000">
24.3.3 ESMF_LocStreamAddKey - Add a key Array created around user memory </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamAddKey()
   subroutine ESMF_LocStreamAddKeyI4(locstream, keyName, farray, copyflag, &amp;
                keyUnits, keyLongName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)                   :: locstream
     character (len=*),         intent(in)                    :: keyName
     integer(ESMF_KIND_I4), dimension(:), intent(in)  :: farray
     type(ESMF_CopyFlag), intent(in), optional       :: copyflag
     character (len=*),    intent(in), optional          :: keyUnits 
     character (len=*),    intent(in), optional   :: keyLongName 
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a key to a locstream. Once a key has been added its internal data
   can be retrieved and used to set key values. 

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to add key to.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to add. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Valid native Fortran array, i.e. memory must be associated with the 
   actual argument. The type/kind/rank information of <TT>farray</TT> will be 
   used to set the key Array's properties accordingly. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farray</TT> directly or will copy the data from 
   <TT>farray</TT> into a new memory allocation. Valid options are 
   <TT>ESMF_DATA_REF</TT> (default) or <TT>ESMF_DATA_COPY</TT>. 
   Depending on the specific situation the <TT>ESMF_DATA_REF</TT> option 
   may be unsafe when specifying an array slice for <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04093400000000000000">
24.3.4 ESMF_LocStreamAddKey - Add a key Array created around user memory</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamAddKey()
   subroutine ESMF_LocStreamAddKeyR4(locstream, keyName, farray, copyflag, &amp;
                keyUnits, keyLongName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)                   :: locstream
     character (len=*),   intent(in)                    :: keyName
     real(ESMF_KIND_R4),  dimension(:), intent(in)      :: farray
     type(ESMF_CopyFlag), intent(in), optional          :: copyflag
     character (len=*),    intent(in), optional         :: keyUnits 
     character (len=*),    intent(in), optional         :: keyLongName 
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a key to a locstream. Once a key has been added its internal data
   can be retrieved and used to set key values. 

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to add key to.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to add. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Valid native Fortran array, i.e. memory must be associated with the 
   actual argument. The type/kind/rank information of <TT>farray</TT> will be 
   used to set the key Array's properties accordingly. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farray</TT> directly or will copy the data from 
   <TT>farray</TT> into a new memory allocation. Valid options are 
   <TT>ESMF_DATA_REF</TT> (default) or <TT>ESMF_DATA_COPY</TT>. 
   Depending on the specific situation the <TT>ESMF_DATA_REF</TT> option 
   may be unsafe when specifying an array slice for <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04093500000000000000">
24.3.5 ESMF_LocStreamAddKey - Add a key Array created around user memory</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamAddKey()
   subroutine ESMF_LocStreamAddKeyR8(locstream, keyName, farray, copyflag, &amp;
                keyUnits, keyLongName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)                   :: locstream
     character (len=*),   intent(in)                    :: keyName
     real(ESMF_KIND_R8),  dimension(:), intent(in)      :: farray
     type(ESMF_CopyFlag), intent(in), optional          :: copyflag
     character (len=*),    intent(in), optional         :: keyUnits 
     character (len=*),    intent(in), optional         :: keyLongName 
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a key to a locstream. Once a key has been added its internal data
   can be retrieved and used to set key values. 

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to add key to.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to add. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Valid native Fortran array, i.e. memory must be associated with the 
   actual argument. The type/kind/rank information of <TT>farray</TT> will be 
   used to set the key Array's properties accordingly. 
   
</DD>
<DT><STRONG>[copyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farray</TT> directly or will copy the data from 
   <TT>farray</TT> into a new memory allocation. Valid options are 
   <TT>ESMF_DATA_REF</TT> (default) or <TT>ESMF_DATA_COPY</TT>. 
   Depending on the specific situation the <TT>ESMF_DATA_REF</TT> option 
   may be unsafe when specifying an array slice for <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04093600000000000000">
24.3.6 ESMF_LocStreamCreate - Create a new LocStream by projecting onto a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateByBkgGrid(locstream, name, coordKeyNames, &amp;
                  background, maskValues, unmappedAction, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateByBkgGrid
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(in)                :: locstream
       character (len=*),    intent(in), optional      :: name
       character (len=*),    intent(in)                :: coordKeyNames
       type(ESMF_Grid),      intent(in)                :: background
       integer(ESMF_KIND_I4), intent(in), optional     :: maskValues(:)
       type(ESMF_UnmappedAction), intent(in), optional :: unmappedAction
       integer,              intent(out), optional     :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an location stream from an existing one in accordance with 
       the distribution of the background Grid.  The entries
       in the new location stream are redistributed, so that they lie on the same PET
       as the piece of Grid which contains the coordinates of the entries. The coordinates
       of the entries are the data in the keys named by <TT>coordKeyNames</TT>. To copy data in
       Fields or FieldBundles built on <TT>locstream</TT> to the new one simply use <TT>ESMF_FieldRedist()</TT>
       or <TT>ESMF_FieldBundleRedist()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>Location stream from which the new location stream is to be created
        
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the resulting location stream
        
</DD>
<DT><STRONG>coordKeyNames</STRONG></DT>
<DD>Names of the keys used to determine the link to background Grid.
            The first key in this list matches up with the first coordinate of the 
            Grid, the second key in this list matches up with the second coordinate
            of the Grid, and so on. The key names should be separated by the : character. 
        
</DD>
<DT><STRONG>background</STRONG></DT>
<DD>Background Grid which determines the distribution of the entries in the new location stream.
            The background Grid 
            needs to have the same number of dimensions as the number of keys in <TT>coordKeyNames</TT>.  
            Note also that this subroutine uses the corner stagger location in the Grid for determining 
            where a point lies, because this is the stagger location which fully contains the cell. 
            A Grid must have coordinate data in this stagger location to be used in this subroutine. 
            For a 2D Grid this stagger location is ESMF_STAGGERLOC_CORNER for a 3D Grid this 
            stagger location is ESMF_STAGGERLOC_CORNER_VFACE. Note that currently the background 
            Grid also needs to have been created with indexflag=ESMF_INDEX_GLOBAL to be usable here. 
       
</DD>
<DT><STRONG>[maskValues]</STRONG></DT>
<DD>List of values that indicate a background grid point should be masked out. 
             If not specified, no masking will occur. 
        
</DD>
<DT><STRONG>[unmappedAction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Options are 
             <TT>ESMF_UNMAPPEDACTION_ERROR</TT> or 
             <TT>ESMF_UNMAPPEDACTION_IGNORE</TT> [NOT IMPLEMENTED]. If not specified, defaults 
             to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>. 
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04093700000000000000">
24.3.7 ESMF_LocStreamCreate - Create a new LocStream by projecting onto a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateByBkgMesh(locstream, name, coordKeyNames, &amp;
                  background, unmappedAction, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateByBkgMesh
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(in)                :: locstream
       character (len=*),    intent(in), optional      :: name
       character (len=*),    intent(in)                :: coordKeyNames
       type(ESMF_Mesh),      intent(in)                :: background
       type(ESMF_UnmappedAction), intent(in), optional :: unmappedAction
       integer,              intent(out), optional     :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an location stream from an existing one in accordance with 
       the distribution of the background Mesh.  The entries
       in the new location stream are redistributed, so that they lie on the same PET
       as the piece of Mesh which contains the coordinates of the entries. The coordinates
       of the entries are the data in the keys named by <TT>coordKeyNames</TT>. To copy data in
       Fields or FieldBundles built on <TT>locstream</TT> to the new one simply use <TT>ESMF_FieldRedist()</TT>
       or <TT>ESMF_FieldBundleRedist()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>Location stream from which the new location stream is to be created
        
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the resulting location stream
        
</DD>
<DT><STRONG>coordKeyNames</STRONG></DT>
<DD>Names of the keys used to determine the link to background Mesh.
            The first key in this list matches up with the first coordinate of the 
            Mesh, the second key in this list matches up with the second coordinate
            of the Mesh, and so on. The key names should be separated by the : character. 
        
</DD>
<DT><STRONG>background</STRONG></DT>
<DD>Background Mesh which determines the distribution of entries in the new locatiion stream.
            The Mesh must have the same spatial dimension as the number of keys in
            <TT>coordKeyNames</TT>. 
        
</DD>
<DT><STRONG>[unmappedAction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Options are 
             <TT>ESMF_UNMAPPEDACTION_ERROR</TT> or 
             <TT>ESMF_UNMAPPEDACTION_IGNORE</TT> [NOT IMPLEMENTED]. If not specified, defaults 
             to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>. 
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04093800000000000000">
24.3.8 ESMF_LocStreamCreate - Create a new location stream from a distgrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateFromDG(name, distgrid, &amp;
                  destroyDistgrid, indexflag, rc )
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateFromDG
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len=*),        intent(in), optional     :: name
       type(ESMF_DistGrid),   intent(in)                  :: distgrid
       logical,                        intent(in),   optional :: destroyDistgrid
       type(ESMF_IndexFlag), intent(in),   optional :: indexflag    
       integer,                       intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types. 

<P>
The arguments are:
       <DL>
<DT><STRONG>name</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Distgrid specifying size and distribution. Only 1D distgrids are allowed.
       
</DD>
<DT><STRONG>[destroyDistgrid]</STRONG></DT>
<DD>If .true. the locstream is responsible for destroying the distgrid.
            Defaults to .false. 
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node2.html#opt:indexflag">9.2.8</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04093900000000000000">
24.3.9 ESMF_LocStreamCreate - Create a new location stream from an irregular dist.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateIrreg(name, minIndex, countsPerDE, indexflag, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateIrreg
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len=*), intent(in), optional         :: name
       integer, intent(in), optional                   :: minIndex
       integer, intent(in)                             :: countsPerDE(:)
       type(ESMF_IndexFlag), intent(in), optional      :: indexflag
       integer, intent(out), optional                  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types.  The <TT>ESMF_DistGrid</TT> is set up, indicating
       how the LocStream is distributed. 

<P>
The arguments are:
       <DL>
<DT><STRONG>name</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Number to start the index ranges at. If not present, defaults
            to 1.
       
</DD>
<DT><STRONG>countsPerDE</STRONG></DT>
<DD>This array specifies the number of locations per DE.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node2.html#opt:indexflag">9.2.8</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040931000000000000000">
24.3.10 ESMF_LocStreamCreate - Create a new location stream from a local count</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateFromLocal(name, localCount, indexflag, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateFromLocal
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len=*), intent(in), optional         :: name
       integer, intent(in)                             :: localCount
       type(ESMF_IndexFlag), intent(in), optional      :: indexflag
       integer, intent(out), optional                  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types.  The <TT>ESMF_DistGrid</TT> is set up, indicating
       how the LocStream is distributed. 

<P>
The arguments are:
       <DL>
<DT><STRONG>name</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>localCount</STRONG></DT>
<DD>Number of grid cells to be distributed to this DE.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node2.html#opt:indexflag">9.2.8</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040931100000000000000">
24.3.11 ESMF_LocStreamCreate - Create a new location stream using a regular distribution.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateReg(name, &amp;
                  regDecomp, decompFlag, minIndex, maxIndex, indexflag, rc )
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateReg
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len=*),     intent(in),  optional  :: name
       integer,               intent(in),  optional  :: regDecomp
       type(ESMF_DecompFlag), intent(in),  optional  :: decompflag
       integer,               intent(in),  optional  :: minIndex
       integer,               intent(in)             :: maxIndex
       type(ESMF_IndexFlag),  intent(in),  optional  :: indexflag
       integer,               intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types.  The <TT>ESMF_DistGrid</TT> is set up, indicating
       how the LocStream is distributed. 
       at a later time. 

<P>
The arguments are:
       <DL>
<DT><STRONG>name</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>Specify into how many chunks to divide the locations. 
            If not specified, defaults to the number of PETs.
       
</DD>
<DT><STRONG>[decompFlag]</STRONG></DT>
<DD>Specify what to do with leftover locations after division.
            If not specified, defaults to <TT>ESMF_DECOMP_HOMOGEN</TT>. Please
            see Section&nbsp;<A HREF="node2.html#opt:decompflag">9.2.7</A> for a full description of the 
            possible options. 
       
</DD>
<DT></DT>
<DD>[[minIndex]]
            The minimum index across all PETs. If not set defaults to 1. 
       
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The maximum index across all PETs.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node2.html#opt:indexflag">9.2.8</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040931200000000000000">
24.3.12 ESMF_LocStreamDestroy - Destroy a LocStream </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LocStreamDestroy(locstream,rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(inout)   :: locstream 
       integer, intent(out), optional               :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Deallocate an <TT>ESMF_LocStream</TT> object and all appropriate 
       internal structures.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>locstream to destroy
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040931300000000000000">
24.3.13 ESMF_LocStreamGet - Return info associated with a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGet()
   subroutine ESMF_LocStreamGetDefault(locstream, distgrid, keyCount, &amp;
                keyNames, localDECount, indexflag, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)             :: locstream
     type(ESMF_DistGrid), intent(out),  optional  :: distgrid
     integer, intent(out),optional                :: keyCount
     character(len=ESMF_MAXSTR),optional          :: keyNames(:) 
     integer, intent(out),optional                :: localDECount
     type(ESMF_IndexFlag), intent(out), optional  :: indexflag
     character(len=*), intent(out),     optional  :: name
     integer, intent(out), optional               :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Query an <TT>ESMF_LocStream</TT> for various information. All arguments after
   the <TT>locstream</TT> are optional. 

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to query.
   
</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object that descibes 
   
</DD>
<DT><STRONG>[keyCount]</STRONG></DT>
<DD>Number of keys in the <TT>locstream</TT>.
   
</DD>
<DT><STRONG>[keyNames]</STRONG></DT>
<DD>The names of the keys in the <TT>locstream</TT>. Keynames should
   be an array of character strings. The character strings should
   be of length ESMF_MAXSTR and the array's length should be
   at least keyCount. 
   
</DD>
<DT><STRONG>[localDECount]</STRONG></DT>
<DD>Number of DEs on this PET in the <TT>locstream</TT>.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>The indexflag for this indexflag.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of queried item.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040931400000000000000">
24.3.14 ESMF_LocStreamGetKey - Get ESMF Array associated with key</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
   subroutine ESMF_LocStreamGetKeyArray(locstream, keyName, keyArray, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)            :: locstream
     character (len=*),    intent(in)            :: keyName
     type(ESMF_Array),     intent(out)            :: keyArray
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get ESMF Array associated with key.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to get key from.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to get. 
   
</DD>
<DT><STRONG>keyArray</STRONG></DT>
<DD>Array associated with key.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040931500000000000000">
24.3.15 ESMF_LocStreamGetKey - Get the bounds of a key Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
       subroutine ESMF_LocStreamGetKeyBounds(locstream, localDE, keyName, &amp; 
           exclusiveLBound, exclusiveUBound, exclusiveCount,     &amp;
           computationalLBound, computationalUBound, computationalCount,     &amp;
           totalLBound, totalUBound, totalCount,     &amp;
           rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream),   intent(in)       :: locstream
       integer,                intent(in)                  :: localDE
       character (len=*),   intent(in)                :: keyName
       integer,                intent(out), optional :: exclusiveLBound
       integer,                intent(out), optional :: exclusiveUBound
       integer,                intent(out), optional :: exclusiveCount
       integer,                intent(out), optional :: computationalLBound
       integer,                intent(out), optional :: computationalUBound
       integer,                intent(out), optional :: computationalCount
       integer,                intent(out), optional :: totalLBound
       integer,                intent(out), optional :: totalUBound
       integer,                intent(out), optional :: totalCount
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets the bounds of a localDE for a locstream.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>LocStream to get the information from.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT>.
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). 
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region
            (i.e. <TT>totalUBound-totalLBound+1</TT>). 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040931600000000000000">
24.3.16 ESMF_LocStreamGetKey - Get Info associated with key</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
   subroutine ESMF_LocStreamGetKeyInfo(locstream, keyName, keyUnits, keyLongName, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)              :: locstream
     character (len=*),    intent(in)              :: keyName
     character (len=*),    intent(out), optional   :: keyUnits 
     character (len=*),    intent(out), optional   :: keyLongName 
     type(ESMF_TypeKind), intent(out), optional    :: typekind
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get ESMF Array associated with key.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to get key from.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to get. 
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the key data
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040931700000000000000">
24.3.17 ESMF_LocStreamGetKey - Get pointer to key values</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
       subroutine ESMF_LocStreamGetKeyI4(locstream, localDE, keyName, &amp; 
           exclusiveLBound, exclusiveUBound, exclusiveCount,     &amp;
           computationalLBound, computationalUBound, computationalCount,     &amp;
           totalLBound, totalUBound, totalCount,     &amp;
           farray, doCopy, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(in) :: locstream
       integer, intent(in) :: localDE
       character (len=*),    intent(in)              :: keyName
       integer,                intent(out), optional :: exclusiveLBound
       integer,                intent(out), optional :: exclusiveUBound
       integer,                intent(out), optional :: exclusiveCount
       integer,                intent(out), optional :: computationalLBound
       integer,                intent(out), optional :: computationalUBound
       integer,                intent(out), optional :: computationalCount
       integer,                intent(out), optional :: totalLBound
       integer,                intent(out), optional :: totalUBound
       integer,                intent(out), optional :: totalCount
       integer(ESMF_KIND_I4), pointer :: farray(:)
       type(ESMF_CopyFlag), intent(in), optional :: docopy
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets a Fortran pointer to the piece of memory which holds the 
      key data for a particular key on the given local DE. 
      This is useful, for example, for setting the key values in a LocStream, or
      for reading the values. 

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>LocStream to get the information from.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The key to get the information from.
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT>.
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). 
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region
            (i.e. <TT>totalUBound-totalLBound+1</TT>). 
       
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>The pointer to the coordinate data.
       
</DD>
<DT><STRONG>[doCopy]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATA_REF</TT>, in this case
            farray is a reference to the data in the Grid coordinate arrays. 
            Please see Section&nbsp;<A HREF="node2.html#opt:copyflag">9.2.5</A> for further description and a
            list of valid values. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040931800000000000000">
24.3.18 ESMF_LocStreamGetKey - Get pointer to key values</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
   subroutine ESMF_LocStreamGetKeyR4(locstream, localDE, keyName,        &amp; 
           exclusiveLBound, exclusiveUBound, exclusiveCount,     &amp;
           computationalLBound, computationalUBound, computationalCount,     &amp;
           totalLBound, totalUBound, totalCount,     &amp;
           farray, doCopy, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(in) :: locstream
       integer, intent(in) :: localDE
       character (len=*),    intent(in)              :: keyName
       integer,                intent(out), optional :: exclusiveLBound
       integer,                intent(out), optional :: exclusiveUBound
       integer,                intent(out), optional :: exclusiveCount
       integer,                intent(out), optional :: computationalLBound
       integer,                intent(out), optional :: computationalUBound
       integer,                intent(out), optional :: computationalCount
       integer,                intent(out), optional :: totalLBound
       integer,                intent(out), optional :: totalUBound
       integer,                intent(out), optional :: totalCount 
       real(ESMF_KIND_R4), pointer :: farray(:)
       type(ESMF_CopyFlag), intent(in), optional :: docopy
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets a Fortran pointer to the piece of memory which holds the 
      key data for a particular key on the given local DE. 
      This is useful, for example, for setting the key values in a LocStream, or
      for reading the values. 

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>LocStream to get the information from.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The key to get the information from.
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT>.
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). 
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region
            (i.e. <TT>totalUBound-totalLBound+1</TT>). 
       
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>The pointer to the coordinate data.
       
</DD>
<DT><STRONG>[doCopy]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATA_REF</TT>, in this case
            farray is a reference to the data in the Grid coordinate arrays. 
            Please see Section&nbsp;<A HREF="node2.html#opt:copyflag">9.2.5</A> for further description and a
            list of valid values. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040931900000000000000">
24.3.19 ESMF_LocStreamGetKey - Get pointer to key values</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
       subroutine ESMF_LocStreamGetKeyR8(locstream, localDE, keyName, &amp; 
           exclusiveLBound, exclusiveUBound, exclusiveCount,     &amp;
           computationalLBound, computationalUBound, computationalCount,     &amp;
           totalLBound, totalUBound, totalCount,     &amp;
           farray, doCopy, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(in) :: locstream
       integer, intent(in) :: localDE
       character (len=*),    intent(in)              :: keyName
       integer,                intent(out), optional :: exclusiveLBound
       integer,                intent(out), optional :: exclusiveUBound
       integer,                intent(out), optional :: exclusiveCount
       integer,                intent(out), optional :: computationalLBound
       integer,                intent(out), optional :: computationalUBound
       integer,                intent(out), optional :: computationalCount
       integer,                intent(out), optional :: totalLBound
       integer,                intent(out), optional :: totalUBound
       integer,                intent(out), optional :: totalCount
       real(ESMF_KIND_R8), pointer :: farray(:)
       type(ESMF_CopyFlag), intent(in), optional :: docopy
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets a Fortran pointer to the piece of memory which holds the 
      key data for a particular key on the given local DE. 
      This is useful, for example, for setting the key values in a LocStream, or
      for reading the values. 

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>LocStream to get the information from.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The key to get the information from.
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT>.
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). 
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region
            (i.e. <TT>totalUBound-totalLBound+1</TT>). 
       
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>The pointer to the coordinate data.
       
</DD>
<DT><STRONG>[doCopy]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATA_REF</TT>, in this case
            farray is a reference to the data in the Grid coordinate arrays. 
            Please see Section&nbsp;<A HREF="node2.html#opt:copyflag">9.2.5</A> for further description and a
            list of valid values. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040932000000000000000">
24.3.20 ESMF_LocStreamGet - Get the local bounds of a location stream</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGet()
       subroutine ESMF_LocStreamGetBounds(locstream, localDE, &amp; 
           exclusiveLBound, exclusiveUBound, exclusiveCount,     &amp;
           computationalLBound, computationalUBound, computationalCount,     &amp;
           rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream),   intent(in) :: locstream
       integer,                intent(in) :: localDE
       integer,                intent(out), optional :: exclusiveLBound
       integer,                intent(out), optional :: exclusiveUBound
       integer,                intent(out), optional :: exclusiveCount
       integer,                intent(out), optional :: computationalLBound
       integer,                intent(out), optional :: computationalUBound
       integer,                intent(out), optional :: computationalCount
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets the bounds of a localDE for a locstream.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>LocStream to get the information from.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT>.
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040932100000000000000">
24.3.21 ESMF_LocStreamPrint - Print the contents of a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LocStreamPrint(locstream, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(inout) :: locstream 
       character (len = *), intent(in), optional :: options
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints information about the <TT>locstream</TT> to <TT>stdout</TT>.
    This subroutine goes through the internal data members of a locstream
    data type and prints information of each data member.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options are not yet supported.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040932200000000000000">
24.3.22 ESMF_LocStreamValidate - Check validity of a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LocStreamValidate(locstream, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(inout) :: locstream 
       character (len = *), intent(in), optional :: options 
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>locstream</TT> is internally consistent.
        Currently this method determines if the <TT>locstream</TT> is uninitialized 
        or already destroyed. 

<P>
The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> to validate.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Validation options are not yet supported.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if the <TT>locstream</TT> 
             is valid.
       
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION040100000000000000000">
25 Mesh Class</A>
</H1>

<P>

<H2><A NAME="SECTION040101000000000000000">
25.1 Description</A>
</H2>

<P>
Unstructured grids are commonly used in the computational solution of Partial Differential equations.  These are especially useful for problems that involve complex geometry, where using the less flexible structured grids can
result in grid representation of regions where no computation is needed.  Finite
element and finite volume methods map naturally to unstructured grids and are used commonly
in hydrology, ocean modeling, and many other applications.

<P>
In order to provide support for application codes using unstructured grids, the ESMF library provides a class for representing 
unstructured grids called the <B>Mesh</B>. Fields can be created on a Mesh to hold data. Fields created on a Mesh can also be used 
as either the source or destination or both of an interpolaton (i.e. an <TT>ESMF_FieldRegridStore()</TT> call) in ESMF allowing data to be 
moved to or from or between unstructured grids. This section describes the Mesh and how to create and use them in ESMF. 

<P>

<H3><A NAME="SECTION040101100000000000000">
25.1.1 Mesh Representation in ESMF</A>
</H3>

<P>
A Mesh in ESMF is described in terms of <B>nodes</B> and <B>elements</B>. A node is a point in space which represents where the coordinate 
information in a Mesh is located. This is also where Field data may be located in a Mesh (i.e. Fields may be created on a Mesh's nodes). An 
element is a higher dimensional shape constructed of nodes. Elements give a Mesh its shape and define the relationship of the nodes to one 
another. 

<P>

<H3><A NAME="SECTION040101200000000000000">
25.1.2 Supported Meshes</A>
</H3>

<P>
The range of Meshes supported by ESMF are defined by several factors: dimension, element types, and distribution.

<P>
ESMF currently only supports Meshes whose number of coordinate dimensions (spatial dimension) is 2 or 3. The dimension of the elements in a Mesh
(parametric dimension) must be less than or equal to the spatial dimension, but also must be either 2 or 3. This means that an ESMF mesh may be
either 2D elements in 2D space, 3D elements in 3D space, or a manifold constructed of 2D elements embedded in 3D space. 

<P>
ESMF currently supports two types of elements for each Mesh parametric dimension. For a parametric dimension of 2 the 
supported element types are triangles or quadralaterals. For a parametric dimension of 3 the supported element types are tetrahedrons
and hexahedrons. See Section&nbsp;<A HREF="node4.html#sec:mesh:opt:elemtype">25.3.1</A> for diagrams of these. The Mesh supports any combination of element types within a particular
dimension, but types from different dimensions may not be mixed, for example, a Mesh cannot be constructed of both quadralaterals and tetrahedra.

<P>
ESMF currently only supports distributions where every node on a PET must be a part of an element on that PET. In other words, there 
must not be nodes without an element on a PET. 

<P>

<H2><A NAME="SECTION040102000000000000000">
25.2 Use and Examples</A>
</H2>

<P>

<P>

<P>
This section describes the use of the ESMF Mesh class. It starts with an explanation and examples of 
   creating a Mesh and then goes through other Mesh methods. This set of sections covers the use of the 
   Mesh class interfaces, for further detail which applies to using a Field specifically on created on a Mesh, please see 
   Section&nbsp;<A HREF="node4.html#sec:field:usage:create_mesh_arrayspec">18.2.14</A>.

<P>

<H3><A NAME="SECTION040102100000000000000"></A>
  <A NAME="sec:mesh:usage:meshCreation"></A>
<BR>
25.2.1 Mesh Creation
</H3>

<P>
To create a Mesh we need to set some properties of the Mesh as a whole,  some properties of each node in the mesh and 
   then some properties of each element which connects the nodes. 

<P>
For the Mesh as a whole we set its parametric dimension (<TT>parametricDim</TT>) and spatial dimension (<TT>spatialDim</TT>). 
   The parametric dimension of a Mesh is the dimension of the topology of the Mesh, this can be thought of as the dimension of 
   the elements which make up the Mesh. For example, a Mesh composed of triangles would have a parametric dimension of 2, whereas
   a Mesh composed of tetrahedra would have a parametric dimension of 3. A Mesh's spatial dimension, on the other hand, is the 
   dimension of the space the Mesh is embedded in, in other words the number of coordinate dimensions needed to describe the 
   location of the nodes making up the Mesh. For example, a Mesh constructed of squares on a plane would have a parametric 
   dimension of 2 and a spatial dimension of 2, whereas if that same Mesh were used to represent the 2D surface of a sphere 
   then the Mesh would still have a parametric dimension of 2, but now its spatial dimension would be 3. 

<P>
The structure of the per node and element information used to create a Mesh is influenced by the Mesh distribution strategy. 
   The Mesh class is distributed by elements. This means that a node must be present on any PET that contains an element 
   associated with that node, but not on any other PET (a node can't be on a PET without an element ""home"). Since a node may be used
   by two or more elements located on different PETs, a node may be duplicated on muliple PETs. When a node is duplicated in this manner, 
   one and only one of the PETs that contain the node must "own" the node. The user sets this ownership when they define the nodes during Mesh creation.
   When a Field is created on a Mesh (i.e. on  the Mesh nodes), on each PET the Field is only created on the nodes which are owned by that PET.
   This means that the size of the Field memory on the PET can be smaller than the number of nodes used to create the Mesh on 
   that PET. Please see Section&nbsp;<A HREF="node4.html#sec:field:usage:create_mesh_arrayspec">18.2.14</A> in Field for further explanation and examples of this
   issue and others in working with Fields on Meshes. 

<P>
For each node in the Mesh we set three properties: the global id of the node (<TT>nodeIds</TT>), node coordinates 
   (<TT>nodeCoords</TT>), and which PET owns the node (<TT>nodeOwners</TT>). The node id is a unique (across all PETs) integer 
   attached to the particular node. It is used to indicate which nodes are the same when connecting together pieces of the 
   Mesh on different processors. The node coordinates indicate the location of a node in space and are used in the
   <TT>ESMF_FieldRegrid()</TT> functionality when interpolating. The node owner indicates which PET is in charge of the node. This
   is used when creating a Field on the Mesh to indicate which PET should contain a Field location for the data.  

<P>
For each element in the Mesh we set three properties: the global id of the element (<TT>elementIds</TT>), the topology type of
   the element (<TT>elementTypes</TT>), and which nodes are connected together to form the element (<TT>elementConn</TT>). The element id is
   a unique (across all PETs) integer attached to the particular element. The element type describes the topology of the element 
   (e.g. a triangle vs. a quadralateral). The range of choices for the topology of the elements in a Mesh are restricted by the 
   Mesh's parametric dimension (e.g. a Mesh can't contain a 2D element like a triangle, when its parametric dimension is 3D), but it can contain
   any combination of elements appropriate to its dimension. The element connectivity indicates which nodes are to be connected together to
   form the element. The number of nodes connected together for each element is implied by the elements topology type (<TT>elementTypes</TT>). 
   It is IMPORTANT to note, that the entries in this list are NOT the global ids of the nodes, but are indices into the PET local lists of
   node info used in the Mesh Create. In other words, the element connectivity isn't specified in terms of the global list of nodes, but instead
   is specified in terms of the locally described node info. One other important point about connectivities is that the order of the nodes in the 
   connectivity list of an element is important. Please see Section&nbsp;<A HREF="node4.html#sec:mesh:opt:elemtype">25.3.1</A> for diagrams illustrating the correct order of
   nodes in an element. 

<P>
Mesh creation may either be performed as a one step process using the full <TT>ESMF_MeshCreate()</TT> call, or may be done in three steps. The
   three step process starts with a more minimal <TT>ESMF_MeshCreate()</TT> call. It is then followed by the <TT>ESMF_MeshAddNodes()</TT> to 
   specify nodes, and then the <TT>ESMF_MeshAddElements()</TT> call to specify elements. This three step sequence is useful to conserve memory
   because the node arrays being used for the <TT>ESMF_MeshAddNodes()</TT> call can be deallocated before creating the arrays to be used in the <TT>ESMF_MeshAddElements()</TT> call.

<P>

<H3><A NAME="SECTION040102200000000000000"></A><A NAME="sec:mesh:1pet1step"></A>
<BR>
25.2.2 Example: Creating a Small Single PET Mesh in one Step
</H3>

<P>
<PRE>
  
   
    2.0   7 ------- 8 ------- 9
          |         |         |
          |    4    |    5    |
          |         |         |
    1.0   4 ------- 5 ------- 6
          |         |  \   3  |
          |    1    |    \    |
          |         |  2   \  |
    0.0   1 ------- 2 ------- 3
  
         0.0       1.0        2.0 
   
          Node Id labels at corners
         Element Id labels in centers
         (Everything owned by PET 0)
</PRE>

<P>
This example is intended to illustrate the creation of a small Mesh on one PET. The reason for starting with a single PET
   case is so that the user can start to familiarize themselves with the concepts of Mesh creation without the added complication of 
   multiple processors. Later examples illustrate the multiple processor case. This example creates the small 2D Mesh which can be 
   seen in the figure above. Note that this Mesh consists of 9 nodes and 5 elements, where the elements are a mixture of 
   quadralaterals and triangles.  The coordinates of the nodes in the Mesh range from 0.0 to 2.0 in both dimensions. The node ids are 
   in the corners of the elements whereas the element ids are in the centers. The following section of code illustrates the creation of
   this Mesh. 

<P>
<PRE>
  ! Set number of nodes
  numNodes=9

  ! Allocate and fill the node id array.
  allocate(nodeIds(numNodes))
  nodeIds=(/1,2,3,4,5,6,7,8,9/) 

  ! Allocate and fill node coordinate array.
  ! Since this is a 2D Mesh the size is 2x the
  ! number of nodes.
  allocate(nodeCoords(2*numNodes))
  nodeCoords=(/0.0,0.0, &amp; ! node id 1
               1.0,0.0, &amp; ! node id 2
               2.0,0.0, &amp; ! node id 3
               0.0,1.0, &amp; ! node id 4
               1.0,1.0, &amp; ! node id 5
               2.0,1.0, &amp; ! node id 6
               0.0,2.0, &amp; ! node id 7
               1.0,2.0, &amp; ! node id 8
               2.0,2.0 /) ! node id 9

  ! Allocate and fill the node owner array.
  ! Since this Mesh is all on PET 0, it's just set to all 0.
  allocate(nodeOwners(numNodes))
  nodeOwners=0 ! everything on PET 0


  ! Set the number of each type of element, plus the total number.
  numQuadElems=3
  numTriElems=2
  numTotElems=numQuadElems+numTriElems


  ! Allocate and fill the element id array.
  allocate(elemIds(numTotElems))
  elemIds=(/1,2,3,4,5/) 


  ! Allocate and fill the element topology type array.
  allocate(elemTypes(numTotElems))
  elemTypes=(/ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 1
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 2
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 3
              ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 4
              ESMF_MESHELEMTYPE_QUAD/)  ! elem id 5


  ! Allocate and fill the element connection type array.
  ! Note that entries in this array refer to the 
  ! positions in the nodeIds, etc. arrays and that
  ! the order and number of entries for each element
  ! reflects that given in the Mesh options 
  ! section for the corresponding entry
  ! in the elemTypes array. The number of 
  ! entries in this elemConn array is the
  ! number of nodes in a quad. (4) times the 
  ! number of quad. elements plus the number
  ! of nodes in a triangle (3) times the number
  ! of triangle elements. 
  allocate(elemConn(4*numQuadElems+3*numTriElems))
  elemConn=(/1,2,5,4, &amp;  ! elem id 1
             2,3,5,   &amp;  ! elem id 2
             3,6,5,   &amp;  ! elem id 3
             4,5,8,7, &amp;  ! elem id 4
             5,6,9,8/)   ! elem id 5


  ! Create Mesh structure in 1 step
  mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
         nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
         nodeOwners=nodeOwners, elementIds=elemIds,&amp;
         elementTypes=elemTypes, elementConn=elemConn, &amp;
         rc=localrc)


  ! After the creation we are through with the arrays, so they may be
  ! deallocated.
  deallocate(nodeIds)
  deallocate(nodeCoords)
  deallocate(nodeOwners)
  deallocate(elemIds)
  deallocate(elemTypes)
  deallocate(elemConn)


  ! Set arrayspec for example field create
  ! Use a dimension of 1, because Mesh data is linearized 
  ! into a one dimensional array. 
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc=localrc)

  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for nodes owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh, arrayspec,  rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION040102300000000000000"></A><A NAME="sec:mesh:1pet3step"></A>
<BR>
25.2.3 Example: Creating a Small Single PET Mesh in Three Steps
</H3>

<P>
This example is intended to illustrate the creation of a small Mesh in three steps on one PET. The Mesh being created is exactly
   the same one as in the last example (Section&nbsp;<A HREF="node4.html#sec:mesh:1pet1step">25.2.2</A>), but the three step process allows the creation to occur in 
   a more memory efficient manner. 

<P>
<PRE>
  ! Create the mesh structure setting the dimensions
  mesh = ESMF_MeshCreate(parametricDim=2,spatialDim=2, rc=localrc)

  ! Set number of nodes
  numNodes=9

  ! Allocate and fill the node id array.
  allocate(nodeIds(numNodes))
  nodeIds=(/1,2,3,4,5,6,7,8,9/) 

  ! Allocate and fill node coordinate array.
  ! Since this is a 2D Mesh the size is 2x the
  ! number of nodes.
  allocate(nodeCoords(2*numNodes))
  nodeCoords=(/0.0,0.0, &amp; ! node id 1
               1.0,0.0, &amp; ! node id 2
               2.0,0.0, &amp; ! node id 3
               0.0,1.0, &amp; ! node id 4
               1.0,1.0, &amp; ! node id 5
               2.0,1.0, &amp; ! node id 6
               0.0,2.0, &amp; ! node id 7
               1.0,2.0, &amp; ! node id 8
               2.0,2.0 /) ! node id 9

  ! Allocate and fill the node owner array.
  ! Since this Mesh is all on PET 0, it's just set to all 0.
  allocate(nodeOwners(numNodes))
  nodeOwners=0 ! everything on PET 0

  ! Add the nodes to the Mesh
  call ESMF_MeshAddNodes(mesh, nodeIds=nodeIds, &amp;
         nodeCoords=nodeCoords, nodeOwners=nodeOwners, rc=localrc)

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! HERE IS THE POINT OF THE THREE STEP METHOD
  ! WE CAN DELETE THESE NODE ARRAYS BEFORE 
  ! ALLOCATING THE ELEMENT ARRAYS, THEREBY
  ! REDUCING THE AMOUNT OF MEMORY NEEDED 
  ! AT ONE TIME. 
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  deallocate(nodeIds)
  deallocate(nodeCoords)
  deallocate(nodeOwners)


  ! Set the number of each type of element, plus the total number.
  numQuadElems=3
  numTriElems=2
  numTotElems=numQuadElems+numTriElems

  ! Allocate and fill the element id array.
  allocate(elemIds(numTotElems))
  elemIds=(/1,2,3,4,5/) 

  ! Allocate and fill the element topology type array.
  allocate(elemTypes(numTotElems))
  elemTypes=(/ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 1
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 2
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 3
              ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 4
              ESMF_MESHELEMTYPE_QUAD/)  ! elem id 5


  ! Allocate and fill the element connection type array.
  ! Note that entries in this array refer to the 
  ! positions in the nodeIds, etc. arrays and that
  ! the order and number of entries for each element
  ! reflects that given in the Mesh options 
  ! section for the corresponding entry
  ! in the elemTypes array. The number of 
  ! entries in this elemConn array is the
  ! number of nodes in a quad. (4) times the 
  ! number of quad. elements plus the number
  ! of nodes in a triangle (3) times the number
  ! of triangle elements. 
  allocate(elemConn(4*numQuadElems+3*numTriElems))
  elemConn=(/1,2,5,4, &amp;  ! elem id 1
             2,3,5,   &amp;  ! elem id 2
             3,6,5,   &amp;  ! elem id 3
             4,5,8,7, &amp;  ! elem id 4
             5,6,9,8/)   ! elem id 5


  ! Finish the creation of the Mesh by adding the elements
  call ESMF_MeshAddElements(mesh, elementIds=elemIds,&amp;
         elementTypes=elemTypes, elementConn=elemConn, &amp;
         rc=localrc)

  ! After the creation we are through with the arrays, so they may be
  ! deallocated.
  deallocate(elemIds)
  deallocate(elemTypes)
  deallocate(elemConn)


  ! Set arrayspec for example field create
  ! Use a dimension of 1, because Mesh data is linearized 
  ! into a one dimensional array. 
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc=localrc)

  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for nodes owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh, arrayspec,  rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION040102400000000000000">
25.2.4 Example: Creating a Small Mesh on 4 PETs in One Step</A>
</H3>

<P>
<PRE>
  
    2.0   7 ------- 8        [8] ------ 9          
          |         |         |         |
          |    4    |         |    5    |
          |         |         |         |
    1.0  [4] ----- [5]       [5] ----- [6]
          
         0.0       1.0       1.0       2.0
  
             PET 2               PET 3
  
  
    1.0   4 ------- 5        [5] ------ 6
          |         |         |  \   3  |
          |    1    |         |    \    |
          |         |         | 2    \  |
    0.0   1 ------- 2        [2] ------ 3
  
         0.0       1.0       1.0      2.0 
   
             PET 0               PET 1
  
                 Node Id labels at corners
                Element Id labels in centers
</PRE>

<P>
This example is intended to illustrate the creation of a small Mesh on multiple PETs. This example creates the same small 2D Mesh as the 
   previous two examples (See Section&nbsp;<A HREF="node4.html#sec:mesh:1pet1step">25.2.2</A> for a diagram), however, in this case the Mesh is broken up across 4 PETs. 
   The figure above illustrates the distribution of the Mesh across the PETs. As in the previous diagram, the node ids are in
   the corners of the elements and the element ids are in the centers. In this figure '[' and ']' around a character indicate a node which
   is owned by another PET. The nodeOwner parameter indicates which PET owns the node.  Note that the three step creation 
   illustrated in Section&nbsp;<A HREF="node4.html#sec:mesh:1pet3step">25.2.3</A> could also be used in a parallel Mesh creation such as this by simply interleaving 
   the three calls in the appropriate places between the node and element array definitions. 

<P>
<PRE>
 ! Break up what's being set by PET
 if (localPET .eq. 0) then !!! This part only for PET 0
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/1,2,4,5/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/0.0,0.0, &amp; ! node id 1
                 1.0,0.0, &amp; ! node id 2
                 0.0,1.0, &amp; ! node id 4
                 1.0,1.0 /) ! node id 5

    ! Allocate and fill the node owner array.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 1
                 0, &amp; ! node id 2
                 0, &amp; ! node id 4
                 0/)  ! node id 5

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/1/) 

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 1

    ! Allocate and fill the element connection type array.
    ! Note that entry are local indices
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,4,3/) ! elem id 1

  else if (localPET .eq. 1) then !!! This part only for PET 1
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/2,3,5,6/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/1.0,0.0, &amp; ! node id 2
                 2.0,0.0, &amp; ! node id 3
                 1.0,1.0, &amp; ! node id 5
                 2.0,1.0 /) ! node id 6

    ! Allocate and fill the node owner array.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 2
                 1, &amp; ! node id 3
                 0, &amp; ! node id 5
                 1/)  ! node id 6

    ! Set the number of each type of element, plus the total number.
    numQuadElems=0
    numTriElems=2
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/2,3/) 

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_TRI, &amp; ! elem id 2
                ESMF_MESHELEMTYPE_TRI/)  ! elem id 3

    ! Allocate and fill the element connection type array.
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,3, &amp; ! elem id 2
               2,4,3/)  ! elem id 3

  else if (localPET .eq. 2) then !!! This part only for PET 2
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/4,5,7,8/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/0.0,1.0, &amp; ! node id 4
                 1.0,1.0, &amp; ! node id 5
                 0.0,2.0, &amp; ! node id 7
                 1.0,2.0 /) ! node id 8

    ! Allocate and fill the node owner array.
    ! Since this Mesh is all on PET 0, it's just set to all 0.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 4
                 0, &amp; ! node id 5
                 2, &amp; ! node id 7
                 2/)  ! node id 8

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/4/) 

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 4

    ! Allocate and fill the element connection type array.
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,4,3/) ! elem id 4

  else if (localPET .eq. 3) then !!! This part only for PET 3
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/5,6,8,9/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/1.0,1.0, &amp;  ! node id 5
                 2.0,1.0, &amp;  ! node id 6
                 1.0,2.0, &amp;  ! node id 8
                 2.0,2.0 /)  ! node id 9

    ! Allocate and fill the node owner array.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 5
                 1, &amp; ! node id 6
                 2, &amp; ! node id 8
                 3/)  ! node id 9

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/5/)  

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 5

    ! Allocate and fill the element connection type array.
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,4,3/) ! elem id 5
  endif

  
  ! Create Mesh structure in 1 step
  mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
         nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
         nodeOwners=nodeOwners, elementIds=elemIds,&amp;
         elementTypes=elemTypes, elementConn=elemConn, &amp;
         rc=localrc)


  ! After the creation we are through with the arrays, so they may be
  ! deallocated.
  deallocate(nodeIds)
  deallocate(nodeCoords)
  deallocate(nodeOwners)
  deallocate(elemIds)
  deallocate(elemTypes)
  deallocate(elemConn)


  ! Set arrayspec for example field create
  ! Use a dimension of 1, because Mesh data is linearized 
  ! into a one dimensional array. 
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc=localrc)

  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for nodes owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh, arrayspec,  rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION040102500000000000000">
25.2.5 Removing Mesh Memory</A>
</H3>

<P>
There are two different levels that the memory in a Mesh can be removed. The first of these is the standard destroy call, 
   <TT>ESMF_MeshDestroy()</TT>. As with other classes, this call removes all memory associated with the object, and afterwards  
   the object can not be used further (i.e. should not be used in any methods). The second, which is unique to Mesh, is the 
   <TT>ESMF_MeshFreeMemory()</TT> call. This call removes the connection and coordinate information associated with the Mesh, but
   leaves the distgrid information. The coordinate and connection information held in the Mesh can consume a large amount of memory
   for a big Mesh, so using this call can very significantly reduce the amount of memory used. However, once this method
   has been used on a Mesh there are some restriction on what may be done with it. Once a Mesh has had its memory freed using this method, 
   any Field built on the Mesh can no longer be used as part of an <TT>ESMF_FieldRegridStore()</TT> call. However, because the distgrid 
   information is still part of the Mesh, Fields built on such a Mesh can still be part of an <TT>ESMF_FieldRegrid()</TT>
   call (where the routehandle was generated previous to the <TT>ESMF_MeshFreeMemory()</TT> operation). Fields may also 
   still be created on these Meshes. The following short piece of code illustrates the use of this call.

<P>
<PRE>
   ! Here a Field built on a mesh may be used
   ! as part of a ESMF_FieldRegridStore() call

   ! This call removes connection and coordinate 
   ! information, significantly reducing the memory used by
   ! mesh, but limiting what can be done with it.
   call ESMF_MeshFreeMemory(mesh, rc=localrc)

   ! Here a new Field may be built on mesh, or
   ! a field built on a mesh may be used as part
   ! of an ESMF_FieldRegrid() call

   ! Destroy the mesh
   call ESMF_MeshDestroy(mesh, rc=localrc)

   ! Here mesh can't be used for anything
</PRE>

<P>

<P>

<H2><A NAME="SECTION040103000000000000000">
25.3 Mesh Options</A>
</H2>

<P>

<H3><A NAME="SECTION040103100000000000000"></A>
<A NAME="sec:mesh:opt:elemtype"></A>
<BR>
25.3.1 ESMF_MeshElemType
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
 An ESMF Mesh can be constructed from a combination of different elements. The type of elements that can
be used in a Mesh depends on the Mesh's parameteric dimension, which is set during Mesh creation. The
following are the valid Mesh element types for each valid Mesh parametric dimension (2D or 3D) .

<P>

<P>
<BR>

<P>
<PRE>
                     3                          4 ---------- 3
                    / \                         |            |  
                   /   \                        |            |
                  /     \                       |            |
                 /       \                      |            |
                /         \                     |            |
               1 --------- 2                    1 ---------- 2

           ESMF_MESHELEMTYPE_TRI            ESMF_MESHELEMTYPE_QUAD

     2D element types (numbers are the order for elementConn during Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 2 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Element Type</TD>
<TD ALIGN="CENTER">Number of Nodes</TD>
<TD ALIGN="LEFT">Description</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_TRI</TD>
<TD ALIGN="CENTER">3</TD>
<TD ALIGN="LEFT">A triangle</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_QUAD</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="LEFT">A quadrilateral (e.g. a rectangle)</TD>
</TR>
</TABLE>

<P>

<P>
<BR>

<P>
<BR>

<P>
<PRE>
                                            
                 3                               8---------------7
                /|\                             /|              /|
               / | \                           / |             / |
              /  |  \                         /  |            /  |
             /   |   \                       /   |           /   |
            /    |    \                     5---------------6    |
           4-----|-----2                    |    |          |    |
            \    |    /                     |    4----------|----3
             \   |   /                      |   /           |   /
              \  |  /                       |  /            |  /
               \ | /                        | /             | /
                \|/                         |/              |/
                 1                          1---------------2

       ESMF_MESHELEMTYPE_TETRA             ESMF_MESHELEMTYPE_HEX  

  3D element types (numbers are the order for elementConn during Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 3 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Element Type</TD>
<TD ALIGN="CENTER">Number of Nodes</TD>
<TD ALIGN="LEFT">Description</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_TETRA</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="LEFT">A tetrahedron (CAN'T BE USED IN REGRID)</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_HEX</TD>
<TD ALIGN="CENTER">8</TD>
<TD ALIGN="LEFT">A hexahedron (e.g. a cube)</TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION040104000000000000000">
25.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION040104100000000000000"></A><A NAME="sec:mesh:api:meshaddelements"></A>
<BR>
25.4.1 ESMF_MeshAddElements - Add elements to a Mesh 
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_MeshAddElements(mesh, elementIds, elementTypes, elementConn, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(inout)                :: mesh
     integer, dimension(:), intent(in)             :: elementIds
     integer, dimension(:), intent(in)             :: elementTypes
     integer, dimension(:), intent(in)             :: elementConn
     integer, intent(out), optional                :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call is the third and last part of the three part mesh create
     sequence and should be called after the mesh is created with <TT>ESMF_MeshCreate()</TT> 
     (<A HREF="node4.html#sec:mesh:api:meshcreate">25.4.3</A>)
     and after the nodes are added with <TT>ESMF_MeshAddNodes()</TT> (<A HREF="node4.html#sec:mesh:api:meshaddnodes">25.4.2</A>).
     This call adds the elements to the 
     mesh and finalizes the create. After this call the Mesh is usable, for
     example a Field may be built on the created Mesh object and 
     this Field may be used in a <TT>ESMF_FieldRegridStore()</TT> call.

<P>
The parameters to this call <TT>elementIds</TT>, <TT>elementTypes</TT>, and
     <TT>elementConn</TT> describe the elements to be created. The description 
     for a particular element lies at the same index location in <TT>elementIds</TT> 
     and <TT>elementTypes</TT>. Each entry in <TT>elementConn</TT> consists of the list of
     nodes used to create that element, so the connections for element <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img71.png"
 ALT="$e$"> in the 
     <TT>elementIds</TT> array will start at <!-- MATH
 $number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
     \cdots + number\_of\_nodes\_in\_element(e-1) + 1$
 -->
<IMG
 WIDTH="842" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img72.png"
 ALT="$number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
\cdots + number\_of\_nodes\_in\_element(e-1) + 1$"> in <TT>elementConn</TT>.

<P>
<DL>
<DT><STRONG>elementIds</STRONG></DT>
<DD>An array containing the global ids of the elements to be created on this PET. 
            This input consists of a 1D array the size of the number of elements on this PET.
     
</DD>
<DT><STRONG>elementTypes</STRONG></DT>
<DD>An array containing the types of the elements to be created on this PET. The types used
            must be appropriate for the parametric dimension of the Mesh. Please see
            Section&nbsp;<A HREF="node4.html#sec:mesh:opt:elemtype">25.3.1</A> for the list of options. This input consists of 
            a 1D array the size of the number of elements on this PET.  
     
</DD>
<DT><STRONG>elementConn</STRONG></DT>
<DD>An array containing the indexes of the sets of nodes to be connected together to form the
           elements to be created on this PET. The entries in this list are NOT node global ids, 
           but rather each entry is a local index (1 based) into the list of nodes which were
           created on this PET by the previous <TT>ESMF_MeshAddNodes()</TT> call.
           In other words, an entry of 1 indicates that this element contains the node
           described by <TT>nodeIds(1)</TT>, <TT>nodeCoords(1)</TT>, etc. passed into the
           <TT>ESMF_MeshAddNodes()</TT> call on this PET. It is also
           important to note that the order of the nodes in an element connectivity list
           matters. Please see Section&nbsp;<A HREF="node4.html#sec:mesh:opt:elemtype">25.3.1</A> for diagrams illustrating
           the correct order of nodes in a element. This input consists of a 1D array with 
           a total size equal to the sum of the number of nodes in each element on
           this PET. The number of nodes in each element is implied by its element type in 
           <TT>elementTypes</TT>. The nodes for each element 
           are in sequence in this array (e.g. the nodes for element 1 are elementConn(1),
           elementConn(2), etc.). 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040104200000000000000"></A><A NAME="sec:mesh:api:meshaddnodes"></A>
<BR>
25.4.2 ESMF_MeshAddNodes - Add nodes to a Mesh 
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_MeshAddNodes(mesh, nodeIds, nodeCoords, nodeOwners, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(inout)                :: mesh
     integer, dimension(:), intent(in)             :: nodeIds
     real(ESMF_KIND_R8), dimension(:), intent(in)  :: nodeCoords
     integer, dimension(:), intent(in)             :: nodeOwners
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call is the second part of the three part mesh create
     sequence and should be called after the mesh's dimensions are set
     using <TT>ESMF_MeshCreate()</TT> (<A HREF="node4.html#sec:mesh:api:meshcreate">25.4.3</A>).
     This call adds the nodes to the 
     mesh. The next step is to call <TT>ESMF_MeshAddElements()</TT> (<A HREF="node4.html#sec:mesh:api:meshaddelements">25.4.1</A>).

<P>
The parameters to this call <TT>nodeIds</TT>, <TT>nodeCoords</TT>, and 
     <TT>nodeOwners</TT> describe the nodes to be created on this PET. 
     The description for a particular node lies at the same index location in 
     <TT>nodeIds</TT> and <TT>nodeOwners</TT>. Each entry
     in <TT>nodeCoords</TT> consists of spatial dimension coordinates, so the coordinates
     for node <IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="$n$"> in the <TT>nodeIds</TT> array will start at <!-- MATH
 $(n-1)*spatialDim+1$
 -->
<IMG
 WIDTH="179" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img74.png"
 ALT="$(n-1)*spatialDim+1$">. 

<P>
<DL>
<DT><STRONG>nodeIds</STRONG></DT>
<DD>An array containing the global ids of the nodes to be created on this PET. 
           This input consists of a 1D array the size of the number of nodes on this PET.
     
</DD>
<DT><STRONG>nodeCoords</STRONG></DT>
<DD>An array containing the physical coordinates of the nodes to be created on this
            PET. This input consists of a 1D array the size of the number of nodes on this PET times the Mesh's 
            spatial dimension (<TT>spatialDim</TT>). The coordinates in this array are ordered
            so that the coordinates for a node lie in sequence in memory. (e.g. for a 
            Mesh with spatial dimension 2, the coordinates for node 1 are in nodeCoords(0) and
            nodeCoords(1), the coordinates for node 2 are in nodeCoords(2) and nodeCoords(3), 
            etc.). 
     
</DD>
<DT><STRONG>nodeOwners</STRONG></DT>
<DD>An array containing the PETs that own the nodes to be created on this PET. 
           If the node is shared with another PET, the value
           may be a PET other than the current one. Only nodes owned by this PET
           will have PET local entries in a Field created on the Mesh. This input consists of 
           a 1D array the size of the number of nodes on this PET.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040104300000000000000"></A><A NAME="sec:mesh:api:meshcreate"></A>
<BR>
25.4.3 ESMF_MeshCreate - Create a Mesh as a 3 step process 
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function ESMF_MeshCreate3Part(parametricDim, spatialDim, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)         :: ESMF_MeshCreate3Part
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                intent(in)            :: parametricDim
     integer,                intent(in)            :: spatialDim
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call is the first part of the three part mesh create
     sequence. This call sets the dimension of the elements in the mesh
     (<TT>parametricDim</TT>) and the number of coordinate dimensions in the mesh
     (<TT>spatialDim</TT>). The next step is to call <TT>ESMF_MeshAddNodes()</TT> (<A HREF="node4.html#sec:mesh:api:meshaddnodes">25.4.2</A>) 
     to add the nodes and then <TT>ESMF_MeshAddElements()</TT> (<A HREF="node4.html#sec:mesh:api:meshaddelements">25.4.1</A>) to add 
     the elements and finalize the mesh.

<P>
<DL>
<DT><STRONG>parametricDim</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would
           have a parametric dimension of 2, whereas a Mesh constructed of cubes would have one
           of 3.)
     
</DD>
<DT><STRONG>spatialDim</STRONG></DT>
<DD>The number of coordinate dimensions needed to describe the locations of the nodes 
           making up the Mesh. For a manifold, the spatial dimesion can be larger than the 
           parametric dim (e.g. the 2D surface of a sphere in 3D space), but it can't be smaller. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040104400000000000000">
25.4.4 ESMF_MeshCreate - Create a Mesh all at once</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function ESMF_MeshCreate1Part(parametricDim, spatialDim, &amp;
                          nodeIds, nodeCoords, nodeOwners, &amp;
                          elementIds, elementTypes, elementConn, &amp;
                          rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)         :: ESMF_MeshCreate1Part
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                intent(in)            :: parametricDim
     integer,                intent(in)            :: spatialDim
     integer, dimension(:), intent(in)             :: nodeIds
     real(ESMF_KIND_R8), dimension(:), intent(in)  :: nodeCoords
     integer, dimension(:), intent(in)             :: nodeOwners
     integer, dimension(:), intent(in)             :: elementIds
     integer, dimension(:), intent(in)             :: elementTypes
     integer, dimension(:), intent(in)             :: elementConn
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create a Mesh object in one step. After this call the Mesh is usable, for
     example, a Field may be built on the created Mesh object and 
     this Field may be used in a <TT>ESMF_FieldRegridStore()</TT> call.

<P>
This call sets the dimension of the elements in the mesh
     (<TT>parametricDim</TT>) and the number of coordinate dimensions in the mesh
     (<TT>spatialDim</TT>). It then creates the nodes, and 
     then creates the elements by connecting together the nodes.

<P>
The parameters to this call <TT>nodeIds</TT>, <TT>nodeCoords</TT>, and 
     <TT>nodeOwners</TT> describe the nodes to be created on this PET. 
     The description for a particular node lies at the same index location in 
     <TT>nodeIds</TT> and <TT>nodeOwners</TT>. Each entry
     in <TT>nodeCoords</TT> consists of spatial dimension coordinates, so the coordinates
     for node <IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="$n$"> in the <TT>nodeIds</TT> array will start at <!-- MATH
 $(n-1)*spatialDim+1$
 -->
<IMG
 WIDTH="179" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img74.png"
 ALT="$(n-1)*spatialDim+1$">. 

<P>
The parameters to this call <TT>elementIds</TT>, <TT>elementTypes</TT>, and
     <TT>elementConn</TT> describe the elements to be created. The description 
     for a particular element lies at the same index location in <TT>elementIds</TT> 
     and <TT>elementTypes</TT>. Each entry in <TT>elementConn</TT> consists of the list of
     nodes used to create that element, so the connections for element <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img71.png"
 ALT="$e$"> in the 
     <TT>elementIds</TT> array will start at <!-- MATH
 $number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
     \cdots + number\_of\_nodes\_in\_element(e-1) + 1$
 -->
<IMG
 WIDTH="842" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img72.png"
 ALT="$number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
\cdots + number\_of\_nodes\_in\_element(e-1) + 1$"> in <TT>elementConn</TT>.

<P>
<DL>
<DT><STRONG>parametricDim</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would
           have a parametric dimension of 2, whereas a Mesh constructed of cubes would have one
           of 3.)
     
</DD>
<DT><STRONG>spatialDim</STRONG></DT>
<DD>The number of coordinate dimensions needed to describe the locations of the nodes 
           making up the Mesh. For a manifold, the spatial dimesion can be larger than the 
           parametric dim (e.g. the 2D surface of a sphere in 3D space), but it can't be smaller. 
     
</DD>
<DT><STRONG>nodeIds</STRONG></DT>
<DD>An array containing the global ids of the nodes to be created on this PET. 
           This input consists of a 1D array the size of the number of nodes on this PET.
     
</DD>
<DT><STRONG>nodeCoords</STRONG></DT>
<DD>An array containing the physical coordinates of the nodes to be created on this
            PET. This input consists of a 1D array the size of the number of nodes on this PET times the Mesh's 
            spatial dimension (<TT>spatialDim</TT>). The coordinates in this array are ordered
            so that the coordinates for a node lie in sequence in memory. (e.g. for a 
            Mesh with spatial dimension 2, the coordinates for node 1 are in nodeCoords(0) and
            nodeCoords(1), the coordinates for node 2 are in nodeCoords(2) and nodeCoords(3), 
            etc.). 
     
</DD>
<DT><STRONG>nodeOwners</STRONG></DT>
<DD>An array containing the PETs that own the nodes to be created on this PET. 
           If the node is shared with another PET, the value
           may be a PET other than the current one. Only nodes owned by this PET
           will have PET local entries in a Field created on the Mesh. This input consists of 
           a 1D array the size of the number of nodes on this PET.
     
</DD>
<DT><STRONG>elementIds</STRONG></DT>
<DD>An array containing the global ids of the elements to be created on this PET. 
            This input consists of a 1D array the size of the number of elements on this PET.
     
</DD>
<DT><STRONG>elementTypes</STRONG></DT>
<DD>An array containing the types of the elements to be created on this PET. The types used
            must be appropriate for the parametric dimension of the Mesh. Please see
            Section&nbsp;<A HREF="node4.html#sec:mesh:opt:elemtype">25.3.1</A> for the list of options. This input consists of 
            a 1D array the size of the number of elements on this PET.  
     
</DD>
<DT><STRONG>elementConn</STRONG></DT>
<DD>An array containing the indexes of the sets of nodes to be connected together to form the
           elements to be created on this PET. The entries in this list are NOT node global ids, 
           but rather each entry is a local index (1 based) into the list of nodes to be 
           created on this PET by this call.
           In other words, an entry of 1 indicates that this element contains the node
           described by <TT>nodeIds(1)</TT>, <TT>nodeCoords(1)</TT>, etc. on this PET. It is also
           important to note that the order of the nodes in an element connectivity list
           matters. Please see Section&nbsp;<A HREF="node4.html#sec:mesh:opt:elemtype">25.3.1</A> for diagrams illustrating
           the correct order of nodes in a element. This input consists of a 1D array with 
           a total size equal to the sum of the number of nodes contained in each element on
           this PET. The number of nodes in each element is implied by its element type in 
           <TT>elementTypes</TT>. The nodes for each element 
           are in sequence in this array (e.g. the nodes for element 1 are elementConn(1),
           elementConn(2), etc.). 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040104500000000000000">
25.4.5 ESMF_MeshDestroy - Destroy a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_MeshDestroy(mesh, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(inout)           :: mesh
     integer,        intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy the Mesh. This call removes all internal memory associated with <TT>mesh</TT>. 
    After this call <TT>mesh</TT> will no longer be usable.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object to be destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040104600000000000000">
25.4.6 ESMF_MeshFreeMemory - Remove a Mesh and its memory</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_MeshFreeMemory(mesh, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(inout)        :: mesh
     integer,        intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call removes the portions of <TT>mesh</TT> which contain connection and coordinate
      information. After this call, Fields build on <TT>mesh</TT> will no longer be usable
      as part of an <TT>ESMF_FieldRegridStore()</TT> operation. However, after this call 
      Fields built on <TT>mesh</TT> can still be used in an <TT>ESMF_FieldRegrid()</TT> 
      operation if the routehandle was generated beforehand. New Fields may also
      be built on <TT>mesh</TT> after this call.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object whose memory is to be freed. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040104700000000000000">
25.4.7 ESMF_MeshGet - Get information from a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_MeshGet(mesh, parametricDim, spatialDim, &amp;
                    nodalDistgrid, elementDistgrid, &amp;
                    numOwnedNodes, ownedNodeCoords, numOwnedElements, isMemFreed, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(inout)                           :: mesh
     integer,             intent(out), optional               :: parametricDim
     integer,             intent(out), optional               :: spatialDim
     type(ESMF_DistGrid), intent(out), optional               :: nodalDistgrid
     type(ESMF_DistGrid), intent(out), optional               :: elementDistgrid
     integer,             intent(out), optional               :: numOwnedNodes
     real(ESMF_KIND_R8), dimension(:), intent(out), optional  :: ownedNodeCoords
     integer,             intent(out), optional               :: numOwnedElements
     logical,             intent(out), optional               :: isMemFreed
     integer,             intent(out), optional               :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get various information from a mesh.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object to retrieve information from.
   
</DD>
<DT><STRONG>[parametricDim]</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would
   have a parametric dimension of 2, whereas a Mesh constructed of cubes would have one
   of 3.)
   
</DD>
<DT><STRONG>[spatialDim]</STRONG></DT>
<DD>The number of coordinate dimensions needed to describe the locations of the nodes 
   making up the Mesh. For a manifold, the spatial dimesion can be larger than the 
   parametric dim (e.g. the 2D surface of a sphere in 3D space), but it can't be smaller. 
   
</DD>
<DT><STRONG>[nodalDistgrid]</STRONG></DT>
<DD>A 1D arbitrary distgrid describing the distribution of the nodes across the PETs. Note that
   on each PET the distgrid will only contain entries for nodes owned by that PET.
   This is the DistGrid that would be used to construct the Array in a Field that is constructed
   on <TT>mesh</TT>.
   
</DD>
<DT><STRONG>[elementDistgrid]</STRONG></DT>
<DD>A 1D arbitrary distgrid describing the distribution of elements across the PETs. Note that
   on each PET the distgrid will only contain entries for elements owned by that PET.
   
</DD>
<DT><STRONG>[numOwnedNodes]</STRONG></DT>
<DD>The number of local nodes which are owned by this PET. This is the number of PET local entries in
   the nodalDistgrid.
   
</DD>
<DT><STRONG>[ownedNodeCoords]</STRONG></DT>
<DD>The coordinates for the local nodes. These coordinates will be in the proper order to correspond
   with the nodes in the <TT>nodalDistgrid</TT> returned by this call, and hence with a Field built on 
   <TT>mesh</TT>. The size of the input array should be the spatial dim of <TT>mesh</TT> times 
   <TT>numOwnedNodes</TT>.
   
</DD>
<DT><STRONG>[numOwnedElements]</STRONG></DT>
<DD>The number of local elements which are owned by this PET. Note that every element is owned by 
   the PET it resides on, so unlike for nodes, <TT>numOwnedElements</TT> is identical to the number of elements on
   the PET. It is also the number of PET local entries in the elementDistgrid. 
   
</DD>
<DT><STRONG>[isMemFreed]</STRONG></DT>
<DD>Indicates if the coordinate and connection memory been freed from <TT>mesh</TT>. If so, it
   can no longer be used as part of an <TT>ESMF_FieldRegridStore()</TT> call.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION040110000000000000000">
26 DistGrid Class</A>
</H1>

<P>

<H2><A NAME="SECTION040111000000000000000">
26.1 Description</A>
</H2>

<P>
<A NAME="sec:DistGrid"></A>The <TT>ESMF_DistGrid</TT> class sits on top of the DELayout class and holds domain information in index space. A DistGrid object captures the index space topology and describes its decomposition in terms of DEs. Combined with DELayout and VM the DistGrid defines the data distribution of a domain decomposition across the computational resources of an ESMF component.

<P>
The global domain is defined as the union or ``patchwork'' of logically rectangular (LR) sub-domains or <EM>patches</EM>. The DistGrid create methods allow the specification of such a patchwork global domain and its decomposition into exclusive, DE-local LR regions according to various degrees of user specified constraints. Complex index space topologies can be constructed by specifying connection relationships between patches during creation.

<P>
The DistGrid class holds domain information for all DEs. Each DE is associated with a local LR region. No overlap of the regions is allowed. The DistGrid offers query methods that allow DE-local topology information to be extracted, e.g. for the construction of halos by higher classes.

<P>
A DistGrid object only contains decomposable dimensions. The minimum rank for a DistGrid object is 1. A maximum rank does not exist for DistGrid objects, however, ranks greater than 7 may lead to difficulties with respect to the Fortran API of higher classes based on DistGrid. The rank of a DELayout object contained within a DistGrid object must be equal to the DistGrid rank. Higher class objects that use the DistGrid, such as an Array object, may be of different rank than the associated DistGrid object. The higher class object will hold the mapping information between its dimensions and the DistGrid dimensions.

<P>

<H2><A NAME="SECTION040112000000000000000">
26.2 Use and Examples</A>
</H2>

<P>
The following examples demonstrate how to create, use and destroy DistGrid objects. In order to produce complete and valid DistGrid objects all of the <TT>ESMF_DistGridCreate()</TT> calls require to be called in unison i.e. on <EM>all</EM> PETs of a component with a complete set of valid arguments.

<P>

<P>

<P>

<H3><A NAME="SECTION040112100000000000000">
26.2.1 Single patch DistGrid with regular decomposition</A>
</H3>

<P>
The minimum information required to create an <TT>ESMF_DistGrid</TT> object
   for a single patch with default decomposition are the corners of the patch
   in index space. The following call will create a 1D DistGrid for a 
   1D index space patch with elements from 1 through 1000. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/1000/), rc=rc)
</PRE>

<P>
A default DELayout with 1 DE per PET will be created during 
   <TT>ESMF_DistGridCreate()</TT>. The 1000 elements of the specified 1D patch will
   then be block decomposed across the available DEs, i.e. across all PETs. 
   Hence, for 4 PETs the (min) <IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img67.png"
 ALT="$\sim$"> (max) corners of the DE-local LR regions
   will be:
   <PRE>
     DE 0 - (1) ~ (250)
     DE 1 - (251) ~ (500)
     DE 2 - (501) ~ (750)
     DE 3 - (751) ~ (1000)
</PRE>

<P>
DistGrids with rank &gt; 1 can also be created with default decompositions,
   specifying only the corners of the patch. The following will create a
   2D DistGrid for a 5x5 patch with default decomposition. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), rc=rc)
</PRE>

<P>
The default decomposition for a DistGrid of rank <IMG
 WIDTH="21" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img75.png"
 ALT="$N$"> will be <!-- MATH
 $(nDEs \times 1
   \times ... \times 1)$
 -->
<IMG
 WIDTH="149" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img76.png"
 ALT="$ (nDEs \times 1
\times ... \times 1) $">, where <IMG
 WIDTH="49" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img77.png"
 ALT="$nDEs$"> is the number of DEs in the DELayout
   and there are <IMG
 WIDTH="48" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img78.png"
 ALT="$N-1$"> factors of <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="$1$">. For the 2D example above this means
   a <IMG
 WIDTH="41" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img79.png"
 ALT="$4 \times 1$"> regular decomposition if executed on 4 PETs and will result
   in the following DE-local LR regions:
   <PRE>
     DE 0 - (1,1) ~ (2,5)
     DE 1 - (3,1) ~ (3,5)
     DE 2 - (4,1) ~ (4,5)
     DE 3 - (5,1) ~ (5,5)
</PRE>

<P>
In many cases the default decomposition will not suffice for higher rank
   DistGrids (rank &gt; 1). For this reason a decomposition descriptor 
   <TT>regDecomp</TT> argument is available during <TT>ESMF_DistGridCreate()</TT>. The
   following call creates a DistGrid on the same 2D patch as before, but now with
   a user specified regular decomposition of <!-- MATH
 $2 \times 3 = 6$
 -->
<IMG
 WIDTH="71" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img80.png"
 ALT="$2 \times 3 = 6 $"> DEs. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
The default DE labeling sequence follows column major order for the
   <TT>regDecomp</TT> argument:
   <PRE>
     -----------&gt; 2nd dimension
     |  0  2  4
     |  1  3  5
     v
    1st dimension
</PRE>

<P>
By default grid points along all dimensions are homogeneously divided between
   the DEs. The maximum element count difference between DEs along any dimension
   is 1. The (min) <IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img67.png"
 ALT="$\sim$"> (max) corners of the DE-local LR domains of the above
   example are as follows:
   <PRE>
     DE 0 - (1,1) ~ (3,2)
     DE 1 - (4,1) ~ (5,2)
     DE 2 - (1,3) ~ (3,4)
     DE 3 - (4,3) ~ (5,4)
     DE 4 - (1,5) ~ (3,5)
     DE 5 - (4,5) ~ (5,5)
</PRE>

<P>
The specifics of the patch decomposition into DE-local LR domains can be
   modified by the optional <TT>decompflag</TT> argument. The following line shows
   how this argument is used to keep ESMF's default decomposition in the first
   dimension but move extra grid points of the second dimension to the last DEs
   in that direction. Extra elements occur if the number of DEs for a certain
   dimension does not evenly divide its extent. In this example there are
   2 extra grid points for the second dimension because its extent is 5 but there
   are 3 DEs along this index space axis. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), decompflag=(/ESMF_DECOMP_DEFAULT,ESMF_DECOMP_RESTLAST/),&amp;
    rc=rc)
</PRE>

<P>
Now DE 4 and DE 5 will hold the extra elements along the 2nd dimension.
   <PRE>
     DE 0 - (1,1) ~ (3,1)
     DE 1 - (4,1) ~ (5,1)
     DE 2 - (1,2) ~ (3,2)
     DE 3 - (4,2) ~ (5,2)
     DE 4 - (1,3) ~ (3,5)
     DE 5 - (4,3) ~ (5,5)
</PRE>

<P>
An alternative way of indicating the DE-local LR regions is to list the 
   index space coordinate as given by the associated DistGrid patch for each
   dimension. For this 2D example there are two lists (dim 1) / (dim 2) for each
   DE:
   <PRE>
     DE 0 - (1,2,3) / (1)
     DE 1 - (4,5)   / (1)
     DE 2 - (1,2,3) / (2)
     DE 3 - (4,5)   / (2)
     DE 4 - (1,2,3) / (3,4,5)
     DE 5 - (4,5)   / (3,4,5)
</PRE>

<P>
Information about DE-local LR regions in the latter format can be obtained 
   from the DistGrid object by use of <TT>ESMF_DistGridGet()</TT> methods:

<P>
<PRE>
  allocate(dimExtent(2, 0:5)) ! (dimCount, deCount)
  call ESMF_DistGridGet(distgrid, delayout=delayout, &amp;
    indexCountPDimPDe=dimExtent, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT)
  call ESMF_DELayoutGet(delayout, localDeCount=localDeCount, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT)
  allocate(localDeList(0:localDeCount-1))
  call ESMF_DELayoutGet(delayout, localDeList=localDeList, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT)
  do localDe=0, localDeCount-1
    de = localDeList(localDe)
    do dim=1, 2
      allocate(localIndexList(dimExtent(dim, de))) ! allocate list to hold indices
      call ESMF_DistGridGet(distgrid, localDe=localDe, dim=dim, &amp;
        indexList=localIndexList, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT)
      print *, "local DE ", localDe," - DE ",de," localIndexList along dim=", &amp;
        dim," :: ", localIndexList
      deallocate(localIndexList)
    enddo
  enddo
  deallocate(localDeList)
  deallocate(dimExtent)
</PRE>

<P>
The advantage of the <TT>localIndexList</TT> format over the min-/max-corner 
   format is that it can be used directly for DE-local to patch index 
   dereferencing. Furthermore the <TT>localIndexList</TT> allows to express very
   general decompositions such as the cyclic decompositions in the first
   dimension generated by the following call: 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), decompflag=(/ESMF_DECOMP_CYCLIC,ESMF_DECOMP_RESTLAST/),&amp;
    rc=rc)
</PRE>

<P>
with decomposition:
   <PRE>
     DE 0 - (1,3,5) / (1)
     DE 1 - (2,4)   / (1)
     DE 2 - (1,3,5) / (2)
     DE 3 - (2,4)   / (2)
     DE 4 - (1,3,5) / (3,4,5)
     DE 5 - (2,4)   / (3,4,5)
</PRE>

<P>
Finally, a DistGrid object is destroyed by calling 

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040112200000000000000">
26.2.2 DistGrid and DELayout</A>
</H3>

<P>
The examples of this section use the 2D DistGrid of the previous section 
   to show the interplay between DistGrid and DELayout. By default, i.e.
   without specifying the <TT>delayout</TT> argument, a DELayout will be created
   during DistGrid creation that provides as many DEs as the DistGrid
   object requires. The implicit call to <TT>ESMF_DELayoutCreate()</TT> is issued
   with a fixed number of DEs and default settings in all other aspects. The
   resulting DE to PET mapping depends on the number of PETs of the current VM
   context. Assuming 6 PETs in the VM 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
will result in the following domain decomposition in terms of DEs
   <PRE>
     0  2  4
     1  3  5
</PRE>
   and their layout or distribution over the available PETs:
   <PRE>
     DE 0  -&gt; PET 0
     DE 1  -&gt; PET 1
     DE 2  -&gt; PET 2
     DE 3  -&gt; PET 3
     DE 4  -&gt; PET 4
     DE 5  -&gt; PET 5
</PRE>

<P>
Running the same example on a 4 PET VM will not change the domain 
   decomposition into 6 DEs as specified by
   <PRE>
     0  2  4
     1  3  5
</PRE>
   but the layout across PETs will now contain multiple DE-to-PET mapping with 
   default cyclic distribution:
   <PRE>
     DE 0  -&gt; PET 0
     DE 1  -&gt; PET 1
     DE 2  -&gt; PET 2
     DE 3  -&gt; PET 3
     DE 4  -&gt; PET 0
     DE 5  -&gt; PET 1
</PRE>

<P>
Sometimes it may be desirable for performance tuning to construct a DELayout
   with specific characteristics. For instance, if the 6 PETs of the above 
   example are running on 3 nodes of a dual-SMP node cluster and there is a 
   higher communication load along the first dimension of the model than along 
   the second dimension it would be sensible to place DEs according to this 
   knowledge. 

<P>
The following example first creates a DELayout 
   with 6 DEs where groups of 2 DEs are to be in fast connection. This DELayout 
   is then used to create a DistGrid. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=6, deGrouping=(/(i/2,i=0,5)/), rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), delayout=delayout, rc=rc)
</PRE>

<P>
This will ensure a distribution of DEs across the cluster resource 
   in the following way:
   <PRE>
     0   2   4
     1   3   5
    SMP SMP SMP
</PRE>

<P>
The interplay between DistGrid and DELayout may at first seem complicated.
   The simple but important rule to understand is that DistGrid describes a 
   domain decomposition and each domain is labeled with a DE number. The DELayout
   describes how these DEs are laid out over the compute resources of the VM, 
   i.e. PETs. The DEs are purely logical elements of decomposition and may be 
   relabeled to fit the algorithm or legacy code better. The following 
   example demonstrates this by describing the exact same distribution of the 
   domain data across the fictitious cluster of SMP-nodes with a different 
   choice of DE labeling: 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=6, deGrouping=(/(mod(i,3),i=0,5)/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), deLabelList=(/0,3,1,4,2,5/), delayout=delayout, rc=rc)
</PRE>

<P>
Here the <TT>deLabelList</TT> argument changes the default DE label sequence from
   column major to row major. The DELayout compensates for this change in DE
   labeling by changing the <TT>deGrouping</TT> argument to map the first dimension
   to SMP nodes as before. The decomposition and layout now looks as follows:
   <PRE>
     0   1   2
     3   4   5
    SMP SMP SMP
</PRE>

<P>
Finally, in order to achieve a completely user-defined distribution of the
   domain data across the PETs of the VM a DELayout may be created from a
   <TT>petMap</TT> before using it in the creation of a DistGrid. If for
   instance the desired distribution of a 2 x 3 decomposition puts the DEs of 
   the first row onto 3 separate PETs (PET 0, 1, 2) and groups the DEs of 
   the second row onto PET 3 a <TT>petMap</TT> must first be setup that
   takes the DE labeling of the DistGrid into account.The following lines of 
   code result in the desired distribution using column major DE labeling by 
   first create a DELayout and then using it in the DistGrid creation. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petMap=(/0,3,1,3,2,3/), rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), delayout=delayout, rc=rc)
</PRE>

<P>
This decomposes the global domain into
   <PRE>
     0   2   4
     1   3   5
</PRE>
   and associates the DEs to the following PETs:
   <PRE>
     DE 0  -&gt; PET 0
     DE 1  -&gt; PET 3
     DE 2  -&gt; PET 1
     DE 3  -&gt; PET 3
     DE 4  -&gt; PET 2
     DE 5  -&gt; PET 3
</PRE> 

<P>

<H3><A NAME="SECTION040112300000000000000">
26.2.3 Single patch DistGrid with decomposition by DE blocks</A>
</H3>

<P>
The examples of the previous sections showed how DistGrid objects with
   regular decompositions are created. However, in some cases a regular 
   decomposition may not be specific enough. The following example shows how 
   the <TT>deBlockList</TT> argument is used to create a DistGrid object with 
   completely user-defined decomposition.

<P>
A single 5x5 LR domain is to be decomposed into 6 DEs. To this end a list is
   constructed that holds the min and max corners of all six DE
   LR blocks. The DE-local LR blocks are arranged as to cover the whole patch 
   domain without overlap. 

<P>
<PRE>
  allocate(deBlockList(2, 2, 6))  ! (dimCount, 2, deCount)
  deBlockList(:,1,1) = (/1,1/)  ! minIndex  1st deBlock
  deBlockList(:,2,1) = (/3,2/)  ! maxIndex  1st deBlock
  deBlockList(:,1,2) = (/4,1/)  ! minIndex  2nd deBlock
  deBlockList(:,2,2) = (/5,2/)  ! maxIndex  2nd deBlock
  deBlockList(:,1,3) = (/1,3/)
  deBlockList(:,2,3) = (/2,4/)
  deBlockList(:,1,4) = (/3,3/)
  deBlockList(:,2,4) = (/5,4/)
  deBlockList(:,1,5) = (/1,5/)
  deBlockList(:,2,5) = (/3,5/)
  deBlockList(:,1,6) = (/4,5/)  ! minIndex  6th deBlock
  deBlockList(:,2,6) = (/5,5/)  ! maxInbex  6th deBlock
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    deBlockList=deBlockList, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION040112400000000000000">
26.2.4 Single patch DistGrid with periodic boundaries</A>
</H3>

<P>
By default the edges of all patches have solid wall boundary conditions. 
   Periodic boundary conditions can be imposed by specifying connections between
   patches. For the single LR domain of the last section periodic boundaries 
   along the first dimension are imposed by adding a
   <TT>connectionList</TT> argument with only one element to the create call.

<P>
Each <TT>connectionList</TT> element is a vector of <TT>(3 * dimCount + 2)</TT>
   integer numbers: 

<P>
<PRE>
  allocate(connectionList(3*2+2, 1))  ! (3*dimCount+2, number of connections)
</PRE>

<P>
and has the following format:

<P>
<TT>(/patchIndex_A, patchIndex_B, positionVector, orientationVector,
   repetitionVector/)</TT>.

<P>
The following constructor call can be used to construct a suitable connectionList
   element. 

<P>
<PRE>
  call ESMF_DistGridConnection(connection=connectionList(:,1), &amp;
     patchIndexA=1, patchIndexB=1, &amp;
     positionVector=(/5, 0/), &amp;
     orientationVector=(/1, 2/), &amp;
     repetitionVector=(/1, 0/), rc=rc)
</PRE>

<P>
The <TT>patchIndexA</TT> and <TT>patchIndexB</TT> arguments specify that this is a
   connection within patch 1. The <TT>positionVector</TT> indicates that there is no
   offset between patchB and patchA along the second dimension, but there is
   an offset of 5 along the first dimension (which in this case is the length of
   dimension 1). This aligns patchB (which is patch 1) right next to patchA
   (which is also patch 1).

<P>
The <TT>orientationVector</TT> fixes the orientation of the patchB index space to
   be the same as the orientation of patchA (it maps index 1 of patchA to index 1
   of patchB and the same for index 2). The <TT>orientationVector</TT> could have
   been omitted in this case which corresponds to the default orientation.

<P>
Finally, the <TT>repetitionVector</TT> idicates that this connetion element will
   be periodically repeated along dimension 1.

<P>
The <TT>connectionList</TT> can now be used to create a <TT>DistGrid</TT> object with the
   desired boundary conditions. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    deBlockList=deBlockList, connectionList=connectionList, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(connectionList)
</PRE>

<P>
This closes the patch along the first dimension on itself, thus imposing
   periodic boundaries along this direction. 

<P>

<H3><A NAME="SECTION040112500000000000000">
26.2.5 2D patchwork DistGrid with regular decomposition</A>
</H3>

<P>
Creating a DistGrid from a list of LR domains is a straight forward
   extension of the case with a single LR domain. The first four 
   arguments of <TT>ESMF_DistGridCreate()</TT> are promoted to rank 2, the 
   second dimension being the patch count index.

<P>
The following 2D patchwork domain consisting of 3 LR patches will 
   be used in the examples of this section:
   <PRE>
     ----------------------------------------&gt; 2nd dim
     |
     |                   (1,11)-----(1,20)
     |                   |               | 
     |                   |               | 
     |                   |               | 
     |                   |               | 
     |                   |               | 
     |                   (10,11)---(10,20)
     |  (11,1)----(11,10)(11,11)---(11,20)
     |  |               ||               |
     |  |               ||               |
     |  |               ||               |
     |  |               ||               |
     |  |               ||               |
     |  (20,1)----(20,10)(20,11)---(20,20)
     |
     |
     v
    1st dim
</PRE>

<P>
The first step in creating a patchwork global domain is to construct the
   <TT>minIndex</TT> and <TT>maxIndex</TT> arrays. 

<P>
<PRE>
  allocate(minIndex(2,3))    ! (dimCount, number of patches)
  allocate(maxIndex(2,3))    ! (dimCount, number of patches)
  minIndex(:,1) = (/11,1/)
  maxIndex(:,1) = (/20,10/)
  minIndex(:,2) = (/11,11/)
  maxIndex(:,2) = (/20,20/)
  minIndex(:,3) = (/1,11/)
  maxIndex(:,3) = (/10,20/)
</PRE>

<P>
Next the regular decomposition for each patch is set up in the
   <TT>regDecomp</TT> array. In this example each patch is associated with a
   single DE. 

<P>
<PRE>
  allocate(regDecomp(2,3))    ! (dimCount, number of patches)
  regDecomp(:,1) = (/1,1/)    ! one DE
  regDecomp(:,2) = (/1,1/)    ! one DE
  regDecomp(:,3) = (/1,1/)    ! one DE
</PRE>

<P>
Finally the DistGrid can be created by calling 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=minIndex, maxIndex=maxIndex, &amp;
    regDecomp=regDecomp, rc=rc)
</PRE>

<P>
The default DE labeling sequence is identical to the patch labeling sequence
   and follows the sequence in which the patches are defined during the create
   call. However, DE labels start at 0 whereas patch labels start at 1. In this 
   case the DE labels look as:
   <PRE>
           2
       0   1
</PRE>

<P>
Each patch can be decomposed differently into DEs. The default DE labeling 
   follows the column major order for each patch. This is demonstrated in the
   following case where the patchwork global domain is decomposed into 9 DEs, 

<P>
<PRE>
  regDecomp(:,1) = (/2,2/)    ! 4 DEs
  regDecomp(:,2) = (/1,3/)    ! 3 DEs
  regDecomp(:,3) = (/2,1/)    ! 2 DEs
  
  distgrid = ESMF_DistGridCreate(minIndex=minIndex, maxIndex=maxIndex, &amp;
    regDecomp=regDecomp, rc=rc)
</PRE>

<P>
resulting in the following decomposition:
   <PRE>
             +-------+
             |   7   |
             |       |
             |   8   |
     +-------+-------+
     | 0   2 |       |
     |       | 4 5 6 |
     | 1   3 |       |
     +-------+-------+
</PRE>

<P>
<PRE>
     DE 0 - (11,1)  ~ (15,5)
     DE 1 - (16,1)  ~ (20,5)
     DE 2 - (11,6)  ~ (15,10)
     DE 3 - (16,6)  ~ (20,10)
     DE 4 - (11,11) ~ (20,14)
     DE 5 - (11,15) ~ (20,17)
     DE 6 - (11,18) ~ (20,20)
     DE 7 - (1,11)  ~ (5,20)
     DE 8 - (6,11)  ~ (10,20)
</PRE>

<P>
The <TT>decompflag</TT> and <TT>deLabelList</TT> arguments can be used much like
   in the single LR domain case to overwrite the default grid decomposition 
   (per patch) and to change the overall DE labeling sequence, respectively. 

<P>

<H3><A NAME="SECTION040112600000000000000"></A>
   <A NAME="DistGrid:ArbitrarySeqInd"></A>
<BR>
26.2.6 Arbitrary DistGrids with user-supplied sequence indices
</H3>

<P>
The DistGrid class supports the communication methods of higher classes, 
   like Array and Field, by associating a unique <EM>sequence index</EM> with each
   DistGrid index tuple. This sequence index can be used to address every Array
   or Field element. By default, the DistGrid does not actually generate and
   store the sequence index of each element. Instead a default sequence through
   the elements is implemented in the DistGrid code. This default sequence 
   is used internally when needed.

<P>
The DistGrid class provides two <TT>ESMF_DistGridCreate()</TT> calls that 
   allow the user to specify arbitrary sequence indices, overriding the use of
   the default sequence index scheme. The user sequence indices are passed to
   the DistGrid in form of 1d Fortran arrays, one array on each PET. The local
   size of this array on each PET determines the number of DistGrid elements on
   the PET. The supplied sequence indices must be unique across all PETs. 

<P>
<PRE>
  allocate(arbSeqIndexList(10))   ! each PET will have 10 elements
  
  do i=1, 10
    arbSeqIndexList(i) = (i-1)*petCount + localPet  ! initialize unique seq. indices
  enddo
</PRE>

<P>
A default DELayout will be created automatically during 
   <TT>ESMF_DistGridCreate()</TT>, associating 1 DE per PET. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(arbSeqIndexList=arbSeqIndexList, rc=rc)
</PRE>

<P>
The user provided sequence index array can be deallocated once it has
   been used. 

<P>
<PRE>
  deallocate(arbSeqIndexList)
</PRE>

<P>
The <TT>distgrid</TT> object can be used just like any other DistGrid object.
   The "arbitrary" nature of <TT>distgrid</TT> will only become visible during
   Array or Field communication methods, where source and destination objects
   map elements according to the sequence indices provided by the associated
   DistGrid objects. 

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
The second <TT>ESMF_DistGridCreate()</TT> call, that accepts the 
   <TT>arbSeqIndexList</TT> argument, allows the user to specify additional,
   regular DistGrid dimensions. These additional DistGrid dimensions are not
   decomposed across DEs, but instead are simply "added" or "multiplied" to the
   1D arbitrary dimension.

<P>
The same <TT>arbSeqIndexList</TT> array as before is used to define the 
   user supplied sequence indices. 

<P>
<PRE>
  allocate(arbSeqIndexList(10))   ! each PET will have 10 elements
  
  do i=1, 10
    arbSeqIndexList(i) = (i-1)*petCount + localPet  ! initialize unique seq. indices
  enddo
</PRE>

<P>
The additional DistGrid dimensions are specified in the usual manner using
   <TT>minIndex</TT> and <TT>maxIndex</TT> arguments. The <TT>dimCount</TT> of the
   resulting DistGrid is the size of the <TT>minIndex</TT> and <TT>maxIndex</TT>
   arguments plus 1 for the arbitrary dimension. The <TT>arbDim</TT> argument is
   used to indicate which or the resulting DistGrid dimensions
   is associated with the arbitrary sequence indices provided by the user. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(arbSeqIndexList=arbSeqIndexList, &amp;
    arbDim=1, minIndex=(/1,1/), maxIndex=(/5,7/), rc=rc)
</PRE>

<P>
<PRE>
  deallocate(arbSeqIndexList)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<H2><A NAME="SECTION040113000000000000000">
26.3 Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI>Multi-patch DistGrids from deBlockList are not yet supported.
</LI>
<LI>The fastAxis feature has not been implemented yet.
</LI>
</UL>

<P>

<H2><A NAME="SECTION040114000000000000000">
26.4 Design and Implementation Notes</A>
</H2>

<P>
<EM>This section will be updated as the implementation of the DistGrid class
nears completion.</EM>

<P>

<H2><A NAME="SECTION040115000000000000000">
26.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION040115100000000000000">
26.5.1 ESMF_DistGridCreate - Create DistGrid object with regular decomposition</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateRD(minIndex, maxIndex, regDecomp, &amp;
     decompflag, regDecompFirstExtra, regDecompLastExtra, deLabelList, &amp;
     indexflag, connectionList, delayout, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                      intent(in)            :: minIndex(:)
     integer,                      intent(in)            :: maxIndex(:)
     integer, target,              intent(in), optional  :: regDecomp(:)
     type(ESMF_DecompFlag), target,intent(in), optional  :: decompflag(:)
     integer, target,              intent(in), optional  :: regDecompFirstExtra(:)
     integer, target,              intent(in), optional  :: regDecompLastExtra(:)
     integer, target,              intent(in), optional  :: deLabelList(:)
     type(ESMF_IndexFlag),         intent(in), optional  :: indexflag
     integer, target,              intent(in), optional  :: connectionList(:,:)
     type(ESMF_DELayout),          intent(in), optional  :: delayout
     type(ESMF_VM),                intent(in), optional  :: vm
     integer,                      intent(out),optional  :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateRD
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> from a single logically rectangular (LR) 
       patch with regular decomposition. A regular decomposition is of the same 
       rank as the patch and decomposes each dimension into a fixed number of 
       DEs. A regular decomposition of a single patch is expressed by a 
       single <TT>regDecomp</TT> list of DE counts in each dimension.

<P>
The arguments are:
       <DL>
<DT><STRONG>minIndex</STRONG></DT>
<DD>Global coordinate tuple of the lower corner of the patch.
       
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>Global coordinate tuple of the upper corner of the patch.
       
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List of DE counts for each dimension. The default decomposition will
            be <TT>deCount</TT><!-- MATH
 $\times 1 \times ... \times 1$
 -->
<IMG
 WIDTH="87" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img81.png"
 ALT="$ \times 1 \times ... \times 1$">. The value of
            <TT>deCount</TT> for a default DELayout equals <TT>petCount</TT>, i.e. the
            default decomposition will be into as many DEs as there are 
            PETs and the distribution will be 1 DE per PET.
       
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
            patch is to be divided between the DEs. The default setting
            is <TT>ESMF_DECOMP_HOMOGEN</TT> in all dimensions. See section
            <A HREF="node2.html#opt:decompflag">9.2.7</A> for a list of valid decomposition flag options.
       
</DD>
<DT><STRONG>[regDecompFirstExtra]</STRONG></DT>
<DD>Extra elements on the first DEs along each dimension in a regular
            decomposition. The default is a zero vector.
       
</DD>
<DT><STRONG>[regDecompLastExtra]</STRONG></DT>
<DD>Extra elements on the last DEs along each dimension in a regular
            decomposition. The default is a zero vector.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the <TT>regDecomp</TT>
            argument.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndex</TT> and
            <TT>maxIndex</TT> arguments are to be interpreted to form a flat
            pseudo global index space (<TT>ESMF_INDEX_GLOBAL</TT>) or are to be 
            taken as patch local (<TT>ESMF_INDEX_DELOCAL</TT>), which is the default.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of connections between patches in index space. The second dimension
            of <TT>connectionList</TT> steps through the connection interface elements, 
            defined by the first index. The first index must be of size
            <TT>2 x dimCount + 2</TT>, where <TT>dimCount</TT> is the rank of the 
            decomposed index space. Each <TT>connectionList</TT> element specifies
            the connection interface in the format

<P>
<TT>(/patchIndex_A,
            patchIndex_B, positionVector, orientationVector/)</TT> where:
            
<UL>
<LI><TT>patchIndex_A</TT> and <TT>patchIndex_B</TT> are the patch
                  index of the two connected patches respectively,
</LI>
<LI><TT>positionVector</TT> is the vector that points from patch A's
                  minIndex to patch B's minIndex.
</LI>
<LI><TT>orientationVector</TT> associates each dimension of patch A
                  with a dimension in patch B's index space. Negative index
                  values may be used to indicate a reversal in index orientation.
            
</LI>
</UL>
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional <TT>ESMF_DELayout</TT> object to be used. By default a new
            DELayout object will be created with the correct number of DEs. If
            a DELayout object is specified its number of DEs must match the 
            number indicated by <TT>regDecomp</TT>.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the
            VM of the current context will lower the method's overhead.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040115200000000000000">
26.5.2 ESMF_DistGridCreate - Create DistGrid object with DE blocks</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDB(minIndex, maxIndex, deBlockList, &amp;
     deLabelList, indexflag, connectionList, delayout, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                      intent(in)            :: minIndex(:)
     integer,                      intent(in)            :: maxIndex(:)
     integer,                      intent(in)            :: deBlockList(:,:,:)
     integer,                      intent(in), optional  :: deLabelList(:)
     type(ESMF_IndexFlag),         intent(in), optional  :: indexflag
     integer,                      intent(in), optional  :: connectionList(:,:)
     type(ESMF_DELayout),          intent(in), optional  :: delayout
     type(ESMF_VM),                intent(in), optional  :: vm
     integer,                      intent(out),optional  :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDB
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> from a single logically rectangular (LR) 
       patch with decomposition specified by <TT>deBlockList</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>minIndex</STRONG></DT>
<DD>Global coordinate tuple of the lower corner of the patch.
       
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>Global coordinate tuple of the upper corner of the patch.
       
</DD>
<DT><STRONG>deBlockList</STRONG></DT>
<DD>List of DE-local LR blocks. The third index of <TT>deBlockList</TT>
            steps through the deBlock elements, which are defined by the first
            two indices. The first index must be of size <TT>dimCount</TT> and the 
            second index must be of size 2. Each 2D element of <TT>deBlockList</TT>
            defined by the first two indices hold the following information.
            <PRE>
                     +---------------------------------------&gt; 2nd index
                     |    1               2           
                     | 1  minIndex(1)    maxIndex(1)
                     | 2  minIndex(2)    maxIndex(2)
                     | .  minIndex(.)    maxIndex(.)
                     | .
                     v
                    1st index
</PRE>
            It is required that there be no overlap between the LR segments
            defined by deBlockList.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the <TT>regDecomp</TT>
            argument.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndex</TT> and
            <TT>maxIndex</TT> arguments are to be interpreted to form a flat
            pseudo global index space (<TT>ESMF_INDEX_GLOBAL</TT>) or are to be 
            taken as patch local (<TT>ESMF_INDEX_DELOCAL</TT>), which is the default.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of connections between patches in index space. The second dimension
            of <TT>connectionList</TT> steps through the connection interface elements, 
            defined by the first index. The first index must be of size
            <TT>2 x dimCount + 2</TT>, where <TT>dimCount</TT> is the rank of the 
            decomposed index space. Each <TT>connectionList</TT> element specifies
            the connection interface in the format

<P>
<TT>(/patchIndex_A,
            patchIndex_B, positionVector, orientationVector/)</TT> where:
            
<UL>
<LI><TT>patchIndex_A</TT> and <TT>patchIndex_B</TT> are the patch
                  index of the two connected patches respectively,
</LI>
<LI><TT>positionVector</TT> is the vector that points from patch A's
                  minIndex to patch B's minIndex.
</LI>
<LI><TT>orientationVector</TT> associates each dimension of patch A
                  with a dimension in patch B's index space. Negative index
                  values may be used to indicate a reversal in index orientation.
            
</LI>
</UL>
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional <TT>ESMF_DELayout</TT> object to be used. By default a new
            DELayout object will be created with the correct number of DEs. If
            a DELayout object is specified its number of DEs must match the 
            number indicated by <TT>regDecomp</TT>.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the
            VM of the current context will lower the method's overhead.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040115300000000000000">
26.5.3 ESMF_DistGridCreate - Create DistGrid object from patchwork with regular decomposition</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateRDP(minIndex, maxIndex, regDecomp,&amp;
     decompflag, regDecompFirstExtra, regDecompLastExtra, deLabelList, &amp;
     indexflag, connectionList, delayout, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                      intent(in)            :: minIndex(:,:)
     integer,                      intent(in)            :: maxIndex(:,:)
     integer,                      intent(in), optional  :: regDecomp(:,:)
     type(ESMF_DecompFlag),target, intent(in), optional  :: decompflag(:,:)
     integer, target,              intent(in), optional  :: regDecompFirstExtra(:,:)
     integer, target,              intent(in), optional  :: regDecompLastExtra(:,:)
     integer,                      intent(in), optional  :: deLabelList(:)
     type(ESMF_IndexFlag),         intent(in), optional  :: indexflag
     integer,                      intent(in), optional  :: connectionList(:,:)
     type(ESMF_DELayout),          intent(in), optional  :: delayout
     type(ESMF_VM),                intent(in), optional  :: vm
     integer,                      intent(out),optional  :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateRDP
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> from a patchwork of logically 
       rectangular (LR) patches with regular decomposition. A regular
       decomposition is of the same rank as the patch and decomposes
       each dimension into a fixed number of DEs. A regular decomposition of a
       patchwork of patches is expressed by a list of DE count vectors, one
       vector for each patch. Each vector contained in the 
       <TT>regDecomp</TT> argument ascribes DE counts for each dimension. It is 
       erroneous to provide more patches than there are DEs.

<P>
The arguments are:
       <DL>
<DT><STRONG>minIndex</STRONG></DT>
<DD>The first index provides the global coordinate tuple of the lower 
            corner of a patch. The second index indicates the patch number.
       
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The first index provides the global coordinate tuple of the upper
            corner of a patch. The second index indicates the patch number.
       
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List of DE counts for each dimension. The second 
            index indicates the patch number. The default decomposition will
            be <TT>deCount</TT><!-- MATH
 $\times 1 \times ... \times 1$
 -->
<IMG
 WIDTH="87" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img81.png"
 ALT="$ \times 1 \times ... \times 1$">. The value of
            <TT>deCount</TT> for a default DELayout equals <TT>petCount</TT>, i.e. the
            default decomposition will be into as many DEs as there are 
            PETs and the distribution will be 1 DE per PET.
       
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of each
            patch is to be divided between the DEs. The default setting
            is <TT>ESMF_DECOMP_HOMOGEN</TT> in all dimensions for all patches. 
            See section <A HREF="node2.html#opt:decompflag">9.2.7</A> for a list of valid decomposition
            flag options. The second index indicates the patch number.
       
</DD>
<DT><STRONG>[regDecompFirstExtra]</STRONG></DT>
<DD>Extra elements on the first DEs along each dimension in a regular
            decomposition. The default is a zero vector. The second index 
            indicates the patch number.
       
</DD>
<DT><STRONG>[regDecompLastExtra]</STRONG></DT>
<DD>Extra elements on the last DEs along each dimension in a regular
            decomposition. The default is a zero vector. The second index 
            indicates the patch number.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the <TT>regDecomp</TT>
            elements in the sequence as they appear following the patch index.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndex</TT> and
            <TT>maxIndex</TT> arguments are to be interpreted to form a flat
            pseudo global index space (<TT>ESMF_INDEX_GLOBAL</TT>) or are to be 
            taken as patch local (<TT>ESMF_INDEX_DELOCAL</TT>), which is the default.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of connections between patches in index space. The second dimension
            of <TT>connectionList</TT> steps through the connection interface elements, 
            defined by the first index. The first index must be of size
            <TT>2 x dimCount + 2</TT>, where <TT>dimCount</TT> is the rank of the 
            decomposed index space. Each <TT>connectionList</TT> element specifies
            the connection interface in the format

<P>
<TT>(/patchIndex_A,
            patchIndex_B, positionVector, orientationVector/)</TT> where:
            
<UL>
<LI><TT>patchIndex_A</TT> and <TT>patchIndex_B</TT> are the patch
                  index of the two connected patches respectively,
</LI>
<LI><TT>positionVector</TT> is the vector that points from patch A's
                  minIndex to patch B's minIndex.
</LI>
<LI><TT>orientationVector</TT> associates each dimension of patch A
                  with a dimension in patch B's index space. Negative index
                  values may be used to indicate a reversal in index orientation.
            
</LI>
</UL>
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional <TT>ESMF_DELayout</TT> object to be used. By default a new
            DELayout object will be created with the correct number of DEs. If
            a DELayout object is specified its number of DEs must match the 
            number indicated by <TT>regDecomp</TT>.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the
            VM of the current context will lower the method's overhead.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040115400000000000000">
26.5.4 ESMF_DistGridCreate - Create 1D DistGrid object from user's arbitray index list</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDBAI1D(arbSeqIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,    intent(in)            :: arbSeqIndexList(:)
     integer,    intent(out),optional  :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDBAI1D
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> of <TT>dimCount</TT> 1 from a PET-local list
       of sequence indices. The PET-local size of the <TT>arbSeqIndexList</TT>
       argument determines the number of local elements in the created DistGrid.
       The sequence indices must be unique across all PETs. A default
       DELayout with 1 DE per PET across all PETs of the current VM is 
       automatically created.

<P>
The arguments are:
       <DL>
<DT><STRONG>arbSeqIndexList</STRONG></DT>
<DD>List of arbitrary sequence indices that reside on the local PET.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040115500000000000000">
26.5.5 ESMF_DistGridCreate - Create (1+n)D DistGrid object from user's arbitray index list and minIndex/maxIndex</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDBAI(arbSeqIndexList, arbDim, &amp;
     minIndex, maxIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,    intent(in)            :: arbSeqIndexList(:)
     integer,    intent(in)            :: arbDim
     integer,    intent(in)            :: minIndex(:)
     integer,    intent(in)            :: maxIndex(:)
     integer,    intent(out),optional  :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDBAI
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> of <TT>dimCount</TT> <IMG
 WIDTH="43" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img82.png"
 ALT="$1+n$">, where 
       <IMG
 WIDTH="32" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img83.png"
 ALT="$n=$"> <TT>size(minIndex)</TT> = <TT>size(maxIndex)</TT>.

<P>
The resulting DistGrid will have a 1D distribution determined by the
       PET-local <TT>arbSeqIndexList</TT>. The PET-local size of the
       <TT>arbSeqIndexList</TT> argument determines the number of local elements 
       along the arbitrarily distributed dimension in the created DistGrid. The
       sequence indices must be unique across all PETs. The associated,
       automatically created DELayout will have 1 DE per PET across all PETs of
       the current VM.

<P>
In addition to the arbitrarily distributed dimension, regular DistGrid
       dimensions can be specified in <TT>minIndex</TT> and <TT>maxIndex</TT>. The
       <IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="$n$"> dimensional subspace spanned by the regular dimensions is "multiplied"
       with the arbitrary dimension on each DE, to form a <IMG
 WIDTH="43" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img82.png"
 ALT="$1+n$"> dimensional
       total index space described by the DistGrid object. The <TT>arbDim</TT>
       argument allows to specify which dimension in the resulting DistGrid
       corresponds to the arbitrarily distributed one.

<P>
The arguments are:
       <DL>
<DT><STRONG>arbSeqIndexList</STRONG></DT>
<DD>List of arbitrary sequence indices that reside on the local PET.
       
</DD>
<DT><STRONG>arbDim</STRONG></DT>
<DD>Dimension of the arbitrary distribution.
       
</DD>
<DT><STRONG>minIndex</STRONG></DT>
<DD>Global coordinate tuple of the lower corner of the tile. The 
            arbitrary dimension is <EM>not</EM> included in this tile
       
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>Global coordinate tuple of the upper corner of the tile. The
            arbitrary dimension is <EM>not</EM> included in this tile
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040115600000000000000">
26.5.6 ESMF_DistGridDestroy - Destroy DistGrid object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridDestroy(distgrid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid), intent(inout)           :: distgrid
     integer,             intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMF_DistGrid</TT> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object to be destroyed.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040115700000000000000">
26.5.7 ESMF_DistGridGet - Get information about DistGrid object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridGet()
   subroutine ESMF_DistGridGetDefault(distgrid, delayout, dimCount, patchCount, &amp;
     minIndexPDimPPatch, maxIndexPDimPPatch, elementCountPPatch, &amp;
     minIndexPDimPDe, maxIndexPDimPDe, elementCountPDe, patchListPDe, &amp;
     indexCountPDimPDe, collocationPDim, regDecompFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),    intent(in)            :: distgrid
     type(ESMF_DELayout),    intent(out), optional :: delayout
     integer,                intent(out), optional :: dimCount
     integer,                intent(out), optional :: patchCount
     integer,        target, intent(out), optional :: minIndexPDimPPatch(:,:)
     integer,        target, intent(out), optional :: maxIndexPDimPPatch(:,:)
     integer,        target, intent(out), optional :: elementCountPPatch(:)
     integer,        target, intent(out), optional :: minIndexPDimPDe(:,:)
     integer,        target, intent(out), optional :: maxIndexPDimPDe(:,:)
     integer,        target, intent(out), optional :: elementCountPDe(:)
     integer,        target, intent(out), optional :: patchListPDe(:)
     integer,        target, intent(out), optional :: indexCountPDimPDe(:,:)
     integer,        target, intent(out), optional :: collocationPDim(:)
     logical,                intent(out), optional :: regDecompFlag
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal DistGrid information.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Queried <TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD><TT>ESMF_DELayout</TT> object associated with <TT>distgrid</TT>.
     
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>Number of dimensions (rank) of <TT>distgrid</TT>.
     
</DD>
<DT><STRONG>[patchCount]</STRONG></DT>
<DD>Number of patches in <TT>distgrid</TT>.
     
</DD>
<DT><STRONG>[minIndexPDimPPatch]</STRONG></DT>
<DD>Lower index space corner per <TT>dim</TT>, per <TT>patch</TT>, with
       <TT>size(minIndexPDimPPatch) == (/dimCount, patchCount/)</TT>.
     
</DD>
<DT><STRONG>[maxIndexPDimPPatch]</STRONG></DT>
<DD>Upper index space corner per <TT>dim</TT>, per <TT>patch</TT>, with
       <TT>size(minIndexPDimPPatch) == (/dimCount, patchCount/)</TT>.
     
</DD>
<DT><STRONG>[elementCountPPatch]</STRONG></DT>
<DD>Number of elements in exclusive region per patch, with
       <TT>size(elementCountPPatch) == (/patchCount/)</TT>
     
</DD>
<DT><STRONG>[minIndexPDimPDe]</STRONG></DT>
<DD>Lower index space corner per <TT>dim</TT>, per <TT>De</TT>, with
       <TT>size(minIndexPDimPDe) == (/dimCount, deCount/)</TT>.
     
</DD>
<DT><STRONG>[maxIndexPDimPDe]</STRONG></DT>
<DD>Upper index space corner per <TT>dim</TT>, per <TT>de</TT>, with
       <TT>size(minIndexPDimPDe) == (/dimCount, deCount/)</TT>.
     
</DD>
<DT><STRONG>[elementCountPDe]</STRONG></DT>
<DD>Number of elements in exclusive region per DE, with
       <TT>size(elementCountPDe) == (/deCount/)</TT>
     
</DD>
<DT><STRONG>[patchListPDe]</STRONG></DT>
<DD>List of patch id numbers, one for each DE, with
       <TT>size(patchListPDe) == (/deCount/)</TT>
     
</DD>
<DT><STRONG>[indexCountPDimPDe]</STRONG></DT>
<DD>Array of extents per <TT>dim</TT>, per <TT>de</TT>, with
       <TT>size(indexCountPDimPDe) == (/dimCount, deCount/)</TT>.
     
</DD>
<DT><STRONG>[collocationPDim]</STRONG></DT>
<DD>List of collocation id numbers, one for each dim, with
       <TT>size(collocationPDim) == (/dimCount/)</TT>
     
</DD>
<DT><STRONG>[regDecompFlag]</STRONG></DT>
<DD>Flag equal to <TT>ESMF_TRUE</TT> for regular decompositions
       and equal to <TT>ESMF_FALSE</TT> otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040115800000000000000">
26.5.8 ESMF_DistGridGet - Get DE local information about DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridGet()
   subroutine ESMF_DistGridGetPLocalDe(distgrid, localDe, collocation, &amp;
     arbSeqIndexFlag, seqIndexList, elementCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),    intent(in)            :: distgrid
     integer,                intent(in)            :: localDe
     integer,                intent(in),  optional :: collocation
     logical,                intent(out), optional :: arbSeqIndexFlag
     integer,        target, intent(out), optional :: seqIndexList(:)
     integer,                intent(out), optional :: elementCount
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal DistGrid information.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Queried <TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>
     
</DD>
<DT><STRONG>[collocation]</STRONG></DT>
<DD>Collocation for which information is requested. Default to first
       collocation in <TT>collocationPDim</TT> list.
     
</DD>
<DT><STRONG>[arbSeqIndexFlag]</STRONG></DT>
<DD>Indicates whether collocation is associated with arbitrary sequence
       indices.
     
</DD>
<DT><STRONG>[seqIndexList]</STRONG></DT>
<DD>List of DistGrid patch-local sequence indices for <TT>localDe</TT>, with
       <TT>size(seqIndexList) == (/elementCountPDe(localDe)/)</TT>.
     
</DD>
<DT><STRONG>[elementCount]</STRONG></DT>
<DD>Number of elements in the localDe, i.e. identical to
       elementCountPDe(localDe).
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040115900000000000000">
26.5.9 ESMF_DistGridGet - Get DE local information for dimension about DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridGet()
   subroutine ESMF_DistGridGetPLocalDePDim(distgrid, localDe, dim, indexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),    intent(in)            :: distgrid
     integer,                intent(in)            :: localDe
     integer,                intent(in)            :: dim
     integer,        target, intent(out)           :: indexList(:)
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal DistGrid information.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Queried <TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>
     
</DD>
<DT><STRONG>dim</STRONG></DT>
<DD>Dimension for which information is requested. <TT>[1,..,dimCount]</TT>
     
</DD>
<DT><STRONG>indexList</STRONG></DT>
<DD>Upon return this holds the list of DistGrid patch-local indices
       for <TT>localDe</TT> along dimension <TT>dim</TT>. The supplied variable 
       must be at least of size <TT>indexCountPDimPDe(dim, de(localDe))</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0401151000000000000000">
26.5.10 ESMF_DistGridPrint - Print DistGrid internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridPrint(distgrid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),  intent(in)              :: distgrid
     integer,              intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints internal information about the specified <TT>ESMF_DistGrid</TT> 
       object to <TT>stdout</TT>. 
<BR>
<P>
Note:  Many <TT>ESMF_&lt;class&gt;Print</TT> methods are implemented in C++.
       On some platforms/compilers there is a potential issue with interleaving
       Fortran and C++ output to <TT>stdout</TT> such that it doesn't appear in
       the expected order.  If this occurs, the <TT>ESMF_IOUnitFlush()</TT> method
       may be used on unit 6 to get coherent output.  
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Specified <TT>ESMF_DistGrid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0401151100000000000000">
26.5.11 ESMF_DistGridMatch - Check if two DistGrid objects match</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_DistGridMatch(distgrid1, distgrid2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_DistGridMatch
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),  intent(in)              :: distgrid1
     type(ESMF_DistGrid),  intent(in)              :: distgrid2
     integer,              intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>distgrid1</TT> and <TT>distgrid2</TT> match. Returns
        <TT>.TRUE.</TT> if DistGrid objects match, <TT>.FALSE.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid1</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object.
       
</DD>
<DT><STRONG>distgrid2</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0401151200000000000000">
26.5.12 ESMF_DistGridValidate - Validate DistGrid internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridValidate(distgrid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),  intent(in)              :: distgrid
     integer,              intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>distgrid</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Specified <TT>ESMF_DistGrid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0401151300000000000000">
26.5.13 ESMF_DistGridConnection - Construct a DistGrid connection element</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridConnection(connection, patchIndexA, patchIndexB, &amp;
     positionVector, orientationVector, repetitionVector, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,        target, intent(out)           :: connection(:)
     integer,                intent(in)            :: patchIndexA
     integer,                intent(in)            :: patchIndexB
     integer,                intent(in)            :: positionVector(:)
     integer,                intent(in),  optional :: orientationVector(:)
     integer,                intent(in),  optional :: repetitionVector(:)
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call helps to construct a DistGrid connection,
       which is a simple vector of integers, out of its components.

<P>
The arguments are:
       <DL>
<DT><STRONG>connection</STRONG></DT>
<DD>Element to be constructed. The provided <TT>connection</TT> must 
          be dimensioned to hold exactly the number of integers that result from
          the input information.
       
</DD>
<DT><STRONG>patchIndexA</STRONG></DT>
<DD>Index of one of the two patches that are to be connected.
       
</DD>
<DT><STRONG>patchIndexB</STRONG></DT>
<DD>Index of one of the two patches that are to be connected.
       
</DD>
<DT><STRONG>positionVector</STRONG></DT>
<DD>Position of patch B's minIndex with respect to patch A's minIndex.
       
</DD>
<DT><STRONG>[orientationVector]</STRONG></DT>
<DD>Associates each dimension of patch A with a dimension in patch B's 
          index space. Negative index values may be used to indicate a 
          reversal in index orientation. It is erroneous to associate multiple
          dimensions of patch A with the same index in patch B. By default
          <TT>orientationVector = (/1,2,3,.../)</TT>, i.e. same orientation as
          patch A.
       
</DD>
<DT><STRONG>[repetitionVector]</STRONG></DT>
<DD>The allowed values for each direction are 0 and 1. An entry of 1
          indicates that this connection element will be repeated along the
          respective dimension. A value of 0 indicates no repetition along this
          dimension. By default <TT>repetitionVector = (/0,0,0,.../)</TT>, i.e. no
          repetition along any direction.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION040120000000000000000">
27 IO Class</A>
</H1>

<P>

<H2><A NAME="SECTION040121000000000000000">
27.1 Description</A>
</H2>

<P>
Earth system modeling applications require efficient and robust tools
for input and output of structured and unstructured gridded data, as
well as observational data streams.  Interfaces and methods provided
by ESMF should allow reading and writing of data in several standard
formats as well as support efficient internal data representations
(see ESMF General Requirements [<A
 HREF="node6.html#ESMFGenReq">8</A>], Section 8.1.3). 
The ESMF IO will provide a unified interface for input and output 
of high level ESMF objects such as Fields.  The system is expected to 
automatically detect file formats at runtime, and to output data in a variety 
of formats, with the posibility of creating companion metadata files. Other 
file IO functionalities, such as writing of error and log messages and input 
of configuration parameters from an ASCII file, are not covered in this
document. 

<P>

<H2><A NAME="SECTION040122000000000000000">
27.2 I/O architecture</A>
</H2>

<P>
We use the experience of the WRF [<A
 HREF="node6.html#WRF-Software">24</A>] and FMS 
[<A
 HREF="node6.html#Balaji_Parallel_IO_2000">5</A>]  projects in defining the 
ESMF I/O architecture that is efficient, flexible, end-to-end, and package 
neutral. Our principles will be:

<P>
<DL>
<DT><STRONG>-</STRONG></DT>
<DD>Define a standard unified I/O interface and API covering 
         ESMF-supported data models.
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>Provide efficient implementation of this API for multiple data 
         formats supported by the ESMF. 
</DD>
</DL>

<P>

<H2><A NAME="SECTION040123000000000000000">
27.3 Data models</A>
</H2>

<P>
Earth system models use a variety of discrete grids to maintain information 
about fields in continuous space, as well as observations. The primary ESMF 
codes employ finite-difference and finite-volume grids, spectral grids, 
unstructured land-surface grids, and ungridded observational networks.

<P>
Fields within a model component are frequently defined on the same
physical grid and are decomposed in memory in an identical fashion;
that is, they share a distributed grid. They form a <EM>bundle of
fields</EM> defined on the same distributed grid. The gridded data are
supported by three ESMF elements: <EM>PhysGrid</EM> element 
for physical grids, <EM>DistGrid</EM> element for distributed grids, and 
<EM>Fields</EM> class for fields ([<A
 HREF="node6.html#ESMF-PhysGrid-Req">9</A>],
[<A
 HREF="node6.html#ESMF-DistGrid-Req">6</A>], [<A
 HREF="node6.html#ESMF-Field-Req">7</A>]). 

<P>
ESMF I/O will support input/output of data defined on all ESMF
supported grids and location streams ([<A
 HREF="node6.html#ESMF-PhysGrid-Req">9</A>],
[<A
 HREF="node6.html#ESMF-DistGrid-Req">6</A>]). For
the purpose of this document, we will consider data belonging to three
broad categories:

<P>
<DL>
<DT><STRONG><B>Structured Gridded Data.</B></STRONG></DT>
<DD>A <EM>structured grid</EM> is one on 
which the relationship between gridpoints can be derived from their
indices, without the need for an explicit map.  A simple example is fields
defined on a rectangular lat/lon grid.

<P>
</DD>
<DT><STRONG><B>Unstructured Gridded Data.</B></STRONG></DT>
<DD>For the more general 
<EM>unstructured grid</EM> the relationship between gridpoints cannot be
derived from their indices, and the specification of an explicit map
is necessary.  An example is a <EM>catchment grid</EM> used by some
land-surface models.

<P>
</DD>
<DT><STRONG><B>Observational Data on location streams.</B></STRONG></DT>
<DD>As defined in 
the <EM>Physical Grid Requirements</EM>, a location stream contains 
a list of locations which 
describe the measurements. Each observation is 
associated with a spatial point or region. A neighbor relationship is not 
defined for observations. 
</DD>
</DL>

<P>
As we have already mentioned, logically rectangular grids are naturally 
represented by multi-dimensional arrays. The two latter data models can be 
represented as one-dimensional arrays of structures with each structure 
containing information about location, field values associated with this 
location, and a list of neighbors, if relevant. 

<P>

<H2><A NAME="SECTION040124000000000000000">
27.4 ESMF metadata conventions</A>
</H2>

<P>
<B>Metadata</B> is data about a digital object, ``structured data about the 
data''. The metadata is usually provided by the creator or distributor of 
the object, and often either accompanies the object or is embedded in the 
file header. As such, metadata can be very useful as the basis for 
information storage and retrieval systems, as well as for utilization of the 
data within Earth Science models.
The information about the object provided by metadata allows optimization of  
resource allocation and organization of storage and retrieval of data. In 
parallel computing such knowledge may be especially important. 

<P>
If metadata are provided, the files may be either <EM>self-described</EM> or
<EM>co-described</EM>, depending on the fashion in which metadata are allocated.
<DL>
<DT><STRONG><B>A self-described file</B></STRONG></DT>
<DD>contains in its header all metadata 
necessary to provide a unique interpretation of the file content
assuming certain conventions.  
</DD>
<DT><STRONG><B>A co-described file</B></STRONG></DT>
<DD>is accompanied by a metadata file. The
metadata file provides a unique interpretation of the data file content
under certain conventions. 
</DD>
</DL>
It is assumed the metadata can be rapidly read by a corresponding API without 
reading an entire content of the data file. Some data files may contain 
complete description of their content, but the way data are represented might 
not allow rapid extraction of metadata. To make such a file co-described, its 
metadata could be extracted and allocated to a companion metadata file.

<P>
Some file formats that we discuss below, such as NetCDF and HDF, are 
organized according to well-defined rules. Their structures and APIs enable 
(but do not require) creation of self-described files. By narrowing 
the definitions, conventions enable a complete and unique description of each 
dataset.

<P>
We assume that the NetCDF conventions for climate and forecast metadata, 
``CF conventions'', will serve as a a basis for ESMF metadata conventions.
 NetCDF Climate-Forecast Metadata Conventions
[<A
 HREF="node6.html#NetCDF_CF_v1_beta3">25</A>] narrow definitions of NetCDF, an
array-oriented data format and a library for gridded data 
[<A
 HREF="node6.html#NetCDF3_UsersGuide_C">26</A>], to allow a unique and complete description
of gridded data used in geoscience. CF conventions specify standard 
dimensions, such as date or time (t), height or depth (<I>z</I>), 
latitude (<I>y</I>), and longitude (<I>x</I>), and specify standard
units for these dimensions and other quantities. 

<P>
We expect ESMF metadata conventions to be based on the CF-conventions,
and to cover fields defined on both structured and unstructured grids,
as well as observational data. Unlike the CF conventions which are
tightly associated with NetCDF, the ESMF conventions are supposed to
be format neutral, and cover all of the ESMF data formats.  These
extensions will become the ESMF standard, and will be enforced by the
ESMF I/O subsystem. However, the specification of ESMF metadata is
optional, and users desiring not to specify any metadata should be
able to do so.

<P>

<H2><A NAME="SECTION040125000000000000000">
27.5 Data formats</A>
</H2>

<P>
Several standard formats are currently used in Earth Science modeling
for input/output of data:

<P>
<DL>
<DT><STRONG><B>NetCDF</B></STRONG></DT>
<DD>Network Common Data Form (NetCDF) is an interface for 
array-oriented data access. The NetCDF library provides an
implementation of the interface. It also defines a 
machine-independent format for representing scientific data. Together,
the interface, library, and format support the creation, access, and
sharing of scientific data. The NetCDF software was developed at the
Unidata Program Center in Boulder, Colorado. See [<A
 HREF="node6.html#NetCDF3_UsersGuide_C">26</A>].
In geoscience, NetCDF can be naturally used for represenation of fields 
defined on logically rectangular grids. NetCDF use in geosciences is 
specified by CF conventions mentioned above [<A
 HREF="node6.html#NetCDF_CF_v1_beta3">25</A>]. 

<P>
To the extent that data on unstructured grids (or even observations) can be 
represented as one-dimensional arrays, NetCDF can also be used to store these 
data. However, it does not provide a high-level abstraction for this type of 
data. 

<P>
</DD>
<DT><STRONG><B>DODS</B></STRONG></DT>
<DD>The Distributed Oceanographic Data System is a system that 
allows access to data over the internet. DODS is created and supported by 
Unidata Program Center in Boulder, Colorado. See [<A
 HREF="node6.html#DODS">30</A>]. DODS enables an 
implementation of NetCDF-client libraries that permits remote access to data 
through the Internet.

<P>
</DD>
<DT><STRONG><B>HDF</B></STRONG></DT>
<DD>The Hierarchical Data Format (HDF) project provides
interface,  software and file formats for scientific data management. 
The HDF software includes I/O libraries and tools for analyzing,
visualizing, and converting scientific data. 

<P>
HDF is developed and supported at the National Center for Supercomputing 
Applications, University of Illinois at Urbana-Champaign. There are two 
different HDF formats, HDF (4.x and previous releases) and HDF5. These 
formats are completely different and <I>not</I> compatible.  See
[<A
 HREF="node6.html#HDF4_tutorials">16</A>], [<A
 HREF="node6.html#HDF5_tutorial">17</A>].

<P>
HDF Scientific Data Sets API allows efficient operating with
multi-dimensional arrays. Although HDF SDS itself does not provide a way
to represent high-level abstractions for data on unstructured grids
and observational data sets, HDF-based applications, such as HDF-EOS
do so in HDF-EOS Point Structure.

<P>
</DD>
<DT><STRONG><B>HDF-EOS</B></STRONG></DT>
<DD>The Hierarchical Data Format - Earth Observing
System (HDF-EOS) is the scientific data format standard selected by
NASA as the baseline standard for the Earth Observing System (EOS). HDF-EOS
is an extension of HDF and uses HDF library calls as its underlying
basis. Version 4.1r1 of HDF is used. The library and tools are written
in C language and a Fortran interface is provided. See [<A
 HREF="node6.html#HDF-EOS">18</A>].

<P>
HDF-EOS can be used for different data models within ESMF. Regular
gridded data are supported by HDF-EOS Grid Structures, while HDF-EOS  
Point Structure covers unstructured grid and observational data.

<P>
</DD>
<DT><STRONG><B>GRIB</B></STRONG></DT>
<DD>GRIdded Binary (GRIB) is the standard gridded data format from the
World Meteorological Organization (WMO).  GRIB is a general purpose,
bit-oriented data exchange format. Most NWP centers use GRIB for all the 
files produced from its analyses and forecasts. Since the GRIB standard does 
not specify a standard API, NWP centers use a variety of software to process 
GRIB files.

<P>
The GRIB format used in ESMF shall be configurable, and shall allow the 
creation of files which conform to the NCEP standard usage.  

<P>
</DD>
<DT><STRONG><B>IEEE Binary Streams</B></STRONG></DT>
<DD>A natural way for a machine to represent data is to use a native
binary data representation. There are two choices of ordering of bytes
(so-called <I>Big Endian</I> and <I>Little Endian</I>), and a lot of
ambiguity in representing floating point data. The latter, however, is
specified, if IEEE Floating Point Standard 754 is satisfied
([<A
 HREF="node6.html#IEEE-Floating-Point">12</A>], [<A
 HREF="node6.html#Kahan-IEEE-754">21</A>]). It is desirable
to be able to use efficient native representation, and optionally
provide ESMF metadata on a companion file using for example XML
[<A
 HREF="node6.html#XML-W3C">10</A>].

<P>
</DD>
<DT><STRONG><B>GrADS</B></STRONG></DT>
<DD>The Grid Analysis and Display System (GrADS) is popular 
visualization software widely used by the earth science modeling
communinity (http://grads.iges.org/grads/). GrADS can read COARDS
compliant NetCDF and HDF files, as well as IEEE binary and GRIB files
provided an appropriate companion metadadata file is provided (in
GrADS parlance these are refered to as <EM>control files</EM>). Files
produced by the ESMF are intended to be GrADS readable, and the ESMF
shall produce GrADS control files upon request.

<P>
</DD>
<DT><STRONG><B>BUFR</B></STRONG></DT>
<DD>Binary Universal Form of Representation of the meteorological 
data (BUFR) is a self-descriptive format for observational data
transmission introduced by the World Meteorological Organization
[<A
 HREF="node6.html#WMO-BUFR-CREX">33</A>]. The form and content of data contained in a BUFR 
message are described within BUFR message itself. In addition, BUFR provides 
condensation, or packing of data. 

<P>
The BUFR is a table-driven code since the Data Description Section
contains a sequence of data descriptors referring to a set of
predefined and internationally agreed tables. Thus, instead of writing
all detailed definitions within a message, one will just write a
number identifying a parameter with its descriptions. The BUFR format
used in ESMF shall be configurable, and shall allow the creation of
files which conform to the NCEP standard usage, in which the
predefined tables are contained in the file.

<P>
</DD>
</DL>

<P>
Modern data management approaches could potentially provide significant 
advantages in manipulating data and have to be carefully studied.
For example, ESMWF has created and employed relational-database based 
Observational Data Base (ODB) software [<A
 HREF="node6.html#ODB">28</A>].  However, such complex 
data management systems are beyond the scope of the basic ESMF I/O. 

<P>

<H2><A NAME="SECTION040126000000000000000">
27.6 Parallel I/O</A>
</H2>

<P>
The future development of ESMF IO facility will require further
optimization with an expected increase in IO amount over the next few
years. Two major factors contrubuting to the increase in I/O intensity are:
<DL>
<DT><STRONG>-</STRONG></DT>
<DD>Enhancement in model resolution;
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>Increase in I/O frequency.
</DD>
</DL>
We also expect significant increase in the amount of satellite data, although 
the amount of I/O related to observational data is not comparable with 
the amount of gridded I/O which drives our performance analysis. 

<P>
There are two aspects of  parallel IO:

<P>
<DL>
<DT><STRONG>-</STRONG></DT>
<DD>How a dataset distributed among multiple processors can be
written to a single file efficiently;

<P>
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>How a single file can be distributed across multiple physical
disks and IO channels.
</DD>
</DL>

<P>
There are several possibilities to perform IO in parallel ([<A
 HREF="node6.html#MPI-2">13</A>]):
<DL>
<DT></DT>
<DD><B>Single-threaded IO:</B> A single process acquires all the data and
writes them out. The features of hardware and OS are used to distribute the 
data over multiple channels and, possibly, to muliple disks.

<P>
</DD>
<DT></DT>
<DD><B>Multithreaded, multi-fileset IO:</B> Many processes write to
multiple independent files. These files may be assembled later. Since each of 
the processes operates with its file logically independently, we can again 
rely on the hardware and OS to operate concurrently with multiple channels and 
multiple disks. 

<P>
</DD>
<DT></DT>
<DD><B>Multithreaded, single-fileset IO:</B> Many processes write to a
single file. Although this approach is the most desirable one, its 
implementation is the most complicated. Since it requires concurrent access 
to the file by multiple processes, it can be implemented within the ESMF I/O 
only when such functionality is provided by an underlying I/O library. 
</DD>
</DL>

<P>
Multithreaded IO offers a simple way to stripe the data accross as many
IO channels and disk channels as are available [<A
 HREF="node6.html#MPI-2">13</A>,<A
 HREF="node6.html#Balaji_Parallel_IO_1999">4</A>,<A
 HREF="node6.html#Balaji_Parallel_IO_2000">5</A>]. Parallel IO implemented in 
GFDL ([<A
 HREF="node6.html#mpp_io">31</A>]) supports parallel writing to single or multiple files. 
It supports NetCDF and binary data formats.

<P>

<H2><A NAME="SECTION040127000000000000000">
27.7 Synchronous and Asynchronous IO</A>
</H2>

<P>
ESMF shall provide an asynchronous option for all ESMF IO models.  It
shall provide async read and write operations, the capability to wait
on individual or groups of I/O operations, and query functions for the
state of an operation.

<P>

<H2><A NAME="SECTION040128000000000000000">
27.8 Location</A>
</H2>

<P>
Input/Output (IO) is part of the ESMF Infrastructure.  It will provide
efficient utilities to input/output gridded data and observational data
to and from the disk. A standard API will allow manipulation of multiple
standard formats.

<P>

<H2><A NAME="SECTION040129000000000000000">
27.9 Scope</A>
</H2>

<P>
ESMF IO is meant to be used for standard API and underlying implementation, 
providing input and outut of gridded data and observational data streams to 
and from the disk in multiple standard formats. I/O with different levels of 
parallelism have to be provided.  

<P>

<P>

<H2><A NAME="SECTION0401210000000000000000">
27.10 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Initial ESMF Attributes implementation</B>  The first version of IO will
support the ESMF Attributes requirements - reading and writing Attributes
from/to XML files.  Future releases will support the remaining IO requirements.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION0401211000000000000000">
27.11 Design and Implementation Notes</A>
</H2>

<P>
The IO class will use the Xerces C++ library to perform reading and writing
of XML files.

<P>

<P>

<H1><A NAME="SECTION040130000000000000000">
28 IOSpec Class</A>
</H1>

<P>

<H2><A NAME="SECTION040131000000000000000">
28.1 Description</A>
</H2>

<P>
The IOSpec in a simple class that specifies the options for 
an IO activity.  An important choice is the IO format.  Currently
only netCDF is supported.  Other options include 
whether IO should be written to a single file or multiple files, 
the Fortran unit number, and the filename.  The IO activity can
be identified as being a restart write <TT>ESMF_IO_RESTART</TT> or 
a history write <TT>ESMF_IO_HISTORY</TT>, if desired.

<P>

<P>

<H2><A NAME="SECTION040132000000000000000">
28.2 Use and Examples</A>
</H2>

<P>
The IOSpec can be used in two ways.  The first way an IOSpec can 
be used is by passing it into the creation method of a data class 
such as a Field or FieldBundle.  This sets a default IOSpec for the 
data object.  Any IO method that involves the data object will 
use the settings in the default IOSpec, as long as there is no 
other IO specification that overrides it.  This brings us to the 
second way to use an IOSpec.  This is not implemented for all data
classes throughout ESMF yet; only Fields can write out data.

<P>
The second mode of usage is to pass an IOSpec into a particular 
IO method, such as an <TT>ESMF_FieldWrite()</TT> call.  The IOSpec 
passed into a write or read call overrides any default settings 
that were set up at data object creation.

<P>

<H2><A NAME="SECTION040133000000000000000">
28.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limited support for archival formats.</B>  The IOSpec does 
not support archival formats besides binary and netCDF.  We 
anticipate adding support for HDF variants, GRIB, and BUFR in 
the future.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION040134000000000000000">
28.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION040134100000000000000">
28.4.1 ESMF_IOSpecGet - Get values in an IOSpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_IOSpecGet(iospec, filename, iofileformat, &amp;
                                 iorwtype, asyncIO, rc)
</PRE><EM>PARAMETERS:</EM>
<PRE>       type (ESMF_IOSpec), intent(in) :: iospec
       character(len=*), intent(out), optional :: filename
       type (ESMF_IOFileFormat), intent(out), optional :: iofileformat
       type (ESMF_IORWType), intent(out), optional :: iorwtype
       logical, intent(out), optional :: asyncIO
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
(insert documentation here.)

<P>
!REQUIREMENTS: 

<P>

<P>

<H3><A NAME="SECTION040134200000000000000">
28.4.2 ESMF_IOSpecSet - Set values in an IOSpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_IOSpecSet(iospec, filename, iofileformat, &amp;
                                 iorwtype, asyncIO, rc)
</PRE><EM>PARAMETERS:</EM>
<PRE>       type (ESMF_IOSpec), intent(inout) :: iospec
       character(len=*), intent(in), optional :: filename
       type (ESMF_IOFileFormat), intent(in), optional :: iofileformat
       type (ESMF_IORWType), intent(in), optional :: iorwtype
       logical, intent(in), optional :: asyncIO
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
(insert documentation here.)

<P>
!REQUIREMENTS: 

<P>

<P>

<P>

<P>

<H1><A NAME="SECTION040140000000000000000">
29 Overview of Distributed Data Methods</A>
</H1>

<P>
FieldBundles, Fields, and Arrays all have versions of the following
data communication methods.  In these objects, data is communicated 
between DEs.  Depending on the underlying communication 
mechanism, this may translate within the framework to a data 
copy, an MPI call, or something else.  
The ESMF goal of providing
performance portability means the framework will in the future
attempt to select the
fastest communication strategy on each hardware platform transparently 
to the user code.  (The current implementation uses MPI for communication.)

<P>
Communication patterns, meaning exactly which bytes need to be copied 
or sent from one PET to another to perform the requested operation,
can be precomputed during an initialization phase and then later 
executed repeatedly.
There is a common object handle, an <TT>ESMF_RouteHandle</TT>, which
identifies these stored communication patterns. 
Only the <TT>ESMF_RouteHandle</TT> and the source and destination 
data pointers must be supplied at runtime to minimize execution overhead.

<P>

<H2><A NAME="SECTION040141000000000000000">
29.1 Higher Level Functions</A>
</H2>
The following three methods are intended to map closely to 
needs of applications programs.  They represent higher level
communications and are described in more detail in the following
sections.  They are:

<P>

<UL>
<LI><B>Halo</B>
Update ghost-cell or halo regions at the boundaries
of a local data decomposition.
</LI>
<LI><B>Regrid</B>
Transform data from one Grid to another, performing
any necessary data interpolation.
</LI>
<LI><B>Redist</B>
Copy data associated with a single Grid from
one decomposition to another.  No data interpolation is necessary.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION040142000000000000000">
29.2 Lower Level Functions</A>
</H2>
The following methods correspond closely to the lower level
MPI communications primitives.  They are:

<P>

<UL>
<LI><B>Gather</B>
Reassembling data which is decomposed over a set of DEs into a single
block of data on one DE.
</LI>
<LI><B>AllGather</B>
Reassembling data which is decomposed over a set of DEs into multiple
copies of a single block of data, one copy per original DE.
</LI>
<LI><B>Scatter</B>
Spreading an undecomposed block of data on one DE over a set of DEs,
decomposing that single block into smaller subsets of data, one
data decomposition per DE.
</LI>
<LI><B>AlltoAll</B>
Spreading an undecomposed block of data from multiple DEs onto
each of the other DEs in the set, resulting in a set of multiple decomposed 
data blocks per DE, one from each of the original source DEs.
</LI>
<LI><B>Broadcast</B>
Spreading an undecomposed block of data from one DE onto all other
DEs, where the resulting data is still undecomposed and simply
copied to all other DEs.
</LI>
<LI><B>Reduction</B>
Computing a single data value, e.g. the data maximum, minimum, sum, etc
from a group of decomposed data blocks across a set of DEs, where the
result is delivered to a single DE.
</LI>
<LI><B>AllReduce</B>
Computing a single data value, e.g. the data maximum, minimum, sum, etc
from a group of decomposed data blocks across a set of DEs, where the
result is delivered to all DEs in the set.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION040143000000000000000"></A>
<A NAME="sec:routeoptions"></A>
<BR>
29.3 Common Options
</H2>

<P>
ESMF will select an appropriate default for the
internal communication strategy for executing the communications.  
However, additional control is available
to the user by specifying the following route options.
(For more details on exactly what changes with the various options,
see Section <A HREF="node4.html#sec:routeimpl">29.4</A>.)

<P>

<H2><A NAME="SECTION040144000000000000000"></A>
<A NAME="sec:routeimpl"></A>
<BR>
29.4 Design and Implementation Notes
</H2>

<P>

<OL>
<LI><P>
There is an internal <TT>ESMC_Route</TT> class which supports the 
distributed communication methods.  There are 4 additional internal-only
classes which support <TT>ESMC_Route</TT>: <TT>ESMC_AxisIndex</TT>, 
<TT>ESMC_XPacket</TT>, <TT>ESMC_CommTable</TT>, and <TT>ESMC_RTable</TT>;
and a public <TT>ESMF_RouteHandle</TT> class which is what the user 
sets and gets.  The implementation is in C++, with interfaces in Fortran 90.

<P>
The general communication strategy is that each
DE computes its own communication information independently,
in parallel, and adds entries to a per-PET route table
which contains all needed sends and receives (or gets and puts) 
stored in terms relative to itself.  (Implementation note: this
code will need to be made thread-safe if multiple threads are
trying to add information to the same route table.)

<P>
AxisIndex is a small helper class which contains an index minimum
and maximum for each dimension and is used to describe an n-dimensional
hypercube of information in index space.  These are associated with 
logically rectangular grids and local data arrays.  
There are usually multiple instances of them, for example the local
data chunk, and the overall global index-space grid this data is
a subset of.  Within each of the local or global categories, there are
also multiple instances to describe the allocated space, the total area,
the computational area, and the exclusive area.  See Figure <A HREF="#fig:halo"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
for the definitions of each of these regions.
(Implementation note: the allocated space is only partially implemented
internally and has no external user API yet.)

<P>
An Exchange Packet (XPacket) describes groups of memory addresses
which constitute an n-dimensional hypercube of data.
Each XPacket has an offset from a base address, 
a contiguous run length, 
a stride (or number of items to skip) per dimension,
and a repeat count per dimension. 
See Figure <A HREF="node4.html#fig:xpacketbasic">19</A> for a diagram of how the XPacket
describes memory.
The actual unit size stored in an XPacket is an item count, 
so before using an XPacket to address bytes of memory
the item size must be known and the
counts multiplied by the number of bytes per item.  This allows
the same XPacket to describe different data types which have the
same memory layout, for example 4 byte integers and 8 byte reals/doubles.
The XPacket methods include basic set/get, how to turn
a list of AxisIndex objects into an XPacket, compute a local XPacket from one
in global (undecomposed grid) space, and a method to compute the intersection
of 2 XPackets and produce a 3rd XPacket describing that region.  

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:xpacketbasic"></A><A NAME="36403"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 19:</STRONG>
How an Exchange Packet (XPacket) describes the memory
layout for a rectangular hypercube of data.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Basic_xpacket}}$
 -->
<IMG
 WIDTH="826" HEIGHT="517" ALIGN="BOTTOM" BORDER="0"
 SRC="img84.png"
 ALT="\scalebox{0.9}{\includegraphics{Basic_xpacket}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The Communication Table (CommTable) class encapsulates which other PETs this
PET needs to talk to, and in what order.  There are create and destroy
methods, methods to set that a PET has data either to
send or receive, and query routines that return an answer
to the question 'which PET should I exchange data with next'.  

<P>
The Route Table (RTable) class contains a list of
XPackets to be sent and received from other PETs.
It has create/destroy methods, methods to add XPackets to the list for 
each PET, and methods to retrieve the XPackets from any list.

<P>
The top level class is a Route.  A Route object contains a send RTable, 
a recv RTable, a CommTable, and a pointer to a Virtual Machine.   
The VM must include all PETs which are participating
in this communication.
The Route methods
include create/destroy, setting a send or recv XPacket
for a particular PET,
and some higher level functions specific to each
type of communication, for example RoutePrecomputeHalo
or RoutePrecomputeRedist.  These latter functions
are where the XPackets are actually computed and added to
the Route table.  Each DE computes its own set of intersections,
either source or destination, and fills its own corresponding PET table.
The Route methods also include a RouteRun method which executes the code
which actually traverses the table and sends the information between PETs.

<P>
A RouteHandle class is a small helper class which is returned through
the public API to the user when a Route is created, and passed back in
through the API to select which precomputed Route is to be executed.
A RouteHandle contains a handle type and a pointer to a Route object.
In addition, for use only by the Regrid code, there is an additional Route
pointer and a TransformValues pointer.  (TransformValues is an internal
class only used by the Regridding code.)  If the RouteHandle describes the
Route for a FieldBundle, then the RouteHandle can contain a list of Routes,
one for each Field in the FieldBundle, and for Regrid use, a list of additional
Routes instead of a single Route.  There is also a flag to indicate whether
a single Route is applicable to all Fields in a FieldBundle or whether there
are multiple Routes.
The RouteHandle methods are fairly basic; mostly accessor methods
for getting and setting values.

<P>
</LI>
<LI><P>
While intended for any distributed data communication method,
the current implementation only builds a Route object for
the halo, redist, and regrid methods.  Scatter, Gather,
AllGather, and AlltoAll 
should have the option of building a Route for operations
which are executed repeatedly.  This should only require
writing a Precompute method for each one; the existing 
RouteRun can be invoked for these operations.
(This is a lack-of-implementation-time issue, not a design
or architecture issue.)

<P>
</LI>
<LI><P>
The original design included automatic detection of different
Routes and internal caching, so the user API did not have to
include a RouteHandle object to identify which Route was
being invoked.  However, users requested that the framework
not cache and that explicit RouteHandle arguments be created
and required to invoke the distributed data methods.
Nothing prevents this code from being revived from the CVS
repository and reinstated in the system, should automatic
caching be desired by future users.

<P>
</LI>
<LI><P>
The current distributed methods have 2 related but distinct
interfaces which differ in what information they require
and whether they use RouteHandles:

<P>
<DL COMPACT>
<DT>Precompute/Run/Release</DT>
<DD>This is the most frequently used interface set.
It contains 3 distinct phases: precomputing which bytes must
be moved, actually executing the communications operation,
and releasing the stored information.  This is intended for
any communication pattern which will be executed more than once.
</DD>
<DT>All-in-One</DT>
<DD>For a communication which will only be executed once, or in
any situation in which the user does not want to save a RouteHandle,
there are interfaces which do not have RouteHandles as part of
the argument list.  Internally the code computes a Route,
executes it, and releases the resources before returning.
</DD>
</DL>

<P>
</LI>
<LI><P>
The current CommTable code executes one very specific communication
strategy based on input from a user who did extensive timing
measurements on several different hardware platforms.  Rather than
broadcasting all data at once asychronously, it selects combinations
of pairs of processors and has them execute a SendRecv operation, which
does both a data send and a data receive in a single call.
At each step in the execution, different pairs of processors
exchange data until all pair combinations have been selected.

<P>
The table itself must be a power of 2 in size; the number of
PETs is rounded up to the next power of 2 and then all entries
for PETs larger than the actual number are marked as no-ops.

<P>
There are many alternative execution strategies, including a
completely asynchronous execution, in numeric PET order, without
computing processor pairs.  Also single-direction communications 
are possible (only the Send XPackets are processed, or only
the Receive XPackets) in either a synchronous or asynchronous mode.  
This would not require any changes to the XPacket or RTable classes,
but would require writing a set of alternative RouteRun methods.

<P>
</LI>
<LI><P>
The current RouteRun routine has many possible performance options for how
to make the tradeoff between time spent packing disjoint memory
blocks into a single buffer to minimize the number of sends,
verses simply sending the contiguous blocks without the pack overhead.
The tradeoffs are not expected to be the same on all systems;
hardware latency verses bandwith characteristics will differ,
plus the underlying communication software (MPI, shared memory, etc)
will change the performance.  Also the size of the data blocks
to be sent, the amount of contiguity, and limits on the number 
of outstanding communication buffers all affect what options are best.

<P>
The <TT>ESMF_RouteOptions</TT> are listed in <A HREF="node4.html#sec:routeoptions">29.3</A>; 
the following description contains more implementation detail 
about what each of the options
controls inside the execution of a Route.  Note that the options
do not affect the creation of a Route, nor any of the Precompute
code, and can optionally be changed each time the Route is run.

<P>
Packing options:
<DL COMPACT>
<DT>By Buffer</DT>
<DD>If multiple memory addresses are provided to RouteRun (from
bundle-level communications, for example), then this option
packs data across all buffers/blocks as specified by the other
packing flags before sending or receiving.
Note: unlike the other packing flags, this is handled in the
code at a higher level by either passing down multiple addresses
into the route run routine or not.  If multiple addresses are
passed into the run routine, they will be packed.  The "no-packing"
option at this level would be identical to looping at the outermost
level in the RouteRun code and therefore there is no disadvantage
to calling this routine once per address (and the advantage is
not adding yet another coding loop inside the already complex
RouteRun code).  The higher level list-of-address code can be
disabled by clearing this flag (which is on by default).
</DD>
<DT>By PET</DT>
<DD>All data from a single block
intended for a remote PET is packed into a single send
buffer, and sent in a single VM communications call.  
A buffer large enough to receive all data 
coming from that remote PET is allocated, the data is received,
and then the data is copied into the final location.
See <A HREF="node4.html#fig:routepackall">24</A>.
</DD>
<DT>By XP</DT>
<DD>All data described by a single XPacket (which is a n-dimensional
hyperslab of memory) is packed into a single buffer for sending,
and a single buffer large enough to receive an XPacket is 
allocated for receiving the data.
See <A HREF="node4.html#fig:routepack">23</A>.
</DD>
<DT>No Packing</DT>
<DD>A VM communication call is made for each single contiguous strip
of memory, regardless of how long or short.
</DD>
<DT>MPI Vector</DT>
<DD>MPI implements a set of interfaces for sending and receiving which
allows certain strided memory patterns to be sent in a single call.
The actual implementation is up to the MPI library itself.  But no
user-level data copy is needed in this case. (Not implemented yet.)
</DD>
</DL>
Note that in all packing options, if the XPacket describes a
chunk of memory which is completely contiguous, then the code
does not allocate a packing or unpacking buffer but supplies the
actual data address to the communications call so the data is
read or written in place.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:xpacketpack"></A><A NAME="36419"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 20:</STRONG>
A common XPacket pattern which generally benefits from
packing; the overlap region between 2 DEs during a halo update
are often short in the contiguous dimension and have a high 
repeat count.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Basic_xpacket_pack}}$
 -->
<IMG
 WIDTH="742" HEIGHT="582" ALIGN="BOTTOM" BORDER="0"
 SRC="img85.png"
 ALT="\scalebox{0.9}{\includegraphics{Basic_xpacket_pack}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:xpacket2up"></A><A NAME="36427"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 21:</STRONG>
When there are multiple XPackets destined for the
same remote PET there are more options for how to order the
contiguous pieces into a packed buffer.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Basic_xpacket_2up}}$
 -->
<IMG
 WIDTH="829" HEIGHT="517" ALIGN="BOTTOM" BORDER="0"
 SRC="img86.png"
 ALT="\scalebox{0.9}{\includegraphics{Basic_xpacket_2up}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:xpacketcontig"></A><A NAME="36433"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 22:</STRONG>
When the XPacket describes memory which is physically
a single contiguous region, there is no need to copy the data
into another buffer; it can be communicated inplace.  There is
a flag in the XPacket which marks how many of the dimensions
are contiguous.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Basic_xpacket_contig}}$
 -->
<IMG
 WIDTH="829" HEIGHT="517" ALIGN="BOTTOM" BORDER="0"
 SRC="img87.png"
 ALT="\scalebox{0.9}{\includegraphics{Basic_xpacket_contig}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:routepack"></A><A NAME="36443"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 23:</STRONG>
Often the overhead of making multiple communication calls 
outweighs the cost of copying non-contiguous data into a contiguous buffer,
sending it in a single operation, and then copying it to the final
memory locations on the receiving side.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Basic_pack_route}}$
 -->
<IMG
 WIDTH="828" HEIGHT="620" ALIGN="BOTTOM" BORDER="0"
 SRC="img88.png"
 ALT="\scalebox{0.9}{\includegraphics{Basic_pack_route}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:routepackall"></A><A NAME="36451"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 24:</STRONG>
Once there is more than a single XPacket to pack, there
are many more interleave options.  For example, packing in the
order: 1, 4, 2, 5, 3, 6 would also be possible here.  However
the code becomes more complicated when the XPackets have different
repeat counts, and has no real performance advantage over the
straightforward packing of each XPacket in sequence.  Note that
this packing is the same whether it refers to multiple XPackets
from the same memory buffer or from multiple buffers.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Basic_2up_route}}$
 -->
<IMG
 WIDTH="828" HEIGHT="537" ALIGN="BOTTOM" BORDER="0"
 SRC="img89.png"
 ALT="\scalebox{0.9}{\includegraphics{Basic_2up_route}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The following options refer to the internal strategy for 
executing the route and not to whether the user-level API call
returns before the route has finished executing.  The current
system only implements user-synchronous calls; asynchronous calls
are on the to-be-written list.

<P>
<DL COMPACT>
<DT>Sync</DT>
<DD>Each pair of processors exchanges data with the VM
equivalent of an MPI_SendRecv() call, which does not return until
both the send and receive have completed.

<P>
</DD>
<DT>Async</DT>
<DD>Each processor executes both an asynchronous send
and asychronous receive to the other processor and does not wait
for completion before moving on to the next communication in the
CommTable.  Then in a separate loop through the RTables, each
call is waited for in turn and when all outstanding communication
calls have completed, then the API call returns to the user.

<P>
</DD>
</DL>
(Note that in the Async case it makes much more sense to iterate
throught the Route table in PET order instead of the complication
of computing communication pairs and iterating in a non-sequential
order.  The code is as it is now for reasons of implementation speed
and not for any other design reason.  This would require a slightly
simpler, but separate, version of the RouteRun() subroutine.)

<P>
</LI>
<LI><P>
FieldBundle-level communication calls have additional packing options
under certain circumstances.  FieldBundles are groups of Fields which
share the same Grid, but they are not required to share the same
data types, data ranks, nor relative data locations.  FieldBundles
in which these things are the same in all Fields are marked inside the
bundle code as being <B>congruent</B>.  At communication store time
FieldBundles which have congruent data in all the Fields have the option
of packing all Field data together into fewer communication calls
which generally is expected to give better performance.   
Fields where the data is not of the same type or perhaps not
the same number of items (e.g. different rank, vertex-centered data
vs. cell centered data) can in theory also be packed but in fact
the code becomes more complicated, and in the case of differing
data types may cause system errors because of accessing data
on non-standard byte offsets or putting mixing integer data
with floating data and causing NaN (not a number) exceptions.
In this case, the conservative implementation strategy is to construct 
a separate Route object for each Field, all enclosed in the same
RouteHandle.  Inside the FieldBundle communication code the execution
for both types of FieldBundles is identical for the caller, but inside
the congruent FieldBundle code calls the <TT>ESMF_RouteRun()</TT> code
once and all communication for all Fields in the FieldBundle is done
when it returns.  The non-congruent FieldBundles execute a separate
<TT>ESMF_RouteRun()</TT> call for each Field and return to the user 
when all Field data have been sent/received.

<P>
There are comments in the code for an intermediate level of
optimization in which the FieldBundle code determines the smallest
number of unique types of Fields in the FieldBundle, and all same types
share the same Route object, but this has not been implemented
at this time.  Once the existing code has been in use for a while,
whether this is useful or needed may become more clear.

<P>
</LI>
<LI><P>
The precompute code for all operations must have enough
information to compute which parts of the data arrays
are expected to be sent to remote PETs and also what
remote data is expected to be received by this PET.

<P>
These computations depend heavily on what type of distributed
method is being executed.  The regridding methods are described
in detail separately in the Regrid Design and Implementation Notes
section.  The halo and redistribution operations are described here.

<P>
<DL COMPACT>
<DT>Halo</DT>
<DD>The total array area, which includes any halo regions,
are intersected with the computational
area of other DEs. The overlap regions are converted from index
space into memory space and stored as XPackets in the RTables.
This code must be aware of: whether the grid was defined as
periodic in any or all of the dimensions since that affects
which halo regions overlap at the grid edges; if the data
is only decomposed into a single block in any dimension (which
means it halos with itself); and if the halo region is large
enough that a halo operation may require intersection with
the N+1 neighbor in any dimension.  

<P>
</DD>
<DT>Redistribute</DT>
<DD>Each DE computes the overlap
between its own computational region and all DEs in the 
remote Grid, again only working in computational area.  
The overlap regions are converted from index
space into memory space and stored as XPackets in the RTables.
After execution a redistribution, a halo operation may be required
to populate any halo regions with consistent data.

<P>
</DD>
</DL>
(Note: the Redistribution code has been reimplemented to intersect
the DEs in index space and then convert the overlap region to an XPacket
representation.  Halo still converts the regions from AxisIndex to 
XPackets and then intersects the XPackets, but this code needs to be
changed to intersect in AxisIndex space and once the overlap is computed
then convert to XPackets.  Intersecting AxisIndex objects is very 
much simpler, both to understand and to execute, and more easily 
extensible to multiple dimensions than intersecting XPackets.)

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION040145000000000000000">
29.5 Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the public
RouteHandle class.  See Appendix A, <I>A Brief Introduction to UML</I>, for a
translation table that lists the symbols in the diagram and their meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="771" HEIGHT="316" ALIGN="BOTTOM" BORDER="0"
 SRC="img90.png"
 ALT="\includegraphics[]{RouteHandle_obj}">

</DIV>

<P>

<H2><A NAME="SECTION040146000000000000000"></A>
<A NAME="sec:regrid:offline"></A>
<BR>
29.6 File Based Regrid Weight Applications
</H2>

<P>

<H3><A NAME="SECTION040146100000000000000">
29.6.1 Structured Grid to Structured Grid</A>
</H3>

<P>
In addition to the online regridding functionality, the ESMF distribution also 
contains an exectuable for generating regridding weights. This tool reads in
two grid files and outputs weights for interpolation
between the two grids. The input and output files are all in netcdf format. The grid files are in 
the same format as is used as an input to SCRIP&nbsp;[<A
 HREF="node6.html#ref:SCRIP">20</A>] and the weight file is the same format as is output 
by SCRIP. The interpolation weights can be generated with either the bilinear
or patch method, both are described below, and there are also conservative regridding 
and pole handling options available.
This application assumes that the source and destination grids
are spherical and that the coordinates given in the files are latitude and longitude
values. This file based regrid weight generation application is fully parallel.

<P>
To generate the interpolation weights, this tool first constructs two ESMF_Mesh 
structures, one for the source and one for the destination grid. The Meshes are constructed from
the cell centers in the grid files, so the interpolation weights generated are for those points. 
The coordinates for the Meshes are three dimensional, and are generated by mapping 
the latitudes and longitudes in the input grid files to 
3D Cartesian coordinates. The regridding occurs in 3D to avoid
problems with periodicity and with the pole singularity. To achieve periodicity 
the Meshes are constructed so that their left and right boundaries are connected. 
Unless the pole option is turned off, the polar region is handled by constructing 
an artificial point in the center of the top and bottom row of grid points. 
The pole is located at the average of the position of the points surrounding
it, but moved in the z-direction to be at the same radius as the rest of the points
in the grid. There are a couple of options for what value is used at the pole. 
The default is for the value at the pole to be the average of the values
of all of the grid points surrounding the pole. For another option, the user may also choose
a number N from 1 to the number of source grid points around the pole. For
each destination point, the value at the pole is then the average of the N source points
surrounding that destination point.

<P>
This regridding application can be used to generate either bilinear or patch interpolation weights. The default interpolation method
is bilinear. The algorithm used by this application to generate the bilinear weights is the standard one found in
many textbooks.  Each destination point is mapped to a location in the source Mesh, the position of the destination point relative 
to the source points surrounding it is used to calculate the interpolation weights. 

<P>
This application can also be used to generate patch interpolation weights. Patch
interpolation is the ESMF version of a techique called ``patch recovery'' commonly
used in finite element modeling&nbsp;[<A
 HREF="node6.html#PatchInterp1">3</A>]&nbsp;[<A
 HREF="node6.html#PatchInterp2">14</A>]. It typically results in better approximations to values and derivatives when compared to bilinear interpolation.  
Patch interpolation works by constructing multiple polynomial patches to represent
the data in a source element. For 2D grids, these polynomials 
are currently 2nd degree 2D polynomials. The interpolated value at the destination point 
is the weighted average of the values of the patches at that point. 

<P>
The patch interpolation process works as follows. 
For each source element containing a destination point
we construct a patch for each corner node that makes up the element (e.g. 4 patches for 
quadrilateral elements, 3 for triangular elements). To construct a polynomial patch for
 a corner node we gather all the elements around that node. 
(Note that this means that the patch interpolation weights depends on the source 
element's nodes, and the nodes of all elements neighboring the source element.)  
We then use a least squares fitting algorithm to choose the set of coefficients 
for the polynomial that produces the best fit for the data in the elements. 
This polynomial will give a value at the destination point that fits the source data 
in the elements surrounding the corner node. We then repeat this process for each 
corner node of the source element generating a new polynomial for each set of elements.  
To calculate the value at the destination point we do a weighted average of the values 
of each of the corner polynomials evaluated at that point. The weight for a corner's 
polynomial is the bilinear weight of the destination point with regard to that corner.  

<P>
Global first-order conservative interpolation weights are also available with the 
file based regrid application. When this option is selected a conservative modification
is applied to the interpolation weights using the L2 method.  The L2 method in ESMF is based
on a finite element method to constrain the interpolation for global conservation of 
mass.  The conservative option can be used with either the patch or bilinear interpolation
and any of the pole options.  If this option is selected, integration weights will be
written to the output file containing the interpolation weights. 
Note that conservation is still in beta and should only be used with extreme caution.
It can have interpolation problems with certain combinations of source and destination grid. 
Particularly those where a high resolution area in the destination aligns with a lower resolution 
region in the source. 

<P>
The file based weight generation tool is located in src/Infrastructure/Mesh/examples 
directory and is called <TT>ESMC_RegridWgtGenEx</TT>. To use this tool ESMF must be compiled 
with the PNETCDF third party library. If the user wishes to use patch interpolation, 
then ESMF must additionally be compiled with the LAPACK third party library. Please see the 
``Third Party Libraries'' section of the ESMF User Guide for more information on this. 
The format for using the executable is as follows:

<P>
<PRE>
ESMC_RegridWgtGenEx [-conservative C] [-method M] [-pole P] &lt;src&gt; &lt;dst&gt; &lt;weights&gt;

Where:

 -conservative - An optional flag for indicating whether the interpolation weights should
                 be generated using the L2 conservation correction to the interpolation
                 method.  If this option is not specified it will default to "off".  The 
                 value C indicates the option that is given for this flag, C can have 
                 the following values:

                 off - Conservative correction is turned off. 
                 on  - Conservative correction is turned on.  

 -method       - An optional flag for indicating which interpolation method will be used.
                 If this option is not specified, then it will default to "bilinear".
                 The value M indicates which option is desired and it can have these 
                 values:

                 bilinear - This option selects the standard bilinear interpolation, this
                            is also the default option.
                 patch    - This option selects the ESMF version of patch recovery 
                            interpolation.

 -pole         - An optional flag for indicating what to do at the pole. If not 
                 specified, the pole defaults to option ``all'' described below. The 
                 value P indicates what should happen at the pole. P can have these 
                 values:

                 none - No pole, the source grid ends at the top (and bottom) row of 
                        nodes specified in &lt;source grid&gt;.
                 all  - Construct an artificial pole placed in the center of the 
                        top (or bottom) row of nodes, but projected onto the sphere 
                        formed by the rest of the grid. The value at this pole is the 
                        average of all the pole values.
                 &lt;N&gt;  - Construct an artificial pole placed in the center of the 
                        top (or bottom) row of nodes, but projected onto the sphere 
                        formed by the rest of the grid. The value at this pole is the 
                        average of the N source nodes next to the pole and surrounding
                        the destination point (i.e. the value may differ for each
                        destination point. Here N ranges from 1 to the number of nodes 
                        around the pole. 
                  
 &lt;src&gt;         - The netcdf file which holds the source grid for the interpolation. 
 
 &lt;dst&gt;         - The netcdf file which holds the destination grid for the interpolation. 

 &lt;weights&gt;     - The netcdf file which will contain the patch interpolation weights 
                 generated by the program.
</PRE>

<P>

<H3><A NAME="SECTION040146200000000000000">
29.6.2 Cubed Sphere to Structured Grid</A>
</H3>

<P>
In addition to the structured grid offline regridding functionality, the ESMF distribution also 
contains an exectuable for generating regridding weights between a cubed sphere grid and
a structured grid. This tool reads in two grid files and outputs weights for interpolation
between the two grids. The input and output files are all in netcdf format. The grid files are in 
the same format as is used as an input to SCRIP&nbsp;[<A
 HREF="node6.html#ref:SCRIP">20</A>] and the weight file is the same format as is output 
by SCRIP.  The interpolation weights can be generated with either the bilinear or patch
regridding methods. This application assumes that the source and destination grids
are spherical and that the coordinates given in the files are latitude and longitude
values. This file based regrid weight generation application generates the interpolation weights
in parallel.

<P>
To generate the interpolation weights, this tool first constructs two ESMF_Mesh 
structures, one for the source and one for the destination grid. The Meshes are constructed from
the cell centers in the grid files, so the interpolation weights generated are for those points. 
The coordinates for the Meshes are three dimensional, and are generated by mapping 
the latitudes and longitudes in the input grid files to 
3D Cartesian coordinates. The regridding occurs in 3D to avoid
problems with the pole singularity. The cubed sphere grid is converted directly to 
a Mesh as is, but to achieve periodicity and to handle the pole, the structured grid
has some connectivity added. For the structured grid, the mesh is constructed so that 
it's left and right boundaries are connected. The polar region is handled by constructing 
an artificial point in the center of the top and bottom row of grid points. 
The pole is located at the average of the position of the points surrounding
it, but moved in the z-direction to be at the same radius as the rest of the points
in the grid. The value at the pole to be the average of the values
of all of the grid points surrounding the pole. 

<P>
This regridding application can be used to generate either bilinear or patch interpolation weights. The 
algorithm used by this application to generate the bilinear weights is the standard one found in
many textbooks.  Each destination point is mapped to a location in the source Mesh, the position of the destination point relative 
to the source points surrounding it is used to calculate the interpolation weights. 

<P>
This application can also be used to generate patch interpolation weights. Patch
interpolation is the ESMF version of a techique called ``patch recovery'' commonly
used in finite element modeling&nbsp;[<A
 HREF="node6.html#PatchInterp1">3</A>]&nbsp;[<A
 HREF="node6.html#PatchInterp2">14</A>]. It typically results in better approximations to values and derivatives when compared to bilinear interpolation.  
Patch interpolation works by constructing multiple polynomial patches to represent
the data in a source element. For 2D grids, these polynomials 
are currently 2nd degree 2D polynomials. The interpolated value at the destination point 
is the weighted average of the values of the patches at that point. 

<P>
The patch interpolation process works as follows. 
For each source element containing a destination point
we construct a patch for each corner node that makes up the element (e.g. 4 patches for 
quadrilateral elements, 3 for triangular elements). To construct a polynomial patch for
 a corner node we gather all the elements around that node. 
(Note that this means that the patch interpolation weights depends on the source 
element's nodes, and the nodes of all elements neighboring the source element.)  
We then use a least squares fitting algorithm to choose the set of coefficients 
for the polynomial that produces the best fit for the data in the elements. 
This polynomial will give a value at the destination point that fits the source data 
in the elements surrounding the corner node. We then repeat this process for each 
corner node of the source element generating a new polynomial for each set of elements.  
To calculate the value at the destination point we do a weighted average of the values 
of each of the corner polynomials evaluated at that point. The weight for a corner's 
polynomial is the bilinear weight of the destination point with regard to that corner.  

<P>
The file based weight generation tool is located in src/Infrastructure/Mesh/examples 
directory and is called <TT>ESMF_CubedSphereRegridEx</TT>. To use this tool ESMF must be compiled 
with the NETCDF third party library. If the user wishes to use patch interpolation, 
then ESMF must additionally be compiled with the LAPACK third party library. Please see the 
``Third Party Libraries'' section of the ESMF User Guide for more information on this. 
The format for using the executable is as follows:

<P>
<PRE>
ESMF_CubedSphereRegridEx &lt;cubed_grid&gt; &lt;struct_grid&gt; &lt;weights&gt; method [rev]

Where:
                  
 &lt;cubed_grid&gt;  - The netcdf file which holds the cubed sphere grid for the interpolation. 
 
 &lt;struct_grid&gt; - The netcdf file which holds the structured grid for the interpolation. 

 &lt;weights&gt;     - The netcdf file which will contain the patch interpolation weights 
                 generated by the program.

  method       - A flag for indicating which interpolation method will be used.
                 The flag can have one of these values:

                 bilinear     - This option selects the standard bilinear interpolation.
                 patch        - This option selects the ESMF version of patch recovery 
                                interpolation.

  rev          - An optional flag that indicates the direction of the regridding. If not 
                 specified the &lt;cubed_grid&gt; is the source and the &lt;struct_grid&gt; is the 
                 destination. If 'rev' is specified, then the reverse interpolation is 
                 performed.
</PRE>

<P>

<P>

<P>

<HR>
<!--Navigation Panel-->
<A NAME="tex2html1450"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1446"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1440"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1448"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1451"
  HREF="node5.html">4 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html1447"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1441"
  HREF="node3.html">2 Superstructure</A>
 &nbsp <B>  <A NAME="tex2html1449"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
