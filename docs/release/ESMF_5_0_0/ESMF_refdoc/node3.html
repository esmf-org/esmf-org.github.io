<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002 (1.67)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>2 Superstructure</TITLE>
<META NAME="description" CONTENT="2 Superstructure">
<META NAME="keywords" CONTENT="ESMF_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node4.html">
<LINK REL="previous" HREF="node2.html">
<LINK REL="up" HREF="ESMF_refdoc.html">
<LINK REL="next" HREF="node4.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html1310"
  HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1306"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1300"
  HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1308"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1311"
  HREF="node4.html">3 Infrastructure: Fields and</A>
<B> Up:</B> <A NAME="tex2html1307"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1301"
  HREF="node2.html">1 ESMF Overview</A>
 &nbsp <B>  <A NAME="tex2html1309"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html1312"
  HREF="node3.html#SECTION03010000000000000000">11 Overview of Superstructure</A>
<UL>
<LI><A NAME="tex2html1313"
  HREF="node3.html#SECTION03011000000000000000">11.1 Superstructure Classes</A>
<LI><A NAME="tex2html1314"
  HREF="node3.html#SECTION03012000000000000000">11.2 Hierarchical Creation of Components</A>
<LI><A NAME="tex2html1315"
  HREF="node3.html#SECTION03013000000000000000">11.3 Sequential and Concurrent Execution of Components</A>
<LI><A NAME="tex2html1316"
  HREF="node3.html#SECTION03014000000000000000">11.4 Intra-Component Communication</A>
<LI><A NAME="tex2html1317"
  HREF="node3.html#SECTION03015000000000000000">11.5 Data Distribution and Scoping in Components</A>
<LI><A NAME="tex2html1318"
  HREF="node3.html#SECTION03016000000000000000">11.6 Performance</A>
<LI><A NAME="tex2html1319"
  HREF="node3.html#SECTION03017000000000000000">11.7 Object Model</A>
</UL>
<LI><A NAME="tex2html1320"
  HREF="node3.html#SECTION03020000000000000000">12 Application Driver and Required ESMF Methods</A>
<UL>
<LI><A NAME="tex2html1321"
  HREF="node3.html#SECTION03021000000000000000">12.1 Description</A>
<LI><A NAME="tex2html1322"
  HREF="node3.html#SECTION03022000000000000000">12.2 Application Driver and Required ESMF Methods Options</A>
<UL>
<LI><A NAME="tex2html1323"
  HREF="node3.html#SECTION03022100000000000000">12.2.1 ESMF_TerminationFlag</A>
</UL>
<LI><A NAME="tex2html1324"
  HREF="node3.html#SECTION03023000000000000000">12.3 Use and Examples</A>
<LI><A NAME="tex2html1325"
  HREF="node3.html#SECTION03024000000000000000">12.4 Required ESMF Methods</A>
<UL>
<LI><A NAME="tex2html1326"
  HREF="node3.html#SECTION03024100000000000000">12.4.1 ESMF_Initialize</A>
<LI><A NAME="tex2html1327"
  HREF="node3.html#SECTION03024200000000000000">12.4.2 ESMF_Finalize</A>
<LI><A NAME="tex2html1328"
  HREF="node3.html#SECTION03024300000000000000">12.4.3 User-Code SetServices Method</A>
<LI><A NAME="tex2html1329"
  HREF="node3.html#SECTION03024400000000000000">12.4.4 User-Code Initialize, Run, and Finalize Methods</A>
<LI><A NAME="tex2html1330"
  HREF="node3.html#SECTION03024500000000000000">12.4.5 User-Code SetVM Method</A>
</UL>
</UL>
<LI><A NAME="tex2html1331"
  HREF="node3.html#SECTION03030000000000000000">13 GridComp Class</A>
<UL>
<LI><A NAME="tex2html1332"
  HREF="node3.html#SECTION03031000000000000000">13.1 Description</A>
<LI><A NAME="tex2html1333"
  HREF="node3.html#SECTION03032000000000000000">13.2 GridComp Options</A>
<UL>
<LI><A NAME="tex2html1334"
  HREF="node3.html#SECTION03032100000000000000">13.2.1 ESMF_GridCompType</A>
</UL>
<LI><A NAME="tex2html1335"
  HREF="node3.html#SECTION03033000000000000000">13.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1336"
  HREF="node3.html#SECTION03033100000000000000">13.3.1 Implementing a User-Code SetServices Routine</A>
<LI><A NAME="tex2html1337"
  HREF="node3.html#SECTION03033200000000000000">13.3.2 Implementing a User-Code Initialize Routine</A>
<LI><A NAME="tex2html1338"
  HREF="node3.html#SECTION03033300000000000000">13.3.3 Implementing a User-Code Run Routine</A>
<LI><A NAME="tex2html1339"
  HREF="node3.html#SECTION03033400000000000000">13.3.4 Implementing a User-Code Finalize Routine</A>
<LI><A NAME="tex2html1340"
  HREF="node3.html#SECTION03033500000000000000">13.3.5 Implementing a User-Code SetVM Routine</A>
<LI><A NAME="tex2html1341"
  HREF="node3.html#SECTION03033600000000000000">13.3.6 Setting and Getting the Internal State</A>
</UL>
<LI><A NAME="tex2html1342"
  HREF="node3.html#SECTION03034000000000000000">13.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html1343"
  HREF="node3.html#SECTION03035000000000000000">13.5 Class API</A>
<UL>
<LI><A NAME="tex2html1344"
  HREF="node3.html#SECTION03035100000000000000">13.5.1 ESMF_GridCompCreate</A>
<LI><A NAME="tex2html1345"
  HREF="node3.html#SECTION03035200000000000000">13.5.2 ESMF_GridCompDestroy</A>
<LI><A NAME="tex2html1346"
  HREF="node3.html#SECTION03035300000000000000">13.5.3 ESMF_GridCompFinalize</A>
<LI><A NAME="tex2html1347"
  HREF="node3.html#SECTION03035400000000000000">13.5.4 ESMF_GridCompGet</A>
<LI><A NAME="tex2html1348"
  HREF="node3.html#SECTION03035500000000000000">13.5.5 ESMF_GridCompGetInternalState</A>
<LI><A NAME="tex2html1349"
  HREF="node3.html#SECTION03035600000000000000">13.5.6 ESMF_GridCompInitialize</A>
<LI><A NAME="tex2html1350"
  HREF="node3.html#SECTION03035700000000000000">13.5.7 ESMF_GridCompIsPetLocal</A>
<LI><A NAME="tex2html1351"
  HREF="node3.html#SECTION03035800000000000000">13.5.8 ESMF_GridCompPrint</A>
<LI><A NAME="tex2html1352"
  HREF="node3.html#SECTION03035900000000000000">13.5.9 ESMF_GridCompReadRestart</A>
<LI><A NAME="tex2html1353"
  HREF="node3.html#SECTION030351000000000000000">13.5.10 ESMF_GridCompRun</A>
<LI><A NAME="tex2html1354"
  HREF="node3.html#SECTION030351100000000000000">13.5.11 ESMF_GridCompSet</A>
<LI><A NAME="tex2html1355"
  HREF="node3.html#SECTION030351200000000000000">13.5.12 ESMF_GridCompSetEntryPoint</A>
<LI><A NAME="tex2html1356"
  HREF="node3.html#SECTION030351300000000000000">13.5.13 ESMF_GridCompSetInternalState</A>
<LI><A NAME="tex2html1357"
  HREF="node3.html#SECTION030351400000000000000">13.5.14 ESMF_GridCompSetServices</A>
<LI><A NAME="tex2html1358"
  HREF="node3.html#SECTION030351500000000000000">13.5.15 ESMF_GridCompSetServices</A>
<LI><A NAME="tex2html1359"
  HREF="node3.html#SECTION030351600000000000000">13.5.16 ESMF_GridCompSetVM</A>
<LI><A NAME="tex2html1360"
  HREF="node3.html#SECTION030351700000000000000">13.5.17 ESMF_GridCompSetVM</A>
<LI><A NAME="tex2html1361"
  HREF="node3.html#SECTION030351800000000000000">13.5.18 ESMF_GridCompSetVMMaxPEs</A>
<LI><A NAME="tex2html1362"
  HREF="node3.html#SECTION030351900000000000000">13.5.19 ESMF_GridCompSetVMMaxThreads</A>
<LI><A NAME="tex2html1363"
  HREF="node3.html#SECTION030352000000000000000">13.5.20 ESMF_GridCompSetVMMinThreads</A>
<LI><A NAME="tex2html1364"
  HREF="node3.html#SECTION030352100000000000000">13.5.21 ESMF_GridCompValidate</A>
<LI><A NAME="tex2html1365"
  HREF="node3.html#SECTION030352200000000000000">13.5.22 ESMF_GridCompWait</A>
<LI><A NAME="tex2html1366"
  HREF="node3.html#SECTION030352300000000000000">13.5.23 ESMF_GridCompWriteRestart</A>
</UL>
</UL>
<LI><A NAME="tex2html1367"
  HREF="node3.html#SECTION03040000000000000000">14 CplComp Class</A>
<UL>
<LI><A NAME="tex2html1368"
  HREF="node3.html#SECTION03041000000000000000">14.1 Description</A>
<LI><A NAME="tex2html1369"
  HREF="node3.html#SECTION03042000000000000000">14.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1370"
  HREF="node3.html#SECTION03042100000000000000">14.2.1 Implementing a User-Code SetServices Routine</A>
<LI><A NAME="tex2html1371"
  HREF="node3.html#SECTION03042200000000000000">14.2.2 Implementing a User-Code Initialize Routine</A>
<LI><A NAME="tex2html1372"
  HREF="node3.html#SECTION03042300000000000000">14.2.3 Implementing a User-Code Run Routine</A>
<LI><A NAME="tex2html1373"
  HREF="node3.html#SECTION03042400000000000000">14.2.4 Implementing a User-Code Finalize Routine</A>
<LI><A NAME="tex2html1374"
  HREF="node3.html#SECTION03042500000000000000">14.2.5 Implementing a User-Code SetVM Routine</A>
</UL>
<LI><A NAME="tex2html1375"
  HREF="node3.html#SECTION03043000000000000000">14.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1376"
  HREF="node3.html#SECTION03044000000000000000">14.4 Class API</A>
<UL>
<LI><A NAME="tex2html1377"
  HREF="node3.html#SECTION03044100000000000000">14.4.1 ESMF_CplCompCreate</A>
<LI><A NAME="tex2html1378"
  HREF="node3.html#SECTION03044200000000000000">14.4.2 ESMF_CplCompDestroy</A>
<LI><A NAME="tex2html1379"
  HREF="node3.html#SECTION03044300000000000000">14.4.3 ESMF_CplCompFinalize</A>
<LI><A NAME="tex2html1380"
  HREF="node3.html#SECTION03044400000000000000">14.4.4 ESMF_CplCompGet</A>
<LI><A NAME="tex2html1381"
  HREF="node3.html#SECTION03044500000000000000">14.4.5 ESMF_CplCompGetInternalState</A>
<LI><A NAME="tex2html1382"
  HREF="node3.html#SECTION03044600000000000000">14.4.6 ESMF_CplCompInitialize</A>
<LI><A NAME="tex2html1383"
  HREF="node3.html#SECTION03044700000000000000">14.4.7 ESMF_CplCompIsPetLocal</A>
<LI><A NAME="tex2html1384"
  HREF="node3.html#SECTION03044800000000000000">14.4.8 ESMF_CplCompPrint</A>
<LI><A NAME="tex2html1385"
  HREF="node3.html#SECTION03044900000000000000">14.4.9 ESMF_CplCompReadRestart</A>
<LI><A NAME="tex2html1386"
  HREF="node3.html#SECTION030441000000000000000">14.4.10 ESMF_CplCompRun</A>
<LI><A NAME="tex2html1387"
  HREF="node3.html#SECTION030441100000000000000">14.4.11 ESMF_CplCompSet</A>
<LI><A NAME="tex2html1388"
  HREF="node3.html#SECTION030441200000000000000">14.4.12 ESMF_CplCompSetEntryPoint</A>
<LI><A NAME="tex2html1389"
  HREF="node3.html#SECTION030441300000000000000">14.4.13 ESMF_CplCompSetInternalState</A>
<LI><A NAME="tex2html1390"
  HREF="node3.html#SECTION030441400000000000000">14.4.14 ESMF_CplCompSetServices</A>
<LI><A NAME="tex2html1391"
  HREF="node3.html#SECTION030441500000000000000">14.4.15 ESMF_CplCompSetServices</A>
<LI><A NAME="tex2html1392"
  HREF="node3.html#SECTION030441600000000000000">14.4.16 ESMF_CplCompSetVM</A>
<LI><A NAME="tex2html1393"
  HREF="node3.html#SECTION030441700000000000000">14.4.17 ESMF_CplCompSetVM</A>
<LI><A NAME="tex2html1394"
  HREF="node3.html#SECTION030441800000000000000">14.4.18 ESMF_CplCompSetVMMaxPEs</A>
<LI><A NAME="tex2html1395"
  HREF="node3.html#SECTION030441900000000000000">14.4.19 ESMF_CplCompSetVMMaxThreads</A>
<LI><A NAME="tex2html1396"
  HREF="node3.html#SECTION030442000000000000000">14.4.20 ESMF_CplCompSetVMMinThreads</A>
<LI><A NAME="tex2html1397"
  HREF="node3.html#SECTION030442100000000000000">14.4.21 ESMF_CplCompValidate</A>
<LI><A NAME="tex2html1398"
  HREF="node3.html#SECTION030442200000000000000">14.4.22 ESMF_CplCompWait</A>
<LI><A NAME="tex2html1399"
  HREF="node3.html#SECTION030442300000000000000">14.4.23 ESMF_CplCompWriteRestart</A>
</UL>
</UL>
<LI><A NAME="tex2html1400"
  HREF="node3.html#SECTION03050000000000000000">15 State Class</A>
<UL>
<LI><A NAME="tex2html1401"
  HREF="node3.html#SECTION03051000000000000000">15.1 Description</A>
<LI><A NAME="tex2html1402"
  HREF="node3.html#SECTION03052000000000000000">15.2 State Options</A>
<UL>
<LI><A NAME="tex2html1403"
  HREF="node3.html#SECTION03052100000000000000">15.2.1 ESMF_StateItemType</A>
<LI><A NAME="tex2html1404"
  HREF="node3.html#SECTION03052200000000000000">15.2.2 ESMF_StateType</A>
</UL>
<LI><A NAME="tex2html1405"
  HREF="node3.html#SECTION03053000000000000000">15.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1406"
  HREF="node3.html#SECTION03053100000000000000">15.3.1 Empty State Create</A>
<LI><A NAME="tex2html1407"
  HREF="node3.html#SECTION03053200000000000000">15.3.2 Adding Items to a State</A>
<LI><A NAME="tex2html1408"
  HREF="node3.html#SECTION03053300000000000000">15.3.3 Adding Placeholders to a State</A>
<LI><A NAME="tex2html1409"
  HREF="node3.html#SECTION03053400000000000000">15.3.4 Marking an Item Needed</A>
<LI><A NAME="tex2html1410"
  HREF="node3.html#SECTION03053500000000000000">15.3.5 Creating a Needed Item</A>
<LI><A NAME="tex2html1411"
  HREF="node3.html#SECTION03053600000000000000">15.3.6 Initialization and SetServices Routines</A>
<LI><A NAME="tex2html1412"
  HREF="node3.html#SECTION03053700000000000000">15.3.7 Creating Components on subsets of the current PET list</A>
<LI><A NAME="tex2html1413"
  HREF="node3.html#SECTION03053800000000000000">15.3.8 Invoking Components on a subset of the Parent PETs</A>
<LI><A NAME="tex2html1414"
  HREF="node3.html#SECTION03053900000000000000">15.3.9 Using State Reconcile</A>
<LI><A NAME="tex2html1415"
  HREF="node3.html#SECTION030531000000000000000">15.3.10 State Read/Write from/to a NetCDF file</A>
<LI><A NAME="tex2html1416"
  HREF="node3.html#SECTION030531100000000000000">15.3.11 ESMF Initialization and Empty State Create</A>
<LI><A NAME="tex2html1417"
  HREF="node3.html#SECTION030531200000000000000">15.3.12 Reading Arrays from a NetCDF file and Adding to a State</A>
<LI><A NAME="tex2html1418"
  HREF="node3.html#SECTION030531300000000000000">15.3.13 Printing Array data from a State</A>
<LI><A NAME="tex2html1419"
  HREF="node3.html#SECTION030531400000000000000">15.3.14 Writing Array data within a State to a NetCDF file</A>
<LI><A NAME="tex2html1420"
  HREF="node3.html#SECTION030531500000000000000">15.3.15 Destroying a State and its constituent Arrays</A>
</UL>
<LI><A NAME="tex2html1421"
  HREF="node3.html#SECTION03054000000000000000">15.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html1422"
  HREF="node3.html#SECTION03055000000000000000">15.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html1423"
  HREF="node3.html#SECTION03056000000000000000">15.6 Object Model</A>
<LI><A NAME="tex2html1424"
  HREF="node3.html#SECTION03057000000000000000">15.7 Class API</A>
<UL>
<LI><A NAME="tex2html1425"
  HREF="node3.html#SECTION03057100000000000000">15.7.1 ESMF_StateAdd</A>
<LI><A NAME="tex2html1426"
  HREF="node3.html#SECTION03057200000000000000">15.7.2 ESMF_StateAdd</A>
<LI><A NAME="tex2html1427"
  HREF="node3.html#SECTION03057300000000000000">15.7.3 ESMF_StateCreate</A>
<LI><A NAME="tex2html1428"
  HREF="node3.html#SECTION03057400000000000000">15.7.4 ESMF_StateDestroy</A>
<LI><A NAME="tex2html1429"
  HREF="node3.html#SECTION03057500000000000000">15.7.5 ESMF_StateGet</A>
<LI><A NAME="tex2html1430"
  HREF="node3.html#SECTION03057600000000000000">15.7.6 ESMF_StateGet</A>
<LI><A NAME="tex2html1431"
  HREF="node3.html#SECTION03057700000000000000">15.7.7 ESMF_StateGet</A>
<LI><A NAME="tex2html1432"
  HREF="node3.html#SECTION03057800000000000000">15.7.8 ESMF_StateGetNeeded</A>
<LI><A NAME="tex2html1433"
  HREF="node3.html#SECTION03057900000000000000">15.7.9 ESMF_StateIsNeeded</A>
<LI><A NAME="tex2html1434"
  HREF="node3.html#SECTION030571000000000000000">15.7.10 ESMF_StatePrint</A>
<LI><A NAME="tex2html1435"
  HREF="node3.html#SECTION030571100000000000000">15.7.11 ESMF_StateRead</A>
<LI><A NAME="tex2html1436"
  HREF="node3.html#SECTION030571200000000000000">15.7.12 ESMF_StateWrite</A>
<LI><A NAME="tex2html1437"
  HREF="node3.html#SECTION030571300000000000000">15.7.13 ESMF_StateReconcile</A>
<LI><A NAME="tex2html1438"
  HREF="node3.html#SECTION030571400000000000000">15.7.14 ESMF_StateSetNeeded</A>
<LI><A NAME="tex2html1439"
  HREF="node3.html#SECTION030571500000000000000">15.7.15 ESMF_StateValidate</A>
</UL></UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION03000000000000000000">
2 Superstructure</A>
</H1>

<P>
<A NAME="part:Superstructure"></A>
<P>

<P>

<P>

<H1><A NAME="SECTION03010000000000000000">
11 Overview of Superstructure</A>
</H1>

<P>
ESMF superstructure classes define an architecture for assembling
Earth system applications from modeling <B>components</B>.  A component
may be defined in terms of the physical domain that it represents,
such as an atmosphere or sea ice model.  It may also be defined in terms
of a computational function, such as a data assimilation system.
Earth system research often requires that such components be <B>coupled</B> 
together to create an application.  By coupling we mean the data 
transformations and, on parallel computing systems, data transfers, 
that are necessary to allow data from one component to be utilized by 
another.  ESMF offers regridding methods and other tools to simplify 
the organization and execution of inter-component data exchanges.  

<P>
In addition to components defined at the level of major physical 
domains and computational functions, components may be defined that 
represent smaller computational functions within larger components, 
such as the transformation of data between the physics and dynamics 
in a spectral atmosphere model, 
or the creation of nested higher resolution regions 
within a coarser grid.  The objective is to couple components at varying 
scales both flexibly and efficiently.  ESMF encourages a hierachical
application structure, in which large components branch into 
smaller sub-components (see Figure <A HREF="node3.html#fig:GEOS5">2</A>).  ESMF also makes 
it easier for the same component to be used in multiple contexts 
without changes to its source code.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Modular, component-based architecture.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Hierarchical assembly of components into applications.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Use of components in multiple contexts without modification.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Sequential or concurrent component execution.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Single program, multiple datastream (SPMD) applications for 
maximum portability and reconfigurability.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Multiple program, multiple datastream (MPMD) option for 
flexibility.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION03011000000000000000">
11.1 Superstructure Classes</A>
</H2>

<P>
There are a small number of classes in the ESMF superstructure:

<P>

<UL>
<LI><B>Component</B>  An ESMF component has two parts, one that is 
supplied by the ESMF and one that is supplied by the user.  The
part that is supplied by the framework is an ESMF derived type that
is either a Gridded Component (<B>GridComp</B>) or a Coupler 
Component (<B>CplComp</B>).  A Gridded Component typically represents
a physical domain in which data is associated with one or more 
grids - for example, a sea ice model.  A Coupler Component 
arranges and executes data transformations and transfers between
one or more Gridded Components. Gridded Components and Coupler 
Components have standard methods, which include initialize, run,
and finalize.  These methods can be multi-phase.

<P>
The second part of an ESMF Component is user code, such as a
model or data assimilation system.  Users set entry points 
within their code so that it is callable by the framework.  
In practice, setting entry points means that within user code 
there are calls to ESMF methods that associate the name of a 
Fortran subroutine with a corresponding standard ESMF operation.  
For example, a user-written initialization routine called 
<TT>myOceanInit</TT> might be associated with the standard 
initialize routine of an ESMF Gridded Component named ``myOcean'' 
that represents an ocean model.

<P>
</LI>
<LI><B>State</B>  ESMF components exchange information with other 
components only through States.  A State is an ESMF derived
type that can contain Fields, FieldBundles, Arrays, ArrayBundles,
and other States.  A Component is associated with two States, an 
<B>Import State</B> and an <B>Export State</B>.  Its Import State 
holds the data that it receives from other Components.  
Its Export State contains data that it can make available to 
other Components. 

<P>
</LI>
<LI><B>Application Driver</B> The Application Driver (<B>AppDriver</B>) 
is a small, generic driver program that contains the ``main'' 
routine for an ESMF application.

<P>
</LI>
</UL>

<P>
An ESMF coupled application typically involves an AppDriver, a parent 
Gridded Component, two or more child Gridded Components that require 
an inter-component data exchange, and one or more Coupler 
Components. 

<P>
The parent Gridded Component is responsible for creating the child 
Gridded Components that are exchanging data, for creating the Coupler, 
for creating the necessary Import and Export States, and for 
setting up the desired sequencing.  The AppDriver ``main'' routine
calls the parent Gridded Component's initialize, run, and finalize 
methods in order to execute the application.  For each of these
standard methods, the parent Gridded Component in turn calls the 
corresponding methods in the child Gridded Components and the 
Coupler Component.  For example, consider a simple coupled 
ocean/atmosphere simulation.  When the initialize method of the 
parent Gridded Component is called by the AppDriver, it in turn 
calls the initialize methods of its child atmosphere and ocean 
Gridded Components, and the initialize method of an 
ocean-to-atmosphere Coupler Component.  Figure <A HREF="node3.html#fig:appunit">3</A>
shows this schematically.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:GEOS5"></A><A NAME="1304"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
ESMF enables applications such as the atmospheric general
circulation model GEOS-5 to be structured hierarchically, and 
reconfigured and extended easily.  Each box in this diagram is an
ESMF Gridded Component.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_GEOS5}}$
 -->
<IMG
 WIDTH="807" HEIGHT="488" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_GEOS5}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION03012000000000000000"></A>
<A NAME="sec:hierarchy"></A>
<BR>
11.2 Hierarchical Creation of Components
</H2>

<P>
Components are allocated computational resources in the form of
<B>Persistent Execution Threads</B>, or <B>PET</B>s.  A list of a Component's
PETs is contained in a structure called a <B>Virtual Machine</B>,
or <B>VM</B>.  The VM also contains information about the topology and
characteristics of the underlying computer.
Components are created hierarchically, with parent Components creating
child Components and allocating some or all of their PETs to each one.
By default ESMF creates a new VM for each child Component, which 
allows Components to tailor their VM resources to match their needs.
In some cases a child may want to share its parent's VM - ESMF
supports this too.

<P>
A Gridded Component may exist across all the PETs in an application. 
A Gridded Component may also reside on a subset of PETs in an
application.  These PETs may wholly coincide with, be wholly contained
within, or wholly contain another Component.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:appunit"></A><A NAME="1318"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
A call to a standard ESMF initialize (run, finalize) method
by a parent component triggers calls to initialize (run, finalize)
all of its child components.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_appunit}}$
 -->
<IMG
 WIDTH="749" HEIGHT="547" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_appunit}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION03013000000000000000"></A>
<A NAME="sec:concurrency"></A>
<BR>
11.3 Sequential and Concurrent Execution of Components
</H2>

<P>
When a set of Gridded Components and a Coupler runs in sequence
on the same set of PETs the application is executing in a <B>sequential</B>
mode. When Gridded Components are created and run on mutually exclusive
sets of PETs, and are coupled by a Coupler Component that extends over
the union of these sets, the mode of execution is <B>concurrent</B>.

<P>
Figure <A HREF="node3.html#fig:serial">4</A> illustrates a typical configuration for 
a simple coupled sequential
application, and Figure <A HREF="node3.html#fig:concurrent">5</A> shows a possible 
configuration for the same application running in a concurrent mode.

<P>
Parent Components can select if and when to wait for concurrently
executing child Components, synchronizing only when required.

<P>
It is possible for ESMF applications to contain some Component sets
that are executing sequentially and others that are executing concurrently.
We might have, for example, atmosphere and land Components created
on the same subset of PETs, ocean and sea ice Components created on
the remainder of PETs, and a Coupler created across all the PETs in
the application.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:serial"></A><A NAME="1332"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 4:</STRONG>
Schematic of the run method of a coupled application, with an
``Atmosphere'' and an ``Ocean'' Gridded Component running sequentially with 
an ``Atm-Ocean Coupler.''  The top-level ``Hurricane Model'' 
Gridded Component contains the sequencing information and time 
advancement loop.  The AppDriver, Coupler, and all Gridded Components 
are distributed over nine PETs.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_serial}}$
 -->
<IMG
 WIDTH="621" HEIGHT="704" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_serial}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:concurrent"></A><A NAME="1340"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5:</STRONG>
Schematic of the run method of a coupled application, with an
``Atmosphere'' and an ``Ocean'' Gridded Component running concurrently with 
an ``Atm-Ocean Coupler.''  The top-level ``Hurricane Model'' 
Gridded Component contains the sequencing information and time 
advancement loop.  The AppDriver, Coupler, and top-level ``Hurricane
Model'' Gridded Component are distributed over nine PETs.  The
``Atmosphere'' Gridded Component is distributed over three PETs and
the ``Ocean'' Gridded Component is distributed over six PETs.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_concurrent}}$
 -->
<IMG
 WIDTH="621" HEIGHT="603" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_concurrent}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION03014000000000000000"></A>
<A NAME="sec:localcomm"></A>
<BR>
11.4 Intra-Component Communication
</H2>

<P>
All data transfers within an ESMF application occur <I>within</I> a
component.  For example, a Gridded Component may contain halo updates.
Another example is that a Coupler Component may redistribute
data between two Gridded Components.  As a result,
the architecture of ESMF does not depend on any particular data
communication mechanism, and new communication schemes can be
introduced without affecting the overall structure of the application.

<P>
Since all data communication happens within a component, a Coupler
Component must be created on the union of the PETs of all
the Gridded Components that it couples.  

<P>

<H2><A NAME="SECTION03015000000000000000"></A>
<A NAME="sec:scoping"></A>
<BR>
11.5 Data Distribution and Scoping in Components
</H2>

<P>
The scope of distributed objects is the VM of the currently 
executing Component.  For this reason, all
PETs in the current VM must make the same distributed object
creation calls.   When a Coupler Component running on a superset
of a Gridded Component's PETs needs to make communication calls
involving objects created by the Gridded Component,
an ESMF-supplied function called <TT>ESMF_StateReconcile()</TT> creates proxy
objects for those PETs that had no previous information about the
distributed objects.  Proxy objects contain no local data but
can be used in communication calls (such as regrid or redistribute)
to describe the remote source for data being moved to the current PET,
or to describe the remote destination for data being moved from the local PET.
Figure <A HREF="node3.html#fig:reconcile">6</A> is a simple schematic that shows the 
sequence of events in a reconcile call.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:reconcile"></A><A NAME="1376"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 6:</STRONG>
An <TT>ESMF_StateReconcile()</TT> call creates proxy 
objects for use in subsequent communication calls.  The reconcile 
call would normally be made during Coupler initialization.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_reconcile}}$
 -->
<IMG
 WIDTH="633" HEIGHT="662" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_reconcile}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION03016000000000000000"></A>
<A NAME="sec:performance"></A>
<BR>
11.6 Performance
</H2>

<P>
The ESMF design enables the user to configure ESMF
applications so that data is transferred directly from one component 
to another, without requiring that it be copied or sent to a different data
buffer as an interim step.  This is likely to be the most efficient way 
of performing inter-component coupling.  However, if desired, an 
application can also be configured so that data from a source component 
is sent to a distinct set of Coupler Component PETs for processing 
before being sent to its destination.

<P>
The ability to overlap computation with communication is essential for
performance.  When running with ESMF the user can initiate data 
sends during Gridded Component execution, as soon as the data is ready.
Computations can then proceed simultaneously with the data transfer.

<P>

<H2><A NAME="SECTION03017000000000000000">
11.7 Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the relationships among
ESMF superstructure classes.  See Appendix A, <I>A Brief Introduction 
to UML</I>, for a translation table that lists the symbols in the diagram 
and their meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="692" HEIGHT="224" ALIGN="BOTTOM" BORDER="0"
 SRC="img7.png"
 ALT="\includegraphics[]{Comp_obj}">   

</DIV>

<P>

<P>

<P>

<H1><A NAME="SECTION03020000000000000000">
12 Application Driver and Required ESMF Methods</A>
</H1>

<P>

<H2><A NAME="SECTION03021000000000000000">
12.1 Description</A>
</H2>

<P>
The ESMF Application Driver (<TT>ESMF_AppDriver</TT>), is a generic ESMF 
driver program that contains a ``main.''  Simpler applications may be
able to use an Application Driver without modification; for more
complex applications, an Application Driver can be used as an extendable 
template.

<P>
ESMF provides a number of different Application Drivers in the 
<TT>$ESMF_DIR/src/Superstructure/AppDriver</TT> directory.
An appropriate one can be chosen depending on how the application
is to be structured.  Options when deciding how to structure an 
application include choices about:

<P>
<DL>
<DT><STRONG>Sequential vs. Concurrent Execution</STRONG></DT>
<DD><P>
In a sequential execution model every Component executes
on all PETs, with each Component completing execution before
the next Component begins.  This has the appeal of 
simplicity of data consumption and production: when a Gridded 
Component starts all required data is available for use, and when 
a Gridded Component finishes all data produced is ready for consumption 
by the next Gridded Component.  This approach also has
the possibility of less data movement if the grid and
data decomposition is done such that each processor's memory contains
the data needed by the next Component.

<P>
In a concurrent execution model subgroups of PETs run
Gridded Components and multiple Gridded Components are active at the 
same time.  Data exchange must be coordinated between Gridded 
Components so that data deadlock does not occur.  This strategy 
has the advantage of allowing coupling to other Gridded Components 
at any time during the computational process, including not 
having to return to the calling level of code before making 
data available.  

<P>
</DD>
<DT><STRONG>Pairwise vs. Hub and Spoke</STRONG></DT>
<DD><P>
Coupler Components are responsible for taking data from one
Gridded Component and putting it into the form expected by another 
Gridded Component.  This might include regridding, change of units, 
averaging, or binning.

<P>
Coupler Components can be written for <I>pairwise</I> data exchange: 
the Coupler Component takes data from a single Component and transforms 
it for use by another single Gridded Component.  This simplifies the 
structure of the Coupler Component code.

<P>
Couplers can also be written using a <I>hub and spoke</I> model where a
single Coupler accepts data from all other Components, can do data
merging or splitting, and formats data for all other Components.

<P>
Multiple Couplers, using either of the above two models or some mixture of
these approaches, are also possible.

<P>
</DD>
<DT><STRONG>Implementation Language</STRONG></DT>
<DD><P>
The ESMF framework currently has Fortran interfaces for all public functions. 
Some functions also have C interfaces, and the number of these is expected to 
increase over time. 

<P>
</DD>
<DT><STRONG>Number of Executables</STRONG></DT>
<DD><P>
The simplest way to run an application
is to run the same executable program on all PETs.  Different Components
can still be run on mutually exclusive PETs by using branching
(e.g., if this is PET 1, 2, or 3, run Component A, if it is
PET 4, 5, or 6 run Component B).  This is a <B>SPMD</B> model, 
Single Program Multiple Data.  

<P>
The alternative is to start a different executable program on different
PETs.  This is a <B>MPMD</B> model, Multiple Program Multiple Data.
There are complications with many job control systems on multiprocessor
machines in getting the different executables started, and getting
inter-process communcations established.  ESMF currently has some
support for MPMD: different Components can run as separate executables,
but the Coupler that transfers data between the Components must still
run on the union of their PETs. This means that the Coupler Component
must be linked into all of the executables.

<P>
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION03022000000000000000">
12.2 Application Driver and Required ESMF Methods Options</A>
</H2>

<P>

<H3><A NAME="SECTION03022100000000000000"></A>
<A NAME="app:terminationflag"></A>
<BR>
12.2.1 ESMF_TerminationFlag
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
The <TT>ESMF_TerminationFlag</TT> determines how an ESMF application is shut down.

<P>
Valid values are:
<DL>
<DT><STRONG>ESMF_ABORT</STRONG></DT>
<DD>Global abort of the ESMF application. There is no guarantee 
         that all PETs will shut down cleanly during an abort. However, all
         attempts are made to prevent the application from hanging and the
         LogErr of at least one PET will be completely flushed during the abort.
         This option should only be used if a condition is detected that
         prevents normal continuation or termination of the application.
         Typical conditions that warrant the use of <TT>ESMF_ABORT</TT> are those
         that occur on a per PET basis where other PETs may be blocked in 
         communication calls, unable to reach the normal termination point.
   
</DD>
<DT><STRONG>ESMF_FINAL</STRONG></DT>
<DD>Normal termination of the ESMF application. Wait for all PETs of the
         global VM to reach <TT>ESMF_Finalize()</TT> before termination. This is
         the clean way of terminating an application. <TT>MPI_Finalize()</TT> will
         be called in case of MPI applications.
   
</DD>
<DT><STRONG>ESMF_KEEPMPI</STRONG></DT>
<DD>Same as <TT>ESMF_FINAL</TT> but <TT>MPI_Finalize()</TT> will <EM>not</EM>
         be called. It is the user code's responsibility to shut down MPI
         cleanly if necessary.
</DD>
</DL>

<P>

<H2><A NAME="SECTION03023000000000000000">
12.3 Use and Examples</A>
</H2>

<P>
ESMF encourages application organization in which there is a single 
top-level Gridded Component.  This provides a simple, clear sequence
of operations at the highest level, and also enables the entire 
application to be treated as a sub-Component of another, larger 
application if desired.  When a simple application is organized in this fashion 
the standard AppDriver can probably be used without much modification.  

<P>
Examples of program organization using the AppDriver can be found in the 
<TT>src/Superstructure/AppDriver</TT> directory.  A set of subdirectories 
within the AppDriver directory follows the naming convention:
<PRE>
&lt;seq|concur&gt;_&lt;pairwise|hub&gt;_&lt;f|c&gt;driver_&lt;spmd|mpmd&gt;
</PRE>

<P>
The example that is currently implemented is
<TT>seq_pairwise_fdriver_spmd</TT>, which
has sequential component execution, a pairwise coupler, a main program
in Fortran, and all processors launching the same executable.
It is also copied automatically into a top-level 
<TT>quick_start</TT> directory at compilation time.  

<P>
The user can copy the AppDriver files into
their own local directory. Some of the files can be used unchanged.
Others are template files which have the rough outline of the code but
need additional application-specific code added in order to perform a
meaningful function.  The <TT>README</TT> file in the AppDriver 
subdirectory or <TT>quick_start</TT> directory contains instructions about 
which files to change.

<P>
Examples of concurrent component execution can be found in the
system tests that are bundled with the ESMF distribution.

<P>

<P>

<P>

<P>
<PRE>
 
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
   EXAMPLE:  This is an AppDriver.F90 file for a sequential ESMF application.
  ------------------------------------------------------------------------------
  ------------------------------------------------------------------------------
  
    The ChangeMe.F90 file that's included below contains a number of definitions 
    that are used by the AppDriver, such as the name of the application's
    main configuration file and the name of the application's SetServices 
    routine.  This file is in the same directory as the AppDriver.F90 file.
  ------------------------------------------------------------------------------
 
 #include "ChangeMe.F90"
 
     program ESMF_AppDriver
 #define ESMF_METHOD "program ESMF_AppDriver"
 
 #include "ESMF.h"
 
     ! ESMF module, defines all ESMF data types and procedures
     use ESMF_Mod
     
     ! Gridded Component registration routines.  Defined in "ChangeMe.F90"
     use USER_APP_Mod, only : SetServices =&gt; USER_APP_SetServices
 
     implicit none
     
  ------------------------------------------------------------------------------
    Define local variables
  ------------------------------------------------------------------------------
 
     ! Components and States
     type(ESMF_GridComp) :: compGridded
     type(ESMF_State) :: defaultstate
 
     ! Configuration information
     type(ESMF_Config) :: config
 
     ! A common Grid
     type(ESMF_Grid) :: grid
 
     ! A Clock, a Calendar, and timesteps
     type(ESMF_Clock) :: clock
     type(ESMF_TimeInterval) :: timeStep
     type(ESMF_Time) :: startTime
     type(ESMF_Time) :: stopTime
 
     ! Variables related to the Grid
     integer :: i_max, j_max
 
     ! Return codes for error checks
     integer :: rc, localrc
         
  ------------------------------------------------------------------------------
    Initialize ESMF.  Note that an output Log is created by default.
  ------------------------------------------------------------------------------
 
     call ESMF_Initialize(defaultCalendar=ESMF_CAL_GREGORIAN, rc=localrc)
     if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
     call ESMF_LogWrite("ESMF AppDriver start", ESMF_LOG_INFO)
 
  ------------------------------------------------------------------------------
    Create and load a configuration file.
    The USER_CONFIG_FILE is set to sample.rc in the ChangeMe.F90 file.
    The sample.rc file is also included in the directory with the AppDriver.F90
    file.
  ------------------------------------------------------------------------------
     
     config = ESMF_ConfigCreate(rc=localrc)
     if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
     call ESMF_ConfigLoadFile(config, USER_CONFIG_FILE, rc = localrc)
     if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
  ------------------------------------------------------------------------------
    Get configuration information.
  
    A configuration file like sample.rc might include:
    - size and coordinate information needed to create the default Grid.
    - the default start time, stop time, and running intervals
      for the main time loop.
  ------------------------------------------------------------------------------
 
     call ESMF_ConfigGetAttribute(config, i_max, 'I Counts:', default=10, rc=localrc)
     if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
     call ESMF_ConfigGetAttribute(config, j_max, 'J Counts:', default=40, rc=localrc)
     if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
  ------------------------------------------------------------------------------
    Create the top Gridded Component.
  ------------------------------------------------------------------------------
 
     compGridded = ESMF_GridCompCreate(name="ESMF Gridded Component", rc=localrc)
     if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
     call ESMF_LogWrite("Component Create finished", ESMF_LOG_INFO)
 
  ------------------------------------------------------------------------------
    Register the set services method for the top Gridded Component.
  ------------------------------------------------------------------------------
 
     call ESMF_GridCompSetServices(compGridded, SetServices, rc)
     if (ESMF_LogMsgFoundError(rc, "Registration failed", rc)) &amp;
         call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
  ------------------------------------------------------------------------------
    Create and initialize a Clock.
  ------------------------------------------------------------------------------
 
       call ESMF_TimeIntervalSet(timeStep, s=2, rc=localrc)
       if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
       call ESMF_TimeSet(startTime, yy=2004, mm=9, dd=25, rc=localrc)
       if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
       call ESMF_TimeSet(stopTime, yy=2004, mm=9, dd=26, rc=localrc)
       if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
       clock = ESMF_ClockCreate("Application Clock", timeStep, startTime, &amp;
                                 stopTime, rc=localrc)
       if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
  ------------------------------------------------------------------------------
    Create and initialize a Grid.
  
    The default lower indices for the Grid are (/1,1/).
    The upper indices for the Grid are read in from the sample.rc file,
    where they are set to (/10,40/).  This means a Grid will be
    created with 10 grid cells in the x direction and 40 grid cells in the
    y direction.  The Grid section in the Reference Manual shows how to set
    coordinates.
  ------------------------------------------------------------------------------
 
       grid = ESMF_GridCreateShapeTile(maxIndex=(/i_max, j_max/), &amp;
                              name="source grid", rc=localrc)
       if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
       ! Attach the grid to the Component
       call ESMF_GridCompSet(compGridded, grid=grid, rc=localrc)
       if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
  ------------------------------------------------------------------------------
    Create and initialize a State to use for both import and export.
    In a real code, separate import and export States would normally be
    created.
  ------------------------------------------------------------------------------
 
       defaultstate = ESMF_StateCreate("Default State", rc=localrc)
       if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
      
  ------------------------------------------------------------------------------
    Call the initialize, run, and finalize methods of the top component.
    When the initialize method of the top component is called, it will in
    turn call the initialize methods of all its child components, they
    will initialize their children, and so on.  The same is true of the
    run and finalize methods.
  ------------------------------------------------------------------------------
  
       call ESMF_GridCompInitialize(compGridded, defaultstate, defaultstate, &amp;
           clock, rc=localrc)
       if (ESMF_LogMsgFoundError(rc, "Initialize failed", rc)) &amp;
           call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
  
       call ESMF_GridCompRun(compGridded, defaultstate, defaultstate, &amp;
           clock, rc=localrc)
       if (ESMF_LogMsgFoundError(rc, "Run failed", rc)) &amp;
           call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
       call ESMF_GridCompFinalize(compGridded, defaultstate, defaultstate, &amp;
           clock, rc=localrc)
       if (ESMF_LogMsgFoundError(rc, "Finalize failed", rc)) &amp;
           call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
  
  
  ------------------------------------------------------------------------------
    Destroy objects.
  ------------------------------------------------------------------------------
 
       call ESMF_ClockDestroy(clock, rc=localrc)
       if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
       call ESMF_StateDestroy(defaultstate, rc=localrc)
       if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
       call ESMF_GridCompDestroy(compGridded, rc=localrc)
       if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, terminationflag=ESMF_ABORT)
 
  ------------------------------------------------------------------------------
    Finalize and clean up.
  ------------------------------------------------------------------------------
 
     call ESMF_Finalize()
 
     end program ESMF_AppDriver
</PRE>    

<P>

<H2><A NAME="SECTION03024000000000000000">
12.4 Required ESMF Methods</A>
</H2>

<P>
There are a few methods that every ESMF application must contain. First,
<TT>ESMF_Initialize()</TT> and <TT>ESMF_Finalize()</TT> are in complete analogy 
to <TT>MPI_Init()</TT> and <TT>MPI_Finalize()</TT> known from MPI. All ESMF
programs, serial or parallel, must initialize the ESMF system at the beginning,
and finalize it at the end of execution. The behavior of calling any
ESMF method before <TT>ESMF_Initialize()</TT>, or after <TT>ESMF_Finalize()</TT>
is undefined.

<P>
Second, every ESMF Component that is accessed by an ESMF application requires
that its set services routine is called through
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>. The Component must implement
one public entry point, its set services routine, that can be called
through the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT> library routine. The
Component set services routine is responsible for setting entry points
for the standard ESMF Component methods Initialize, Run, and Finalize.

<P>
Finally, the Component library call <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> can
optionally be issues <EM>before</EM> calling
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>. Similar to 
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT>
call requires a public entry point into the Component. It allows the Component
to adjust certain aspects of its execution environment, i.e. its own VM, before
it is started up.

<P>
The following sections discuss the above mentioned aspects in more detail.

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION03024100000000000000">
12.4.1 ESMF_Initialize - Initialize ESMF</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_Initialize(defaultConfigFileName, defaultCalendar, &amp;
         defaultLogFileName, defaultLogType, mpiCommunicator,  &amp;
         IOUnitLower, IOUnitUpper, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character(len=*),        intent(in),  optional :: defaultConfigFileName
       type(ESMF_CalendarType), intent(in),  optional :: defaultCalendar
       character(len=*),        intent(in),  optional :: defaultLogFileName
       type(ESMF_LogType),      intent(in),  optional :: defaultLogType
       integer,                 intent(in),  optional :: mpiCommunicator
       integer,                 intent(in),  optional :: IOUnitLower
       integer,                 intent(in),  optional :: IOUnitUpper
       type(ESMF_VM),           intent(out), optional :: vm
       integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method must be called once on each PET before
       any other ESMF methods are used.  The method contains a
       barrier before returning, ensuring that all processes
       made it successfully through initialization.

<P>
Typically <TT>ESMF_Initialize()</TT> will call <TT>MPI_Init()</TT> 
       internally unless MPI has been initialized by the user code before
       initializing the framework. If the MPI initialization is left to
       <TT>ESMF_Initialize()</TT> it inherits all of the MPI implementation 
       dependent limitations of what may or may not be done before 
       <TT>MPI_Init()</TT>. For instance, it is unsafe for some MPI
       implementations, such as MPICH, to do IO before the MPI environment
       is initialized. Please consult the documentation of your MPI
       implementation for details.

<P>
Note that when using MPICH as the MPI library, ESMF needs to use
       the application command line arguments for <TT>MPI_Init()</TT>. However,
       ESMF acquires these arguments internally and the user does not need
       to worry about providing them. Also, note that ESMF does not alter
       the command line arguments, so that if the user obtains them they will
       be as specified on the command line (including those which MPICH would
       normally strip out). 

<P>
By default, <TT>ESMF_Initialize()</TT> will open multiple error log files,
       one per processor.  This is very useful for debugging purpose.  However,
       when running the application on a large number of processors, opening a
       large number of log files and writing log messages from all the processors
       could become a performance bottleneck.  Therefore, it is recommended
       to turn the Error Log feature off in these situations by setting
       <TT>defaultLogType</TT> to ESMF_LOG_NONE.

<P>
When integrating ESMF with applications where Fortran unit number conflicts
       exist, the optional <TT>IOUnitLower</TT> and <TT>IOUnitUpper</TT> arguments may be
       used to specify an alternate unit number range.  See section <A HREF="node5.html#fio:unitnumbers">43.2.1</A>
       for more information on how ESMF uses Fortran unit numbers.

<P>
Before exiting the application the user must call <TT>ESMF_Finalize()</TT>
       to release resources and clean up ESMF gracefully.

<P>
The arguments are:
       <DL>
<DT><STRONG>[defaultConfigFilename]</STRONG></DT>
<DD>Name of the default configuration file for the entire application.
       
</DD>
<DT><STRONG>[defaultCalendar]</STRONG></DT>
<DD>Sets the default calendar to be used by ESMF Time Manager.
             See section <A HREF="node5.html#opt:calendartype">34.2.1</A> for a list of valid options.
             If not specified, defaults to <TT>ESMF_CAL_NOCALENDAR</TT>.
       
</DD>
<DT><STRONG>[defaultLogFileName]</STRONG></DT>
<DD>Name of the default log file for warning and error messages.
             If not specified, defaults to <TT>ESMF_ErrorLog</TT>.
       
</DD>
<DT><STRONG>[defaultLogType]</STRONG></DT>
<DD>Sets the default Log Type to be used by ESMF Log Manager.
             See section <A HREF="node5.html#opt:logtype">40.2.3</A> for a list of valid options.
             If not specified, defaults to <TT>ESMF_LOG_MULTI</TT>.
       
</DD>
<DT><STRONG>[mpiCommunicator]</STRONG></DT>
<DD>MPI communicator defining the group of processes on which the
             ESMF application is running.
             If not specified, defaults to <TT>MPI_COMM_WORLD</TT>.
       
</DD>
<DT><STRONG>[IOUnitLower]</STRONG></DT>
<DD>Lower bound for Fortran unit numbers used within the ESMF library.
             Fortran units are primarily used for log files.  Legal unit numbers
             are positive integers.  A value higher than 10 is recommended
             in order to avoid the compiler-specific
             reservations which are typically found on the first few units.
             If not specified, defaults to <TT>ESMF_LOG_FORT_UNIT_NUMBER</TT>,
             which is distributed with a value of 50.
       
</DD>
<DT><STRONG>[IOUnitUpper]</STRONG></DT>
<DD>Upper bound for Fortran unit numbers used within the ESMF library.
             Must be set to a value at least 5 units higher than <TT>IOUnitLower</TT>.
             If not specified, defaults to <TT>ESMF_LOG_UPPER</TT>, which is
             distributed with a value of 99.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Returns the global <TT>ESMF_VM</TT> that was created 
             during initialization.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION03024200000000000000">
12.4.2 ESMF_Finalize - Clean up and close ESMF</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_Finalize(terminationflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TerminationFlag), intent(in), optional  :: terminationflag
       integer, intent(out), optional                    :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This must be called once on each PET before the application exits
       to allow ESMF to flush buffers, close open connections, and 
       release internal resources cleanly. The optional argument 
       <TT>terminationflag</TT> may be used to indicate the mode of termination.  
       Note that this call must be issued only once per PET with 
       <TT>terminationflag=ESMF_FINAL</TT>, and that this call may not be followed
       by <TT>ESMF_Initialize()</TT>.  This last restriction means that it is not
       possible to restart ESMF within the same execution.

<P>
The arguments are:
       <DL>
<DT><STRONG>[terminationflag]</STRONG></DT>
<DD>Specify mode of termination. The default is <TT>ESMF_FINAL</TT>
             which waits for all PETs of the global VM to reach 
             <TT>ESMF_Finalize()</TT> before termination. See section 
             <A HREF="node3.html#app:terminationflag">12.2.1</A> for a complete list and description of
             valid flags.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03024300000000000000">
12.4.3 User-Code SetServices Method</A>
</H3>

<P>
Many programs call some library routines.  The library
documentation must explain what the routine name is, what arguments 
are required and what are optional, and what the code does.  

<P>
In contrast, all ESMF components must be written to <I>be called</I>
by another part of the program; in effect, an ESMF component takes the 
place of a library.  The interface is prescribed by the framework,
and the component writer must provide specific subroutines which 
have standard argument lists and perform specific operations.
For technical reasons <EM>none</EM> of the arguments in user-provided subroutines
must be declared as <EM>optional</EM>.

<P>
The only <EM>required</EM> public interface of a Component is its
set services method.  This subroutine must have an
externally accessible name (be a public symbol), take a component
as the first argument, and an integer return code as the second. 
Both arguments are required and must <EM>not</EM> be declared as 
<TT>optional</TT>. If an intent is specified in the interface it must be 
<TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
second argument. The subroutine name is not predefined, it is set by the
component writer, but must be provided as part of the component 
documentation.

<P>
The required function that the set services subroutine must provide is to
specify the user-code entry points for the standard ESMF Component methods. To
this end the user-written set services routine calls the
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetEntryPoint()</TT> method to set each 
Component entry point.

<P>
See sections <A HREF="node3.html#sec:GridSetServ">13.3.1</A> and <A HREF="node3.html#sec:CplSetServ">14.2.1</A> for examples of
how to write a user-code set services routine.

<P>
Note that a component does not call its own set services routine;
the AppDriver or parent component code, which is creating a component, 
will first call <TT>ESMF_&lt;Grid/Cpl&gt;CompCreate()</TT> to create an "empty" 
component, and then must call into <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, 
supplying the user-code set services routine as an argument. The framework
calls into the user-code set services, after the Component's VM has been
started up.

<P>

<H3><A NAME="SECTION03024400000000000000">
12.4.4 User-Code Initialize, Run, and Finalize Methods</A>
</H3>

<P>
The required standard ESMF Component methods, for which user-code entry
points must be set, are Initialize, Run, and Finalize. Currently optional,
a Component may also set entry points for the WriteRestart and
ReadRestart methods.

<P>
Sections <A HREF="node3.html#sec:GridSetServ">13.3.1</A> and <A HREF="node3.html#sec:CplSetServ">14.2.1</A> provide examples
of how the entry points for Initialize, Run, and Finalize are set during
the user-code set services routine, using the 
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetEntryPoint()</TT> library call.

<P>
All standard user-code methods must abide <EM>exactly</EM> to the prescribed
interfaces. <EM>None</EM> of the arguments must be declared as <EM>optional</EM>.

<P>
The names of the Initialize, Run, and Finalize user-code subroutines do
not need to be public; in fact it is far better for them to be private to
lower the chances of public symbol clashes between different components.

<P>
See sections <A HREF="node3.html#sec:GridInitialize">13.3.2</A>, <A HREF="node3.html#sec:GridRun">13.3.3</A>,
<A HREF="node3.html#sec:GridFinalize">13.3.4</A>, and <A HREF="node3.html#sec:CplInitialize">14.2.2</A>, <A HREF="node3.html#sec:CplRun">14.2.3</A>,
<A HREF="node3.html#sec:CplFinalize">14.2.4</A> for examples of how to write entry points for the 
standard ESMF Component methods.

<P>

<H3><A NAME="SECTION03024500000000000000"></A>
<A NAME="sec:AppDriverSetVM"></A>
<BR>
12.4.5 User-Code SetVM Method
</H3>

<P>
When the AppDriver or parent component code calls
<TT>ESMF_&lt;Grid/Cpl&gt;CompCreate()</TT> it has the option to specify a 
<TT>petList</TT> argument. All of the parent PETs contained in this list become
resources of the child component. By default all of the parent PETs are 
provided to the child component.

<P>
Unless the optional <TT>contextflag</TT> argument is used during 
<TT>ESMF_&lt;Grid/Cpl&gt;CompCreate()</TT>, to indicate that the child component will
execute in the same VM as the parent, the child component has the option
to set certain aspects of how the provided resources are to be used when
executing child component methods. The resources provided via the parent PETs
are the associated processing elements (PEs) and virtual address spaces (VASs).

<P>
The optional user-written set vm routine is called from the parent
through the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> library code, and is the only
place where the child component can set aspects of its own VM before it is 
started up. The child component's VM must be running before its set services
routine can be called, and thus the optional <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT>
call must be placed <EM>before</EM> <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>.

<P>
If called by the parent, the user-code set vm routine has the option to
specify how the PETs of the child component share the provided parent PEs.
Further, PETs on the same single system image can be set to run multi-threaded,
within a reduced number of VAS, allowing a component to leverage shared memory
concepts.

<P>
Sections <A HREF="node3.html#sec:GridSetVM">13.3.5</A> and <A HREF="node3.html#sec:CplSetVM">14.2.5</A> provide examples for
simple user-written set vm routines.

<P>

<P>

<H1><A NAME="SECTION03030000000000000000">
13 GridComp Class</A>
</H1>

<P>

<H2><A NAME="SECTION03031000000000000000">
13.1 Description</A>
</H2>

<A NAME="sec:GridComp"></A>

In Earth system modeling, the most natural way to think about an ESMF 
Gridded Component, or <TT>ESMF_GridComp</TT>, is as a piece of code 
representing a particular physical domain; for example, an atmospheric 
model or an ocean model.  Gridded Components may also represent individual
processes, such as radiation or chemistry.  It's up to the application
writer to decide how deeply to ``componentize.''

Earth system software components tend to share a number of basic 
features.  Most ingest and produce a variety of physical fields; refer to 
a (possibly noncontiguous) spatial region and a grid that is 
partitioned across a set of computational resources; and require 
a clock, usually for stepping a governing set of PDEs forward in time.  
Most can also be divided into distinct initialize, run, and finalize 
computational phases.  These common characteristics are used 
within ESMF to define a Gridded Component data structure that 
is tailored for Earth system modeling and yet is still flexible
enough to represent a variety of domains.

A well-designed Gridded Component does not store information 
internally about how it couples to other Gridded Components.  That
allows it to be used in different contexts without changes to source
code.  The idea here is to avoid situations in which slightly
different versions of the same model source are maintained for use in 
different contexts - standalone vs. coupled versions, for example.
Data is passed between Gridded Components using an intermediary 
Coupler Component, described in Section <A HREF="node3.html#sec:CplComp">14.1</A>.

An ESMF Gridded Component has two parts, one which is user-written
and another which is part of the framework.  The user-written
part is software that represents a physical domain or performs some
other computational function.  It forms the body of the Gridded 
Component.  It may be a piece of legacy code, or it may be developed 
expressly for use with the ESMF.  It must contain routines with
standard ESMF interfaces that can be called to initialize, run, and
finalize the Gridded Component.  These routines can have separate 
callable phases, such as distinct first and second initialization steps.

The part provided by ESMF is the Gridded Component derived type 
itself, <TT>ESMF_GridComp</TT>.  An <TT>ESMF_GridComp</TT> must be created 
for every portion of the application that will be represented 
as a separate component; for example, in a climate model, there may 
be Gridded Components representing the land, ocean, sea ice, and 
atmosphere.  If the application contains an ensemble of identical 
Gridded Components, every one has its own associated <TT>ESMF_GridComp</TT>.
Each Gridded Component has its own name and is allocated
a set of computational resources, in the form of an ESMF Virtual
Machine, or VM.

The user-written part of a Gridded Component is associated with an
<TT>ESMF_GridComp</TT> derived type through a routine called SetServices.
This is a routine that the user must write, and declare public.
Inside the SetServices routine the user must call  
<TT>ESMF_SetEntryPoint</TT> methods that associate a standard ESMF 
operation with the name of the corresponding Fortran subroutine in their user code.


<P>

<H2><A NAME="SECTION03032000000000000000">
13.2 GridComp Options</A>
</H2>

<P>

<H3><A NAME="SECTION03032100000000000000"></A>
<A NAME="opt:gridcomptype"></A>
<BR>
13.2.1 ESMF_GridCompType
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
The <TT>ESMF_GridCompType</TT> flag identifies what sort of physical domain
or computational function a particular <TT>ESMF_GridComp</TT> represents.
The flag values are purely informational; they are not used anywhere 
within the framework.  Use of this flag is optional.

<P>
Valid values are:
<DL>
<DT><STRONG>ESMF_ATM</STRONG></DT>
<DD>Atmospheric model.
   
</DD>
<DT><STRONG>ESMF_LAND</STRONG></DT>
<DD>Land model.
   
</DD>
<DT><STRONG>ESMF_OCEAN</STRONG></DT>
<DD>Ocean model.
   
</DD>
<DT><STRONG>ESMF_SEAICE</STRONG></DT>
<DD>Sea ice model.
   
</DD>
<DT><STRONG>ESMF_RIVER</STRONG></DT>
<DD>River model.
   
</DD>
<DT><STRONG>ESMF_OTHER</STRONG></DT>
<DD>Other type of model or system.
</DD>
</DL>

<P>

<H2><A NAME="SECTION03033000000000000000">
13.3 Use and Examples</A>
</H2>

<P>
A Gridded Component is a computational entity which consumes and produces data. It uses a State object to exchange data between itself and other Components. It uses a Clock object to manage time, and a VM to describe its own and its child components' computational resources.

<P>
This section shows how to create Gridded Components.  For demonstrations
of the use of Gridded Components, see the system tests that are bundled with the ESMF software
distribution.  These can be found in the directory <TT>esmf/src/system_tests</TT>.

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION03033100000000000000">
13.3.1 Implementing a User-Code SetServices Routine</A>
</H3>

<P>
<A NAME="sec:GridSetServ"></A>
<P>
Every <TT>ESMF_GridComp</TT> is required to provide and document
   a public set services routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   <TT>ESMF_GridComp</TT> as the first argument, and
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set services routine must call the ESMF method 
   <TT>ESMF_GridCompSetEntryPoint()</TT> to
   register with the framework what user-code subroutines should be called 
   to initialize, run, and finalize the component.  There are
   additional routines which can be registered as well, for checkpoint
   and restart functions.

<P>
Note that the actual subroutines being registered do not have to be
   public to this module; only the set services routine itself must
   be available to be used by other code. 

<P>
<PRE>
    ! Example Gridded Component
    module ESMF_GriddedCompEx
    
    ! ESMF Framework module
    use ESMF_Mod
    implicit none
    public GComp_SetServices
    public GComp_SetVM

    contains

    subroutine GComp_SetServices(comp, rc)
      type(ESMF_GridComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional

      ! Set the entry points for standard ESMF Component methods
      call ESMF_GridCompSetEntryPoint(comp, ESMF_SETINIT, userRoutine=GComp_Init, rc=rc)
      call ESMF_GridCompSetEntryPoint(comp, ESMF_SETRUN, userRoutine=GComp_Run, rc=rc)
      call ESMF_GridCompSetEntryPoint(comp, ESMF_SETFINAL, userRoutine=GComp_Final, rc=rc)

      rc = ESMF_SUCCESS

    end subroutine
</PRE>

<P>

<P>

<H3><A NAME="SECTION03033200000000000000">
13.3.2 Implementing a User-Code Initialize Routine</A>
</H3>

<P>
<A NAME="sec:GridInitialize"></A>
<P>
When a higher level component is ready to begin using an 
   <TT>ESMF_GridComp</TT>, it will call its initialize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
At initialization time the component can allocate data space, open
   data files, set up initial conditions; anything it needs to do to
   prepare to run.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine GComp_Init(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                       ! must not be optional
      type(ESMF_State)      :: importState, exportState   ! must not be optional
      type(ESMF_Clock)      :: clock                      ! must not be optional
      integer, intent(out)  :: rc                         ! must not be optional

      print *, "Gridded Comp Init starting"

      ! This is where the model specific setup code goes.  
 
      ! If the initial Export state needs to be filled, do it here.
      !call ESMF_StateAdd(exportState, field, rc)
      !call ESMF_StateAdd(exportState, bundle, rc)
      print *, "Gridded Comp Init returning"
   
      rc = ESMF_SUCCESS

    end subroutine GComp_Init
</PRE>

<P>

<P>

<H3><A NAME="SECTION03033300000000000000">
13.3.3 Implementing a User-Code Run Routine</A>
</H3>

<P>
<A NAME="sec:GridRun"></A>
<P>
During the execution loop, the run routine may be called many times.
   Each time it should read data from the <TT>importState</TT>, use the
   <TT>clock</TT> to determine what the current time is in the calling
   component, compute new values or process the data,
   and produce any output and place it in the <TT>exportState</TT>. 

<P>
When a higher level component is ready to use the <TT>ESMF_GridComp</TT>
   it will call its run routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
It is expected that this is where the bulk of the model computation
   or data analysis will occur.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine GComp_Run(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                       ! must not be optional
      type(ESMF_State)      :: importState, exportState   ! must not be optional
      type(ESMF_Clock)      :: clock                      ! must not be optional
      integer, intent(out)  :: rc                         ! must not be optional

      print *, "Gridded Comp Run starting"
      ! call ESMF_StateGet(), etc to get fields, bundles, arrays
      !  from import state.

      ! This is where the model specific computation goes.

      ! Fill export state here using ESMF_StateAdd(), etc

      print *, "Gridded Comp Run returning"

      rc = ESMF_SUCCESS

    end subroutine GComp_Run
</PRE>

<P>

<P>

<H3><A NAME="SECTION03033400000000000000">
13.3.4 Implementing a User-Code Finalize Routine</A>
</H3>

<P>
<A NAME="sec:GridFinalize"></A>
<P>
At the end of application execution, each <TT>ESMF_GridComp</TT> should
   deallocate data space, close open files, and flush final results.
   These functions should be placed in a finalize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned.

<P>
<PRE>
    subroutine GComp_Final(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                       ! must not be optional
      type(ESMF_State)      :: importState, exportState   ! must not be optional
      type(ESMF_Clock)      :: clock                      ! must not be optional
      integer, intent(out)  :: rc                         ! must not be optional

      print *, "Gridded Comp Final starting"
    
      ! Add whatever code here needed

      print *, "Gridded Comp Final returning"
   
      rc = ESMF_SUCCESS

    end subroutine GComp_Final
</PRE>

<P>

<P>

<H3><A NAME="SECTION03033500000000000000">
13.3.5 Implementing a User-Code SetVM Routine</A>
</H3>

<P>
<A NAME="sec:GridSetVM"></A>
<P>
Every <TT>ESMF_GridComp</TT> can optionally provide and document
   a public set vm routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   <TT>ESMF_GridComp</TT> as the first argument, and
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set vm routine is the only place where the child component can
   use the <TT>ESMF_GridCompSetVMMaxPEs()</TT>, or
   <TT>ESMF_GridCompSetVMMaxThreads()</TT>, or 
   <TT>ESMF_GridCompSetVMMinThreads()</TT> call to modify aspects of its own VM.

<P>
A component's VM is started up right before its set services routine is
   entered. <TT>ESMF_GridCompSetVM()</TT> is executing in the parent VM, and must
   be called <EM>before</EM> <TT>ESMF_GridCompSetServices()</TT>. 

<P>
<PRE>
    subroutine GComp_SetVM(comp, rc)
      type(ESMF_GridComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional
      
      type(ESMF_VM) :: vm
      logical :: pthreadsEnabled
      
      ! Test for Pthread support, all SetVM calls require it
      call ESMF_VMGetGlobal(vm, rc=rc)
      call ESMF_VMGet(vm, pthreadsEnabledFlag=pthreadsEnabled, rc=rc)

      if (pthreadsEnabled) then
        ! run PETs single-threaded
        call ESMF_GridCompSetVMMinThreads(comp, rc=rc)
      endif

      rc = ESMF_SUCCESS

    end subroutine

    end module ESMF_GriddedCompEx
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION03033600000000000000">
13.3.6 Setting and Getting the Internal State</A>
</H3>  

<P>
ESMF provides the concept of an Internal State that is associated with
     a Component. Through the Internal State API a user can attach a private
     data block to a Component, and later retrieve a pointer to this memory
     allocation. Setting and getting of Internal State information are
     supported from anywhere in the Component's SetServices, Initialize, Run,
     or Finalize code.

<P>
The code below demonstrates the basic Internal State API
     of <TT>ESMF_&lt;Grid|Cpl&gt;SetInternalState()</TT> and
     <TT>ESMF_&lt;Grid|Cpl&gt;GetInternalState()</TT>. Notice that an extra level of
     indirection to the user data is necessary!

<P>
<PRE>
  ! ESMF Framework module
  use ESMF_Mod
  implicit none
  
  type(ESMF_GridComp) :: comp
  integer :: rc, finalrc

  ! Internal State Variables
  type testData
  sequence
    integer :: testValue
    real    :: testScaling
  end type

  type dataWrapper
  sequence
    type(testData), pointer :: p
  end type

  type(dataWrapper) :: wrap1, wrap2
  type(testData), target :: data
  type(testData), pointer :: datap  ! extra level of indirection

  finalrc = ESMF_SUCCESS
!-------------------------------------------------------------------------
        
  call ESMF_Initialize(rc=rc)
  if (rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE 

!-------------------------------------------------------------------------

  !  Creation of a Component
  comp = ESMF_GridCompCreate(name="test", rc=rc)  
  if (rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE 

!-------------------------------------------------------------------------
! This could be called, for example, during a Component's initialize phase.

    ! Initialize private data block
  data%testValue = 4567
  data%testScaling = 0.5

  ! Set Internal State
  wrap1%p =&gt; data
  call ESMF_GridCompSetInternalState(comp, wrap1, rc)
  if (rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE 

!-------------------------------------------------------------------------
! This could be called, for example, during a Component's run phase.

  ! Get Internal State
  call ESMF_GridCompGetInternalState(comp, wrap2, rc)
  if (rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE 

  ! Access private data block and verify data
  datap =&gt; wrap2%p 
  if ((datap%testValue .ne. 4567) .or. (datap%testScaling .ne. 0.5)) then
    print *, "did not get same values back"
    finalrc = ESMF_FAILURE
  else
    print *, "got same values back from GetInternalState as original"
  endif
</PRE>

<P>

<P>

<P>

<P>
When working with ESMF Internal States it is important to consider the
     applying scoping rules. The user must ensure that the private data block,
     that is being referenced, persists for the entire access period. This is
     not an issue in the previous example, where the private data block was
     defined on the scope of the main program. However, the Internal State 
     construct is often useful inside of Component modules to hold Component
     specific data between calls. One option to ensure persisting private data
     blocks is to use the Fortran SAVE attribute either on local or module
     variables. A second option, illustrated in the following example, is to 
     use Fortran pointers and user controlled memory management via allocate()
     and deallocate() calls.

<P>
One situation where the Internal State is useful is in the
     creation of ensembles of the same Component. In this case it can 
     be tricky to distinguish which data, held in saved module variables, 
     belongs to which ensemble member - especially if the ensemble members
     are executing on the same set of PETs. The Internal State solves this
     problem by providing a handle to instance specific data allocations.

<P>
<PRE>
module user_mod

  use ESMF_Mod

  implicit none
  
  ! module variables
  private

  ! Internal State Variables
  type testData
  sequence
    integer       :: testValue        ! scalar data
    real          :: testScaling      ! scalar data
    real, pointer :: testArray(:)     ! array data
  end type

  type dataWrapper
  sequence
    type(testData), pointer :: p
  end type
</PRE>

<P>
<PRE>
  contains !--------------------------------------------------------------------
</PRE>

<P>
<PRE>
  subroutine mygcomp_init(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: istate, estate
    type(ESMF_Clock):: clock
    integer, intent(out):: rc

    ! Local variables
    type(dataWrapper) :: wrap
    type(testData), pointer :: data
    integer :: i

    rc = ESMF_SUCCESS
    
    ! Allocate private data block
    allocate(data)

    ! Initialize private data block
    data%testValue = 4567         ! initialize scalar data
    data%testScaling = 0.5        ! initialize scalar data
    allocate(data%testArray(10))  ! allocate array data
    
    do i=1, 10
      data%testArray(i) = real(i) ! initialize array data
    enddo
    
    ! In a real ensemble application the initial data would be set to something
    ! unique for this ensemble member. This could be accomplished for example
    ! by reading a member specific config file that was specified by the
    ! driver code. Alternatively, Attributes, set by the driver, could be used
    ! to label the Component instances as specific ensemble members.
    
    ! Set Internal State
    wrap%p =&gt; data
    call ESMF_GridCompSetInternalState(gcomp, wrap, rc)

  end subroutine !--------------------------------------------------------------
  
  subroutine mygcomp_run(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: istate, estate
    type(ESMF_Clock):: clock
    integer, intent(out):: rc

    ! Local variables
    type(dataWrapper) :: wrap
    type(testData), pointer :: data
    logical :: match = .true.
    integer :: i
    
    rc = ESMF_SUCCESS

    ! Get Internal State
    call ESMF_GridCompGetInternalState(gcomp, wrap, rc)
    if (rc/=ESMF_SUCCESS) return

    ! Access private data block and verify data
    data =&gt; wrap%p 
    if (data%testValue .ne. 4567) match = .false.   ! test scalar data
    if (data%testScaling .ne. 0.5) match = .false.  ! test scalar data
    do i=1, 10
      if (data%testArray(i) .ne. real(i)) match = .false. ! test array data
    enddo
    
    if (match) then
      print *, "got same values back from GetInternalState as original"
    else
      print *, "did not get same values back"
      rc = ESMF_FAILURE
    endif
    
  end subroutine !--------------------------------------------------------------

  subroutine mygcomp_final(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: istate, estate
    type(ESMF_Clock):: clock
    integer, intent(out):: rc

    ! Local variables
    type(dataWrapper) :: wrap
    type(testData), pointer :: data

    rc = ESMF_SUCCESS
    
    ! Get Internal State
    call ESMF_GridCompGetInternalState(gcomp, wrap, rc)
    if (rc/=ESMF_SUCCESS) return
    
    ! Deallocate private data block
    data =&gt; wrap%p 
    deallocate(data%testArray)  ! deallocate array data
    deallocate(data)
    
  end subroutine !--------------------------------------------------------------


end module
</PRE>

<P>

<P>

<H2><A NAME="SECTION03034000000000000000">
13.4 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No optional arguments.</B> User-written routines called by SetServices,
and registered for Initialize, Run and Finalize, <EM>must not</EM> declare any
of the arguments as optional.

<P>
</LI>
<LI><B>Namespace isolation.</B>
If possible, Gridded Components should attempt to make 
all data private, so public names do not interfere with data 
in other components.

<P>
</LI>
<LI><B>Single execution mode.</B>
It is not expected that a single Gridded Component be able 
to function in both sequential and concurrent modes, although 
Gridded Components of different types can be nested. For example,
a concurrently called Gridded Component can contain several nested 
sequential Gridded Components. 

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION03035000000000000000">
13.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION03035100000000000000">
13.5.1 ESMF_GridCompCreate - Create a Gridded Component</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive function ESMF_GridCompCreate(name, gridcomptype, grid, config, &amp;
     configFile, clock, petList, contextflag, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_GridComp) :: ESMF_GridCompCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),        intent(in),    optional :: name
     type(ESMF_GridCompType), intent(in),    optional :: gridcomptype 
     type(ESMF_Grid),         intent(inout), optional :: grid
     type(ESMF_Config),       intent(inout), optional :: config
     character(len=*),        intent(in),    optional :: configFile
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(in),    optional :: petList(:)
     type(ESMF_ContextFlag),  intent(in),    optional :: contextflag
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This interface creates an <TT>ESMF_GridComp</TT> object. By default, a
   separate VM context will be created for each component.  This implies
   creating a new MPI communicator and allocating additional memory to
   manage the VM resources. When running on a large number of processors,
   creating a separate VM for each component could be both time and memory
   inefficient.  If the application is sequential, i.e., each component is
   running on all the PETs of the global VM, it will be more efficient to use
   the global VM instead of creating a new one.  This can be done by setting
   <TT>contextflag</TT> to ESMF_CHILD_IN_PARENT_VM.

<P>
The return value is the new <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the newly-created <TT>ESMF_GridComp</TT>.  This name can be altered
     from within the <TT>ESMF_GridComp</TT> code once the initialization routine
     is called.
   
</DD>
<DT><STRONG>[gridcomptype]</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> model type, where model includes 
     <TT>ESMF_ATM, ESMF_LAND, ESMF_OCEAN, ESMF_SEAICE, ESMF_RIVER</TT>.  
     Note that this has no meaning to the framework, it is an
     annotation for user code to query. See section
     <A HREF="node3.html#opt:gridcomptype">13.2.1</A> for a complete list of valid types.
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD>Default <TT>ESMF_Grid</TT> associated with this <TT>gridcomp</TT>. Note that
     it is perfectly ok to not pass a Grid in for this argument. This argument is 
     simply a convenience for the user to allow them to associate a Grid
     with a component for their later use. The grid isn't actually used
     in the component code. 
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>An already-created <TT>ESMF_Config</TT> configuration object
     from which the new component
     can read in namelist-type information to set parameters for this run.
     If both are specified, this object takes priority over <TT>configFile</TT>.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>The filename of an <TT>ESMF_Config</TT> format file.  
     If specified, this file is opened an <TT>ESMF_Config</TT> configuration
     object is created for the file, and attached to the new component.  
     The user can call <TT>ESMF_GridCompGet()</TT> to get and use the object.
     If both are specified, the <TT>config</TT> object takes priority
     over this one.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Component-specific <TT>ESMF_Clock</TT>.  This clock is available to be
     queried and updated by the new <TT>ESMF_GridComp</TT> as it chooses.
     This should
     not be the parent component clock, which should be maintained and passed
     down to the initialize/run/finalize routines separately.
   
</DD>
<DT><STRONG>[petList]</STRONG></DT>
<DD>List of parent <TT>PET</TT>s given to the created child component by the
     parent component. If <TT>petList</TT> is not specified all of the
     parent <TT>PET</TT>s will be given to the child component. The order of
     PETs in <TT>petList</TT> determines how the child local PETs refer back to
     the parent PETs.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Specify the component's VM context. The default context is
     <TT>ESMF_CHILD_IN_NEW_VM</TT>. See section <A HREF="node2.html#opt:contextflag">9.2.4</A> for a
     complete list of valid flags.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03035200000000000000">
13.5.2 ESMF_GridCompDestroy - Release resources for a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompDestroy(gridcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)            :: gridcomp
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Releases all resources associated with this <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Release all resources associated with this <TT>ESMF_GridComp</TT>
     and mark the object as invalid.  It is an error to pass this
     object into any other routines after being destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03035300000000000000">
13.5.3 ESMF_GridCompFinalize - Call the GridComp's finalize routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompFinalize(gridcomp, importState, &amp;
     exportState, clock, phase, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                              :: gridcomp
     type(ESMF_State),        intent(inout), optional :: importState
     type(ESMF_State),        intent(inout), optional :: exportState
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(in),    optional :: phase
     type(ESMF_BlockingFlag), intent(in),    optional :: blockingflag
     integer,                 intent(out),   optional :: userRc
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user-supplied finalization code for 
   an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> to call finalize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default
     is 1.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03035400000000000000">
13.5.4 ESMF_GridCompGet - Query a GridComp for information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompGet(gridcomp, name, gridcomptype, grid, config, &amp;
     configFile, clock, vm, contextflag, currentMethod, currentPhase, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: gridcomp
     character(len=*),        intent(out), optional :: name
     type(ESMF_GridCompType), intent(out), optional :: gridcomptype 
     type(ESMF_Grid),         intent(out), optional :: grid
     type(ESMF_Config),       intent(out), optional :: config
     character(len=*),        intent(out), optional :: configFile
     type(ESMF_Clock),        intent(out), optional :: clock
     type(ESMF_VM),           intent(out), optional :: vm
     type(ESMF_ContextFlag),  intent(out), optional :: contextflag
     type(ESMF_Method),       intent(out), optional :: currentMethod
     integer,                 intent(out), optional :: currentPhase
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns information about an <TT>ESMF_GridComp</TT>.
   For queries where the caller
   only wants a single value, specify the argument by name.
   All the arguments after the <TT>gridcomp</TT> argument are optional
   to facilitate this.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> object to query.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Return the name of the <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[gridcomptype]</STRONG></DT>
<DD>Return the model type of this <TT>ESMF_GridComp</TT>. See section
     <A HREF="node3.html#opt:gridcomptype">13.2.1</A> for a complete list of valid types.
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD>Return the <TT>ESMF_Grid</TT> associated with this <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>Return the <TT>ESMF_Config</TT> object for this <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>Return the configuration filename for this <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Return the private clock for this <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Return the <TT>ESMF_VM</TT> for this <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Return the <TT>ESMF_ContextFlag</TT> for this <TT>ESMF_GridComp</TT>.
     See section <A HREF="node2.html#opt:contextflag">9.2.4</A> for a complete list of valid flags.
   
</DD>
<DT><STRONG>[currentMethod]</STRONG></DT>
<DD>Return the current <TT>ESMF_Method</TT> of the <TT>ESMF_GridComp</TT> execution.
     See section <A HREF="node2.html#opt:method">9.1.1</A>  for a complete list of valid options.
   
</DD>
<DT><STRONG>[currentPhase]</STRONG></DT>
<DD>Return the current <TT>phase</TT> of the <TT>ESMF_GridComp</TT> execution.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03035500000000000000">
13.5.5 ESMF_GridCompGetInternalState - Get private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompGetInternalState(gridcomp, dataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout) :: gridcomp
     type(any), pointer                 :: dataPointer
     integer,             intent(out)   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_GridComp</TT> at any time after 
   <TT>ESMF_GridCompSetInternalState</TT> has been called.
   Since init, run, and finalize must be separate subroutines, data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by this call.
   When running multiple instantiations of an <TT>ESMF_GridComp</TT>, 
   for example during ensemble runs, 
   it may be simpler to maintain private data specific to 
   each run with private data blocks.  A corresponding 
   <TT>ESMF_GridCompSetInternalState</TT> call sets the data pointer to 
   this block, and this call retrieves the data pointer.
   Note that the <TT>dataPointer</TT> argument needs to be a derived type
   which contains only a pointer of the type of the data block defined
   by the user.  When making this call the pointer needs to be unassociated.
   When the call returns, the pointer will now reference the original
   data block which was set during the previous call to
   <TT>ESMF_GridCompSetInternalState</TT>.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_GridCompSetInternalState</TT> will be accessible.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>An <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>dataPointer</STRONG></DT>
<DD>A derived type, containing only an unassociated pointer 
     to the private data block.
     The framework will fill in the pointer. When this call returns, the
     pointer is set to the same address set during the last
     <TT>ESMF_GridCompSetInternalState</TT> call.
     This level of indirection is needed to reliably set and retrieve 
     the data block no matter which architecture or compiler is used.  
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03035600000000000000">
13.5.6 ESMF_GridCompInitialize - Call the GridComp's initialize routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompInitialize(gridcomp, importState, &amp;
     exportState, clock, phase, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                              :: gridcomp
     type(ESMF_State),        intent(inout), optional :: importState
     type(ESMF_State),        intent(inout), optional :: exportState
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(in),    optional :: phase
     type(ESMF_BlockingFlag), intent(in),    optional :: blockingflag
     integer,                 intent(out),   optional :: userRc
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user initialization code for a GridComp.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call initialize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03035700000000000000">
13.5.7 ESMF_GridCompIsPetLocal - Inquire if this component is to execute on the calling PET.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive function ESMF_GridCompIsPetLocal(gridcomp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_GridCompIsPetLocal
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Inquire if this <TT>ESMF_GridComp</TT> object is to execute on the calling PET.

<P>
The return value is <TT>.true.</TT> if the component is to execute on the 
   calling PET, <TT>.false.</TT> otherwise.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> queried.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03035800000000000000">
13.5.8 ESMF_GridCompPrint - Print the contents of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompPrint(gridcomp, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                       :: gridcomp
     character(len = *), intent(in),  optional :: options
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints information about an <TT>ESMF_GridComp</TT> to <TT>stdout</TT>. 
<BR>
<P>
Note:  Many <TT>ESMF_&lt;class&gt;Print</TT> methods are implemented in C++.
   On some platforms/compilers there is a potential issue with interleaving
   Fortran and C++ output to <TT>stdout</TT> such that it doesn't appear in
   the expected order.  If this occurs, the <TT>ESMF_IOUnitFlush()</TT> method
   may be used on unit 6 to get coherent output.  
<BR>
<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to print.
   
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options are not yet supported.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03035900000000000000">
13.5.9 ESMF_GridCompReadRestart - Call the GridComp's read restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompReadRestart(gridcomp, importState, &amp;
     exportState, clock, phase, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                              :: gridcomp
     type(ESMF_State),        intent(inout), optional :: importState
     type(ESMF_State),        intent(inout), optional :: exportState
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(in),    optional :: phase
     type(ESMF_BlockingFlag), intent(in),    optional :: blockingflag
     integer,                 intent(out),   optional :: userRc
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user read restart code for an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.    
     Single-phase routines require only one invocation to complete
     their work.    
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase  
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030351000000000000000">
13.5.10 ESMF_GridCompRun - Call the GridComp's run routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompRun(gridcomp, importState, exportState,&amp;
     clock, phase, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                              :: gridcomp
     type(ESMF_State),        intent(inout), optional :: importState
     type(ESMF_State),        intent(inout), optional :: exportState
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(in),    optional :: phase
     type(ESMF_BlockingFlag), intent(in),    optional :: blockingflag
     integer,                 intent(out),   optional :: userRc
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user run code for an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.    
     Single-phase routines require only one invocation to complete
     their work.    
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase  
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030351100000000000000">
13.5.11 ESMF_GridCompSet - Set or reset information about the GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSet(gridcomp, name, gridcomptype, grid, config, &amp;
     configFile, clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)           :: gridcomp
     character(len=*),        intent(in),    optional :: name
     type(ESMF_GridCompType), intent(in),    optional :: gridcomptype 
     type(ESMF_Grid),         intent(inout), optional :: grid
     type(ESMF_Config),       intent(inout), optional :: config
     character(len=*),        intent(in),    optional :: configFile
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets or resets information about an <TT>ESMF_GridComp</TT>.
   The caller can set individual values by specifying
   the arguments by name.
   All the arguments except <TT>gridcomp</TT> are optional    
   to facilitate this.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to change.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Set the name of the <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[gridcomptype]</STRONG></DT>
<DD>Set the model type for this <TT>ESMF_GridComp</TT>. See section
     <A HREF="node3.html#opt:gridcomptype">13.2.1</A> for a complete list of valid types.
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD>Set the <TT>ESMF_Grid</TT> associated with the <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>Set the configuration information for the <TT>ESMF_GridComp</TT> from
     this already created <TT>ESMF_Config</TT> object.   
     If specified, takes priority over <TT>configFile</TT>.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>Set the configuration filename for this <TT>ESMF_GridComp</TT>.
     An <TT>ESMF_Config</TT> object will be created for this file
     and attached to the <TT>ESMF_GridComp</TT>.  Superceeded by <TT>config</TT>
     if both are specified.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Set the private clock for this <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030351200000000000000">
13.5.12 ESMF_GridCompSetEntryPoint - Set user routine as entry point for standard Component method</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetEntryPoint(gridcomp, method, userRoutine, phase, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in) :: gridcomp
     type(ESMF_Method),   intent(in) :: method
     interface
       subroutine userRoutine(gridcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_GridComp)         :: gridcomp     ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer, intent(in),  optional  :: phase
     integer, intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Registers a user-supplied <TT>userRoutine</TT> as the entry point for one of the
   predefined Component <TT>method</TT>s. After this call the <TT>userRoutine</TT>
   becomes accessible via the standard Component method API.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>An <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>method</STRONG></DT>
<DD>One of a set of predefined Component methods - e.g. <TT>ESMF_SETINIT</TT>, 
     <TT>ESMF_SETRUN</TT>, <TT>ESMF_SETFINAL</TT>. See section <A HREF="node2.html#opt:method">9.1.1</A> 
     for a complete list of valid method options.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated for this Component 
     <TT>method</TT>. This subroutine does not have to be public.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>The <TT>phase</TT> number for multi-phase methods. For single phase 
     methods the <TT>phase</TT> argument can be omitted. The default setting
     is 1.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
The Component writer must supply a subroutine with the exact interface 
   shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
   must not be declared as optional, and the types, intent and order must match.

<P>

<P>

<H3><A NAME="SECTION030351300000000000000">
13.5.13 ESMF_GridCompSetInternalState - Set private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetInternalState(gridcomp, dataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout) :: gridcomp
     type(any), pointer                 :: dataPointer
     integer,             intent(out)   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_GridComp</TT> at any time, but 
   expected to be
   most useful when called during the registration process, or initialization.
   Since init, run, and finalize must be separate subroutines, data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by subsequent calls.
   When running multiple instantiations of an <TT>ESMF_GridComp</TT>, 
   for example during
   ensemble runs, it may be simpler to maintain private data specific to 
   each run with private data blocks.  A corresponding 
   <TT>ESMF_GridCompGetInternalState</TT> call retrieves the data pointer.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_GridCompSetInternalState</TT> will be accessible.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>An <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>dataPointer</STRONG></DT>
<DD>A pointer to the private data block, wrapped in a derived type which
     contains only a pointer to the block.  This level of indirection is
     needed to reliably set and retrieve the data block no matter which
     architecture or compiler is used.  
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030351400000000000000">
13.5.14 ESMF_GridCompSetServices - Call user routine to register GridComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompSetServices(gridcomp, userRoutine, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)            :: gridcomp
     interface
       subroutine userRoutine(gridcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer, intent(out), optional :: userRc
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call into user provided <TT>userRoutine</TT> which is responsible for
   for setting Component's Initialize(), Run() and Finalize() services.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Routine to be called.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
The Component writer must supply a subroutine with the exact interface 
   shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
   must not be declared as optional, and the types, intent and order must match.

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive calls
   to <TT>ESMF_GridCompSetEntryPoint()</TT> to preset callback routines for
   standard Component Initialize(), Run() and Finalize() methods.

<P>

<P>

<H3><A NAME="SECTION030351500000000000000">
13.5.15 ESMF_GridCompSetServices - Call user routine, located in shared object, to register GridComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCompSetServices()
   recursive subroutine ESMF_GridCompSetServicesShObj(gridcomp, userRoutine, &amp;
     sharedObj, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     character(len=*),    intent(in)            :: userRoutine
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call into user provided routine which is responsible for setting
   Component's Initialize(), Run() and Finalize() services. The named
   <TT>userRoutine</TT> must exist in the shared object file specified in the
   <TT>sharedObj</TT> argument. All of the platform specific details about 
   dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of routine to be called.
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
The Component writer must supply a subroutine with the exact interface 
   shown for <TT>userRoutine</TT> below. Arguments must not be declared
   as optional, and the types, intent and order must match.

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface
       subroutine userRoutine(gridcomp, rc)
         type(ESMF_GridComp)  :: gridcomp   ! must not be optional
         integer, intent(out) :: rc         ! must not be optional
       end subroutine
     end interface
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive calls
   to <TT>ESMF_GridCompSetEntryPoint()</TT> to preset callback routines for
   standard Component Initialize(), Run() and Finalize() methods.

<P>

<P>

<H3><A NAME="SECTION030351600000000000000">
13.5.16 ESMF_GridCompSetVM - Call user routine to set GridComp VM properies</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompSetVM(gridcomp, userRoutine, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)            :: gridcomp
     interface
       subroutine userRoutine(gridcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer, intent(out), optional :: userRc
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible for
   for setting Component's VM properties. 

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Routine to be called.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
The Component writer must supply a subroutine with the exact interface 
   shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
   must not be declared as optional, and the types, intent and order must match.

<P>
The subroutine, when called by the framework, is expected to use any of the
   <TT>ESMF_GridCompSetVMxxx()</TT> methods to set the properties of the VM
   associated with the Gridded Component.

<P>

<P>

<H3><A NAME="SECTION030351700000000000000">
13.5.17 ESMF_GridCompSetVM - Call user routine, located in shared object, to set GridComp VM properies</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCompSetVM()
   recursive subroutine ESMF_GridCompSetVMShObj(gridcomp, userRoutine, sharedObj, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     character(len=*),    intent(in)            :: userRoutine
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible for
   for setting Component's VM properties. The named <TT>userRoutine</TT> must exist
   in the shared object file specified in the <TT>sharedObj</TT> argument. All of
   the platform specific details about dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Routine to be called.
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
The Component writer must supply a subroutine with the exact interface 
   shown for <TT>userRoutine</TT> below. Arguments must not be declared
   as optional, and the types, intent and order must match.

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface
       subroutine userRoutine(gridcomp, rc)
         type(ESMF_GridComp)  :: gridcomp    ! must not be optional
         integer, intent(out) :: rc          ! must not be optional
       end subroutine
     end interface
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
The subroutine, when called by the framework, is expected to use any of the
   <TT>ESMF_GridCompSetVMxxx()</TT> methods to set the properties of the VM
   associated with the Gridded Component.

<P>

<P>

<H3><A NAME="SECTION030351800000000000000">
13.5.18 ESMF_GridCompSetVMMaxPEs - Set VM for Gridded Component to associate max PEs with PETs.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetVMMaxPEs(gridcomp, max, pref_intra_process, &amp;
     pref_intra_ssi, pref_inter_ssi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     integer,             intent(in),  optional :: max
     integer,             intent(in),  optional :: pref_intra_process
     integer,             intent(in),  optional :: pref_intra_ssi
     integer,             intent(in),  optional :: pref_inter_ssi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_GridComp</TT>.
     Attempts to associate <TT>max</TT> PEs with each PET. Only PEs that are 
     located on the same single system image can be associated with the same PET.
     Within this constraint the call tries to get as close as possible to the
     number specified by <TT>max</TT>.

<P>
The typical use of <TT>ESMF_GridCompSetVMMaxPEs()</TT> is to allocate
     multiple PEs per PET in a Component for user-level threading, e.g. OpenMP.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[max]</STRONG></DT>
<DD>Maximum number of PEs per PET. Default is peCount.
   
</DD>
<DT><STRONG>[pref_intra_process]</STRONG></DT>
<DD>Intra process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_intra_ssi]</STRONG></DT>
<DD>Intra SSI communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_inter_ssi]</STRONG></DT>
<DD>Inter process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030351900000000000000">
13.5.19 ESMF_GridCompSetVMMaxThreads - Set VM for Gridded Component with multi-threaded PETs.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetVMMaxThreads(gridcomp, max, pref_intra_process, &amp;
     pref_intra_ssi, pref_inter_ssi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     integer,             intent(in),  optional :: max
     integer,             intent(in),  optional :: pref_intra_process
     integer,             intent(in),  optional :: pref_intra_ssi
     integer,             intent(in),  optional :: pref_inter_ssi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_GridComp</TT>.
     Attempts to provide <TT>max</TT> threaded PETs in each VAS. Only as many
     threaded PETs as there are PEs located on the same single system image
     can be associated with the same VAS. Within this constraint the call
     tries to get as close as possible to the number specified by <TT>max</TT>.

<P>
The typical use of <TT>ESMF_GridCompSetVMMaxThreads()</TT> is to run a 
     Component multi-threaded with a groups of PETs that execute within the
     same virtual address space.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[max]</STRONG></DT>
<DD>Maximum threading level.
   
</DD>
<DT><STRONG>[pref_intra_process]</STRONG></DT>
<DD>Intra process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_intra_ssi]</STRONG></DT>
<DD>Intra SSI communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_inter_ssi]</STRONG></DT>
<DD>Inter process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030352000000000000000">
13.5.20 ESMF_GridCompSetVMMinThreads - Set VM for Gridded Component with reduced threading level.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetVMMinThreads(gridcomp, max, pref_intra_process, &amp;
     pref_intra_ssi, pref_inter_ssi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     integer,             intent(in),  optional :: max
     integer,             intent(in),  optional :: pref_intra_process
     integer,             intent(in),  optional :: pref_intra_ssi
     integer,             intent(in),  optional :: pref_inter_ssi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_GridComp</TT>.
     Reduces the number of threaded PETs in each VAS. The <TT>max</TT> argument
     may be specified to limit the maximum number of PEs that a single PET 
     may be associated with.

<P>
The typical use of <TT>ESMF_GridCompSetVMMinThreads()</TT> is to run a 
     Component across a set of single-threaded PETs.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[max]</STRONG></DT>
<DD>Maximum number of PEs per PET. Default is peCount.
   
</DD>
<DT><STRONG>[pref_intra_process]</STRONG></DT>
<DD>Intra process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_intra_ssi]</STRONG></DT>
<DD>Intra SSI communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_inter_ssi]</STRONG></DT>
<DD>Inter process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030352100000000000000">
13.5.21 ESMF_GridCompValidate - Check validity of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompValidate(gridcomp, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                       :: gridcomp
     character(len = *), intent(in),  optional :: options
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Currently all this method does is to check that the <TT>gridcomp</TT> exists.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to validate.
   
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Validation options are not yet supported.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030352200000000000000">
13.5.22 ESMF_GridCompWait - Wait for a GridComp to return</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompWait(gridcomp, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: gridcomp
     type(ESMF_BlockingFlag), intent(in),  optional :: blockingflag
     integer,                 intent(out), optional :: userRc
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
When executing asychronously, wait for an <TT>ESMF_GridComp</TT> to return.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to wait for.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030352300000000000000">
13.5.23 ESMF_GridCompWriteRestart - Call the GridComp's write restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompWriteRestart(gridcomp, importState, &amp;
     exportState, clock, phase, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                              :: gridcomp
     type(ESMF_State),        intent(inout), optional :: importState
     type(ESMF_State),        intent(inout), optional :: exportState
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(in),    optional :: phase
     type(ESMF_BlockingFlag), intent(in),    optional :: blockingflag
     integer,                 intent(out),   optional :: userRc
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user write restart code for an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.    
     Single-phase routines require only one invocation to complete
     their work.    
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase  
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H1><A NAME="SECTION03040000000000000000">
14 CplComp Class</A>
</H1>

<P>

<H2><A NAME="SECTION03041000000000000000">
14.1 Description</A>
</H2>

<P>
<A NAME="sec:CplComp"></A>
<P>
In a large, multi-component application such as a weather 
forecasting or climate prediction system running within ESMF, 
physical domains and major system functions are represented 
as Gridded Components 
(see Section <A HREF="node3.html#sec:GridComp">13.1</A>).  A Coupler Component, or 
<TT>ESMF_CplComp</TT>, arranges and executes the data 
transformations between the Gridded Components.  Ideally, 
Coupler Components should contain all the information 
about inter-component communication for an application.
This enables the Gridded Components in the application to be 
used in multiple contexts; that is, used in different coupled 
configurations without changes to their source code. 
For example, the same atmosphere might in one case be coupled 
to an ocean in a hurricane prediction model, and in another
coupled to a data assimilation system for numerical weather 
prediction.

<P>
Like Gridded Components, Coupler Components have two parts, one
that is provided by the user and another that is part of the 
framework.  The user-written portion of the software is the coupling
code necessary for a particular exchange between Gridded Components.  
The term ``user-written'' is somewhat misleading here, since within 
a Coupler Component the user can leverage ESMF infrastructure 
software for regridding, redistribution, lower-level communications, 
calendar management, and other functions.  However, ESMF is unlikely 
to offer all the software necessary to customize a data transfer
between Gridded Components.  ESMF does not currently offer tools 
for unit tranformations or time averaging operations, so users 
must manage those operations themseves.

<P>
The user-written Coupler Component code must be divided into 
separately callable initialize, run, and finalize methods.  The 
interfaces for these methods are prescribed by ESMF.

<P>
The second part of a Coupler Component is the <TT>ESMF_CplComp</TT>
derived type within ESMF.  The user must create one of these types
to represent a specific coupling function, such as the regular
transfer of data between a data assimilation system and an 
atmospheric model.  <A NAME="tex2html15"
  HREF="footnode.html#foot4171"><SUP>2</SUP></A>
<P>
The user-written part of a Coupler Component is associated with an
<TT>ESMF_CplComp</TT> derived type through a routine called SetServices.
This is a routine that the user must write, and declare public.
Inside the SetServices routine the user must call 
<TT>ESMF_SetEntryPoint</TT> methods that associate a standard ESMF 
operation with the name of the corresponding Fortran subroutine in 
their user code.  For example, a user routine called ``couplerInit''
might be associated with the standard initialize routine in a 
Coupler Component.

<P>
Coupler Components can be written to transform data between a 
pair of Gridded Components, or a single Coupler Component can couple 
more than two Gridded Components.

<P>

<H2><A NAME="SECTION03042000000000000000">
14.2 Use and Examples</A>
</H2>

<P>
A Coupler Component manages the transformation of data between Components.
It contains a list of State objects and the operations needed to
make them compatible, including such things as regridding and unit conversion.
Coupler Components are user-written, following prescribed ESMF interfaces
and, wherever desired, using ESMF infrastructure tools.

<P>

<P>

<P>

<H3><A NAME="SECTION03042100000000000000">
14.2.1 Implementing a User-Code SetServices Routine</A>
</H3>

<P>
<A NAME="sec:CplSetServ"></A>
<P>
Every <TT>ESMF_CplComp</TT> is required to provide and document
   a public set services routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an 
   <TT>ESMF_CplComp</TT> as the first argument, and 
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set services routine must call the ESMF method 
   <TT>ESMF_CplCompSetEntryPoint()</TT> to
   register with the framework what user-code subroutines should be called
   to initialize, run, and finalize the component.  There are
   additional routines which can be registered as well, for checkpoint
   and restart functions.

<P>
Note that the actual subroutines being registered do not have to be
   public to this module; only the set services routine itself must
   be available to be used by other code. 

<P>
<PRE>
    ! Example Coupler Component
    module ESMF_CouplerEx
    
    ! ESMF Framework module
    use ESMF_Mod
    implicit none
    public CPL_SetServices

    contains

    subroutine CPL_SetServices(comp, rc)
      type(ESMF_CplComp)    :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional

      ! Set the entry points for standard ESMF Component methods
      call ESMF_CplCompSetEntryPoint(comp, ESMF_SETINIT, userRoutine=CPL_Init, rc=rc)
      call ESMF_CplCompSetEntryPoint(comp, ESMF_SETRUN, userRoutine=CPL_Run, rc=rc)
      call ESMF_CplCompSetEntryPoint(comp, ESMF_SETFINAL, userRoutine=CPL_Final, rc=rc)

      rc = ESMF_SUCCESS
    end subroutine
</PRE>

<P>

<P>

<H3><A NAME="SECTION03042200000000000000">
14.2.2 Implementing a User-Code Initialize Routine</A>
</H3>

<P>
<A NAME="sec:CplInitialize"></A>
<P>
When a higher level component is ready to begin using an 
   <TT>ESMF_CplComp</TT>, it will call its initialize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
At initialization time the component can allocate data space, open
   data files, set up initial conditions; anything it needs to do to
   prepare to run.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine CPL_Init(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp                       ! must not be optional
      type(ESMF_State)      :: importState, exportState   ! must not be optional
      type(ESMF_Clock)      :: clock                      ! must not be optional
      integer, intent(out)  :: rc                         ! must not be optional

      print *, "Coupler Init starting"
    
      ! Add whatever code here needed
      ! Precompute any needed values, fill in any inital values
      !  needed in Import States

      rc = ESMF_SUCCESS

      print *, "Coupler Init returning"
   
    end subroutine CPL_Init
</PRE>

<P>

<P>

<H3><A NAME="SECTION03042300000000000000">
14.2.3 Implementing a User-Code Run Routine</A>
</H3>

<P>
<A NAME="sec:CplRun"></A>
<P>
During the execution loop, the run routine may be called many times.
   Each time it should read data from the <TT>importState</TT>, use the
   <TT>clock</TT> to determine what the current time is in the calling
   component, compute new values or process the data, 
   and produce any output and place it in the <TT>exportState</TT>.

<P>
When a higher level component is ready to use the <TT>ESMF_CplComp</TT>
   it will call its run routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
It is expected that this is where the bulk of the model computation
   or data analysis will occur.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine CPL_Run(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp                       ! must not be optional
      type(ESMF_State)      :: importState, exportState   ! must not be optional
      type(ESMF_Clock)      :: clock                      ! must not be optional
      integer, intent(out)  :: rc                         ! must not be optional

      print *, "Coupler Run starting"

      ! Add whatever code needed here to transform Export state data
      !  into Import states for the next timestep.  

      rc = ESMF_SUCCESS

      print *, "Coupler Run returning"

    end subroutine CPL_Run
</PRE>

<P>

<P>

<H3><A NAME="SECTION03042400000000000000">
14.2.4 Implementing a User-Code Finalize Routine</A>
</H3>

<P>
<A NAME="sec:CplFinalize"></A>
<P>
At the end of application execution, each <TT>ESMF_CplComp</TT> should
   deallocate data space, close open files, and flush final results.
   These functions should be placed in a finalize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned.

<P>
<PRE>
    subroutine CPL_Final(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp                       ! must not be optional
      type(ESMF_State)      :: importState, exportState   ! must not be optional
      type(ESMF_Clock)      :: clock                      ! must not be optional
      integer, intent(out)  :: rc                         ! must not be optional

      print *, "Coupler Final starting"
    
      ! Add whatever code needed here to compute final values and
      !  finish the computation.

      rc = ESMF_SUCCESS

      print *, "Coupler Final returning"
   
    end subroutine CPL_Final
</PRE>

<P>

<P>

<H3><A NAME="SECTION03042500000000000000">
14.2.5 Implementing a User-Code SetVM Routine</A>
</H3>

<P>
<A NAME="sec:CplSetVM"></A>
<P>
Every <TT>ESMF_CplComp</TT> can optionally provide and document
   a public set vm routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   <TT>ESMF_CplComp</TT> as the first argument, and
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set vm routine is the only place where the child component can
   use the <TT>ESMF_CplCompSetVMMaxPEs()</TT>, or
   <TT>ESMF_CplCompSetVMMaxThreads()</TT>, or 
   <TT>ESMF_CplCompSetVMMinThreads()</TT> call to modify aspects of its own VM.

<P>
A component's VM is started up right before its set services routine is
   entered. <TT>ESMF_CplCompSetVM()</TT> is executing in the parent VM, and must
   be called <EM>before</EM> <TT>ESMF_CplCompSetServices()</TT>. 

<P>
<PRE>
    subroutine GComp_SetVM(comp, rc)
      type(ESMF_CplComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional
      
      type(ESMF_VM) :: vm
      logical :: pthreadsEnabled
      
      ! Test for Pthread support, all SetVM calls require it
      call ESMF_VMGetGlobal(vm, rc=rc)
      call ESMF_VMGet(vm, pthreadsEnabledFlag=pthreadsEnabled, rc=rc)

      if (pthreadsEnabled) then
        ! run PETs single-threaded
        call ESMF_CplCompSetVMMinThreads(comp, rc=rc)
      endif

      rc = ESMF_SUCCESS

    end subroutine

    end module ESMF_CouplerEx
</PRE>

<P>

<P>

<H2><A NAME="SECTION03043000000000000000">
14.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No optional arguments.</B> User-written routines called by SetServices,
and registered for Initialize, Run and Finalize, <EM>must not</EM> declare any
of the arguments as optional.

<P>
</LI>
<LI><B>No Transforms.</B>  Components must exchange data through 
<TT>ESMF_State</TT> objects.  The input data are available at the time 
the component code is called, and data to be returned to another 
component are available when that code returns.  

<P>
</LI>
<LI><B>No automatic unit conversions.</B>  The ESMF framework does not 
currently contain tools for performing unit conversions, operations that 
are fairly standard within Coupler Components.

<P>
</LI>
<LI><B>No accumulator.</B>  The ESMF does not have an accumulator tool, to
perform time averaging of fields for coupling.  This is likely to be developed
in the near term.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION03044000000000000000">
14.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION03044100000000000000">
14.4.1 ESMF_CplCompCreate - Create a Coupler Component</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive function ESMF_CplCompCreate(name, config, configFile, clock, &amp;
     petList, contextflag, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_CplComp) :: ESMF_CplCompCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),       intent(in),     optional :: name
     type(ESMF_Config),      intent(inout),  optional :: config
     character(len=*),       intent(in),     optional :: configFile
     type(ESMF_Clock),       intent(inout),  optional :: clock
     integer,                intent(in),     optional :: petList(:)
     type(ESMF_ContextFlag), intent(in),     optional :: contextflag
     integer,                intent(out),    optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This interface creates an <TT>ESMF_CplComp</TT> object. By default, a
   separate VM context will be created for each component.  This implies
   creating a new MPI communicator and allocating additional memory to
   manage the VM resources. When running on a large number of processors,
   creating a separate VM for each component could be both time and memory
   inefficient.  If the application is sequential, i.e., each component is
   running on all the PETs of the global VM, it will be more efficient to use
   the global VM instead of creating a new one.  This can be done by setting
   <TT>contextflag</TT> to ESMF_CHILD_IN_PARENT_VM.

<P>
The return value is the new <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the newly-created <TT>ESMF_CplComp</TT>.  This name can be altered 
     from within the <TT>ESMF_CplComp</TT> code once the initialization routine
     is called.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>An already-created <TT>ESMF_Config</TT> configuration object 
     from which the new component
     can read in namelist-type information to set parameters for this run.
     If both are specified, this object takes priority over <TT>configFile</TT>.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>The filename of an <TT>ESMF_Config</TT> format file.  
     If specified, this file is opened, an <TT>ESMF_Config</TT> configuration
     object is created for the file, and attached to the new component.  
     The user can call <TT>ESMF_CplCompGet()</TT> to get and use the object.
     If both are specified, the <TT>config</TT> object takes priority 
     over this one.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Component-specific <TT>ESMF_Clock</TT>.  This clock is available to be
     queried and updated by the new <TT>ESMF_CplComp</TT> as it chooses.  
     This should
     not be the parent component clock, which should be maintained and passed
     down to the initialize/run/finalize routines separately.
   
</DD>
<DT><STRONG>[petList]</STRONG></DT>
<DD>List of parent <TT>PET</TT>s given to the created child component by the
     parent component. If <TT>petList</TT> is not specified all of the
     parent <TT>PET</TT>s will be given to the child component. The order of
     PETs in <TT>petList</TT> determines how the child local PETs refer back to
     the parent PETs.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Specify the component's VM context. The default context is
     <TT>ESMF_CHILD_IN_NEW_VM</TT>. See section <A HREF="node2.html#opt:contextflag">9.2.4</A> for a
     complete list of valid flags.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03044200000000000000">
14.4.2 ESMF_CplCompDestroy - Release resources for a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompDestroy(cplcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)             :: cplcomp
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Releases all resources associated with this <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Release all resources associated with this <TT>ESMF_CplComp</TT>
     and mark the object as invalid.  It is an error to pass this
     object into any other routines after being destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03044300000000000000">
14.4.3 ESMF_CplCompFinalize - Call the CplComp's finalize routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompFinalize(cplcomp, importState, exportState, &amp;
     clock, phase, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                               :: cplcomp
     type(ESMF_State),        intent(inout), optional :: importState
     type(ESMF_State),        intent(inout), optional :: exportState
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(in),    optional :: phase
     type(ESMF_BlockingFlag), intent(in),    optional :: blockingflag
     integer,                 intent(out),   optional :: userRc
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user-supplied finalization routine for 
   an <TT>ESMF_CplComp</TT>.

<P>
The arguments are: 
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> to call finalize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.  
     Single-phase routines require only one invocation to complete
     their work.  
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase 
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03044400000000000000">
14.4.4 ESMF_CplCompGet - Query a CplComp for information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompGet(cplcomp, name, config, configFile, clock, vm, &amp;
     contextflag, currentMethod, currentPhase, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),     intent(inout)         :: cplcomp
     character(len=*),       intent(out), optional :: name
     type(ESMF_Config),      intent(out), optional :: config
     character(len=*),       intent(out), optional :: configFile
     type(ESMF_Clock),       intent(out), optional :: clock
     type(ESMF_VM),          intent(out), optional :: vm
     type(ESMF_ContextFlag), intent(out), optional :: contextflag
     type(ESMF_Method),      intent(out), optional :: currentMethod
     integer,                intent(out), optional :: currentPhase
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns information about an <TT>ESMF_CplComp</TT>.
   For queries where the caller
   only wants a single value, specify the argument by name.
   All the arguments after <TT>cplcomp</TT> argument are optional 
   to facilitate this.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to query.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Return the name of the <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>Return the <TT>ESMF_Config</TT> object for this <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>Return the configuration filename for this <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Return the private clock for this <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Return the <TT>ESMF_VM</TT> for this <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Return the <TT>ESMF_ContextFlag</TT> for this <TT>ESMF_CplComp</TT>.
     See section <A HREF="node2.html#opt:contextflag">9.2.4</A> for a complete list of valid flags.
   
</DD>
<DT><STRONG>[currentMethod]</STRONG></DT>
<DD>Return the current <TT>ESMF_Method</TT> of the <TT>ESMF_CplComp</TT> execution.
     See section <A HREF="node2.html#opt:method">9.1.1</A>  for a complete list of valid options.
   
</DD>
<DT><STRONG>[currentPhase]</STRONG></DT>
<DD>Return the current <TT>phase</TT> of the <TT>ESMF_CplComp</TT> execution.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03044500000000000000">
14.4.5 ESMF_CplCompGetInternalState - Get private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompGetInternalState(cplcomp, dataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout) :: cplcomp
     type(any), pointer                :: dataPointer
     integer,            intent(out)   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_CplComp</TT> at any time after 
   <TT>ESMF_CplCompSetInternalState</TT> has been called.
   Since init, run, and finalize must be separate subroutines, data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by this call.
   When running multiple instantiations of an <TT>ESMF_CplComp</TT>, 
   for example during ensemble runs, 
   it may be simpler to maintain private data specific to 
   each run with private data blocks.  A corresponding 
   <TT>ESMF_CplCompSetInternalState</TT> call sets the data pointer to 
   this block, and this call retrieves the data pointer.   
   Note that the <TT>dataPointer</TT> argument needs to be a derived type
   which contains only a pointer of the type of the data block defined
   by the user.  When making this call the pointer needs to be unassociated.
   When the call returns, the pointer will now reference the original
   data block which was set during the previous call to
   <TT>ESMF_CplCompSetInternalState</TT>.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_CplCompSetInternalState</TT> will be accessible.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>An <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>dataPointer</STRONG></DT>
<DD>A derived type, containing only an unassociated pointer 
     to the private data block.
     The framework will fill in the pointer. When this call returns, the
     pointer is set to the same address set during the last
     <TT>ESMF_CplCompSetInternalState</TT> call.
     This level of indirection is needed to reliably set and retrieve 
     the data block no matter which architecture or compiler is used.  
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03044600000000000000">
14.4.6 ESMF_CplCompInitialize - Call the CplComp's initialize routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompInitialize(cplcomp, importState, &amp;
     exportState, clock, phase, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                               :: cplcomp
     type(ESMF_State),        intent(inout), optional :: importState
     type(ESMF_State),        intent(inout), optional :: exportState
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(in),    optional :: phase
     type(ESMF_BlockingFlag), intent(in),    optional :: blockingflag
     integer,                 intent(out),   optional :: userRc
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user initialization code for a CplComp.

<P>
The arguments are: 
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call initialize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.  
     Single-phase routines require only one invocation to complete
     their work.  
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase 
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03044700000000000000">
14.4.7 ESMF_CplCompIsPetLocal - Inquire if this component is to execute on the calling PET.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive function ESMF_CplCompIsPetLocal(cplcomp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_CplCompIsPetLocal
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)         :: cplcomp
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Inquire if this <TT>ESMF_CplComp</TT> object is to execute on the calling PET.

<P>
The return value is <TT>.true.</TT> if the component is to execute on the 
   calling PET, <TT>.false.</TT> otherwise.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> queried.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03044800000000000000">
14.4.8 ESMF_CplCompPrint - Print the contents of a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompPrint(cplcomp, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                        :: cplcomp
     character(len = *), intent(in),  optional :: options
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints information about an <TT>ESMF_CplComp</TT> to <TT>stdout</TT>. 
<BR>
<P>
Note:  Many <TT>ESMF_&lt;class&gt;Print</TT> methods are implemented in C++.
   On some platforms/compilers there is a potential issue with interleaving
   Fortran and C++ output to <TT>stdout</TT> such that it doesn't appear in
   the expected order.  If this occurs, the <TT>ESMF_IOUnitFlush()</TT> method
   may be used on unit 6 to get coherent output.  
<BR>
<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to print.
   
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options are not yet supported.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03044900000000000000">
14.4.9 ESMF_CplCompReadRestart - Call the CplComp's read restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompReadRestart(cplcomp, importState, &amp;
     exportState, clock, phase, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                               :: cplcomp
     type(ESMF_State),        intent(inout), optional :: importState
     type(ESMF_State),        intent(inout), optional :: exportState
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(in),    optional :: phase
     type(ESMF_BlockingFlag), intent(in),    optional :: blockingflag
     integer,                 intent(out),   optional :: userRc
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user read restart code for an <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.    
     Single-phase routines require only one invocation to complete
     their work.    
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase  
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030441000000000000000">
14.4.10 ESMF_CplCompRun - Call the CplComp's run routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompRun(cplcomp, importState, exportState, &amp;
     clock, phase, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                               :: cplcomp
     type(ESMF_State),        intent(inout), optional :: importState
     type(ESMF_State),        intent(inout), optional :: exportState
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(in),    optional :: phase
     type(ESMF_BlockingFlag), intent(in),    optional :: blockingflag
     integer,                 intent(out),   optional :: userRc
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user run code for an <TT>ESMF_CplComp</TT>.

<P>
The arguments are: 
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.  
     Single-phase routines require only one invocation to complete
     their work.  
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase 
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030441100000000000000">
14.4.11 ESMF_CplCompSet - Set or reset information about the CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSet(cplcomp, name, config, configFile, clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)           :: cplcomp
     character(len=*),   intent(in),    optional :: name
     type(ESMF_Config),  intent(inout), optional :: config
     character(len=*),   intent(in),    optional :: configFile
     type(ESMF_Clock),   intent(inout), optional :: clock
     integer,            intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets or resets information about an <TT>ESMF_CplComp</TT>.
   The caller can set individual values by specifying
   the arguments by name.
   All the arguments except <TT>cplcomp</TT> are optional 
   to facilitate this.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to change.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Set the name of the <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>Set the configuration information for the <TT>ESMF_CplComp</TT> from
     this already created <TT>ESMF_Config</TT> object.   
     If specified, takes priority over <TT>configFile</TT>.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>Set the configuration filename for this <TT>ESMF_CplComp</TT>.
     An <TT>ESMF_Config</TT> object will be created for this file
     and attached to the <TT>ESMF_CplComp</TT>.  Superceeded by <TT>config</TT>
     if both are specified.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Set the private clock for this <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030441200000000000000">
14.4.12 ESMF_CplCompSetEntryPoint - Set user routine as entry point for standard Component method</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetEntryPoint(cplcomp, method, userRoutine, phase, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent (in) :: cplcomp
     type(ESMF_Method),  intent(in)  :: method
     interface
       subroutine userRoutine(cplcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer, intent(in),  optional  :: phase
     integer, intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Registers a user-supplied <TT>userRoutine</TT> as the entry point for one of the
   predefined Component <TT>method</TT>s. After this call the <TT>userRoutine</TT>
   becomes accessible via the standard Component method API.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>An <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>method</STRONG></DT>
<DD>One of a set of predefined Component methods - e.g. <TT>ESMF_SETINIT</TT>, 
     <TT>ESMF_SETRUN</TT>, <TT>ESMF_SETFINAL</TT>. See section <A HREF="node2.html#opt:method">9.1.1</A> 
     for a complete list of valid method options.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated for this <TT>method</TT>.
     This subroutine does not have to be public.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>The <TT>phase</TT> number for multi-phase methods. For single phase 
     methods the <TT>phase</TT> argument can be omitted. The default setting
     is 1.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
The Component writer must supply a subroutine with the exact interface 
   shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
   must not be declared as optional, and the types, intent and order must match.

<P>

<P>

<H3><A NAME="SECTION030441300000000000000">
14.4.13 ESMF_CplCompSetInternalState - Set private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetInternalState(cplcomp, dataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout) :: cplcomp
     type(any), pointer                :: dataPointer
     integer,            intent(out)   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_CplComp</TT> at any time, but 
   expected to be
   most useful when called during the registration process, or initialization.
   Since init, run, and finalize must be separate subroutines data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by subsequent calls.
   When running multiple instantiations of an <TT>ESMF_CplComp</TT>, 
   for example during
   ensemble runs, it may be simpler to maintain private data specific to 
   each run with private data blocks.  A corresponding 
   <TT>ESMF_CplCompGetInternalState</TT> call retrieves the data pointer.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_CplCompSetInternalState</TT> will be accessible.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>An <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>dataPointer</STRONG></DT>
<DD>A pointer to the private data block, wrapped in a derived type which
     contains only a pointer to the block.  This level of indirection is
     needed to reliably set and retrieve the data block no matter which
     architecture or compiler is used.  
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030441400000000000000">
14.4.14 ESMF_CplCompSetServices - Call user routine to register CplComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompSetServices(cplcomp, userRoutine, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)             :: cplcomp
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer, intent(out), optional :: userRc
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call into user provided <TT>userRoutine</TT> which is responsible for
   for setting Component's Initialize(), Run() and Finalize() services.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Routine to be called.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
The Component writer must supply a subroutine with the exact interface 
   shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
   must not be declared as optional, and the types, intent and order must match.

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive calls to
   <TT>ESMF_CplCompSetEntryPoint()</TT> to preset callback routines for standard
   Component Initialize(), Run() and Finalize() methods.

<P>

<P>

<H3><A NAME="SECTION030441500000000000000">
14.4.15 ESMF_CplCompSetServices - Call user routine, located in shared object, to register CplComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_CplCompSetServices()
   recursive subroutine ESMF_CplCompSetServicesShObj(cplcomp, userRoutine, &amp;
     sharedObj, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
     character(len=*),    intent(in)            :: userRoutine
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call into user provided routine which is responsible for setting
   Component's Initialize(), Run() and Finalize() services. The named
   <TT>userRoutine</TT> must exist in the shared object file specified in the
   <TT>sharedObj</TT> argument. All of the platform specific details about 
   dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of routine to be called.
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
The Component writer must supply a subroutine with the exact interface 
   shown for <TT>userRoutine</TT> below. Arguments must not be declared
   as optional, and the types, intent and order must match.

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface
       subroutine userRoutine(cplcomp, rc)
         type(ESMF_CplComp)   :: cplcomp    ! must not be optional
         integer, intent(out) :: rc         ! must not be optional
       end subroutine
     end interface
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive
   calls to <TT>ESMF_CplCompSetEntryPoint()</TT> to preset callback routines for
   standard Component Initialize(), Run() and Finalize() methods.

<P>

<P>

<H3><A NAME="SECTION030441600000000000000">
14.4.16 ESMF_CplCompSetVM - Call user routine to set CplComp VM properies</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompSetVM(cplcomp, userRoutine, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)             :: cplcomp
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer, intent(out), optional :: userRc
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible for
   for setting Component's VM properties. 

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Routine to be called.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
The Component writer must supply a subroutine with the exact interface 
   shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
   must not be declared as optional, and the types, intent and order must match.

<P>
The subroutine, when called by the framework, is expected to use any of the
   <TT>ESMF_CplCompSetVMxxx()</TT> methods to set the properties of the VM
   associated with the Coupler Component.

<P>

<P>

<H3><A NAME="SECTION030441700000000000000">
14.4.17 ESMF_CplCompSetVM - Set CplComp VM properties in routine located in shared object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_CplCompSetVM()
   recursive subroutine ESMF_CplCompSetVMShObj(cplcomp, userRoutine, sharedObj, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
     character(len=*),    intent(in)            :: userRoutine
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible for
   for setting Component's VM properties. The named <TT>userRoutine</TT> must exist
   in the shared object file specified in the <TT>sharedObj</TT> argument. All of
   the platform specific details about dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Routine to be called.
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the 
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
The Component writer must supply a subroutine with the exact interface 
   shown for <TT>userRoutine</TT> below. Arguments must not be declared
   as optional, and the types, intent and order must match.

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface
       subroutine userRoutine(cplcomp, rc)
         type(ESMF_CplComp)   :: cplcomp     ! must not be optional
         integer, intent(out) :: rc          ! must not be optional
       end subroutine
     end interface
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
The subroutine, when called by the framework, is expected to use any of the
   <TT>ESMF_CplCompSetVMxxx()</TT> methods to set the properties of the VM
   associated with the Coupler Component.

<P>

<P>

<H3><A NAME="SECTION030441800000000000000">
14.4.18 ESMF_CplCompSetVMMaxPEs - Set VM for Coupler Component to associate max PEs with PETs.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetVMMaxPEs(cplcomp, max, pref_intra_process, &amp;
     pref_intra_ssi, pref_inter_ssi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
     integer,             intent(in),  optional :: max
     integer,             intent(in),  optional :: pref_intra_process
     integer,             intent(in),  optional :: pref_intra_ssi
     integer,             intent(in),  optional :: pref_inter_ssi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_CplComp</TT>.
     Attempts to associate <TT>max</TT> PEs with each PET. Only PEs that are 
     located on the same single system image can be associated with the same PET.
     Within this constraint the call tries to get as close as possible to the
     number specified by <TT>max</TT>.

<P>
The typical use of <TT>ESMF_CplCompSetVMMaxPEs()</TT> is to allocate
     multiple PEs per PET in a Component for user-level threading, e.g. OpenMP.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[max]</STRONG></DT>
<DD>Maximum number of PEs per PET. Default is peCount.
   
</DD>
<DT><STRONG>[pref_intra_process]</STRONG></DT>
<DD>Intra process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_intra_ssi]</STRONG></DT>
<DD>Intra SSI communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_inter_ssi]</STRONG></DT>
<DD>Inter process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030441900000000000000">
14.4.19 ESMF_CplCompSetVMMaxThreads - Set VM for Gridded Component with multi-threaded PETs.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetVMMaxThreads(cplcomp, max, pref_intra_process, &amp;
     pref_intra_ssi, pref_inter_ssi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
     integer,             intent(in),  optional :: max
     integer,             intent(in),  optional :: pref_intra_process
     integer,             intent(in),  optional :: pref_intra_ssi
     integer,             intent(in),  optional :: pref_inter_ssi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_CplComp</TT>.
     Attempts to provide <TT>max</TT> threaded PETs in each VAS. Only as many
     threaded PETs as there are PEs located on the same single system image
     can be associated with the same VAS. Within this constraint the call
     tries to get as close as possible to the number specified by <TT>max</TT>.

<P>
The typical use of <TT>ESMF_CplCompSetVMMaxThreads()</TT> is to run a 
     Component multi-threaded with a groups of PETs that execute within the
     same virtual address space.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[max]</STRONG></DT>
<DD>Maximum threading level.
   
</DD>
<DT><STRONG>[pref_intra_process]</STRONG></DT>
<DD>Intra process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_intra_ssi]</STRONG></DT>
<DD>Intra SSI communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_inter_ssi]</STRONG></DT>
<DD>Inter process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030442000000000000000">
14.4.20 ESMF_CplCompSetVMMinThreads - Set VM for Coupler Component with reduced threading level.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetVMMinThreads(cplcomp, max, pref_intra_process, &amp;
     pref_intra_ssi, pref_inter_ssi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
     integer,             intent(in),  optional :: max
     integer,             intent(in),  optional :: pref_intra_process
     integer,             intent(in),  optional :: pref_intra_ssi
     integer,             intent(in),  optional :: pref_inter_ssi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_CplComp</TT>.
     Reduces the number of threaded PETs in each VAS. The <TT>max</TT> argument
     may be specified to limit the maximum number of PEs that a single PET 
     may be associated with.

<P>
The typical use of <TT>ESMF_CplCompSetVMMinThreads()</TT> is to run a 
     Component across a set of single-threaded PETs.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[max]</STRONG></DT>
<DD>Maximum number of PEs per PET. Default is peCount.
   
</DD>
<DT><STRONG>[pref_intra_process]</STRONG></DT>
<DD>Intra process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_intra_ssi]</STRONG></DT>
<DD>Intra SSI communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pref_inter_ssi]</STRONG></DT>
<DD>Inter process communication preference.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030442100000000000000">
14.4.21 ESMF_CplCompValidate - Ensure the CplComp is internally consistent</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompValidate(cplcomp, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                        :: cplcomp
     character(len = *), intent(in),  optional :: options
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Currently all this method does is to check that the <TT>cplcomp</TT> exists.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to validate.
   
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Validation options are not yet supported.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030442200000000000000">
14.4.22 ESMF_CplCompWait - Wait for a CplComp to return</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompWait(cplcomp, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),      intent(inout)         :: cplcomp
     type(ESMF_BlockingFlag), intent(in),  optional :: blockingflag
     integer,                 intent(out), optional :: userRc
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
When executing asychronously, wait for an <TT>ESMF_CplComp</TT> to return.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to wait for.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030442300000000000000">
14.4.23 ESMF_CplCompWriteRestart - Call the CplComp's write restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompWriteRestart(cplcomp, importState, &amp;
     exportState, clock, phase, blockingflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),      intent(inout)           :: cplcomp
     type(ESMF_State),        intent(inout), optional :: importState
     type(ESMF_State),        intent(inout), optional :: exportState
     type(ESMF_Clock),        intent(inout), optional :: clock
     integer,                 intent(in),    optional :: phase
     type(ESMF_BlockingFlag), intent(in),    optional :: blockingflag
     integer,                 intent(out),   optional :: userRc
     integer,                 intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user write restart code for an <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.    
     Single-phase routines require only one invocation to complete
     their work.    
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase  
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[blockingflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#opt:blockingflag">9.2.2</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION03050000000000000000">
15 State Class</A>
</H1>

<P>

<H2><A NAME="SECTION03051000000000000000">
15.1 Description</A>
</H2>

<P>
A State contains the data and metadata to be transferred between 
ESMF components.  It is an important class, because it defines a 
standard for how data is represented in data transfers between Earth
science Components.  The 
State construct is a rational compromise between a fully prescribed 
interface - one that would dictate what specific fields should be 
transferred between components - and an interface in which data structures
are completely ad hoc.

<P>
There are two types of States, import and export.
An import State contains data that is necessary for a Gridded Component
or Coupler Component to execute, and an export State contains the data
that a Gridded Component or Coupler Component can make available.

<P>
States can contain Arrays, ArrayBundles, Fields, FieldBundles, and other States.  They
cannot directly contain Fortran arrays.   Objects in a State must span
the VM on which they are running.  For sequentially executing components
which run on the same set of PETs this happens by calling the object
create methods on each PET, creating the object in unison.   For
concurrently executing components which are running on subsets of PETs,
an additional reconcile method is provided by the ESMF to broadcast information
about objects which were created in sub-components.

<P>
State methods include creation and deletion, adding and retrieving 
data items, adding and retrieving attributes, and performing queries.  

<P>

<P>

<H2><A NAME="SECTION03052000000000000000">
15.2 State Options</A>
</H2>

<P>

<H3><A NAME="SECTION03052100000000000000"></A>
<A NAME="opt:stateitemtype"></A>
<BR>
15.2.1 ESMF_StateItemType
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Specifies the type of object being added to or retrieved from an
ESMF_State.

<P>
Valid values are:
<DL>
<DT><STRONG>ESMF_STATEITEM_BUNDLE</STRONG></DT>
<DD>Refers to an <TT>ESMF_FieldBundle</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_FIELD</STRONG></DT>
<DD>Refers to an <TT>ESMF_Field</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_ARRAY</STRONG></DT>
<DD>Refers to an <TT>ESMF_Array</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_STATE</STRONG></DT>
<DD>Refers to an <TT>ESMF_State</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_NAME</STRONG></DT>
<DD>Refers to a data name used as a placeholder within 
         an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_NOTFOUND</STRONG></DT>
<DD>Only valid as a return object type from a query routine.  Indicates
         that no object with this name exists in the <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_UNKNOWN</STRONG></DT>
<DD>Object type within an <TT>ESMF_State</TT> is unknown.
</DD>
</DL>

<P>

<H3><A NAME="SECTION03052200000000000000"></A>
<A NAME="opt:statetype"></A>
<BR>
15.2.2 ESMF_StateType
</H3>
<I>DESCRIPTION:
<BR></I>
Specifies whether an <TT>ESMF_State</TT> contains data to be imported
into a component or exported from a component. 

<P>
Valid values are:
<DL>
<DT><STRONG>ESMF_STATE_IMPORT</STRONG></DT>
<DD>Contains data to be imported into a component.
   
</DD>
<DT><STRONG>ESMF_STATE_EXPORT</STRONG></DT>
<DD>Contains data to be exported out of a component.
   
</DD>
<DT><STRONG>ESMF_STATE_INVALID</STRONG></DT>
<DD>Does not contain valid data.
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION03053000000000000000">
15.3 Use and Examples</A>
</H2>

<P>
A Gridded Component generally has one associated import 
State and one export State.  Generally the States 
associated with a Gridded Component will be created by 
the Gridded Component's parent component.
In many cases, the States will be created containing 
no data.  Both the empty States and the
newly created Gridded Component are passed
by the parent component into the Gridded Component's initialize 
method.  This is where the States get prepared for use 
and the import State is first filled with data.

<P>
States can be created in a number of ways without the Fields, Arrays,
FieldBundles, ArrayBundles, and other States they will eventually contain.
They can be created with names as placeholders where 
these data items will eventually be.  When the States are passed 
into the Gridded Component's initialize method, Field,
FieldBundle, Array, and ArrayBundle create calls can be made in that method
to replace the name placeholders with real data objects.

<P>
States can also be filled with data items that do not yet 
have data allocated.  Fields, FieldBundles, Arrays, and ArrayBundles each have 
methods that support their creation without actual data 
allocation - the Grid and Attributes are set up but no
Fortran array of data values is allocated.  In this approach, 
when a State is passed into its associated Gridded Component's 
initialize method, the incomplete Arrays, Fields, FieldBundles,
and ArrayBundles within the State can allocate or reference data 
inside the initialize method.

<P>
States are passed through the interfaces of the Gridded 
and Coupler Components' run methods in order to carry data 
between the components.  While we expect
a Gridded Component's import State to be filled with data 
during initialization, its export State will typically be
filled over the course of its run method.  At the end of
a Gridded Component's run method, the filled export State 
is passed out through the argument list into a Coupler 
Component's run method.  We recommend the convention that 
it enters the Coupler Component as the Coupler Component's
import State.  Here is it transformed into a form
that another Gridded Component requires, and passed out
of the Coupler Component as its export State.  It can then
be passed into the run method of a recipient Gridded Component
as that component's import State.

<P>
While the above sounds complicated, the rule is simple:
a State going into a component is an import State, and a 
State leaving a component is an export State.

<P>
Data items within a State can be marked needed or not needed,
depending on whether they are required for a particular 
application configuration.  If the item is marked not needed,
the user can make the Gridded Component's initialize method 
clever enough to not allocate the data for that item at all
and not compute it within the Gridded Component code.
For example, some diagnostics may not be desired for all 
runs.

<P>
Other flags will eventually be available for data items within 
a State, such as data ready for reading or writing, data valid or 
invalid, and data required for restart or not.  These are not
yet fully implemented, so only the default value for each value 
can be set at this time.

<P>
Objects inside States are normally created in <TT>unison</TT> where
each PET executing a component makes the same object create call.
If the object contains data, like a Field, each PET may have a
different local chunk of the entire dataset but each Field has
the same name and is logically one part of a single distributed 
object.   As States are passed between components, if any object
in a State was not created in unison on all the current PETs 
then some PETs have no object to pass into a
communication method (e.g. regrid or data redistribution).
The <TT>ESMF_StateReconcile()</TT> method must be called to broadcast 
information about these objects to all PETs in a component;
after which all PETs have a single uniform view of all objects and metadata.  

<P>
If components are running in sequential mode on all available PETs
and States are being passed between them there is no need to call 
<TT>ESMF_StateReconcile</TT> since all PETs have a uniform view of the objects.
However, if components are running on a subset of the PETs, as is
usually the case when running in concurrent mode, then when States
are passed into components which contain a superset of those PETs,
for example, a Coupler Component, all PETs must call <TT>ESMF_StateReconcile</TT>
on the States before using them in any ESMF communication methods.
The reconciliation process broadcasts information about objects
which exist only on a subset of the PETs.  On PETs missing those
objects it creates a <I>proxy</I> object which contains any
qualities of the original object plus enough information for it
to be a data source or destination for a regrid or data redistribution
operation.  There is an option to turn off metadata reconciliation in the 
<TT>ESMF_StateReconcile</TT> call.

<P>

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_StateEx - State creation and operation
!
! !DESCRIPTION:
!
! This program shows examples of State creation and manipulation
!-----------------------------------------------------------------------------

    ! ESMF Framework module
    use ESMF_Mod
    implicit none

    ! Local variables
    integer :: rc
    character(ESMF_MAXSTR) :: statename, bundlename, dataname
    !type(ESMF_Field) :: field1
    type(ESMF_FieldBundle) :: bundle1, bundle2
    type(ESMF_State) :: state1, state2, state3
</PRE>

<P>

<H3><A NAME="SECTION03053100000000000000">
15.3.1 Empty State Create</A>
</H3>

<P>
Creation of an empty <TT>ESMF_State</TT>, which will be added to later. 

<P>
<PRE>
    statename = "Atmosphere"
    state1 = ESMF_StateCreate(statename, statetype=ESMF_STATE_IMPORT, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION03053200000000000000">
15.3.2 Adding Items to a State</A>
</H3>

<P>
Creation of an empty <TT>ESMF_State</TT>, and adding an <TT>ESMF_FieldBundle</TT>
    to it.  Note that the <TT>ESMF_FieldBundle</TT> does not get destroyed when
    the <TT>ESMF_State</TT> is destroyed; the <TT>ESMF_State</TT> only contains
    a reference to the objects it contains.  It also does not make a copy;
    the original objects can be updated and code accessing them by using
    the <TT>ESMF_State</TT> will see the updated version. 

<P>
<PRE>
    statename = "Ocean"
    state2 = ESMF_StateCreate(statename, statetype=ESMF_STATE_EXPORT, rc=rc)
</PRE>

<P>
<PRE>
    bundlename = "Temperature"
    bundle1 = ESMF_FieldBundleCreate(name=bundlename, rc=rc)
    print *, "FieldBundle Create returned", rc
</PRE>

<P>
<PRE>
    call ESMF_StateAdd(state2, bundle1, rc)
    print *, "StateAdd returned", rc
</PRE>

<P>
<PRE>
    call ESMF_StateDestroy(state2, rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleDestroy(bundle1, rc)
</PRE>

<P>

<H3><A NAME="SECTION03053300000000000000">
15.3.3 Adding Placeholders to a State</A>
</H3>

<P>
If a component could potentially produce a large number of optional
   items, one strategy is to add the names only of those objects to the
   <TT>ESMF_State</TT>.  Other components can call framework routines to
   set the <TT>ESMF_NEEDED</TT> flag to indicate they require that data.
   The original component can query this flag and then produce only the
   data that is required by another component. 

<P>
<PRE>
    statename = "Ocean"
    state3 = ESMF_StateCreate(statename, statetype=ESMF_STATE_EXPORT, rc=rc)
</PRE>

<P>
<PRE>
    dataname = "Downward wind"
    call ESMF_StateAdd(state3, dataname, rc)
</PRE>

<P>
<PRE>
    dataname = "Humidity"
    call ESMF_StateAdd(state3, dataname, rc)
</PRE>

<P>

<H3><A NAME="SECTION03053400000000000000">
15.3.4 Marking an Item Needed</A>
</H3>

<P>
How to set the <TT>NEEDED</TT> state of an item. 

<P>
<PRE>
    dataname = "Downward wind"
    call ESMF_StateSetNeeded(state3, dataname, ESMF_NEEDED, rc)
</PRE>

<P>

<H3><A NAME="SECTION03053500000000000000">
15.3.5 Creating a Needed Item</A>
</H3>

<P>
Query an item for the <TT>NEEDED</TT> status, and creating an item on demand.
   Similar flags exist for "Ready", "Valid", and "Required for Restart",
   to mark each data item as ready, having been validated, or needed if the
   application is to be checkpointed and restarted.  The flags are supported
   to help coordinate the data exchange between components. 

<P>
<PRE>
    dataname = "Downward wind"
    if (ESMF_StateIsNeeded(state3, dataname, rc)) then
</PRE>

<P>
<PRE>
        bundlename = dataname
        bundle2 = ESMF_FieldBundleCreate(name=bundlename, rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_StateAdd(state3, bundle2, rc)
</PRE>

<P>
<PRE>
    else
        print *, "Data not marked as needed", trim(dataname)
    endif
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION03053600000000000000">
15.3.6 Initialization and SetServices Routines</A>
</H3>

<P>
These are the separate subroutines called by the code below. 

<P>
<PRE>
! Initialize routine which creates "field1" on PETs 0 and 1
subroutine comp1_init(gcomp, istate, ostate, clock, rc)
    type(ESMF_GridComp)  :: gcomp
    type(ESMF_State)     :: istate, ostate
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    type(ESMF_Field) :: field1
    integer :: localrc

    print *, "i am comp1_init"

    field1 = ESMF_FieldCreateEmpty(name="Comp1 Field", rc=localrc)
  
    call ESMF_StateAdd(istate, field1, rc=localrc)
    
    rc = localrc

end subroutine comp1_init

! Initialize routine which creates "field2" on PETs 2 and 3
subroutine comp2_init(gcomp, istate, ostate, clock, rc)
    type(ESMF_GridComp)  :: gcomp
    type(ESMF_State)     :: istate, ostate
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    type(ESMF_Field) :: field2
    integer :: localrc

    print *, "i am comp2_init"

    field2 = ESMF_FieldCreateEmpty(name="Comp2 Field", rc=localrc)
    
    call ESMF_StateAdd(istate, field2, rc=localrc)

    rc = localrc

end subroutine comp2_init

subroutine comp_dummy(gcomp, rc)
   type(ESMF_GridComp)  :: gcomp
   integer, intent(out) :: rc

   rc = ESMF_SUCCESS
end subroutine comp_dummy
</PRE>

<P>
<PRE>
! !PROGRAM: ESMF_StateReconcileEx - State reconciliation
!
! !DESCRIPTION:
!
! This program shows examples of using the State Reconcile function
!-----------------------------------------------------------------------------

    ! ESMF Framework module
    use ESMF_Mod
    use ESMF_StateReconcileEx_Mod
    implicit none

    ! Local variables
    integer :: rc, petCount
    type(ESMF_State) :: state1
    type(ESMF_GridComp) :: comp1, comp2
    type(ESMF_VM) :: vm
    character(len=ESMF_MAXSTR) :: comp1name, comp2name, statename
</PRE>

<P>

<H3><A NAME="SECTION03053700000000000000">
15.3.7 Creating Components on subsets of the current PET list</A>
</H3>

<P>
A Component can be created which will run only on a subset of the
    current PET list. 

<P>
<PRE>
    ! Get the global VM for this job.
    call ESMF_VMGetGlobal(vm=vm, rc=rc)

    comp1name = "Atmosphere"
    comp1 = ESMF_GridCompCreate(name=comp1name, petList=(/ 0, 1 /), rc=rc)
    print *, "GridComp Create returned, name = ", trim(comp1name)

    comp2name = "Ocean"
    comp2 = ESMF_GridCompCreate(name=comp2name, petList=(/ 2, 3 /), rc=rc)
    print *, "GridComp Create returned, name = ", trim(comp2name)

    statename = "Ocn2Atm"
    state1 = ESMF_StateCreate(statename, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION03053800000000000000">
15.3.8 Invoking Components on a subset of the Parent PETs</A>
</H3>

<P>
Here we register the subroutines which should be called for initialization.
    Then we call ESMF_GridCompInitialize() on all PETs, but the code runs
    only on the PETs given in the petList when the Component was created.

<P>
Because this example is so short, we call the entry point code
    directly instead of the normal procedure of nesting it in a separate
    SetServices() subroutine.  

<P>
<PRE>
    ! This is where the VM for each component is initialized.
    ! Normally you would call SetEntryPoint inside set services,
    ! but to make this example very short, they are called inline below.
    ! This is o.k. because the SetServices routine must execute from within
    ! the parent component VM.
    call ESMF_GridCompSetVM(comp1, comp_dummy, rc)
    call ESMF_GridCompSetVM(comp2, comp_dummy, rc)
    call ESMF_GridCompSetServices(comp1, comp_dummy, rc)
    call ESMF_GridCompSetServices(comp2, comp_dummy, rc)

    print *, "ready to set entry point 1"
    call ESMF_GridCompSetEntryPoint(comp1, ESMF_SETINIT, comp1_init, rc=rc)

    print *, "ready to set entry point 2"
    call ESMF_GridCompSetEntryPoint(comp2, ESMF_SETINIT, comp2_init, rc=rc)


    print *, "ready to call init for comp 1"
    call ESMF_GridCompInitialize(comp1, state1, rc=rc)
    print *, "ready to call init for comp 2"
    call ESMF_GridCompInitialize(comp2, state1, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION03053900000000000000">
15.3.9 Using State Reconcile</A>
</H3>

<P>
Now we have <TT>state1</TT> containing <TT>field1</TT> on PETs 0 and 1, and
   <TT>state1</TT> containing <TT>field2</TT> on PETs 2 and 3.  For the code
   to have a rational view of the data, we call <TT>ESMF_StateReconcile</TT>
   which determines which objects are missing from any PET, and communicates
   information about the object.  There is the option of turning metadata
   reconciliation on or off with the optional parameter shown in the call 
   below.  The default behavior is for metadata reconciliation to be off.
   After the call to reconcile, all
   <TT>ESMF_State</TT> objects now have a consistent view of the data. 

<P>
<PRE>
    print *, "State before calling StateReconcile()"
    call ESMF_StatePrint(state1, rc=rc)

    call ESMF_StateReconcile(state1, vm, ESMF_ATTRECONCILE_OFF, rc=rc)

    print *, "State after calling StateReconcile()"
    call ESMF_StatePrint(state1, rc=rc)
</PRE>

<P>
<PRE>
end program ESMF_StateReconcileEx
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION030531000000000000000"></A>
   <A NAME="example:StateRdWr"></A>
<BR>
15.3.10 State Read/Write from/to a NetCDF file
</H3> 

<P>
<PRE>
! !PROGRAM: ESMF_StateReadWriteEx - State Read/Write from/to a NetCDF file
!
! !DESCRIPTION:
!
! This program shows an example of reading and writing Arrays from a State
! from/to a NetCDF file.
!-----------------------------------------------------------------------------

    ! ESMF Framework module
    use ESMF_Mod
    implicit none

    ! Local variables
    type(ESMF_State) :: state
    type(ESMF_Array) :: latArray, lonArray, timeArray, humidArray, &amp;
                        tempArray, pArray, rhArray
    type(ESMF_VM) :: vm
    integer :: localPet, rc
</PRE>

<P>

<H3><A NAME="SECTION030531100000000000000">
15.3.11 ESMF Initialization and Empty State Create</A>
</H3>

<P>
Initialize ESMF and Create an empty <TT>ESMF_State</TT>, which will be
    subsequently filled with <TT>ESMF_Arrays</TT> from a file.

<P>
<PRE>
    call ESMF_Initialize(vm=vm, rc=rc)
    call ESMF_VMGet(vm, localPet=localPet, rc=rc)

    state = ESMF_StateCreate("Ocean Import", ESMF_STATE_IMPORT, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION030531200000000000000">
15.3.12 Reading Arrays from a NetCDF file and Adding to a State</A>
</H3>

<P>
The following line of code will read all Array data contained in a NetCDF
    file, place them in <TT>ESMF_Arrays</TT> and add them to an <TT>ESMF_State</TT>.
    Only PET 0 reads the file; the States in the other PETs remain empty.
    Currently, the data is not decomposed or distributed; each PET
    has only 1 DE and only PET 0 contains data after reading the file.
    Future versions of ESMF will support data decomposition and distribution
    upon reading a file.

<P>
Note that the third party NetCDF library must be installed.  For more
    details, see the "ESMF Users Guide", 
    "Building and Installing the ESMF, Third Party Libraries, NetCDF" and
    the website http://www.unidata.ucar.edu/software/netcdf. 

<P>
<PRE>
    ! Read the NetCDF data file into Array objects in the State on PET 0
    call ESMF_StateRead(state, "io_netcdf_testdata.nc", rc=rc)

    ! If the NetCDF library is not present (on PET 0), cleanup and exit 
    if (rc == ESMF_RC_LIB_NOT_PRESENT) then
      call ESMF_StateDestroy(state, rc=rc)
      goto 10
    endif
</PRE>

<P>
Only reading data into <TT>ESMF_Arrays</TT> is supported at this time;
    <TT>ESMF_ArrayBundles</TT>, <TT>ESMF_Fields</TT>, and <TT>ESMF_FieldBundles</TT>
    will be supported in future releases of ESMF. 

<P>

<H3><A NAME="SECTION030531300000000000000">
15.3.13 Printing Array data from a State</A>
</H3>

<P>
To see that the State now contains the same data as in the file, the
    following shows how to print out what Arrays are contained within the
    State and to print the data contained within each Array.  The NetCDF utility
    "ncdump" can be used to view the contents of the NetCDF file.
    In this example, only PET 0 will contain data. 

<P>
<PRE>
    if (localPet == 0) then
      ! Print the names and attributes of Array objects contained in the State
      call ESMF_StatePrint(state, rc=rc)

      ! Get each Array by name from the State
      call ESMF_StateGet(state, "lat",  latArray,   rc=rc)
      call ESMF_StateGet(state, "lon",  lonArray,   rc=rc)
      call ESMF_StateGet(state, "time", timeArray,  rc=rc)
      call ESMF_StateGet(state, "Q",    humidArray, rc=rc)
      call ESMF_StateGet(state, "TEMP", tempArray,  rc=rc)
      call ESMF_StateGet(state, "p",    pArray,     rc=rc)
      call ESMF_StateGet(state, "rh",   rhArray,    rc=rc)

      ! Print out the Array data
      call ESMF_ArrayPrint(latArray,   rc=rc)
      call ESMF_ArrayPrint(lonArray,   rc=rc)
      call ESMF_ArrayPrint(timeArray,  rc=rc)
      call ESMF_ArrayPrint(humidArray, rc=rc)
      call ESMF_ArrayPrint(tempArray,  rc=rc)
      call ESMF_ArrayPrint(pArray,     rc=rc)
      call ESMF_ArrayPrint(rhArray,    rc=rc)
    endif
</PRE>

<P>
Note that the Arrays "lat", "lon", and "time" hold spatial and temporal
    coordinate data for the dimensions latitude, longitude and time,
    respectively.  These will be used in future releases of ESMF to create
    <TT>ESMF_Grids</TT>. 

<P>

<H3><A NAME="SECTION030531400000000000000">
15.3.14 Writing Array data within a State to a NetCDF file</A>
</H3>

<P>
All the Array data within the State on PET 0 can be written out to a NetCDF
    file as follows: 

<P>
<PRE>
    ! Write Arrays within the State on PET 0 to a NetCDF file
    call ESMF_StateWrite(state, "io_netcdf_testdata_out.nc", rc=rc)
</PRE>

<P>
Currently writing is limited to PET 0; future versions of ESMF will allow
    parallel writing, as well as parallel reading. 

<P>

<H3><A NAME="SECTION030531500000000000000">
15.3.15 Destroying a State and its constituent Arrays</A>
</H3>

<P>
Destroying a State only deallocates the container, not the contents, as
    the contents may be used in other States and elsewhere.  The contents of a
    State, such as the Arrays in this example, must be destroyed separately.
    Only PET 0 in this example will have Arrays that need to be destroyed. 

<P>
<PRE>
    ! Destroy the State container
    call ESMF_StateDestroy(state, rc=rc)

    if (localPet == 0) then
      ! Destroy the constituent Arrays
      call ESMF_ArrayDestroy(latArray,   rc=rc)
      call ESMF_ArrayDestroy(lonArray,   rc=rc)
      call ESMF_ArrayDestroy(timeArray,  rc=rc)
      call ESMF_ArrayDestroy(humidArray, rc=rc)
      call ESMF_ArrayDestroy(tempArray,  rc=rc)
      call ESMF_ArrayDestroy(pArray,     rc=rc)
      call ESMF_ArrayDestroy(rhArray,    rc=rc)
    endif
</PRE>

<P>
<PRE>
 10 continue  ! Exit point if NetCDF not present (PET 0)
    call ESMF_Finalize(rc=rc)
</PRE>

<P>

<P>

<H2><A NAME="SECTION03054000000000000000">
15.4 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Flags not fully implemented.</B>
The flags for indicating various qualities associated with 
data items in a State - validity, whether or not the item is
required for restart, read/write status - are not fully implemented.
Although their defaults can be set, the associated methods for 
setting and getting these flags have not been implemented.
(The <TT>needed</TT> flag is fully supported.)

<P>
</LI>
<LI><B>No synchronization at object create time.</B>
Object IDs are using during the reconcile process to identify objects
which are unknown to some subset of the PETs in the currently running VM.
Object IDs are assigned in sequential order at object create time.
User input at design time requested there be no communication overhead
during the create of an object, so there is no opportunity to
synchronize IDs if one or more PETs create objects which
are not in unison (not all PETs in the VM make the same calls).

<P>
Even if the user follows the unison rules, if components are running on 
a subset of the PETs, when they return to the parent (calling) component
the next available ID will potentially not be the same across all
PETs in the VM.  Part of the reconcile process or part of the return
to the parent will need to have a broadcast which sends the current
ID number, and all PETs can reset the next available number to the highest
number broadcast.  This could be an async call to avoid as much as
possible serialization and barrier issues.

<P>
Default object names are based on the object id (e.g. "Field1", "Field2")
to create unique object names, so basing the detection of unique objects 
on the name instead of on the object id is no better solution.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION03055000000000000000">
15.5 Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>States contain the name of the associated Component, a flag for Import
or Export, and a list of data objects, which can be a combination of
FieldBundles, Fields, and/or Arrays.  The objects must be named and have
the proper attributes so they can be identified by the receiver of
the data.  For example, units and other detailed information
may need to be associated with the data as an Attribute.  

<P>
</LI>
<LI>Data contained in States must be created in unison on each
PET of the current VM.  This allows the creation process to avoid
doing communications since each PET can compute any information
it needs to know about any remote PET (for example, the grid
distribute method can compute the decomposition of the grid on
not only the local PET but also the remote PETs since it knows
each PET is making the identical call).  For all PETs to have a
consistent view of the data this means objects must be given
unique names when created, or all objects must be created in
the same order on all PETs so ESMF can generate consistent
default names for the objects.

<P>
When running components on subsets of the original VM all the
PETs can create consistent objects but then when they are put
into a State and passed to a component with a different VM and
a different set of PETs, a communication call (reconcile) must be 
made to communicate the missing information to the PETs which were 
not involved in the original object creation.  The reconcile call
broadcasts object lists; those PETs which are missing any objects
in the total list can receive enough information to
reconstruct a proxy object which contains all necessary information
about that object, with no local data, on that PET.  These proxy
objects can be queried by ESMF routines to determine the amount
of data and what PETs contain data which is destined to be moved
to the local PET (for receiving data) and conversely, can determine
which other PETs are going to receive data and how much (for
sending data).

<P>
For example, the FieldExcl system test creates 2 Gridded Components
on separate subsets of PETs.  They use the option of mapping
particular, non-monotonic PETs to DEs.  The following figures 
illustrate how the DEs are mapped in each of the Gridded Components
in that test:

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_source"></A><A NAME="6656"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 7:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the source grid created by <TT>user_model1.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_src_grid}}$
 -->
<IMG
 WIDTH="421" HEIGHT="248" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_src_grid}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_destination"></A><A NAME="6658"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 8:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the destination grid created by <TT>user_model2.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_dst_grid}}$
 -->
<IMG
 WIDTH="414" HEIGHT="238" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_dst_grid}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
In the coupler code, all PETs must make the reconcile call before
accessing data in the State.  On PETs which already contain data,
the objects are unchanged.  On PETs which were not involved during
the creation of the FieldBundles or Fields, the reconcile call adds an
object to the State which contains all the same metadata associated
with the object, but creates a slightly different Grid object,
called a Proxy Grid. These PETs contain no local data, so the
Array object is empty, and the DELayout for the Grid is like this:

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_source_cpl"></A><A NAME="6660"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 9:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the source grid after the reconcile call in <TT>user_coupler.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_src_grid_cpl}}$
 -->
<IMG
 WIDTH="624" HEIGHT="289" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_src_grid_cpl}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_destination_cpl"></A><A NAME="6662"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 10:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the destination grid after the reconcile call in <TT>user_coupler.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_dst_grid_cpl}}$
 -->
<IMG
 WIDTH="688" HEIGHT="296" ALIGN="BOTTOM" BORDER="0"
 SRC="img11.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_dst_grid_cpl}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION03056000000000000000">
15.6 Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
State class.  States can contain FieldBundles, Fields, Arrays, or nested
States.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="749" HEIGHT="216" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="\includegraphics[]{State_obj}">   

</DIV>

<P>

<H2><A NAME="SECTION03057000000000000000">
15.7 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION03057100000000000000">
15.7.1 ESMF_StateAdd - Add a single item to a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_StateAdd(state, &lt;item&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_State), intent(inout)          :: state
      &lt;item&gt;, see below for supported values
      integer,          intent(out),  optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a reference to a single &lt;item&gt; to an existing 
        <TT>state</TT>.  Any of the supported &lt;item&gt;s can
        be marked needed for a particular run using the
        <TT>ESMF_StateSetNeeded()</TT> call.  The name of the
        &lt;item&gt; must be unique within the <TT>state</TT>.  

<P>
One of the supported options below is to add only the name of the
        item to the <TT>state</TT> during a first pass.  The name can be
        replaced with the actual &lt;item&gt; in a later call.
        When doing this, the name of the &lt;item&gt; provided to the
        <TT>state</TT> during the first pass must match the name stored
        in the &lt;item&gt; itself.

<P>
Supported values for &lt;item&gt; are:
        <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in)            :: array
        
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in)      :: arraybundle
        
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in)            :: field
        
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in)      :: fieldbundle
        
</DD>
<DT></DT>
<DD>character (len=*), intent(in)            :: name
        
</DD>
<DT></DT>
<DD>type(ESMF_RouteHandle), intent(in)      :: routehandle
        
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in)            :: nestedState
        
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to which &lt;item&gt;s will be added.
   
</DD>
<DT><STRONG>&lt;item&gt;</STRONG></DT>
<DD>The &lt;item&gt; to be added.  This is a reference only; when
        the <TT>state</TT> is destroyed the &lt;item&gt;s contained in it will
        not be destroyed.   Also, the &lt;item&gt; cannot be safely 
        destroyed before the <TT>state</TT> is destroyed.
        Since &lt;item&gt;s can be added to multiple containers, it remains
        the user's responsibility to manage their
        destruction when they are no longer in use.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION03057200000000000000">
15.7.2 ESMF_StateAdd - Add a list of items to a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_StateAdd(state, &lt;itemList&gt;, count, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_State), intent(inout)          :: state 
      &lt;itemList&gt;, see below for supported values
      integer,          intent(in),   optional :: count
      integer,          intent(out),  optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a list of items to an <TT>ESMF_State</TT>.

<P>
Supported values for &lt;itemList&gt; are:   
      <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in)             :: arrayList(:)
      
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in)       :: arraybundleList(:)
      
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in)             :: fieldList(:)
      
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in)       :: fieldbundleList(:)
      
</DD>
<DT></DT>
<DD>character (len=*), intent(in)             :: nameList(:)
      
</DD>
<DT></DT>
<DD>type(ESMF_RouteHandle), intent(in)       :: routehandleList(:)
      
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in)             :: stateList(:)
      
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> to which the &lt;itemList&gt; will be added.
   
</DD>
<DT><STRONG>&lt;itemList&gt;</STRONG></DT>
<DD>The list of items to be added.
       This is a reference only; when
       the <TT>ESMF_State</TT> is destroyed the &lt;itemList&gt; contained in it will
       not be destroyed.   Also, the &lt;itemList&gt; cannot be safely 
       destroyed before the <TT>ESMF_State</TT> is destroyed.
       Since &lt;itemList&gt;s can be added to multiple containers, it remains
       the user's responsibility to manage their
       destruction when they are no longer in use.
   
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>The number of items to be added. By default equal to the
       size of the &lt;itemList&gt; argument.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION03057300000000000000">
15.7.3 ESMF_StateCreate - Create a new State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_StateCreate(stateName, statetype, &amp;
                    bundleList, fieldList, arrayList, nestedStateList, &amp;
                    nameList, itemCount, &amp;
                    neededflag, readyflag, validflag, reqforrestartflag, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_State) :: ESMF_StateCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character(len=*), intent(in), optional :: stateName 
       type(ESMF_StateType), intent(in), optional :: statetype
       type(ESMF_FieldBundle), dimension(:), intent(inout), optional :: bundleList
       type(ESMF_Field), dimension(:), intent(inout), optional :: fieldList
       type(ESMF_Array), dimension(:), intent(in), optional :: arrayList
       type(ESMF_State), dimension(:), intent(in), optional :: nestedStateList
       character(len=*), dimension(:), intent(in), optional :: nameList
       integer, intent(in), optional :: itemCount
       type(ESMF_NeededFlag), optional :: neededflag
       type(ESMF_ReadyFlag), optional :: readyflag
       type(ESMF_ValidFlag), optional :: validflag
       type(ESMF_ReqForRestartFlag), optional :: reqforrestartflag
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_State</TT>, set default characteristics for
     objects added to it, and optionally add initial objects to it.

<P>
The arguments are:
    <DL>
<DT><STRONG>[stateName]</STRONG></DT>
<DD>Name of this <TT>ESMF_State</TT> object.   A default name will be generated
      if none is specified.
     
</DD>
<DT><STRONG>[statetype]</STRONG></DT>
<DD>Import or Export <TT>ESMF_State</TT>.  Valid values are 
      <TT>ESMF_STATE_IMPORT</TT>, <TT>ESMF_STATE_EXPORT</TT>, 
      or <TT>ESMF_STATE_UNSPECIFIED</TT> The default 
      is <TT>ESMF_STATE_UNSPECIFIED</TT>.
     
</DD>
<DT><STRONG>[bundleList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_FieldBundle</TT>s.
     
</DD>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_Field</TT>s.
     
</DD>
<DT><STRONG>[arrayList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_Array</TT>s.
     
</DD>
<DT><STRONG>[nestedStateList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_State</TT>s to be nested 
      inside the outer <TT>ESMF_State</TT>.
     
</DD>
<DT><STRONG>[nameList]</STRONG></DT>
<DD>A list (Fortran array) of character string name placeholders.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The total number of things - FieldBundles, Fields, 
      Arrays, States, and Names - to be added.
      If <TT>itemCount</TT> is not specified, it will be computed internally based
      on the length of each object list.
      If <TT>itemCount</TT> is specified this routine
      will do an error check to verify the total number of items found
      in the argument lists matches this count of the expected number of items.
     
</DD>
<DT><STRONG>[neededflag]</STRONG></DT>
<DD>Set the default value for new items added to an <TT>ESMF_State</TT>.
      Possible values are listed in Section&nbsp;<A HREF="node2.html#opt:neededflag">9.2.9</A>.  
      If not specified, the default value is set to <TT>ESMF_NEEDED</TT>.
     
</DD>
<DT><STRONG>[readyflag]</STRONG></DT>
<DD>Set the default value for new items added to an <TT>ESMF_State</TT>.  
      Possible values are listed in Section&nbsp;<A HREF="node2.html#opt:readyflag">9.2.10</A>. 
      If not specified, the default value is set to <TT>ESMF_READYTOREAD</TT>.
     
</DD>
<DT><STRONG>[validflag]</STRONG></DT>
<DD>Set the default value for new items added to an <TT>ESMF_State</TT>.
      Possible values are listed in Section&nbsp;<A HREF="node2.html#opt:validflag">9.2.16</A>.   
      If not specified, the default value is set to <TT>ESMF_VALID</TT>.
     
</DD>
<DT><STRONG>[reqforrestartflag]</STRONG></DT>
<DD>Set the default value for new items added to an <TT>ESMF_State</TT>. 
      Possible values are listed in Section&nbsp;<A HREF="node2.html#opt:reqforrestartflag">9.2.14</A>.    
      If not specified, the default 
      value is set to <TT>ESMF_REQUIRED_FOR_RESTART</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03057400000000000000">
15.7.4 ESMF_StateDestroy - Release resources for a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       recursive subroutine ESMF_StateDestroy(state, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State) :: state
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Releases all resources associated with this <TT>ESMF_State</TT>. Actual
       objects added to <TT>ESMF_State</TT>s will not be destroyed, it
       remains the user's responsibility to destroy these objects in the correct
       context. However, proxy objects automatically created during
       <TT>ESMF_StateReconcile()</TT> are destroyed when the State is destroyed.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>Destroy contents of this <TT>ESMF_State</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03057500000000000000">
15.7.5 ESMF_StateGet - Get information about a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_StateGet()   
       subroutine ESMF_StateGetInfo(state, nestedFlag, name, statetype, itemCount, &amp;
                                itemNameList, stateitemtypeList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
       type(ESMF_NestedFlag), intent(in), optional :: nestedFlag
       character (len=*), intent(out), optional :: name
       type(ESMF_StateType), intent(out), optional :: statetype
       integer, intent(out), optional :: itemCount
       character (len=*), intent(out), optional :: itemNameList(:)
       type(ESMF_StateItemType), intent(out), optional :: stateitemtypeList(:)
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the requested information about this <TT>ESMF_State</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> object to be queried.
       
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD><TT>ESMF_NESTED_OFF</TT> - return information at the current State level only
         <TT>ESMF_NESTED_ON</TT> - recursively return nested State information
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of this <TT>ESMF_State</TT>.
       
</DD>
<DT><STRONG>[statetype]</STRONG></DT>
<DD>Import or Export <TT>ESMF_State</TT>.  Possible values are
         listed in Section&nbsp;<A HREF="node3.html#opt:statetype">15.2.2</A>.
       
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Count of items in <TT>state</TT>, including all objects
         as well as placeholder names.
       
</DD>
<DT><STRONG>[itemNameList]</STRONG></DT>
<DD>Array of item names in <TT>state</TT>,
         including placeholder names.  <TT>itemNameList</TT> must be at least
         <TT>itemCount</TT> long.
       
</DD>
<DT><STRONG>[stateitemtypeList]</STRONG></DT>
<DD>Array of possible item object types in <TT>state</TT>, including
         placeholder
         names. Must be at least <TT>itemCount</TT> long.  Options are
         listed in Section&nbsp;<A HREF="node3.html#opt:stateitemtype">15.2.1</A>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03057600000000000000">
15.7.6 ESMF_StateGet - Retrieve an item from a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>        subroutine ESMF_StateGet(state, itemName, &lt;item&gt;, nestedStateName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_State),  intent(in)            :: state
        character (len=*), intent(in)            :: itemName
        &lt;item&gt;, see below for supported values
        character (len=*), intent(in),  optional :: nestedStateName
        integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns an &lt;item&gt; from an <TT>ESMF_State</TT> by name.  
        If the <TT>ESMF_State</TT> contains the &lt;item&gt; directly, only
        <TT>itemName</TT> is required.
        If the <TT>state</TT> contains multiple nested <TT>ESMF_State</TT>s
        and the &lt;item&gt; is one level down, this routine can return it
        in a single call by specifing the proper <TT>nestedStateName</TT>.
        <TT>ESMF_State</TT>s can be nested to any depth, but this routine 
        only searches immediate descendents.  
        It is an error to specify a <TT>nestedStateName</TT> if the
        <TT>state</TT> contains no nested <TT>ESMF_State</TT>s.

<P>
Supported values for &lt;item&gt; are:
        <DL>
<DT></DT>
<DD>type(ESMF_Array),  intent(out)           :: array
        
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(out)      :: arraybundle
        
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(out)            :: field
        
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(out)      :: fieldbundle
        
</DD>
<DT></DT>
<DD>type(ESMF_RouteHandle),  intent(out)     :: routehandle
        
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(out)            :: nestedState
        
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>State to query for an &lt;item&gt; named <TT>itemName</TT>.
       
</DD>
<DT><STRONG>itemName</STRONG></DT>
<DD>Name of &lt;item&gt; to be returned.
       
</DD>
<DT><STRONG>&lt;item&gt;</STRONG></DT>
<DD>Returned reference to the &lt;item&gt;.
       
</DD>
<DT><STRONG>[nestedStateName]</STRONG></DT>
<DD>Optional.  An error if specified when the <TT>state</TT> argument contains
       no nested <TT>ESMF_State</TT>s.  Required if the <TT>state</TT> contains 
       multiple nested <TT>ESMF_State</TT>s and the &lt;item&gt; being requested is
       one level down in one of the nested <TT>ESMF_State</TT>.
       <TT>ESMF_State</TT> must be selected by this <TT>nestedStateName</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03057700000000000000">
15.7.7 ESMF_StateGet - Get information about an item in a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_StateGet()   
       subroutine ESMF_StateGetItemInfo(state, name, stateitemtype, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
       character (len=*), intent(in) :: name
       type(ESMF_StateItemType), intent(out) :: stateitemtype
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the type for the item named
       <TT>name</TT> in this <TT>ESMF_State</TT>.  If no item with this name
       exists, the value <TT>ESMF_STATEITEM_NOTFOUND</TT> will be returned
       and the error code will not be set to an error.  Thus this routine
       can be used to safely query for the existance of items by name 
       whether or not they are expected to be there.   The error code will
       be set in case of other errors, for example if the <TT>ESMF_State</TT>
       itself is invalid.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD><TT>ESMF_State</TT> to be queried.
        
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>Name of the item to return information about.
        
</DD>
<DT><STRONG>stateitemtype</STRONG></DT>
<DD>Returned item types for the item with the given name, including 
          placeholder names.  Options are
          listed in Section&nbsp;<A HREF="node3.html#opt:stateitemtype">15.2.1</A>.  If no item with the
          given name is found, <TT>ESMF_STATEITEM_NOTFOUND</TT> will be returned
          and <TT>rc</TT> will <B>not</B> be set to an error.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
         
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03057800000000000000">
15.7.8 ESMF_StateGetNeeded - Query whether a data item is needed</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StateGetNeeded(state, itemName, neededflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
       character (len=*), intent(in) :: itemName
       type(ESMF_NeededFlag), intent(out) :: neededflag
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the status of the <TT>neededflag</TT> for the data item
        named by <TT>itemName</TT> in the <TT>ESMF_State</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to query.
        
</DD>
<DT><STRONG>itemName</STRONG></DT>
<DD>Name of the data item to query.
        
</DD>
<DT><STRONG>neededflag</STRONG></DT>
<DD>Whether state item is needed or not for a particular application
         configuration.  Possible values are listed in 
         Section&nbsp;<A HREF="node2.html#opt:neededflag">9.2.9</A>.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION03057900000000000000">
15.7.9 ESMF_StateIsNeeded - Return logical true if data item needed</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_StateIsNeeded(state, itemName, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_StateIsNeeded
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
       character (len=*), intent(in) :: itemName
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns true if the status of the <TT>needed</TT> flag for the data item
        named by <TT>itemName</TT> in the <TT>ESMF_State</TT> is 
        <TT>ESMF_STATEITEM_NEEDED</TT>.  Returns false for no item found 
        with the specified name or item marked not needed.  Also sets error
        code if <TT>dataname</TT> not found.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD><TT>ESMF_State</TT> to query.
        
</DD>
<DT><STRONG>itemName</STRONG></DT>
<DD>Name of the data item to query.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030571000000000000000">
15.7.10 ESMF_StatePrint - Print the internal data for a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StatePrint(state, options, nestedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State) :: state
       character (len = *),   intent(in), optional :: options
       type(ESMF_NestedFlag), intent(in), optional :: nestedFlag
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints information about the <TT>state</TT> to <TT>stdout</TT>. 
<BR>
<P>
Note:  Many <TT>ESMF_&lt;class&gt;Print</TT> methods are implemented in C++.
       On some platforms/compilers there is a potential issue with interleaving
       Fortran and C++ output to <TT>stdout</TT> such that it doesn't appear in
       the expected order.  If this occurs, the <TT>ESMF_IOUnitFlush()</TT> method
       may be used on unit <TT>ESMF_IOstdout</TT> to get coherent output.  
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to print.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options:
           " ", or "brief" - print names and types of the objects within the state (default)
           "long" - print additional information, such as proxy flags
       
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD><TT>ESMF_NESTED_OFF</TT> - print objects at the current State level only
           <TT>ESMF_NESTED_ON</TT> - recursively print nested State objects
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030571100000000000000">
15.7.11 ESMF_StateRead - Read data items from a file into a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StateRead(state, fileName, fileFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State)                                :: state 
       character (len=*),        intent(in)            :: fileName
       type (ESMF_IOFileFormat), intent(in),  optional :: fileFormat
       integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Currently limited to read in all Arrays from a netCDF file and add them
       to a State object.  Future releases will enable more items of a State
       to be read from a file of various formats.

<P>
Only PET 0 reads the file; the States in other PETs remain empty.
       Currently, the data is not decomposed or distributed; each PET
       has only 1 DE and only PET 0 contains data after reading the file.
       Future versions of ESMF will support data decomposition and distribution
       upon reading a file.  See Section&nbsp;<A HREF="node3.html#example:StateRdWr">15.3.10</A> for
       an example.

<P>
Note that the third party NetCDF library must be installed.  For more
       details, see the "ESMF Users Guide",
       "Building and Installing the ESMF, Third Party Libraries, NetCDF" and
       the website http://www.unidata.ucar.edu/software/netcdf.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to add items read from file.  Currently only
         Arrays are supported.
       
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>File to be read.
       
</DD>
<DT><STRONG>[fileFormat]</STRONG></DT>
<DD>The file format to be used.  Currently, only
         ESMF_IO_FILEFORMAT_NETCDF is supported, which is the default.
         Future releases will support others.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
         Equals <TT>ESMF_RC_LIB_NOT_PRESENT</TT> if fileFormat is 
         ESMF_IO_FILEFORMAT_NETCDF and the NetCDF library is not present.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION030571200000000000000">
15.7.12 ESMF_StateWrite - Write items from a State to file</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StateWrite(state, fileName, fileFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State)                                :: state 
       character (len=*),        intent(in)            :: fileName
       type (ESMF_IOFileFormat), intent(in),  optional :: fileFormat
       integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Currently limited to write out all Arrays of a State object to a
       netCDF file.  Future releases will enable more item types of a State to
       be written to files of various formats.

<P>
Writing is currently limited to PET 0; future versions of ESMF will allow
       parallel writing, as well as parallel reading.

<P>
See Section&nbsp;<A HREF="node3.html#example:StateRdWr">15.3.10</A> for an example.

<P>
Note that the third party NetCDF library must be installed.  For more
       details, see the "ESMF Users Guide",
       "Building and Installing the ESMF, Third Party Libraries, NetCDF" and
       the website http://www.unidata.ucar.edu/software/netcdf.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> from which to write items.  Currently limited to
         Arrays.
       
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>File to be written.  
       
</DD>
<DT><STRONG>[fileFormat]</STRONG></DT>
<DD>The file format to be used.  Currently, only
         ESMF_IO_FILEFORMAT_NETCDF is supported, which is the default.
         Future releases will support others.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
         Equals <TT>ESMF_RC_LIB_NOT_PRESENT</TT> if fileFormat is 
         ESMF_IO_FILEFORMAT_NETCDF and the NetCDF library is not present.
       
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION030571300000000000000">
15.7.13 ESMF_StateReconcile - Reconcile State data across all PETs in a VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StateReconcile(state, vm, attreconflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(inout) :: state
       type(ESMF_VM), intent(in) :: vm
       type(ESMF_AttReconcileFlag), intent(in), optional :: attreconflag        
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Must be called for any <TT>ESMF_State</TT> which contains ESMF objects
       that have not been created on all the <TT>PET</TT>s of the currently
       running <TT>ESMF_Component</TT>.  
       For example, if a coupler is operating on data
       which was created by another component that ran on only a subset
       of the coupler's <TT>PET</TT>s, the coupler must make this call first
       before operating on any data inside that <TT>ESMF_State</TT>.
       After calling <TT>ESMF_StateReconcile</TT> all <TT>PET</TT>s will have
       a common view of all objects contained in this <TT>ESMF_State</TT>.
       The option to reconcile the metadata associated with the objects
       contained in this <TT>ESMF_State</TT> also exists.  The default behavior
       for this capability is to <I>not</I> reconcile metadata unless told
       otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD><TT>ESMF_State</TT> to reconcile.
       
</DD>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> for this <TT>ESMF_Component</TT>.
       
</DD>
<DT><STRONG>[attreconflag]</STRONG></DT>
<DD>Flag to tell if Attribute reconciliation is to be done as well as data reconciliation
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>
NOTE:  The options for <TT>attreconflag</TT> include:
              
<OL>
<LI>ESMF_ATTRECONCILE_ON will allow reconciliation of metadata (Attributes)
</LI>
<LI>ESMF_ATTRECONCILE_OFF is the default behavior, this option turns off
                                              the metadata reconciliation
              
</LI>
</OL>

<P>

<P>

<P>

<H3><A NAME="SECTION030571400000000000000">
15.7.14 ESMF_StateSetNeeded - Set if a data item is needed</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StateSetNeeded(state, itemName, neededflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(inout) :: state
       character (len=*), intent(in) :: itemName
       type(ESMF_NeededFlag), intent(in) :: neededflag
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the status of the <TT>needed</TT> flag for the data item
        named by <TT>itemName</TT> in the <TT>ESMF_State</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to set.
         
</DD>
<DT><STRONG>itemName</STRONG></DT>
<DD>Name of the data item to set.
         
</DD>
<DT><STRONG>neededflag</STRONG></DT>
<DD>Set status of data item to this.  See Section&nbsp;<A HREF="node2.html#opt:neededflag">9.2.9</A>
          for possible values.
         
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
         
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION030571500000000000000">
15.7.15 ESMF_StateValidate - Check validity of a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StateValidate(state, options, nestedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State) :: state
       character (len = *),   intent(in), optional :: options
       type(ESMF_NestedFlag), intent(in), optional :: nestedFlag
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>state</TT> is internally consistent.
        Currently this method determines if the <TT>state</TT> is uninitialized 
        or already destroyed.  The method returns an error code if problems 
        are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to validate.
       
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD><TT>ESMF_NESTED_OFF</TT> - validates at the current State level only
         <TT>ESMF_NESTED_ON</TT> - recursively validates any nested States
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Validation options are not yet supported.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<HR>
<!--Navigation Panel-->
<A NAME="tex2html1310"
  HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1306"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1300"
  HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1308"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1311"
  HREF="node4.html">3 Infrastructure: Fields and</A>
<B> Up:</B> <A NAME="tex2html1307"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1301"
  HREF="node2.html">1 ESMF Overview</A>
 &nbsp <B>  <A NAME="tex2html1309"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
