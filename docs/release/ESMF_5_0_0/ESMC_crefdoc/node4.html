<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002 (1.67)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>3 Infrastructure: Fields and Grids</TITLE>
<META NAME="description" CONTENT="3 Infrastructure: Fields and Grids">
<META NAME="keywords" CONTENT="ESMC_crefdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMC_crefdoc.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="ESMC_crefdoc.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html301"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html297"
  HREF="ESMC_crefdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html291"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html299"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html302"
  HREF="node5.html">4 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html298"
  HREF="ESMC_crefdoc.html">ESMC_crefdoc</A>
<B> Previous:</B> <A NAME="tex2html292"
  HREF="node3.html">2 Superstructure</A>
 &nbsp <B>  <A NAME="tex2html300"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html303"
  HREF="node4.html#SECTION04010000000000000000">8 Overview of Infrastructure Data Handling</A>
<UL>
<LI><A NAME="tex2html304"
  HREF="node4.html#SECTION04011000000000000000">8.1 Infrastructure Data Classes</A>
<LI><A NAME="tex2html305"
  HREF="node4.html#SECTION04012000000000000000">8.2 Design and Implementation Notes</A>
</UL>
<LI><A NAME="tex2html306"
  HREF="node4.html#SECTION04020000000000000000">9 Field Class</A>
<UL>
<LI><A NAME="tex2html307"
  HREF="node4.html#SECTION04021000000000000000">9.1 Description</A>
<UL>
<LI><A NAME="tex2html308"
  HREF="node4.html#SECTION04021100000000000000">9.1.1 Field Creation and Destruction</A>
</UL>
<LI><A NAME="tex2html309"
  HREF="node4.html#SECTION04022000000000000000">9.2 Class API</A>
<LI><A NAME="tex2html310"
  HREF="node4.html#SECTION04023000000000000000">9.3 C++:  Class Interface ESMC_Field - Public C interface to the ESMF Field class (Source File: ESMC_Field.h)</A>
</UL>
<LI><A NAME="tex2html311"
  HREF="node4.html#SECTION04030000000000000000">10 Array Class</A>
<UL>
<LI><A NAME="tex2html312"
  HREF="node4.html#SECTION04031000000000000000">10.1 Description</A>
<LI><A NAME="tex2html313"
  HREF="node4.html#SECTION04032000000000000000">10.2 Class API</A>
<LI><A NAME="tex2html314"
  HREF="node4.html#SECTION04033000000000000000">10.3 C++:  Class Interface ESMC_Array - Public C interface to the ESMF Array class (Source File: ESMC_Array.h)</A>
</UL>
<LI><A NAME="tex2html315"
  HREF="node4.html#SECTION04040000000000000000">11 ArraySpec Class</A>
<UL>
<LI><A NAME="tex2html316"
  HREF="node4.html#SECTION04041000000000000000">11.1 Description</A>
<LI><A NAME="tex2html317"
  HREF="node4.html#SECTION04042000000000000000">11.2 Class API</A>
<LI><A NAME="tex2html318"
  HREF="node4.html#SECTION04043000000000000000">11.3 C++:  Class Interface ESMC_ArraySpec - uniform access to arrays from F90 and C++ (Source File: ESMC_ArraySpec.h)</A>
</UL>
<LI><A NAME="tex2html319"
  HREF="node4.html#SECTION04050000000000000000">12 Grid Class</A>
<UL>
<LI><A NAME="tex2html320"
  HREF="node4.html#SECTION04051000000000000000">12.1 Description</A>
<UL>
<LI><A NAME="tex2html321"
  HREF="node4.html#SECTION04051100000000000000">12.1.1 Grid Representation in ESMF</A>
<LI><A NAME="tex2html322"
  HREF="node4.html#SECTION04051200000000000000">12.1.2 Supported Grids</A>
<LI><A NAME="tex2html323"
  HREF="node4.html#SECTION04051300000000000000">12.1.3 Grid Topologies and Periodicity</A>
<LI><A NAME="tex2html324"
  HREF="node4.html#SECTION04051400000000000000">12.1.4 Grid Distribution</A>
<LI><A NAME="tex2html325"
  HREF="node4.html#SECTION04051500000000000000">12.1.5 Grid Coordinates</A>
<LI><A NAME="tex2html326"
  HREF="node4.html#SECTION04051600000000000000">12.1.6 Coordinate Specification and Generation</A>
<LI><A NAME="tex2html327"
  HREF="node4.html#SECTION04051700000000000000">12.1.7 Staggering</A>
<LI><A NAME="tex2html328"
  HREF="node4.html#SECTION04051800000000000000">12.1.8 Options for Building Grids</A>
</UL>
<LI><A NAME="tex2html329"
  HREF="node4.html#SECTION04052000000000000000">12.2 Class API: General Grid Methods</A>
<LI><A NAME="tex2html330"
  HREF="node4.html#SECTION04053000000000000000">12.3 C++:  Class Interface ESMC_Grid - Public C interface to the Grid object (Source File: ESMC_Grid.h)</A>
</UL>
<LI><A NAME="tex2html331"
  HREF="node4.html#SECTION04060000000000000000">13 LocStream Class</A>
<UL>
<LI><A NAME="tex2html332"
  HREF="node4.html#SECTION04061000000000000000">13.1 Description</A>
<UL>
<LI><A NAME="tex2html333"
  HREF="node4.html#SECTION04061100000000000000">13.1.1 How is a LocStream different than a Grid?</A>
<LI><A NAME="tex2html334"
  HREF="node4.html#SECTION04061200000000000000">13.1.2 How is a LocStream different than a Mesh?</A>
</UL>
</UL>
<LI><A NAME="tex2html335"
  HREF="node4.html#SECTION04070000000000000000">14 Mesh Class</A>
<UL>
<LI><A NAME="tex2html336"
  HREF="node4.html#SECTION04071000000000000000">14.1 Description</A>
<UL>
<LI><A NAME="tex2html337"
  HREF="node4.html#SECTION04071100000000000000">14.1.1 Mesh Representation in ESMF</A>
<LI><A NAME="tex2html338"
  HREF="node4.html#SECTION04071200000000000000">14.1.2 Supported Meshes</A>
</UL>
<LI><A NAME="tex2html339"
  HREF="node4.html#SECTION04072000000000000000">14.2 Class API</A>
</UL>
<LI><A NAME="tex2html340"
  HREF="node4.html#SECTION04080000000000000000">15 DistGrid Class</A>
<UL>
<LI><A NAME="tex2html341"
  HREF="node4.html#SECTION04081000000000000000">15.1 Description</A>
<LI><A NAME="tex2html342"
  HREF="node4.html#SECTION04082000000000000000">15.2 Class API</A>
<LI><A NAME="tex2html343"
  HREF="node4.html#SECTION04083000000000000000">15.3 C++:  Class Interface ESMC_DistGrid - Public C interface to the ESMF DistGrid class (Source File: ESMC_DistGrid.h)</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION04000000000000000000">
3 Infrastructure:  Fields and Grids</A>
</H1>

<P>

<P>

<H1><A NAME="SECTION04010000000000000000">
8 Overview of Infrastructure Data Handling</A>
</H1>

The ESMF infrastructure data classes are part of the framework's 
hierarchy of structures for handling Earth system model data and 
metadata on parallel platforms.  The hierarchy is in complexity; the 
simplest data class in the infrastructure represents a distributed 
array and the most complex data class represents a bundle of physical 
fields that are discretized on the same grid.  Data class methods 
are called both from user-written code and from other classes 
internal to the framework. 

Data classes are distributed over <B>DE</B>s, or <B>Decomposition Elements</B>.  
A DE represents a piece of a decomposition.  A DELayout is a collection
of DEs with some associated connectivity that describes a specific 
distribution.  For example, the distribution of a grid divided 
into four segments in the x-dimension would be expressed in ESMF as
a DELayout with four DEs lying along an x-axis. This abstract concept 
enables a data decomposition to be defined in 
terms of threads, MPI processes, virtual decomposition elements, or
combinations of these without changes to user code.  This is a
primary strategy for ensuring optimal performance and portability
for codes using the ESMF for communications.

ESMF data classes are useful because they provide a standard, 
convenient way for developers to collect together information 
related to model or observational data.  The information assembled 
in a data class includes a data pointer, a set of attributes 
(e.g. units, although attributes can also be user-defined), and a 
description of an associated grid.  The same set of information within 
an ESMF data object can be used by the framework to arrange 
intercomponent data transfers, to perform I/O, for communications
such as gathers and scatters, for simplification of interfaces 
within user code, for debugging, and for other functions.  
This unifies and organizes codes overall so that the user need not
define different representations of metadata for the same field 
for I/O and for component coupling.  

Since it is critical that users be able to introduce ESMF into their
codes easily and incrementally, ESMF data classes can be created based 
on native Fortran pointers.  Likewise, there are methods for retrieving 
native Fortran pointers from within ESMF data objects.  This allows
the user to perform allocations using ESMF, and to retrieve Fortran
arrays later for optimized model calculations.  The ESMF data classes 
do not have associated differential operators or other mathematical 
methods.

For flexibility, it is not necessary to build an ESMF data object 
all at once.  For example, it's possible to create a 
field but to defer allocation of the associated field data until 
a later time.

<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Hierarchy of data structures designed specifically for the Earth 
system domain and high performance, parallel computing.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Multi-use ESMF structures simplify user code overall.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Data objects support incremental construction and deferred allocation.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Native Fortran arrays can be associated with or retrieved from ESMF data
objects, for ease of adoption, convenience, and performance.</TD>
</TR>
</TABLE>
</DIV>
<H2><A NAME="SECTION04011000000000000000">
8.1 Infrastructure Data Classes</A>
</H2>

The main classes that are used for model and observational data manipulation
are as follows:

<UL>
<LI><B>Array</B>  An ESMF Array contains a data pointer, 
information about its associated datatype, precision, and 
dimension.  

Data elements in Arrays are partitioned into categories 
defined by the role the data element plays in distributed halo 
operations.  Haloing - sometimes called ghosting - is the 
practice of copying portions of array data to multiple memory 
locations to ensure that data dependencies can be satisfied 
quickly when performing a calculation.  ESMF Arrays contain 
an <B>exclusive</B> domain, which contains data elements
updated exclusively and definitively by a given DE; a 
<B>computational</B> domain, which contains all data elements
with values that are updated by the DE in computations; and 
a <B>total</B> domain, which includes both the computational 
domain and data elements from other DEs which may be read 
but are not updated in computations.

</LI>
<LI><B>ArrayBundle</B> ArrayBundles are collections of
Arrays that are stored in a single object.  Unlike FieldBundles,
they don't need to be distributed the same way across PETs.  The
motivation for ArrayBundles is both convenience and performance.

</LI>
<LI><B>Field</B>  A Field holds model and/or observational 
data together with its underlying grid or set of spatial 
locations.  It provides methods for configuration, 
initialization, setting and retrieving data values, 
data I/O, data regridding, and manipulation of attributes.

</LI>
<LI><B>FieldBundle</B> Groups of Fields on the same underlying 
physical grid can be collected into a single object called a FieldBundle.  
A FieldBundle provides two major functions: it allows groups of 
Fields to be manipulated using a single identifier, for example 
during export or import of data between Components; and 
it allows data from multiple Fields to be packed together 
in memory for higher locality of reference and ease in 
subsetting operations.  Packing a set of Fields into a single
FieldBundle before performing a data communication allows the set 
to be transferred at once rather than as a Field at a time.
This can improve performance on high-latency platforms.

FieldBundle objects contain methods for setting and retrieving constituent 
fields, regridding, data I/O, and reordering of data in memory.

</LI>
</UL>


<P>

<P>

<H2><A NAME="SECTION04012000000000000000">
8.2 Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>In communication methods such as Regrid, Redist, Scatter, etc. 
the FieldBundle and Field code cascades down through the Array code, so 
that the actual computations exist in only one place in the source.

<P>
</LI>
</OL>

<P>

<P>

<P>

<P>

<H1><A NAME="SECTION04020000000000000000">
9 Field Class</A>
</H1>

<P>

<H2><A NAME="SECTION04021000000000000000">
9.1 Description</A>
</H2>

<P>
An ESMF Field represents a physical field, such as temperature.
The motivation for including Fields in ESMF is that bundles of 
Fields are the entities that are normally exchanged when coupling
Components.  

<P>
The ESMF Field class contains distributed, discretized field data, a reference 
to its associated grid, and metadata.  The Field class maintains the
relationship of how a data array maps onto a grid (e.g. one item per
cell located at the cell center, one item per cell located at the NW
corner,  one item per cell vertex, ...).  This means that different Fields
which are on the same underlying ESMF Grid but have different
staggerings can share the same Grid object without needing to replicate
it multiple times. 

<P>
Fields can be added to States for use in inter-Component
data communications.  Fields can also be added to FieldBundles,
which are currently defined as groups of Fields on the same underlying
grid.  One motivation for FieldBundles is convenience; another is the
ability to perform optimized collective data transfers.  

<P>
Field communications, including data redistribution, regriding, scatter,
and gather, are enabled in this release.  Field halo update operation is
not enabled in this release and will be enabled in subsequent releases.

<P>
ESMF does not currently support vector fields, so the components of 
a vector field must be stored as separate Field objects.  

<P>

<P>

<P>
A Field serves as an annotator of data, since it carries 
a description of the grid it is associated with and metadata 
such as name and units.  Fields can be used in this capacity
alone, as convenient, descriptive containers into which arrays 
can be placed and retrieved.  However, for most codes the primary 
use of Fields is in the context of import and export States,
which are the objects that carry coupling information between 
Components.  Fields enable data to be self-describing, and a
State holding ESMF Fields contains data in a standard format
that can be queried and manipulated.  

<P>
The sections below go into more detail about Field usage.

<P>

<H3><A NAME="SECTION04021100000000000000">
9.1.1 Field Creation and Destruction</A>
</H3>

<P>
Fields can be created and destroyed at any time during 
application execution.  However, these Field methods require 
some time to complete.  We do not recommend that the user
create or destroy Fields inside performance-critical 
computational loops.

<P>
All versions of the <TT>ESMF_FieldCreate()</TT> 
routines require a Grid object as input, or require a Grid
be added before most operations involving Fields can be performed.
The Grid contains the information needed to know which 
Decomposition Elements (DEs) are participating in 
the processing of this Field, and which subsets of the data
are local to a particular DE.

<P>
The details of how the create process happens depends 
on which of the variants of the <TT>ESMF_FieldCreate()</TT> 
call is used.  Some of the variants are discussed below.

<P>
There are versions of the <TT>ESMF_FieldCreate()</TT> interface
which create the Field based on the input Grid.  The ESMF
can allocate the proper amount of 
space but not assign initial values.  The user code
can then get the pointer to the uninitialized buffer and 
set the initial data values.

<P>
Other versions of the <TT>ESMF_FieldCreate()</TT> interface
allow user code to attach arrays that have already been
allocated by the user.  Empty Fields can also be created in
which case the data can be added at some later time.

<P>
For versions of Create which do not specify data values,
user code can create an ArraySpec object, which
contains information about the typekind and rank of the
data values in the array.  Then at Field create time, the
appropriate amount of memory is allocated to contain the
data which is local to each DE.

<P>
When finished with a <TT>ESMF_Field</TT>, the <TT>ESMF_FieldDestroy</TT> method
removes it.  However, the objects inside the <TT>ESMF_Field</TT>
created externally should be destroyed separately, 
since objects can be added to
more than one <TT>ESMF_Field</TT>.  For example, the same <TT>ESMF_Grid</TT>
can be referenced by multiple <TT>ESMF_Field</TT>s.  In this case the
internal Grid is not deleted by the <TT>ESMF_FieldDestroy</TT> call.

<P>

<H2><A NAME="SECTION04022000000000000000">
9.2 Class API</A>
</H2>

<P>

<P>

<P>

<H2><A NAME="SECTION04023000000000000000">
9.3 C++:  Class Interface ESMC_Field - Public C interface to the ESMF Field class (Source File: ESMC_Field.h)</A>
</H2>

<P>
The code in this file defines the public C Field class and declares method
   signatures (prototypes).  The companion file <TT>ESMC_Field.C</TT> contains
   the definitions (full code bodies) for the Field methods.

<P>

<P>

<P>

<H1><A NAME="SECTION04030000000000000000">
10 Array Class</A>
</H1>

<P>

<H2><A NAME="SECTION04031000000000000000">
10.1 Description</A>
</H2>

<P>
The Array class is an alternative to the Field class for representing distributed, structured data.  Unlike Fields, which are built to carry grid coordinate information, Arrays can only carry information about the <I>indices</I> associated with grid cells.  Since they do not have coordinate information, Arrays cannot be used to calculate interpolation weights.  However, if the user can supply interpolation weights (using a package such as SCRIP), the Array sparse matrix multiply operation can be used to apply the weights and transfer data to the new grid.  Arrays can also perform redistribution, scatter, and gather operations.

<P>
Like Fields, Arrays can be added to a State and used in inter-component data communications.  Arrays can also be grouped together into ArrayBundles so that collective operations can be performed on the whole group.  One motivation for this is convenience; another is the ability to schedule optimized, collective data transfers.   

<P>
From a technical standpoint, the <TT>ESMF_Array</TT> class is an index space based, distributed data storage class. It provides DE-local memory allocations within DE-centric index regions and defines the relationship to the index space described by DistGrid. The Array class offers common communication patterns within the index space formalism. As part of the ESMF index space layer Array has close relationship to the DistGrid and DELayout classes.

<P>

<H2><A NAME="SECTION04032000000000000000">
10.2 Class API</A>
</H2>

<P>

<P>

<P>

<H2><A NAME="SECTION04033000000000000000">
10.3 C++:  Class Interface ESMC_Array - Public C interface to the ESMF Array class (Source File: ESMC_Array.h)</A>
</H2>

<P>
The code in this file defines the public C Array class and declares method 
   signatures (prototypes).  The companion file <TT>ESMC_Array.C</TT> contains
   the definitions (full code bodies) for the Array methods.

<P>

<P>

<P>

<H1><A NAME="SECTION04040000000000000000">
11 ArraySpec Class</A>
</H1>

<P>

<H2><A NAME="SECTION04041000000000000000">
11.1 Description</A>
</H2>

<P>
An ArraySpec is a very simple class that contains type, kind, and
rank information about an array.  This information is stored in two
parameters.  <B>TypeKind</B> describes the data type of the elements
in the array and their precision.  <B>Rank</B> is the number of dimensions
in the array.

<P>
The only methods that are associated with the ArraySpec class are those 
that allow you to set and retrieve this information.

<P>

<P>

<H2><A NAME="SECTION04042000000000000000">
11.2 Class API</A>
</H2>

<P>

<P>

<P>

<H2><A NAME="SECTION04043000000000000000">
11.3 C++:  Class Interface ESMC_ArraySpec - uniform access to arrays from F90 and C++ (Source File: ESMC_ArraySpec.h)</A>
</H2>

<P>
The code in this file defines the public C ArraySpec interfaces and declares
   method signatures (prototypes).  The companion file <TT>ESMC_ArraySpec.C</TT>
   contains the definitions (full code bodies) for the ArraySpec methods.

<P>

<P>

<P>

<H1><A NAME="SECTION04050000000000000000">
12 Grid Class</A>
</H1>

<P>

<H2><A NAME="SECTION04051000000000000000">
12.1 Description</A>
</H2>

<P>
The ESMF Grid class is used to describe the geometry and discretization
of logically rectangular physical grids.  It also contains the
description of the grid's underlying topology and the decomposition
of the physical grid across the available computational resources.
The most frequent use of the Grid class is to describe physical grids
in user code so that sufficient information is available to perform ESMF
methods such as regridding.  

<P>
In the current release (v3.1.0)
the functionality in this class is partially implemented.  
Multi-tile grids are not supported, and edge connectivities 
are not implemented and default to aperiodic.  
Other constraints of the current
implementation are noted in the usage section and in the API
descriptions.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Representation of grids formed by logically rectangular regions,
including uniform and rectilinear grids (e.g. lat-lon grids),
curvilinear grids (e.g. displaced pole grids), and grids formed
by connected logically rectangular regions (e.g. cubed sphere grids)
[CONNECTED REGIONS ARE NOT YET SUPPORTED].</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for 1D, 2D, 3D, and higher dimension grids.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Distribution of grids across computational resources for parallel
operations - users set which grid dimensions are distributed.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Grids can be created already distributed, so that no single
resource needs global information during the creation process.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options to define periodicity and other edge connectivities either 
explicitly or implicitly via shape shortcuts [EDGE CONNECTIVITIES
CURRENTLY DEFAULT TO APERIODIC BOUNDS].</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for users to define grid coordinates themselves or call
prefabricated coordinate generation routines for standard grids
[NO GENERATION ROUTINES YET].</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for incremental construction of grids.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for using a set of pre-defined stagger locations or for setting
custom stagger locations.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION04051100000000000000">
12.1.1 Grid Representation in ESMF</A>
</H3>

<P>
ESMF Grids are based on the concepts described in <I>A Standard
Description of Grids Used in Earth System Models</I> [Balaji 2006].  In this document
Balaji introduces the mosaic concept as a means of describing
a wide variety of Earth system model grids.  A <B>mosaic</B> is
composed of grid tiles connected at their edges.  Mosaic grids
includes simple, single tile grids as a special case.  

<P>
The ESMF Grid class is a representation of a mosaic grid.  Each ESMF
Grid is constructed of one or more logically rectangular <B>Tiles</B>.
A Tile will usually have some physical significance (e.g. the region
of the world covered by one face of a cubed sphere grid).

<P>
The piece of a Tile that resides on one DE (for simple cases, a DE
can be thought of as a processor - see section on the DELayout)
is called a <B>LocalTile</B>.  For example, the six faces of a cubed
sphere grid are each Tiles, and each Tile can be divided into many
LocalTiles.  

<P>
Every ESMF Grid contains a DistGrid object, which defines the Grid's
index space, topology, distribution, and connectivities.  It enables
the user to define the complex edge relationships of tripole and other
grids.  The DistGrid can be created explicitly and passed into a Grid
creation routine, or it can be created implicitly if the user takes
a Grid creation shortcut.  Options for grid creation are described in 
more detail in section <A HREF="node4.html#sec:gridcreateoptions">12.1.8</A>. The DistGrid used
in Grid creation describes the properties of the Grid cells. In addition
to this one, the Grid internally creates DistGrids for each stagger location. 
These stagger DistGrids are related to the original DistGrid, but may 
contain extra padding to represent the extent of the index space of
the stagger. These DistGrids are what are used when a Field is created 
on a Grid. 

<P>

<H3><A NAME="SECTION04051200000000000000">
12.1.2 Supported Grids</A>
</H3>

<P>
The range of supported grids in ESMF can be defined by:

<UL>
<LI>Types of topologies and shapes supported.  ESMF supports one or
more logically rectangular grid Tiles with connectivities specified
between cells.  For more details see section <A HREF="node4.html#sec:ShapeShortcut">12.1.3</A>.
</LI>
<LI>Types of distributions supported.  ESMF supports  regular,
irregular, or arbitrary distributions of data.  
For more details see section <A HREF="node4.html#sec:desc:dist">12.1.4</A>.
</LI>
<LI>Types of coordinates supported.  ESMF supports uniform, rectilinear,
and curvilinear coordinates.  For more details see section <A HREF="node4.html#sec:coordspec">12.1.5</A>.
</LI>
</UL>

<P>

<H3><A NAME="SECTION04051300000000000000"></A>
<A NAME="sec:ShapeShortcut"></A>
<BR>
12.1.3 Grid Topologies and Periodicity
</H3>
ESMF has shortcuts for the creation of standard Grid topologies 
or <B>shapes</B> up to 3D.  In many cases, these enable the user to
bypass the step of creating a DistGrid before creating the Grid.  The basic call is 
<TT>ESMF_GridCreateShapeTile()</TT>.  With this call, the user can specify for
each dimension whether there is no connection, it is periodic, it
is a pole, or it is a bipole.  The assumed connectivities for poles and
bipoles are described in section <A HREF="#sec:opt:gridconn"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>.  Connectivities
are specified using the ESMF_GridConn parameter, which has values
such as ESMF_GRIDCONN_PERIODIC.

<P>
The table below shows the ESMF_GridConn settings used to create 
standard shapes in 2D using the ESMF_GridCreateShapeTile() call.  Two values
are specified for each dimension, one for the low end and one for 
the high end of the dimension's index values.  Note that connectivities
have not been implemented as of v4.0.0 and default to aperiodic bounds.

<P>

<P>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">2D Shape</TD>
<TD ALIGN="CENTER"><B>connDim1(1)</B></TD>
<TD ALIGN="CENTER"><B>connDim1(2)</B></TD>
<TD ALIGN="CENTER"><B>connDim2(1)</B></TD>
<TD ALIGN="CENTER"><B>connDim2(2)</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Rectangle</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Bipole Sphere</B></TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Tripole Sphere</B></TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">BIPOLE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Cylinder</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Torus</B></TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
</TABLE>

<P>
<BR>

<P>
If the user's grid shape is too complex for an ESMF shortcut routine,
or involves more than three dimensions, a DistGrid can be created
to specify the shape in detail.  This DistGrid is then passed
into a Grid create call.

<P>

<H3><A NAME="SECTION04051400000000000000"></A>
<A NAME="sec:desc:dist"></A>
<BR>
12.1.4 Grid Distribution
</H3>

<P>
ESMF Grids have several options for data distribution (also referred to
as decomposition).  As ESMF Grids are cell based, these 
options are all specified  in terms of how the cells in the Grid
are broken up between DEs. 

<P>
The main distribution options are regular, irregular, and arbitrary.
A <B>regular</B> distribution is one in which the same number of
contiguous grid cells are assigned to each DE in the
distributed dimension.  A <B>irregular</B> distribution is one in which
unequal numbers of contiguous grid cells are assigned to each
DE in the distributed dimension.  An <B>arbitrary</B> distribution is
one in which any grid cell can be assigned to any DE.  Any of these
distribution options can be applied to any of the grid shapes (i.e.,
rectangle) or types (i.e., rectilinear).  Support for arbitrary distribution 
is limited in v4.0.0, See section <A HREF="#example:ArbGridWithUndistDim"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for
more detail descriptions.

<P>
Figure <A HREF="node4.html#fig:GridDecomps">7</A> illustrates options for distribution.

<DIV ALIGN="CENTER"><A NAME="fig:GridDecomps"></A><A NAME="1553"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 7:</STRONG>
Examples of regular and irregular decomposition of
a grid <B>a</B> that is 6x6, and an arbitrary decomposition of
a grid <B>b</B> that is 6x3.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{GridDecomps}}$
 -->
<IMG
 WIDTH="726" HEIGHT="220" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.png"
 ALT="\scalebox{0.9}{\includegraphics{GridDecomps}}"></TD></TR>
</TABLE>
</DIV>

<P>
A distribution can also be specified using the DistGrid, by passing
object into a Grid create call.

<P>

<H3><A NAME="SECTION04051500000000000000"></A>
<A NAME="sec:coordspec"></A>
<BR>
12.1.5 Grid Coordinates
</H3>
Grid Tiles can have uniform, rectilinear, or curvilinear
coordinates.  The coordinates of <B>uniform</B> grids are equally spaced along
their axes, and can be fully specified by the coordinates of the two opposing points
that define the grid's physical span.  The coordinates of <B>rectilinear</B> grids
are unequally spaced along their axes, and can be fully specified by giving
the spacing of grid points along each axis.  The coordinates of <B>curvilinear 
grids</B> must be specified by giving the explicit set of coordinates for each
grid point.  Curvilinear grids are often uniform or rectilinear grids that 
have been warped; for example, to place a pole over a land mass so that it
does not affect the computations performed on an ocean model grid.  Figure
<A HREF="node4.html#fig:LogRectGrids">8</A> shows examples of each type of grid.

<P>
Any of these logically rectangular grid types can be combined through edge
connections to form a mosaic.  Cubed sphere and yin-yang grids are examples
of mosaic grids.  Note that as of v4.0.0 multi-tile grids have not yet been
implemented.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:LogRectGrids"></A><A NAME="1484"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 8:</STRONG>
Types of logically rectangular grid tiles.  Red circles show the
values needed to specify grid coordinates for each type.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{LogRectGrids}}$
 -->
<IMG
 WIDTH="726" HEIGHT="219" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="\scalebox{0.9}{\includegraphics{LogRectGrids}}"></TD></TR>
</TABLE>
</DIV>

<P>
Each of these coordinate types can be set for each of the standard grid shapes
described in section <A HREF="node4.html#sec:ShapeShortcut">12.1.3</A>.  

<P>
The table below shows how examples of common single Tile grids fall 
into this shape and coordinate taxonomy.  Note that any
of the grids in the table can have a regular or arbitrary distribution.

<P>

<P>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122><B>Uniform</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122><B>Rectilinear</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122><B>Curvilinear</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65><B>Sphere</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Global uniform lat-lon grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Gaussian grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Displaced pole grid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=65><B>Rectangle</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Regional uniform lat-lon grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Gaussian grid section</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=122>Polar stereographic grid section</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION04051600000000000000">
12.1.6 Coordinate Specification and Generation</A>
</H3>

<P>
There are two ways of specifying coordinates in ESMF.  The
first way is for the user to <B>set</B> the coordinates.  The second 
way is to take a shortcut and have the framework <B>generate</B>
the coordinates.  

<P>
No ESMF generation routines are currently available.

<P>
See Section&nbsp;<A HREF="#sec:usage:staggerloc"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for more description and examples of
setting coordinates.

<P>

<H3><A NAME="SECTION04051700000000000000">
12.1.7 Staggering</A>
</H3>

<P>
<B>Staggering</B> is a finite difference technique in which the values 
of different physical quantities are placed at different locations
within a grid cell. 

<P>
The ESMF Grid class supports a variety of stagger locations, including
cell centers, corners, and edge centers. The default stagger location in 
ESMF is the cell center, and cell counts in Grid are based on this assumption.
Combinations of the 2D ESMF stagger locations are sufficient to specify any of the
Arakawa staggers.  ESMF also supports staggering in 3D and higher dimensions.
There are shortcuts for standard staggers, and interfaces through which users 
can create custom staggers.  

<P>
As a default the ESMF Grid class provides symmetric staggering, so
that cell centers are enclosed by cell perimeter (e.g. corner) 
stagger locations. This means the coordinate arrays for stagger
locations other than the center will have an additional element of 
padding in order to enclose the cell center locations.
However, to achieve other types of staggering, the user may alter 
or eliminate this padding by using the appropriate options when adding
coordinates to a Grid. 

<P>
In v4.0.0, only the cell center stagger location is supported for an
arbitrarily distributed grid. For examples and a full description of the stagger interface 
see Section&nbsp;<A HREF="#sec:usage:staggerloc"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>. 

<P>

<H3><A NAME="SECTION04051800000000000000"></A>
<A NAME="sec:gridcreateoptions"></A>
<BR>
12.1.8 Options for Building Grids
</H3>

<P>
ESMF Grid objects must represent a wide range of grid types 
and use cases, some of them quite complex.  As a result, multiple
ways to build Grid objects are required.  This section describes
the stages to building Grids, the options for each stage, and 
typical calling sequences.

<P>
In ESMF there are two main stages to building Grids.  The
<TT>ESMF_GridStatus</TT> value stored within the Grid object reflects
the stage the Grid has attained (see Section&nbsp;<A HREF="#sec:opt:gridstatus"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>).
These stages are:

<P>

<OL>
<LI>Create the Grid topology or shape.  At the completion of this
stage, the Grid has a specific topology and distribution, but
empty coordinate arrays.  The Grid can be used as the basis for
allocating a Field. Its <TT>ESMF_GridStatus</TT> parameter has 
a value of <TT>ESMF_GRIDSTATUS_SHAPE_READY</TT>.  

<P>
The options for specifying the Grid shape are:

<UL>
<LI>Use the <TT>ESMF_GridCreateShapeTile()</TT> shortcut method to 
specify the Grid size and dimension, and to select from a limited set
of edge connectivities.   
</LI>
<LI>Create a DistGrid using the <TT>ESMF_DistGridCreate()</TT>
method.  This enables the user to specify connectivities in 
greater detail than using <TT>ESMF_GridCreateShapeTile()</TT>.  Then
pass the DistGrid into a general <TT>ESMF_GridCreate()</TT> method.
</LI>
</UL>

<P>
</LI>
<LI>Specify the Grid coordinates and any other information
required for regridding (this can vary depending on the particular
regridding method).  At the completion of this stage, the Grid can
be used in a regridding operation (once Grid is connected to regrid;
as of v3.1.0, it is not).  Its <TT>ESMF_GridStatus</TT>
has a value of <TT>ESMF_GRIDSTATUS_REGRID_READY</TT>.
</LI>
</OL>

<P>
When creating the Grid shape and specifying the Grid coordinates,
the user can either specify all required information at once,
or can provide information incrementally.  The call
<TT>ESMF_GridCreateEmpty()</TT> builds a Grid object
container that can be filled in with a subsequent call to 
the <TT>ESMF_GridSetCommitShapeTile()</TT> method. 
The <TT>ESMF_GridSetCommitShapeTile()</TT> creates the 
grid and sets the appropriate flag to indicate that
its usable (the status equals <TT>ESMF_GRIDSTATUS_SHAPE_READY</TT>
after the commit). The Grid is implicitly in a valid state after being committed. 

<P>
For consistency's sake the <TT>ESMF_GridSetCommitShapeTile()</TT>
call must occur on the same or a subset of the PETs as the
<TT>ESMF_GridCreateEmpty()</TT> call. The 
<TT>ESMF_GridSetCommitShapeTile()</TT> call uses the VM for
the context in which it's executed and the "empty" Grid contains
no information about the VM in which it was run.  If the
<TT>ESMF_GridSetCommitShapeTile()</TT> call occurs
in a subset of the PETs in which the <TT>ESMF_GridCreateEmpty()</TT> was 
executed, the Grid is created only in that subset. The grid objects outside the subset will
still be "empty" and not usable. 

<P>
The following table summarizes possible call sequences
for building Grids.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><B>Create Shape</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>From shape shortcut</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>grid = ESMF_GridCreateShapeTile(...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>Using DistGrid with general create interface</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>distgrid = ESMF_DistGridCreate(...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>grid = ESMF_GridCreate(distgrid, ...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>Incremental</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>grid = ESMF_GridCreateEmpty(...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>call ESMF_GridSetCommitShapeTile(grid, ...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Set Coordinates</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>Set coordinates by copy or reference</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>call ESMF_GridSetCoord(grid, ...)</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>Retrieve ESMF Array of coordinates from Grid and set values</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>call ESMF_GridGetCoord(grid, esmfArray, ...), set values</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>Retrieve local bounds and native array from Grid and set values</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>call ESMF_GridGetCoord(grid, lbound, ubound, array), set values</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION04052000000000000000">
12.2 Class API: General Grid Methods</A>
</H2>

<P>

<P>

<P>

<H2><A NAME="SECTION04053000000000000000">
12.3 C++:  Class Interface ESMC_Grid - Public C interface to the Grid object (Source File: ESMC_Grid.h)</A>
</H2>

<P>
The code in this file defines the C public Grid class and declares method 
   signatures (prototypes).  The companion file ESMC_Grid.C contains
   the definitions (full code bodies) for the Grid methods.

<P>
---------------------------------------

<P>

<P><P>
<BR>
<EM>USES:</EM>
<PRE> #include "ESMCI_Grid.h"
 
 
 extern "C" {
 
   class declaration type
 typedef struct {
       ESMCI::Grid *grid;
</PRE>

<P>

<P>

<P>

<H1><A NAME="SECTION04060000000000000000">
13 LocStream Class</A>
</H1>

<P>

<H2><A NAME="SECTION04061000000000000000">
13.1 Description</A>
</H2>

<P>
A location stream (LocStream) is used to represent the locations of
a set of data points.  The values of the data points are stored within
a Field or FieldBundle created using the LocStream.

<P>
In the data assimilation world, LocStreams can
be thought of as a set of observations.  Their locations are generally
described using Cartesian (x, y, z), or (lat, lon, height) coordinates.
There is no assumption of any regularity in the positions of the points.
To make the concept more general, the locations for each data point are
represented using a construct called Keys, which can include other
descriptors besides location.

<P>
Although Keys are similar in concept to ESMF Attributes they have important
differences. First, Keys always occur as vectors, never as scalars.
Second, Keys are local to the DE: each DE can have a different Key
list with a different number of of elements. Third, the local Key 
list always has the same number of elements as there are local observations
on that DE.  Finally, Keys may be used for the distribution of LocStreams.
As such, they must be defined before the LocStream is distributed.

<P>
LocStreams can be very large. Data assimilation systems might use
LocStreams with up to <IMG
 WIDTH="29" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.png"
 ALT="$10^{8}$"> observations, so efficiency is critical.

<P>
Common operations involving LocStreams are similar to those involving Grids.
In data assimilation, for example, there is an immediate need to:

<P>

<OL>
<LI>Create a Field or FieldBundle on a LocStream.
</LI>
<LI>Redistribute data between Fields defined on LocStreams.
</LI>
<LI>Gather a bundle of data defined on a LocStream to a root
DE (for output). Similarly, scatter from a root DE.
</LI>
<LI>Halo region exchange for a Field defined by a haloed LocStream.
</LI>
<LI>Extract Fortran array from Field which was defined by a LocStream.
</LI>
</OL>

<P>
The operations on the Fortran arrays underlyinng LocStreams are usually simple numerical ones. However,
it is necessary to sort them in place, and access only portions of the them. It would
not be efficient to continually create new LocStreams to reflect this sorting. Instead,
the sorting is managed by the application through permutation arrays while keeping
the data in place. Locations can become inactive, e.g., if the quality control asserts that
observation is invalid. This can be managed again by the application through masks.

<P>

<H3><A NAME="SECTION04061100000000000000">
13.1.1 How is a LocStream different than a Grid?</A>
</H3>
A LocStream differs from a Grid in that no topological structure is
maintained between the points
(e.g. the class contains no information about which point is the neighbor
of which other point).

<P>

<H3><A NAME="SECTION04061200000000000000">
13.1.2 How is a LocStream different than a Mesh?</A>
</H3>
A Mesh consists of irregularly positioned points, but it has connectivity
also: each data point has a set of neighboring data points. There is no requirement that the
points in a LocStream have connectivity, indeed any particular spatial relationship to
one another.
Due to their heritage from data assimilation, many of the operations on LocStreams
do not resemble typical operations on Meshes, for example in a finite-volume
or finite-element code. 

<P>

<P>

<H1><A NAME="SECTION04070000000000000000">
14 Mesh Class</A>
</H1>

<P>

<H2><A NAME="SECTION04071000000000000000">
14.1 Description</A>
</H2>

<P>
Unstructured grids are commonly used in the computational solution of Partial Differential equations.  These are especially useful for problems that involve complex geometry, where using the less flexible structured grids can
result in grid representation of regions where no computation is needed.  Finite
element and finite volume methods map naturally to unstructured grids and are used commonly
in hydrology, ocean modeling, and many other applications.

<P>
In order to provide support for application codes using unstructured grids, the ESMF library provides a class for representing 
unstructured grids called the <B>Mesh</B>. Fields can be created on a Mesh to hold data. Fields created on a Mesh can also be used 
as either the source or destination or both of an interpolaton (i.e. an <TT>ESMF_FieldRegridStore()</TT> call) in ESMF allowing data to be 
moved to or from or between unstructured grids. This section describes the Mesh and how to create and use them in ESMF. 

<P>

<H3><A NAME="SECTION04071100000000000000">
14.1.1 Mesh Representation in ESMF</A>
</H3>

<P>
A Mesh in ESMF is described in terms of <B>nodes</B> and <B>elements</B>. A node is a point in space which represents where the coordinate 
information in a Mesh is located. This is also where Field data may be located in a Mesh (i.e. Fields may be created on a Mesh's nodes). An 
element is a higher dimensional shape constructed of nodes. Elements give a Mesh its shape and define the relationship of the nodes to one 
another. 

<P>

<H3><A NAME="SECTION04071200000000000000">
14.1.2 Supported Meshes</A>
</H3>

<P>
The range of Meshes supported by ESMF are defined by several factors: dimension, element types, and distribution.

<P>
ESMF currently only supports Meshes whose number of coordinate dimensions (spatial dimension) is 2 or 3. The dimension of the elements in a Mesh
(parametric dimension) must be less than or equal to the spatial dimension, but also must be either 2 or 3. This means that an ESMF mesh may be
either 2D elements in 2D space, 3D elements in 3D space, or a manifold constructed of 2D elements embedded in 3D space. 

<P>
ESMF currently supports two types of elements for each Mesh parametric dimension. For a parametric dimension of 2 the 
supported element types are triangles or quadralaterals. For a parametric dimension of 3 the supported element types are tetrahedrons
and hexahedrons. See Section&nbsp;<A HREF="#sec:mesh:opt:elemtype"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for diagrams of these. The Mesh supports any combination of element types within a particular
dimension, but types from different dimensions may not be mixed, for example, a Mesh cannot be constructed of both quadralaterals and tetrahedra.

<P>
ESMF currently only supports distributions where every node on a PET must be a part of an element on that PET. In other words, there 
must not be nodes without an element on a PET. 

<P>

<H2><A NAME="SECTION04072000000000000000">
14.2 Class API</A>
</H2>

<P>

<P>

<H1><A NAME="SECTION04080000000000000000">
15 DistGrid Class</A>
</H1>

<P>

<H2><A NAME="SECTION04081000000000000000">
15.1 Description</A>
</H2>

<P>
<A NAME="sec:DistGrid"></A>The <TT>ESMF_DistGrid</TT> class sits on top of the DELayout class and holds domain information in index space. A DistGrid object captures the index space topology and describes its decomposition in terms of DEs. Combined with DELayout and VM the DistGrid defines the data distribution of a domain decomposition across the computational resources of an ESMF component.

<P>
The global domain is defined as the union or ``patchwork'' of logically rectangular (LR) sub-domains or <EM>patches</EM>. The DistGrid create methods allow the specification of such a patchwork global domain and its decomposition into exclusive, DE-local LR regions according to various degrees of user specified constraints. Complex index space topologies can be constructed by specifying connection relationships between patches during creation.

<P>
The DistGrid class holds domain information for all DEs. Each DE is associated with a local LR region. No overlap of the regions is allowed. The DistGrid offers query methods that allow DE-local topology information to be extracted, e.g. for the construction of halos by higher classes.

<P>
A DistGrid object only contains decomposable dimensions. The minimum rank for a DistGrid object is 1. A maximum rank does not exist for DistGrid objects, however, ranks greater than 7 may lead to difficulties with respect to the Fortran API of higher classes based on DistGrid. The rank of a DELayout object contained within a DistGrid object must be equal to the DistGrid rank. Higher class objects that use the DistGrid, such as an Array object, may be of different rank than the associated DistGrid object. The higher class object will hold the mapping information between its dimensions and the DistGrid dimensions.

<P>

<H2><A NAME="SECTION04082000000000000000">
15.2 Class API</A>
</H2>

<P>

<P>

<P>

<H2><A NAME="SECTION04083000000000000000">
15.3 C++:  Class Interface ESMC_DistGrid - Public C interface to the ESMF DistGrid class (Source File: ESMC_DistGrid.h)</A>
</H2>

<P>
The code in this file defines the public C DistGrid class and declares method
   signatures (prototypes).  The companion file <TT>ESMC_DistGrid.C</TT> contains
   the definitions (full code bodies) for the DistGrid methods.

<P>

<P>

<P>

<HR>
<!--Navigation Panel-->
<A NAME="tex2html301"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html297"
  HREF="ESMC_crefdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html291"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html299"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html302"
  HREF="node5.html">4 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html298"
  HREF="ESMC_crefdoc.html">ESMC_crefdoc</A>
<B> Previous:</B> <A NAME="tex2html292"
  HREF="node3.html">2 Superstructure</A>
 &nbsp <B>  <A NAME="tex2html300"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
