==1917== Memcheck, a memory error detector
==1917== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==1917== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info
==1917== Command: ./ESMF_CoupledFlow
==1917== 
==1919== Memcheck, a memory error detector
==1919== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==1919== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info
==1919== Command: ./ESMF_CoupledFlow
==1919== 
==1918== Memcheck, a memory error detector
==1918== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==1918== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info
==1918== Command: ./ESMF_CoupledFlow
==1918== 
==1920== Memcheck, a memory error detector
==1920== Copyright (C) 2002-2009, and GNU GPL'd, by Julian Seward et al.
==1920== Using Valgrind-3.5.0 and LibVEX; rerun with -h for copyright info
==1920== Command: ./ESMF_CoupledFlow
==1920== 
==1918== Conditional jump or move depends on uninitialised value(s)
==1918==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1918==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1918==    by 0x9F2576: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11243)
==1918==    by 0x9E10D4: ESMCI::Array::redist(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4986)
==1918==    by 0x9CC2FC: c_esmc_arrayredist_ (ESMCI_Array_F.C:838)
==1918==    by 0xD30F2C: __esmf_arrayhamod_MOD_esmf_arrayredist (ESMF_ArrayHa.F90:753)
==1918==    by 0x85C2D2: __esmf_gridmod_MOD_esmf_gridcreatecopyfromnewdg (ESMF_Grid.F90:2937)
==1918==    by 0x858F8E: __esmf_gridmod_MOD_esmf_gridcreatecopyfromreg (ESMF_Grid.F90:3395)
==1918==    by 0x4310EE: __coupledflowmod_MOD_coupledflow_init (CoupledFlowDemo.F90:283)
==1918==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1918==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1918==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1918== 
==1917== Conditional jump or move depends on uninitialised value(s)
==1917==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1917==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1917==    by 0x9F2576: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11243)
==1917==    by 0x9E10D4: ESMCI::Array::redist(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4986)
==1917==    by 0x9CC2FC: c_esmc_arrayredist_ (ESMCI_Array_F.C:838)
==1917==    by 0xD30F2C: __esmf_arrayhamod_MOD_esmf_arrayredist (ESMF_ArrayHa.F90:753)
==1917==    by 0x85C2D2: __esmf_gridmod_MOD_esmf_gridcreatecopyfromnewdg (ESMF_Grid.F90:2937)
==1917==    by 0x858F8E: __esmf_gridmod_MOD_esmf_gridcreatecopyfromreg (ESMF_Grid.F90:3395)
==1917==    by 0x4310EE: __coupledflowmod_MOD_coupledflow_init (CoupledFlowDemo.F90:283)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917== 
==1917== Conditional jump or move depends on uninitialised value(s)
==1917==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1917==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1917==    by 0x9F262B: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11262)
==1917==    by 0x9E10D4: ESMCI::Array::redist(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4986)
==1917==    by 0x9CC2FC: c_esmc_arrayredist_ (ESMCI_Array_F.C:838)
==1917==    by 0xD30F2C: __esmf_arrayhamod_MOD_esmf_arrayredist (ESMF_ArrayHa.F90:753)
==1917==    by 0x85C2D2: __esmf_gridmod_MOD_esmf_gridcreatecopyfromnewdg (ESMF_Grid.F90:2937)
==1917==    by 0x858F8E: __esmf_gridmod_MOD_esmf_gridcreatecopyfromreg (ESMF_Grid.F90:3395)
==1917==    by 0x4310EE: __coupledflowmod_MOD_coupledflow_init (CoupledFlowDemo.F90:283)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917== 
==1918== Conditional jump or move depends on uninitialised value(s)
==1918==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1918==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1918==    by 0x9F262B: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11262)
==1918==    by 0x9E10D4: ESMCI::Array::redist(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4986)
==1918==    by 0x9CC2FC: c_esmc_arrayredist_ (ESMCI_Array_F.C:838)
==1918==    by 0xD30F2C: __esmf_arrayhamod_MOD_esmf_arrayredist (ESMF_ArrayHa.F90:753)
==1918==    by 0x85C2D2: __esmf_gridmod_MOD_esmf_gridcreatecopyfromnewdg (ESMF_Grid.F90:2937)
==1918==    by 0x858F8E: __esmf_gridmod_MOD_esmf_gridcreatecopyfromreg (ESMF_Grid.F90:3395)
==1918==    by 0x4310EE: __coupledflowmod_MOD_coupledflow_init (CoupledFlowDemo.F90:283)
==1918==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1918==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1918==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1918== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1920==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1920==    by 0x9F262B: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11262)
==1920==    by 0x9E10D4: ESMCI::Array::redist(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4986)
==1920==    by 0x9CC2FC: c_esmc_arrayredist_ (ESMCI_Array_F.C:838)
==1920==    by 0xD30F2C: __esmf_arrayhamod_MOD_esmf_arrayredist (ESMF_ArrayHa.F90:753)
==1920==    by 0x85C2D2: __esmf_gridmod_MOD_esmf_gridcreatecopyfromnewdg (ESMF_Grid.F90:2937)
==1920==    by 0x858F8E: __esmf_gridmod_MOD_esmf_gridcreatecopyfromreg (ESMF_Grid.F90:3395)
==1920==    by 0x4310EE: __coupledflowmod_MOD_coupledflow_init (CoupledFlowDemo.F90:283)
==1920==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1920==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1920==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1920== 
==1919== Conditional jump or move depends on uninitialised value(s)
==1919==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1919==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1919==    by 0x9F262B: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11262)
==1919==    by 0x9E10D4: ESMCI::Array::redist(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4986)
==1919==    by 0x9CC2FC: c_esmc_arrayredist_ (ESMCI_Array_F.C:838)
==1919==    by 0xD30F2C: __esmf_arrayhamod_MOD_esmf_arrayredist (ESMF_ArrayHa.F90:753)
==1919==    by 0x85C2D2: __esmf_gridmod_MOD_esmf_gridcreatecopyfromnewdg (ESMF_Grid.F90:2937)
==1919==    by 0x858F8E: __esmf_gridmod_MOD_esmf_gridcreatecopyfromreg (ESMF_Grid.F90:3395)
==1919==    by 0x4310EE: __coupledflowmod_MOD_coupledflow_init (CoupledFlowDemo.F90:283)
==1919==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1919==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1919==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1919== 
==1919== Conditional jump or move depends on uninitialised value(s)
==1919==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1919==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1919==    by 0x9F2576: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11243)
==1919==    by 0x9DF026: ESMCI::Array::halo(ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4373)
==1919==    by 0x9CC06F: c_esmc_arrayhalo_ (ESMCI_Array_F.C:762)
==1919==    by 0xD31CA6: __esmf_arrayhamod_MOD_esmf_arrayhalo (ESMF_ArrayHa.F90:218)
==1919==    by 0x7B138E: __esmf_fieldhalomod_MOD_esmf_fieldhalo (ESMF_FieldHalo.F90:186)
==1919==    by 0x4296A2: __flowsolvermod_MOD_flowinit (FlowSolverMod.F90:701)
==1919==    by 0x42B1EE: __flowsolvermod_MOD_flow_init1 (FlowSolverMod.F90:315)
==1919==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1919==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1919==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1919== 
==1919== Conditional jump or move depends on uninitialised value(s)
==1919==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1919==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1919==    by 0x9F262B: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11262)
==1919==    by 0x9DF026: ESMCI::Array::halo(ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4373)
==1919==    by 0x9CC06F: c_esmc_arrayhalo_ (ESMCI_Array_F.C:762)
==1919==    by 0xD31CA6: __esmf_arrayhamod_MOD_esmf_arrayhalo (ESMF_ArrayHa.F90:218)
==1919==    by 0x7B138E: __esmf_fieldhalomod_MOD_esmf_fieldhalo (ESMF_FieldHalo.F90:186)
==1919==    by 0x4296A2: __flowsolvermod_MOD_flowinit (FlowSolverMod.F90:701)
==1919==    by 0x42B1EE: __flowsolvermod_MOD_flow_init1 (FlowSolverMod.F90:315)
==1919==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1919==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1919==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1919== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1920==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1920==    by 0x9F2576: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11243)
==1920==    by 0x9DF026: ESMCI::Array::halo(ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4373)
==1920==    by 0x9CC06F: c_esmc_arrayhalo_ (ESMCI_Array_F.C:762)
==1920==    by 0xD31CA6: __esmf_arrayhamod_MOD_esmf_arrayhalo (ESMF_ArrayHa.F90:218)
==1920==    by 0x7B138E: __esmf_fieldhalomod_MOD_esmf_fieldhalo (ESMF_FieldHalo.F90:186)
==1920==    by 0x4296A2: __flowsolvermod_MOD_flowinit (FlowSolverMod.F90:701)
==1920==    by 0x42B1EE: __flowsolvermod_MOD_flow_init1 (FlowSolverMod.F90:315)
==1920==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1920==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1920==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1920== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1920==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1920==    by 0x9F262B: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11262)
==1920==    by 0x9DF026: ESMCI::Array::halo(ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4373)
==1920==    by 0x9CC06F: c_esmc_arrayhalo_ (ESMCI_Array_F.C:762)
==1920==    by 0xD31CA6: __esmf_arrayhamod_MOD_esmf_arrayhalo (ESMF_ArrayHa.F90:218)
==1920==    by 0x7B138E: __esmf_fieldhalomod_MOD_esmf_fieldhalo (ESMF_FieldHalo.F90:186)
==1920==    by 0x4296A2: __flowsolvermod_MOD_flowinit (FlowSolverMod.F90:701)
==1920==    by 0x42B1EE: __flowsolvermod_MOD_flow_init1 (FlowSolverMod.F90:315)
==1920==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1920==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1920==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1920== 
==1918== Conditional jump or move depends on uninitialised value(s)
==1918==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1918==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1918==    by 0x9F2576: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11243)
==1918==    by 0x9DF026: ESMCI::Array::halo(ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4373)
==1918==    by 0x9CC06F: c_esmc_arrayhalo_ (ESMCI_Array_F.C:762)
==1918==    by 0xD31CA6: __esmf_arrayhamod_MOD_esmf_arrayhalo (ESMF_ArrayHa.F90:218)
==1918==    by 0x7B138E: __esmf_fieldhalomod_MOD_esmf_fieldhalo (ESMF_FieldHalo.F90:186)
==1918==    by 0x4296A2: __flowsolvermod_MOD_flowinit (FlowSolverMod.F90:701)
==1918==    by 0x42B1EE: __flowsolvermod_MOD_flow_init1 (FlowSolverMod.F90:315)
==1918==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1918==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1918==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1918== 
==1918== Conditional jump or move depends on uninitialised value(s)
==1918==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1918==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1918==    by 0x9F262B: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11262)
==1918==    by 0x9DF026: ESMCI::Array::halo(ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4373)
==1918==    by 0x9CC06F: c_esmc_arrayhalo_ (ESMCI_Array_F.C:762)
==1918==    by 0xD31CA6: __esmf_arrayhamod_MOD_esmf_arrayhalo (ESMF_ArrayHa.F90:218)
==1918==    by 0x7B138E: __esmf_fieldhalomod_MOD_esmf_fieldhalo (ESMF_FieldHalo.F90:186)
==1918==    by 0x4296A2: __flowsolvermod_MOD_flowinit (FlowSolverMod.F90:701)
==1918==    by 0x42B1EE: __flowsolvermod_MOD_flow_init1 (FlowSolverMod.F90:315)
==1918==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1918==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1918==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1918== 
 Coupled Flow Demo Application Start
 Comp Creates finished
 CoupledFlowDemo: Registered Initialize, Run, and Finalize routines
 Coupled Flow Component SetServices finished, rc =           0           0
 Comp Creates finished
 in user register routine
 InjectorMod: Registered Initialize, Run, and Finalize routines
 InjectorMod: Registered Private Data block for Internal State
 FlowSolverMod: Registered Initialize, Run, and Finalize routines
 CouplerMod: Registered Initialize, Run, and Finalize routines
 Injection Model Initialize finished, rc =           0
 Flow_Init1(): dx =    1282.0513     dy =    694.44446    
 dt =    2.0000000000000000     
 Flow Model Initialize finished, rc =           0
 Coupler Init starting
 Coupler Init returning
 Coupler Init starting
 Coupler Init returning
 Coupler Initialize finished, rc =           0
 Injection Model Initialize finished, rc =           0
 Flow Model Initialize finished, rc =           0
 Coupled Flow Component Initialize finished, rc =           0           0
 Run Loop Start time
 Coupled Flow Demo Application Start
 Comp Creates finished
 CoupledFlowDemo: Registered Initialize, Run, and Finalize routines
 Coupled Flow Component SetServices finished, rc =           0           0
 Comp Creates finished
 in user register routine
 InjectorMod: Registered Initialize, Run, and Finalize routines
 InjectorMod: Registered Private Data block for Internal State
 FlowSolverMod: Registered Initialize, Run, and Finalize routines
 CouplerMod: Registered Initialize, Run, and Finalize routines
 Injection Model Initialize finished, rc =           0
 Flow_Init1(): dx =    1282.0513     dy =    694.44446    
 dt =    2.0000000000000000     
 Flow Model Initialize finished, rc =           0
 Coupler Init starting
 Coupler Init returning
 Coupler Init starting
 Coupler Init returning
 Coupler Initialize finished, rc =           0
 Injection Model Initialize finished, rc =           0
 Flow Model Initialize finished, rc =           0
 Coupled Flow Component Initialize finished, rc =           0           0
 Run Loop Start time
 Coupled Flow Demo Application Start
 Comp Creates finished
 CoupledFlowDemo: Registered Initialize, Run, and Finalize routines
 Coupled Flow Component SetServices finished, rc =           0           0
 Comp Creates finished
 in user register routine
 InjectorMod: Registered Initialize, Run, and Finalize routines
 InjectorMod: Registered Private Data block for Internal State
 FlowSolverMod: Registered Initialize, Run, and Finalize routines
 CouplerMod: Registered Initialize, Run, and Finalize routines
 Injection Model Initialize finished, rc =           0
 Flow_Init1(): dx =    1282.0513     dy =    694.44446    
 dt =    2.0000000000000000     
 Flow Model Initialize finished, rc =           0
 Coupler Init starting
 Coupler Init returning
 Coupler Init starting
 Coupler Init returning
 Coupler Initialize finished, rc =           0
 Injection Model Initialize finished, rc =           0
 Flow Model Initialize finished, rc =           0
 Coupled Flow Component Initialize finished, rc =           0           0
 Run Loop Start time
Clock ----------------------------------Clock ---------------------------------- Coupled Flow Demo Application Start
 Comp Creates finished
 CoupledFlowDemo: Registered Initialize, Run, and Finalize routines
 Coupled Flow Component SetServices finished, rc =           0           0
 Comp Creates finished
 in user register routine
 InjectorMod: Registered Initialize, Run, and Finalize routines
 InjectorMod: Registered Private Data block for Internal State
 FlowSolverMod: Registered Initialize, Run, and Finalize routines
 CouplerMod: Registered Initialize, Run, and Finalize routines
 Injection Model Initialize finished, rc =           0
 Flow_Init1(): dx =    1282.0513     dy =    694.44446    
 dt =    2.0000000000000000     
 Flow Model Initialize finished, rc =           0
 Coupler Init starting
 Coupler Init returning
 Coupler Init starting
 Coupler Init returning
 Coupler Initialize finished, rc =           0
 Injection Model Initialize finished, rc =           0
 Flow Model Initialize finished, rc =           0
 Coupled Flow Component Initialize finished, rc =           0           0
 Run Loop Start time


Clock ----------------------------------currTime = 

Time -----------------------------------
currTime = 
Clock ----------------------------------Time -----------------------------------

currTime = 
Time -----------------------------------
currTime = 
Time -----------------------------------
2003-05-15T09:00:00
end Time -------------------------------

2003-05-15T09:00:00
end Time -------------------------------

end Clock ------------------------------

end Clock ------------------------------

2003-05-15T09:00:00
end Time -------------------------------

end Clock ------------------------------

2003-05-15T09:00:00
end Time -------------------------------

end Clock ------------------------------

==1917== Conditional jump or move depends on uninitialised value(s)
==1917==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1917==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1917==    by 0x9F2576: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11243)
==1917==    by 0x9DF026: ESMCI::Array::halo(ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4373)
==1917==    by 0x9CC06F: c_esmc_arrayhalo_ (ESMCI_Array_F.C:762)
==1917==    by 0xD31CA6: __esmf_arrayhamod_MOD_esmf_arrayhalo (ESMF_ArrayHa.F90:218)
==1917==    by 0x7B138E: __esmf_fieldhalomod_MOD_esmf_fieldhalo (ESMF_FieldHalo.F90:186)
==1917==    by 0x420B55: __flowsolvermod_MOD_flowvel (FlowSolverMod.F90:1503)
==1917==    by 0x426CA9: __flowsolvermod_MOD_flowsolve (FlowSolverMod.F90:890)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917== 
==1917== Conditional jump or move depends on uninitialised value(s)
==1917==    at 0x444FD5: ESMCI::VMK::cancelled(ESMCI::VMK::status*) (ESMCI_VMKernel.C:2819)
==1917==    by 0xA9B0B6: ESMCI::XXE::exec(int, char**, int*, int, bool*, bool*, double*, int, int) (ESMCI_DELayout.C:2925)
==1917==    by 0x9F262B: ESMCI::Array::sparseMatMul(ESMCI::Array*, ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, ESMC_Region_Flag, ESMC_TermOrder_Flag, bool, bool) (ESMCI_Array.C:11262)
==1917==    by 0x9DF026: ESMCI::Array::halo(ESMCI::Array*, ESMCI::RouteHandle**, ESMC_CommFlag, bool*, bool*, bool) (ESMCI_Array.C:4373)
==1917==    by 0x9CC06F: c_esmc_arrayhalo_ (ESMCI_Array_F.C:762)
==1917==    by 0xD31CA6: __esmf_arrayhamod_MOD_esmf_arrayhalo (ESMF_ArrayHa.F90:218)
==1917==    by 0x7B138E: __esmf_fieldhalomod_MOD_esmf_fieldhalo (ESMF_FieldHalo.F90:186)
==1917==    by 0x420B55: __flowsolvermod_MOD_flowvel (FlowSolverMod.F90:1503)
==1917==    by 0x426CA9: __flowsolvermod_MOD_flowsolve (FlowSolverMod.F90:890)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917== 
==1919== Conditional jump or move depends on uninitialised value(s)
==1919==    at 0x42C94B: __injectormod_MOD_injector_run (InjectorMod.F90:496)
==1919==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1919==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1919==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1919==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1919==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1919==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1919==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1919==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1919==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1919==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1919==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1919== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x42C94B: __injectormod_MOD_injector_run (InjectorMod.F90:496)
==1920==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1920==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1920==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1920==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1920==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1920==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1920==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1920==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1920==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1920==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1920==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1920== 
==1918== Conditional jump or move depends on uninitialised value(s)
==1918==    at 0x42C94B: __injectormod_MOD_injector_run (InjectorMod.F90:496)
==1918==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1918==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1918==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1918==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1918==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1918==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1918==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1918==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1918==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1918==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1918==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1918== 
==1919== Conditional jump or move depends on uninitialised value(s)
==1919==    at 0x42C951: __injectormod_MOD_injector_run (InjectorMod.F90:496)
==1919==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1919==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1919==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1919==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1919==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1919==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1919==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1919==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1919==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1919==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1919==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1919== 
==1917== Conditional jump or move depends on uninitialised value(s)
==1917==    at 0x42C94B: __injectormod_MOD_injector_run (InjectorMod.F90:496)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1917==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1917==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1917==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1917==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917== 
==1917== Conditional jump or move depends on uninitialised value(s)
==1917==    at 0x42C951: __injectormod_MOD_injector_run (InjectorMod.F90:496)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1917==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1917==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1917==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1917==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x4A07079: strlen (mc_replace_strmem.c:275)
==1920==    by 0x4F42B38: T.44 (cfortran.h:553)
==1920==    by 0x4F42D7F: nf_inq_var_ (fort-genvar.c:28)
==1920==    by 0x4F4A8DA: __netcdf_MOD_nf90_inquire_variable (netcdf_variables.f90:65)
==1920==    by 0xF26DE6: __esmfpionfwrite_mod_MOD_write_nfdarray_real (pionfwrite_mod.F90:129)
==1920==    by 0xE9B9AB: __esmfpiodarray_MOD_write_darray_nf_real (piodarray.F90:574)
==1920==    by 0xEAF101: __esmfpiodarray_MOD_write_darray_1d_real (piodarray.F90:191)
==1920==    by 0xEAD460: __esmfpiodarray_MOD_write_darray_2d_real (piodarray.F90:245)
==1920==    by 0xD9DABF: esmcpio_cpp_write_darray_real (darray_cpp_binding.F90:599)
==1920==    by 0xC5432E: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:1160)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x4A07088: strlen (mc_replace_strmem.c:275)
==1920==    by 0x4F42B38: T.44 (cfortran.h:553)
==1920==    by 0x4F42D7F: nf_inq_var_ (fort-genvar.c:28)
==1920==    by 0x4F4A8DA: __netcdf_MOD_nf90_inquire_variable (netcdf_variables.f90:65)
==1920==    by 0xF26DE6: __esmfpionfwrite_mod_MOD_write_nfdarray_real (pionfwrite_mod.F90:129)
==1920==    by 0xE9B9AB: __esmfpiodarray_MOD_write_darray_nf_real (piodarray.F90:574)
==1920==    by 0xEAF101: __esmfpiodarray_MOD_write_darray_1d_real (piodarray.F90:191)
==1920==    by 0xEAD460: __esmfpiodarray_MOD_write_darray_2d_real (piodarray.F90:245)
==1920==    by 0xD9DABF: esmcpio_cpp_write_darray_real (darray_cpp_binding.F90:599)
==1920==    by 0xC5432E: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:1160)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x4F42B4C: T.44 (cfortran.h:555)
==1920==    by 0x4F42D7F: nf_inq_var_ (fort-genvar.c:28)
==1920==    by 0x4F4A8DA: __netcdf_MOD_nf90_inquire_variable (netcdf_variables.f90:65)
==1920==    by 0xF26DE6: __esmfpionfwrite_mod_MOD_write_nfdarray_real (pionfwrite_mod.F90:129)
==1920==    by 0xE9B9AB: __esmfpiodarray_MOD_write_darray_nf_real (piodarray.F90:574)
==1920==    by 0xEAF101: __esmfpiodarray_MOD_write_darray_1d_real (piodarray.F90:191)
==1920==    by 0xEAD460: __esmfpiodarray_MOD_write_darray_2d_real (piodarray.F90:245)
==1920==    by 0xD9DABF: esmcpio_cpp_write_darray_real (darray_cpp_binding.F90:599)
==1920==    by 0xC5432E: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:1160)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920==    by 0xB9A1F4: c_esmc_iowrite_ (ESMCI_IO_F.C:157)
==1920== 
==1920== Use of uninitialised value of size 8
==1920==    at 0x4F42B68: T.44 (cfortran.h:556)
==1920==    by 0x4F42D7F: nf_inq_var_ (fort-genvar.c:28)
==1920==    by 0x4F4A8DA: __netcdf_MOD_nf90_inquire_variable (netcdf_variables.f90:65)
==1920==    by 0xF26DE6: __esmfpionfwrite_mod_MOD_write_nfdarray_real (pionfwrite_mod.F90:129)
==1920==    by 0xE9B9AB: __esmfpiodarray_MOD_write_darray_nf_real (piodarray.F90:574)
==1920==    by 0xEAF101: __esmfpiodarray_MOD_write_darray_1d_real (piodarray.F90:191)
==1920==    by 0xEAD460: __esmfpiodarray_MOD_write_darray_2d_real (piodarray.F90:245)
==1920==    by 0xD9DABF: esmcpio_cpp_write_darray_real (darray_cpp_binding.F90:599)
==1920==    by 0xC5432E: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:1160)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920==    by 0xB9A1F4: c_esmc_iowrite_ (ESMCI_IO_F.C:157)
==1920== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x4A07079: strlen (mc_replace_strmem.c:275)
==1920==    by 0x4F41938: T.38 (cfortran.h:553)
==1920==    by 0x4F41C0A: nf_inq_dim_ (fort-dim.c:35)
==1920==    by 0x4F49300: __netcdf_MOD_nf90_inquire_dimension (netcdf_dims.f90:42)
==1920==    by 0xD6936A: __esmfnf_mod_MOD_pio_inq_dimlen (nf_mod.F90:1369)
==1920==    by 0xD6738B: esmcpio_cpp_inq_dimlen (nf_cpp_binding.F90:1272)
==1920==    by 0xC536B8: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:905)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920==    by 0xB9A1F4: c_esmc_iowrite_ (ESMCI_IO_F.C:157)
==1920==    by 0x86F27B: __esmf_iomod_MOD_esmf_iowrite (ESMF_IO.F90:505)
==1920==    by 0x7C4F16: __esmf_fieldwrmod_MOD_esmf_fieldwrite (ESMF_FieldWr.F90:225)
==1920== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x4A07088: strlen (mc_replace_strmem.c:275)
==1920==    by 0x4F41938: T.38 (cfortran.h:553)
==1920==    by 0x4F41C0A: nf_inq_dim_ (fort-dim.c:35)
==1920==    by 0x4F49300: __netcdf_MOD_nf90_inquire_dimension (netcdf_dims.f90:42)
==1920==    by 0xD6936A: __esmfnf_mod_MOD_pio_inq_dimlen (nf_mod.F90:1369)
==1920==    by 0xD6738B: esmcpio_cpp_inq_dimlen (nf_cpp_binding.F90:1272)
==1920==    by 0xC536B8: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:905)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920==    by 0xB9A1F4: c_esmc_iowrite_ (ESMCI_IO_F.C:157)
==1920==    by 0x86F27B: __esmf_iomod_MOD_esmf_iowrite (ESMF_IO.F90:505)
==1920==    by 0x7C4F16: __esmf_fieldwrmod_MOD_esmf_fieldwrite (ESMF_FieldWr.F90:225)
==1920== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x4F4194C: T.38 (cfortran.h:555)
==1920==    by 0x4F41C0A: nf_inq_dim_ (fort-dim.c:35)
==1920==    by 0x4F49300: __netcdf_MOD_nf90_inquire_dimension (netcdf_dims.f90:42)
==1920==    by 0xD6936A: __esmfnf_mod_MOD_pio_inq_dimlen (nf_mod.F90:1369)
==1920==    by 0xD6738B: esmcpio_cpp_inq_dimlen (nf_cpp_binding.F90:1272)
==1920==    by 0xC536B8: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:905)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920==    by 0xB9A1F4: c_esmc_iowrite_ (ESMCI_IO_F.C:157)
==1920==    by 0x86F27B: __esmf_iomod_MOD_esmf_iowrite (ESMF_IO.F90:505)
==1920==    by 0x7C4F16: __esmf_fieldwrmod_MOD_esmf_fieldwrite (ESMF_FieldWr.F90:225)
==1920==    by 0x41D2E7: __flowsolvermod_MOD_flowprint (FlowSolverMod.F90:1758)
==1920== 
==1920== Use of uninitialised value of size 8
==1920==    at 0x4F41968: T.38 (cfortran.h:556)
==1920==    by 0x4F41C0A: nf_inq_dim_ (fort-dim.c:35)
==1920==    by 0x4F49300: __netcdf_MOD_nf90_inquire_dimension (netcdf_dims.f90:42)
==1920==    by 0xD6936A: __esmfnf_mod_MOD_pio_inq_dimlen (nf_mod.F90:1369)
==1920==    by 0xD6738B: esmcpio_cpp_inq_dimlen (nf_cpp_binding.F90:1272)
==1920==    by 0xC536B8: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:905)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920==    by 0xB9A1F4: c_esmc_iowrite_ (ESMCI_IO_F.C:157)
==1920==    by 0x86F27B: __esmf_iomod_MOD_esmf_iowrite (ESMF_IO.F90:505)
==1920==    by 0x7C4F16: __esmf_fieldwrmod_MOD_esmf_fieldwrite (ESMF_FieldWr.F90:225)
==1920==    by 0x41D2E7: __flowsolvermod_MOD_flowprint (FlowSolverMod.F90:1758)
==1920== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x4F42B4C: T.44 (cfortran.h:555)
==1920==    by 0x4F42D7F: nf_inq_var_ (fort-genvar.c:28)
==1920==    by 0x4F4A8DA: __netcdf_MOD_nf90_inquire_variable (netcdf_variables.f90:65)
==1920==    by 0xD6AF5B: __esmfnf_mod_MOD_inq_varndims_vid (nf_mod.F90:847)
==1920==    by 0xD6AD7E: __esmfnf_mod_MOD_inq_varndims_vdesc (nf_mod.F90:886)
==1920==    by 0xD66DE5: esmcpio_cpp_inq_varndims_vdesc (nf_cpp_binding.F90:798)
==1920==    by 0xC538A2: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:954)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920==    by 0xB9A1F4: c_esmc_iowrite_ (ESMCI_IO_F.C:157)
==1920==    by 0x86F27B: __esmf_iomod_MOD_esmf_iowrite (ESMF_IO.F90:505)
==1920==    by 0x7C4F16: __esmf_fieldwrmod_MOD_esmf_fieldwrite (ESMF_FieldWr.F90:225)
==1920== 
==1920== Use of uninitialised value of size 8
==1920==    at 0x4F42B68: T.44 (cfortran.h:556)
==1920==    by 0x4F42D7F: nf_inq_var_ (fort-genvar.c:28)
==1920==    by 0x4F4A8DA: __netcdf_MOD_nf90_inquire_variable (netcdf_variables.f90:65)
==1920==    by 0xD6AF5B: __esmfnf_mod_MOD_inq_varndims_vid (nf_mod.F90:847)
==1920==    by 0xD6AD7E: __esmfnf_mod_MOD_inq_varndims_vdesc (nf_mod.F90:886)
==1920==    by 0xD66DE5: esmcpio_cpp_inq_varndims_vdesc (nf_cpp_binding.F90:798)
==1920==    by 0xC538A2: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:954)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920==    by 0xB9A1F4: c_esmc_iowrite_ (ESMCI_IO_F.C:157)
==1920==    by 0x86F27B: __esmf_iomod_MOD_esmf_iowrite (ESMF_IO.F90:505)
==1920==    by 0x7C4F16: __esmf_fieldwrmod_MOD_esmf_fieldwrite (ESMF_FieldWr.F90:225)
==1920== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x4F42B4C: T.44 (cfortran.h:555)
==1920==    by 0x4F42D7F: nf_inq_var_ (fort-genvar.c:28)
==1920==    by 0x4F4A8DA: __netcdf_MOD_nf90_inquire_variable (netcdf_variables.f90:65)
==1920==    by 0xD6A6F8: __esmfnf_mod_MOD_inq_vardimid_vid (nf_mod.F90:1033)
==1920==    by 0xD6A306: __esmfnf_mod_MOD_inq_vardimid_vdesc (nf_mod.F90:1071)
==1920==    by 0xD670AC: esmcpio_cpp_inq_vardimid_vdesc (nf_cpp_binding.F90:951)
==1920==    by 0xC539C1: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:978)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920==    by 0xB9A1F4: c_esmc_iowrite_ (ESMCI_IO_F.C:157)
==1920==    by 0x86F27B: __esmf_iomod_MOD_esmf_iowrite (ESMF_IO.F90:505)
==1920==    by 0x7C4F16: __esmf_fieldwrmod_MOD_esmf_fieldwrite (ESMF_FieldWr.F90:225)
==1920== 
==1920== Use of uninitialised value of size 8
==1920==    at 0x4F42B68: T.44 (cfortran.h:556)
==1920==    by 0x4F42D7F: nf_inq_var_ (fort-genvar.c:28)
==1920==    by 0x4F4A8DA: __netcdf_MOD_nf90_inquire_variable (netcdf_variables.f90:65)
==1920==    by 0xD6A6F8: __esmfnf_mod_MOD_inq_vardimid_vid (nf_mod.F90:1033)
==1920==    by 0xD6A306: __esmfnf_mod_MOD_inq_vardimid_vdesc (nf_mod.F90:1071)
==1920==    by 0xD670AC: esmcpio_cpp_inq_vardimid_vdesc (nf_cpp_binding.F90:951)
==1920==    by 0xC539C1: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:978)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920==    by 0xB9A1F4: c_esmc_iowrite_ (ESMCI_IO_F.C:157)
==1920==    by 0x86F27B: __esmf_iomod_MOD_esmf_iowrite (ESMF_IO.F90:505)
==1920==    by 0x7C4F16: __esmf_fieldwrmod_MOD_esmf_fieldwrite (ESMF_FieldWr.F90:225)
==1920== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x4F4195E: T.38 (cfortran.h:555)
==1920==    by 0x4F41C0A: nf_inq_dim_ (fort-dim.c:35)
==1920==    by 0x4F49300: __netcdf_MOD_nf90_inquire_dimension (netcdf_dims.f90:42)
==1920==    by 0xD6936A: __esmfnf_mod_MOD_pio_inq_dimlen (nf_mod.F90:1369)
==1920==    by 0xD6738B: esmcpio_cpp_inq_dimlen (nf_cpp_binding.F90:1272)
==1920==    by 0xC53A9C: ESMCI::PIO_Handler::arrayWrite(ESMCI::Array*, char const*, int*, int*) (ESMCI_PIO_Handler.C:993)
==1920==    by 0xB9BC51: ESMCI::IO::write(int*) (ESMCI_IO.C:453)
==1920==    by 0xB9BADE: ESMCI::IO::write(char const*, ESMC_IOFmt_Flag, bool, ESMC_FileStatus_Flag, int*) (ESMCI_IO.C:395)
==1920==    by 0xB9A1F4: c_esmc_iowrite_ (ESMCI_IO_F.C:157)
==1920==    by 0x86F27B: __esmf_iomod_MOD_esmf_iowrite (ESMF_IO.F90:505)
==1920==    by 0x7C4F16: __esmf_fieldwrmod_MOD_esmf_fieldwrite (ESMF_FieldWr.F90:225)
==1920==    by 0x41D2E7: __flowsolvermod_MOD_flowprint (FlowSolverMod.F90:1758)
==1920== 
==1919== Conditional jump or move depends on uninitialised value(s)
==1919==    at 0x42C792: __injectormod_MOD_injector_run (InjectorMod.F90:483)
==1919==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1919==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1919==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1919==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1919==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1919==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1919==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1919==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1919==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1919==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1919==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1919== 
==1918== Conditional jump or move depends on uninitialised value(s)
==1918==    at 0x42C792: __injectormod_MOD_injector_run (InjectorMod.F90:483)
==1918==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1918==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1918==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1918==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1918==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1918==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1918==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1918==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1918==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1918==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1918==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1918== 
==1919== Conditional jump or move depends on uninitialised value(s)
==1919==    at 0x42C798: __injectormod_MOD_injector_run (InjectorMod.F90:483)
==1919==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1919==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1919==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1919==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1919==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1919==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1919==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1919==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1919==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1919==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1919==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1919== 
==1920== Conditional jump or move depends on uninitialised value(s)
==1920==    at 0x42C792: __injectormod_MOD_injector_run (InjectorMod.F90:483)
==1920==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1920==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1920==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1920==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1920==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1920==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1920==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1920==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1920==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1920==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1920==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1920== 
==1917== Conditional jump or move depends on uninitialised value(s)
==1917==    at 0x42C792: __injectormod_MOD_injector_run (InjectorMod.F90:483)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1917==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1917==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1917==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1917==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917== 
==1917== Conditional jump or move depends on uninitialised value(s)
==1917==    at 0x42C798: __injectormod_MOD_injector_run (InjectorMod.F90:483)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917==    by 0x44E921: ESMCI::VM::enter(ESMCI::VMPlan*, void*, void*) (ESMCI_VM.C:806)
==1917==    by 0x4373E7: c_esmc_ftablecallentrypointvm_ (ESMCI_FTable.C:858)
==1917==    by 0x5AC173: __esmf_compmod_MOD_esmf_compexecute (ESMF_Comp.F90:1201)
==1917==    by 0x7CCF1A: __esmf_gridcompmod_MOD_esmf_gridcomprun (ESMF_GridComp.F90:1656)
==1917==    by 0x4302DA: __coupledflowmod_MOD_coupledflow_run (CoupledFlowDemo.F90:539)
==1917==    by 0x43984C: ESMCI::FTable::callVFuncPtr(char const*, ESMCI::VM*, int*) (ESMCI_FTable.C:1822)
==1917==    by 0x436FCF: ESMCI_FTableCallEntryPointVMHop (ESMCI_FTable.C:729)
==1917==    by 0x441699: ESMCI::VMK::enter(ESMCI::VMKPlan*, void*, void*) (ESMCI_VMKernel.C:1761)
==1917== 
 Run Loop End time
Clock ----------------------------------
currTime = 
Time -----------------------------------
 Run Loop End time
Clock ----------------------------------
currTime = 
Time -----------------------------------
2003-05-15T09:30:00
end Time -------------------------------

end Clock ------------------------------

 Run Loop End time
Clock ----------------------------------
currTime = 
Time -----------------------------------
2003-05-15T09:30:00
end Time -------------------------------

end Clock ------------------------------

2003-05-15T09:30:00
end Time -------------------------------

end Clock ------------------------------

 Run Loop End time
Clock ----------------------------------
currTime = 
Time -----------------------------------
2003-05-15T09:30:00
end Time -------------------------------

end Clock ------------------------------

 Coupled Flow Component Run finished, rc =           0           0
 Injector Finalize starting
 Injector Finalize returning
 Coupler Final starting
 Coupler Final returning
 CoupledFlowMod finished calling all subcomponent Finalize routines
 ready to destroy all states
 ready to destroy all components
 end of CoupledFlowMod Finalization routine
 Coupled Flow Component Finalize finished, rc =           0           0
 **********************************************************
 SUCCESS!  Your ESMF Coupled Flow Application Demo ran to completion!
 See the output files in the source directory for the generated data.
 **********************************************************
 Coupled Flow Component Run finished, rc =           0           0
 Injector Finalize starting
 Injector Finalize returning
 Coupler Final starting
 Coupler Final returning
 CoupledFlowMod finished calling all subcomponent Finalize routines
 ready to destroy all states
 ready to destroy all components
 end of CoupledFlowMod Finalization routine
 Coupled Flow Component Finalize finished, rc =           0           0
 **********************************************************
 SUCCESS!  Your ESMF Coupled Flow Application Demo ran to completion!
 See the output files in the source directory for the generated data.
 **********************************************************
 Coupled Flow Component Run finished, rc =           0           0
 Injector Finalize starting
 Injector Finalize returning
 Coupler Final starting
 Coupler Final returning
 CoupledFlowMod finished calling all subcomponent Finalize routines
 ready to destroy all states
 ready to destroy all components
 end of CoupledFlowMod Finalization routine
 Coupled Flow Component Finalize finished, rc =           0           0
 **********************************************************
 SUCCESS!  Your ESMF Coupled Flow Application Demo ran to completion!
 See the output files in the source directory for the generated data.
 **********************************************************
 Coupled Flow Component Run finished, rc =           0           0
 Injector Finalize starting
 Injector Finalize returning
 Coupler Final starting
 Coupler Final returning
 CoupledFlowMod finished calling all subcomponent Finalize routines
 ready to destroy all states
 ready to destroy all components
 end of CoupledFlowMod Finalization routine
 Coupled Flow Component Finalize finished, rc =           0           0
 **********************************************************
 SUCCESS!  Your ESMF Coupled Flow Application Demo ran to completion!
 See the output files in the source directory for the generated data.
 **********************************************************
==1920== Invalid free() / delete / delete[]
==1920==    at 0x4A05D21: free (vg_replace_malloc.c:325)
==1920==    by 0x33C0B0C24A: ??? (in /lib64/libc-2.5.so)
==1920==    by 0x33C0B0BE41: ??? (in /lib64/libc-2.5.so)
==1920==    by 0x48024E8: _vgnU_freeres (vg_preloaded.c:62)
==1920==    by 0x33C0A33224: exit (in /lib64/libc-2.5.so)
==1920==    by 0x33C0A1D9FA: (below main) (in /lib64/libc-2.5.so)
==1920==  Address 0x5bbd6c8 is not stack'd, malloc'd or (recently) free'd
==1920== 
==1917== Invalid free() / delete / delete[]
==1917==    at 0x4A05D21: free (vg_replace_malloc.c:325)
==1917==    by 0x33C0B0C24A: ??? (in /lib64/libc-2.5.so)
==1917==    by 0x33C0B0BE41: ??? (in /lib64/libc-2.5.so)
==1917==    by 0x48024E8: _vgnU_freeres (vg_preloaded.c:62)
==1917==    by 0x33C0A33224: exit (in /lib64/libc-2.5.so)
==1917==    by 0x33C0A1D9FA: (below main) (in /lib64/libc-2.5.so)
==1917==  Address 0x5bbd6c8 is not stack'd, malloc'd or (recently) free'd
==1917== 
==1920== 
==1920== HEAP SUMMARY:
==1920==     in use at exit: 64 bytes in 1 blocks
==1920==   total heap usage: 2,619,246 allocs, 2,619,247 frees, 218,646,342 bytes allocated
==1920== 
==1917== 
==1917== HEAP SUMMARY:
==1917==     in use at exit: 64 bytes in 1 blocks
==1917==   total heap usage: 2,645,683 allocs, 2,645,684 frees, 210,100,696 bytes allocated
==1917== 
==1919== Invalid free() / delete / delete[]
==1919==    at 0x4A05D21: free (vg_replace_malloc.c:325)
==1919==    by 0x33C0B0C24A: ??? (in /lib64/libc-2.5.so)
==1919==    by 0x33C0B0BE41: ??? (in /lib64/libc-2.5.so)
==1919==    by 0x48024E8: _vgnU_freeres (vg_preloaded.c:62)
==1919==    by 0x33C0A33224: exit (in /lib64/libc-2.5.so)
==1919==    by 0x33C0A1D9FA: (below main) (in /lib64/libc-2.5.so)
==1919==  Address 0x5bbd6c8 is not stack'd, malloc'd or (recently) free'd
==1919== 
==1919== 
==1919== HEAP SUMMARY:
==1919==     in use at exit: 64 bytes in 1 blocks
==1919==   total heap usage: 2,616,278 allocs, 2,616,279 frees, 226,030,065 bytes allocated
==1919== 
==1920== LEAK SUMMARY:
==1920==    definitely lost: 0 bytes in 0 blocks
==1920==    indirectly lost: 0 bytes in 0 blocks
==1920==      possibly lost: 0 bytes in 0 blocks
==1920==    still reachable: 64 bytes in 1 blocks
==1920==         suppressed: 0 bytes in 0 blocks
==1920== Reachable blocks (those to which a pointer was found) are not shown.
==1920== To see them, rerun with: --leak-check=full --show-reachable=yes
==1920== 
==1920== For counts of detected and suppressed errors, rerun with: -v
==1920== Use --track-origins=yes to see where uninitialised values come from
==1920== ERROR SUMMARY: 2912306 errors from 19 contexts (suppressed: 4 from 4)
==1917== LEAK SUMMARY:
==1917==    definitely lost: 0 bytes in 0 blocks
==1917==    indirectly lost: 0 bytes in 0 blocks
==1917==      possibly lost: 0 bytes in 0 blocks
==1917==    still reachable: 64 bytes in 1 blocks
==1917==         suppressed: 0 bytes in 0 blocks
==1917== Reachable blocks (those to which a pointer was found) are not shown.
==1917== To see them, rerun with: --leak-check=full --show-reachable=yes
==1917== 
==1917== For counts of detected and suppressed errors, rerun with: -v
==1917== Use --track-origins=yes to see where uninitialised values come from
==1917== ERROR SUMMARY: 2688588 errors from 9 contexts (suppressed: 4 from 4)
==1919== LEAK SUMMARY:
==1919==    definitely lost: 0 bytes in 0 blocks
==1919==    indirectly lost: 0 bytes in 0 blocks
==1919==      possibly lost: 0 bytes in 0 blocks
==1919==    still reachable: 64 bytes in 1 blocks
==1919==         suppressed: 0 bytes in 0 blocks
==1919== Reachable blocks (those to which a pointer was found) are not shown.
==1919== To see them, rerun with: --leak-check=full --show-reachable=yes
==1919== 
==1919== For counts of detected and suppressed errors, rerun with: -v
==1919== Use --track-origins=yes to see where uninitialised values come from
==1919== ERROR SUMMARY: 3003787 errors from 8 contexts (suppressed: 4 from 4)
==1918== Invalid free() / delete / delete[]
==1918==    at 0x4A05D21: free (vg_replace_malloc.c:325)
==1918==    by 0x33C0B0C24A: ??? (in /lib64/libc-2.5.so)
==1918==    by 0x33C0B0BE41: ??? (in /lib64/libc-2.5.so)
==1918==    by 0x48024E8: _vgnU_freeres (vg_preloaded.c:62)
==1918==    by 0x33C0A33224: exit (in /lib64/libc-2.5.so)
==1918==    by 0x33C0A1D9FA: (below main) (in /lib64/libc-2.5.so)
==1918==  Address 0x5bbd6c8 is not stack'd, malloc'd or (recently) free'd
==1918== 
==1918== 
==1918== HEAP SUMMARY:
==1918==     in use at exit: 64 bytes in 1 blocks
==1918==   total heap usage: 2,646,793 allocs, 2,646,794 frees, 221,255,161 bytes allocated
==1918== 
==1918== LEAK SUMMARY:
==1918==    definitely lost: 0 bytes in 0 blocks
==1918==    indirectly lost: 0 bytes in 0 blocks
==1918==      possibly lost: 0 bytes in 0 blocks
==1918==    still reachable: 64 bytes in 1 blocks
==1918==         suppressed: 0 bytes in 0 blocks
==1918== Reachable blocks (those to which a pointer was found) are not shown.
==1918== To see them, rerun with: --leak-check=full --show-reachable=yes
==1918== 
==1918== For counts of detected and suppressed errors, rerun with: -v
==1918== Use --track-origins=yes to see where uninitialised values come from
==1918== ERROR SUMMARY: 2875036 errors from 7 contexts (suppressed: 4 from 4)
