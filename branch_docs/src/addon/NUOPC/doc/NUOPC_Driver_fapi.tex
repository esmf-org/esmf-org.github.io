%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: NUOPC\_Driver.F90,  Date: Tue May  5 21:00:28 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [NUOPC\_DriverAddComp] {NUOPC\_DriverAddComp - Add a GridComp child to a Driver}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverAddComp()
   recursive subroutine NUOPC_DriverAddGridComp(driver, compLabel, &
     compSetServicesRoutine, compSetVMRoutine, petList, info, comp, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: compLabel
     interface
       recursive subroutine compSetServicesRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     interface
       recursive subroutine compSetVMRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     optional                                   :: compSetVMRoutine
     integer,             intent(in),  optional :: petList(:)
     type(ESMF_Info),     intent(in),  optional :: info
     type(ESMF_GridComp), intent(out), optional :: comp
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Create and add a GridComp (i.e. Model, Mediator, or Driver) as a child 
   component to a Driver. The component is created on the provided {\tt petList},
   or by default across all of the Driver PETs.
  
   The specified {\tt compSetServicesRoutine()} is called back immediately after
   the new child component has been created internally. Very little around the
   component is set up at that time (e.g. component attributes are not 
   available). The routine should therefore be very light weight, with the sole
   purpose of setting the entry points of the component -- typically by deriving 
   from a generic component followed by the appropriate specilizations.
  
   If provided, the {\tt compSetVMRoutine()} is called back before the 
   {\tt compSetServicesRoutine()}. This allows the child component to set
   aspects of its own VM, such as threading or the PE distribution among PETs.
  
   The {\tt compLabel} must uniquely identify the child component within the
   context of the Driver component.
  
   If the {\tt comp} argument is specified, it will reference the newly created
   component on return. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverAddComp] {NUOPC\_DriverAddComp - Add a GridComp child from shared object to a Driver}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverAddComp()
   recursive subroutine NUOPC_DriverAddGridCompSO(driver, compLabel, &
     sharedObj, petList, comp, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: compLabel
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(in),  optional :: petList(:)
     type(ESMF_GridComp), intent(out), optional :: comp
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create and add a GridComp (i.e. Model, Mediator, or Driver) as a child 
   component to a Driver. The component is created on the provided {\tt petList},
   or by default across all of the Driver PETs. 
  
   The {\tt SetServices()} routine in the {\tt sharedObj} is called back
   immediately after the
   new child component has been created internally. Very little around the
   component is set up at that time (e.g. component attributes are not 
   available). The routine should therefore be very light weight, with the sole
   purpose of setting the entry points of the component -- typically by deriving 
   from a generic component followed by the appropriate specilizations.
  
   The {\tt compLabel} must uniquely identify the child component within the
   context of the Driver component.
  
   If the {\tt comp} argument is specified, it will reference the newly created
   component on return. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverAddComp] {NUOPC\_DriverAddComp - Add a CplComp child to a Driver}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverAddComp()
   recursive subroutine NUOPC_DriverAddCplComp(driver, srcCompLabel, &
     dstCompLabel, compSetServicesRoutine, compSetVMRoutine, petList, info, &
     comp, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: srcCompLabel
     character(len=*),    intent(in)            :: dstCompLabel
     interface
       recursive subroutine compSetServicesRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     interface
       recursive subroutine compSetVMRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     optional                                   :: compSetVMRoutine
     integer, target,     intent(in),  optional :: petList(:)
     type(ESMF_Info),     intent(in),  optional :: info
     type(ESMF_CplComp),  intent(out), optional :: comp
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Create and add a CplComp (i.e. Connector) as a child component to a Driver.
   The component is created on the provided {\tt petList}, or by default across 
   the union of PETs of the components indicated by {\tt srcCompLabel}
   and {\tt dstCompLabel}.
  
   The specified {\tt SetServices()} routine is called back immediately after the
   new child component has been created internally. Very little around the
   component is set up at that time (e.g. component attributes are not 
   available). The routine should therefore be very light weight, with the sole
   purpose of setting the entry points of the component -- typically by deriving 
   from a generic component followed by the appropriate specilizations.
  
   The {\tt compLabel} must uniquely identify the child component within the 
   context of the Driver component.
  
   If the {\tt comp} argument is specified, it will reference the newly created
   component on return. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverAddRunElement] {NUOPC\_DriverAddRunElement - Add RunElement for Model, Mediator, or Driver}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverAddRunElement()
   recursive subroutine NUOPC_DriverAddRunElementMPL(driver, slot, compLabel, &
     phaseLabel, relaxedflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     character(len=*),    intent(in)            :: compLabel
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: phaseLabel
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Add an element associated with a Model, Mediator, or Driver component to the
   run sequence of the Driver. The component must have been added to the Driver,
   and associated with {\tt compLabel} prior to this call.
  
   If {\tt phaseLabel} was not specified, the first entry in the
   {\tt RunPhaseMap} attribute of the referenced component will be used to 
   determine the run phase of the added element.
  
   By default an error is returned if no component is associated with the 
   specified {\tt compLabel}. This error can be suppressed by setting
   {\tt relaxedflag=.true.}, and no entry will be added to the run sequence.
  
   The {\tt slot} number identifies the run sequence time slot in case multiple
   sequences are available. Slots start counting from 1. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverAddRunElement] {NUOPC\_DriverAddRunElement - Add RunElement for Connector}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverAddRunElement()
   recursive subroutine NUOPC_DriverAddRunElementCPL(driver, slot, srcCompLabel,&
     dstCompLabel, phaseLabel, relaxedflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     character(len=*),    intent(in)            :: srcCompLabel
     character(len=*),    intent(in)            :: dstCompLabel
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: phaseLabel
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Add an element associated with a Connector component to the
   run sequence of the Driver. The component must have been added to the Driver,
   and associated with {\tt srcCompLabel} and {\tt dstCompLabel} prior to this
   call.
  
   If {\tt phaseLabel} was not specified, the first entry in the
   {\tt RunPhaseMap} attribute of the referenced component will be used to 
   determine the run phase of the added element.
  
   By default an error is returned if no component is associated with the 
   specified {\tt compLabel}. This error can be suppressed by setting
   {\tt relaxedflag=.true.}, and no entry will be added to the run sequence.
  
   The {\tt slot} number identifies the run sequence time slot in case multiple
   sequences are available. Slots start counting from 1. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverAddRunElement] {NUOPC\_DriverAddRunElement - Add RunElement that links to another slot}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverAddRunElement()
   recursive subroutine NUOPC_DriverAddRunElementL(driver, slot, linkSlot, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     integer,             intent(in)            :: linkSlot
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Add an element to the run sequence of the Driver that links to the time slot
   indicated by {\tt linkSlot}. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverEgestRunSequence] {NUOPC\_DriverEgestRunSequence - Egest the run sequence as FreeFormat}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine NUOPC_DriverEgestRunSequence(driver, freeFormat, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                           :: driver
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Egest the run sequence stored in the driver as a FreeFormat object. It is the
   caller's responsibility to destroy the created freeFormat object. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverGet] {NUOPC\_DriverGet - Get info from a Driver}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverGet()
   recursive subroutine NUOPC_DriverGet(driver, slotCount, parentClock, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     integer,             intent(out), optional :: slotCount
     type(ESMF_Clock),    intent(out), optional :: parentClock
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


     Access Driver information. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverGetComp] {NUOPC\_DriverGetComp - Get a GridComp child from a Driver}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetGridComp(driver, compLabel, comp, petList, &
     importState, exportState, relaxedflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: compLabel
     type(ESMF_GridComp), intent(out), optional :: comp
     integer,             pointer,     optional :: petList(:)
     type(ESMF_State),    intent(out), optional :: importState
     type(ESMF_State),    intent(out), optional :: exportState
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Query the Driver for a GridComp (i.e. Model, Mediator, or Driver) child 
   component that was added under {\tt compLabel}.
  
   If provided, the {\tt petList} argument will be associated with the petList
   that was used to create the referenced component.
  
   By default an error is returned if no component is associated with the 
   specified {\tt compLabel}. This error can be suppressed by setting
   {\tt relaxedflag=.true.}, and unassociated arguments will be returned. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverGetComp] {NUOPC\_DriverGetComp - Get a CplComp child from a Driver}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetCplComp(driver, srcCompLabel, &
     dstCompLabel, comp, petList, relaxedflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: srcCompLabel
     character(len=*),    intent(in)            :: dstCompLabel
     type(ESMF_CplComp),  intent(out), optional :: comp
     integer,             pointer    , optional :: petList(:)
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Query the Driver for a CplComp (i.e. Connector) child 
   component that was added under {\tt compLabel}.
  
   If provided, the {\tt petList} argument will be associated with the petList
   that was used to create the referenced component.
  
   By default an error is returned if no component is associated with the 
   specified {\tt compLabel}. This error can be suppressed by setting
   {\tt relaxedflag=.true.}, and unassociated arguments will be returned. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverGetComp] {NUOPC\_DriverGetComp - Get all the GridComp child components from a Driver}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetAllGridComp(driver, compList, petLists, &
     rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     type(ESMF_GridComp), pointer, optional     :: compList(:)
     type(ESMF_PtrInt1D), pointer, optional     :: petLists(:)
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Get all the GridComp (i.e. Model, Mediator, or Driver) child components from a
   Driver. The incoming {\tt compList} and {\tt petLists} arguments must be 
   unassociated. On return it becomes the responsibility of the caller to 
   deallocate the associated {\tt compList} and {\tt petLists} arguments 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverGetComp] {NUOPC\_DriverGetComp - Get all the CplComp child components from a Driver}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetAllCplComp(driver, compList, petLists, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     type(ESMF_CplComp),  pointer               :: compList(:)
     type(ESMF_PtrInt1D), pointer, optional     :: petLists(:)
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Get all the CplComp (i.e. Connector) child components from a
   Driver. The incoming {\tt compList} and {\tt petLists} arguments must be 
   unassociated. On return it becomes the responsibility of the caller to 
   deallocate the associated {\tt compList} and {\tt petLists} arguments 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverIngestRunSequence] {NUOPC\_DriverIngestRunSequence - Ingest the run sequence from FreeFormat}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine NUOPC_DriverIngestRunSequence(driver, freeFormat, &
     autoAddConnectors, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                           :: driver
     type(NUOPC_FreeFormat), intent(in), target    :: freeFormat
     logical,                intent(in),  optional :: autoAddConnectors
     integer,                intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Ingest the run sequence from a FreeFormat object and replace the 
   run sequence currently held by the driver. Every line in 
   {\tt freeFormat} corresponds to either a component run sequence element, or 
   is part of a time loop defintion.
  
   Component run sequence elements define the run method of a single component.
   The lines are interpreted sequentially, however, components will execute 
   concurrently as long as this is not prevented by data-dependencies or
   overlapping petLists.
  
   Each line specifies the precise run method phase for a single component 
   instance. For model, mediator, and driver components the format is this:
  
   \begin{verbatim}
     compLabel [phaseLabel]
   \end{verbatim}
   Here {\tt compLabel} is the label by which the component instance is known to
   the driver. It is optionally followed a {\tt phaseLabel} identifying a
   specific run phase. An example of calling the run phase of the ATM instance 
   that contains the "fast" processes, and is labeled {\tt fast}:
  
   \begin{verbatim}
     ATM fast
   \end{verbatim}
   By default, i.e. without {\tt phaseLabel}, the first
   registered run method of the component is used.
  
   The format for connector components is different. It looks like this:
  
   \begin{verbatim}
     srcCompLabel -> dstCompLabel [connectionOptions]
   \end{verbatim}
   A connector instance is uniquely known by the two components it connects, 
   i.e. by {\tt srcCompLabel} and {\tt dstCompLabel}. The syntax requires that
   the token {\tt ->} be specified between source and destination. Optionally
   {\tt connectionOptions} can be supplied using the format discussed 
   under section \ref{connection_options}. The connection options are set
   as attribute {\tt ConnectionOptions} on the respective connector component.
  
   An example of executing the connector
   instance that transfers fields from the ATM component to the OCN component,
   using redistribution for remapping:
   
   \begin{verbatim}
     ATM -> OCN :remapMethod=redist
   \end{verbatim}
  
   By default {\tt autoAddConnectors} is {\tt .false.}, which means that all 
   components referenced in the {\tt freeFormat} run sequence, including 
   connectors, must already be available as child components of the {\tt driver}
   component. An error will be returned if this is not the case. 
   However, when {\tt autoAddConnectors} is set to {\tt .true.}, connector
   components encountered in the run sequence that are no already present in 
   the {\tt driver} will be added automatically. The default 
   {\tt NUOPC\_Connector} implementation is used for all automatically added
   connector instances.
  
   Lines that contain a time loop definition have the general format:
  
   \begin{verbatim}
     @{timeStep|*}[:runDuration]
       ...
       ...
     @
   \end{verbatim}
   Both {\tt timeStep} and {\tt runDuration} are numbers in units of seconds.
   Time loops can be nested and concatenated.
  
   A wildcard "*" character can be specified in place of an actual {\tt timeStep}
   number. In this case the {\tt timeStep} of the associated run clock object
   is set to be equal to the {\tt timeStep} of the time loop one level up in the
   loop nesting hierarchy.
   If a wildcard time step is used for a single outer time loop in the run
   sequence, then the associated run clock is identical to the driver clock and
   must be set explicitly by the driver code, or its parent component.
  
   The {\tt runDuration} specification is optional. If omitted, the duration of
   the associated run clock is set to the {\tt timeStep} of the time loop one
   level up in the loop nesting hierarchy. This ensures that for a single
   nested time loop, the loop returns to the parent loop level at the appropriate
   time.
  
   A simple example of a single time loop with one hour timestep:
  
   \begin{verbatim}
     @3600
       ...
       ...
     @
   \end{verbatim}
   Each time loop has its own associated clock object. NUOPC manages these clock
   objects, i.e. their creation and destruction, as well as {\tt startTime}, 
   {\tt endTime}, {\tt timeStep} adjustments during the execution. The outer 
   most time loop of the run sequence is a special case. It uses the driver 
   clock itself. If a single outer most loop is defined in the run sequence
   provided by {\tt freeFormat}, this loop becomes the driver loop level 
   directly. Therefore, setting the {\tt timeStep} or {\tt runDuration} for
   the outer most time loop results modifiying the driver clock itself.
   However, for cases with concatenated loops on the upper level of 
   the run sequence in {\tt freeFormat}, a single outer loop is added
   automatically during ingestion, and the driver clock is used for this loop 
   instead.
  
   A more complex run sequence example, that shows component run
   sequence elements outside of time loops, a nested time loop, time step 
   wildcards, explicit duration specifications, and concatenated time loops:
   
   \begin{verbatim}
     @100:800
       ATM -> OCN
       OCN -> ATM
       ATM
       OCN
       @*
         OCN -> EXTOCN
         EXTOCN
       @
     @
     ATM -> EXTATM
     EXTATM
     @100:1000
       ATM -> OCN
       OCN -> ATM
       ATM
       OCN
     @
   \end{verbatim}
   Here the {\tt timeStep} of the first time loop is explicitly chosen at
   $100s$. The {\tt runDuration} is explicitly set to $800s$. The first time
   loop steps the current time forward for $800s$, for each iteration executing
   ATM-OCN coupling, followed by the nested loop that calls the 
   {\tt OCN -> EXTOCN} and {\tt EXTOCN} components. The nested loop uses a 
    wildcard {\tt timeStep} and therefore is
   identical to the parent loop level {\tt timeStep} of $100s$. The nested
   {\tt runDuration} is not specified and therefore also defaults to the parent
   time step of $100s$. In other words, the nested loop is executed exactly once
   for every parent loop iteration.
  
   After $800s$ the first time loop is exited, and followed by explicit calls to
   {\tt ATM -> EXTAMT} and {\tt EXTATM} components. Finally the second time loop
   is entered for another $1000s$ {\tt runDuration}. The {\tt timeStep} is again
   explicitly set to $100s$. The second time loop only implements ATM-OCN
   coupling, and no coupling to EXTOCN is implemented. Finally, after $1800s$
   the sequence returns to the driver level loop. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverNewRunSequence] {NUOPC\_DriverNewRunSequence - Replace the run sequence in a Driver}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine NUOPC_DriverNewRunSequence(driver, slotCount, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slotCount
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Replace the current run sequence of the Driver with a new one that has 
   {\tt slotCount} slots. Each slot uses its own clock for time keeping. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverPrint] {NUOPC\_DriverPrint - Print internal Driver information}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine NUOPC_DriverPrint(driver, orderflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     logical,             intent(in),  optional :: orderflag
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Print internal Driver information. If {\tt orderflag} is provided and set
   to {\tt .true.}, the output is ordered from lowest to highest PET. Setting 
   this flag makes the method collective. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_DriverSetRunSequence] {NUOPC\_DriverSetRunSequence - Set internals of RunSequence slot}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_DriverSetRunSequence()
   recursive subroutine NUOPC_DriverSetRunSequence(driver, slot, clock, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     type(ESMF_Clock),    intent(in)            :: clock
     integer,             intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Set the {\tt clock} in the run sequence under {\tt slot} of the Driver.
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
