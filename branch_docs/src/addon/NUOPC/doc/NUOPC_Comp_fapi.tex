%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: NUOPC\_Comp.F90,  Date: Tue May  5 21:00:28 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [NUOPC\_CompAreServicesSet] {NUOPC\_CompAreServicesSet - Check if SetServices was called}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAreServicesSet() 
   function NUOPC_GridCompAreServicesSet(comp, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: NUOPC_GridCompAreServicesSet\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp), intent(in)            :: comp
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Return {\tt .true.} if SetServices has been called for {\tt comp}. 
     Otherwise return {\tt .false.}. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAreServicesSet] {NUOPC\_CompAreServicesSet - Check if SetServices was called}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAreServicesSet() 
   function NUOPC_CplCompAreServicesSet(comp, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: NUOPC_CplCompAreServicesSet\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(in)            :: comp
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Return {\tt .true.} if SetServices has been called for {\tt comp}.
     Otherwise return {\tt .false.}. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeAdd] {NUOPC\_CompAttributeAdd - Add NUOPC GridComp Attributes}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeAdd() 
   subroutine NUOPC_GridCompAttributeAdd(comp, attrList, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                       :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Add Attributes to the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeAdd] {NUOPC\_CompAttributeAdd - Add NUOPC CplComp Attributes}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeAdd() 
   subroutine NUOPC_CplCompAttributeAdd(comp, attrList, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                        :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Add Attributes to the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeEgest] {NUOPC\_CompAttributeEgest - Egest NUOPC GridComp Attributes in FreeFormat}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeEgest() 
   subroutine NUOPC_GridCompAttributeEge(comp, freeFormat, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp),    intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Egest the Attributes of the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance") as a FreeFormat object.
     It is the caller's responsibility to destroy the created {\tt freeFormat}
     object. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeEgest] {NUOPC\_CompAttributeEgest - Egest NUOPC CplComp Attributes in FreeFormat}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeEgest() 
   subroutine NUOPC_CplCompAttributeEge(comp, freeFormat, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),     intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Egest the Attributes of the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance") as a FreeFormat object.
     It is the caller's responsibility to destroy the created {\tt freeFormat}
     object. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeGet] {NUOPC\_CompAttributeGet - Get a NUOPC GridComp Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGet(comp, name, value, isPresent, isSet, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp), intent(in)            :: comp
     character(*),        intent(in)            :: name
     character(*),        intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Access the Attribute {\tt name} inside of {\tt comp} using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Unless {\tt isPresent} and/or {\tt isSet} are provided, return with error
     if the Attribute is not present or not set. {\tt isSet } will be 
     {\tt .false.} for not present Attributes and not set Attributes. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeGet] {NUOPC\_CompAttributeGet - Get a NUOPC CplComp Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGet(comp, name, value, isPresent, isSet, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),  intent(in)            :: comp
     character(*),        intent(in)            :: name
     character(*),        intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Access the Attribute {\tt name} inside of {\tt comp} using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Unless {\tt isPresent} and/or {\tt isSet} are provided, return with error
     if the Attribute is not present or not set. {\tt isSet } will be 
     {\tt .false.} for not present Attributes and not set Attributes. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeGet] {NUOPC\_CompAttributeGet - Get a NUOPC GridComp Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGetI(comp, name, value, isPresent, isSet, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp), intent(in)            :: comp
     character(*),        intent(in)            :: name
     integer,             intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Access the Attribute {\tt name} inside of {\tt comp} using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Unless {\tt isPresent} and/or {\tt isSet} are provided, return with error
     if the Attribute is not present or not set. {\tt isSet } will be 
     {\tt .false.} for not present Attributes and not set Attributes. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeGet] {NUOPC\_CompAttributeGet - Get a NUOPC CplComp Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGetI(comp, name, value, isPresent, isSet, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),  intent(in)            :: comp
     character(*),        intent(in)            :: name
     integer,             intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Access the Attribute {\tt name} inside of {\tt comp} using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Unless {\tt isPresent} and/or {\tt isSet} are provided, return with error
     if the Attribute is not present or not set. {\tt isSet } will be 
     {\tt .false.} for not present Attributes and not set Attributes. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeGet] {NUOPC\_CompAttributeGet - Get a NUOPC GridComp Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGetSL(comp, name, valueList, isPresent, &
     isSet, itemCount, typekind, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp),       intent(in)            :: comp
     character(*),              intent(in)            :: name
     character(*),              intent(out), optional :: valueList(:)
     logical,                   intent(out), optional :: isPresent
     logical,                   intent(out), optional :: isSet
     integer,                   intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag),  intent(out), optional :: typekind
     integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Access the Attribute {\tt name} inside of {\tt comp} using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Unless {\tt isPresent} and/or {\tt isSet} are provided, return with error
     if the Attribute is not present or not set. {\tt isSet } will be 
     {\tt .false.} for not present Attributes and not set Attributes. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeGet] {NUOPC\_CompAttributeGet - Get a NUOPC CplComp Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGetSL(comp, name, valueList, isPresent, &
     isSet, itemCount, typekind, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),       intent(in)            :: comp
     character(*),             intent(in)            :: name
     character(*),             intent(out), optional :: valueList(:)
     logical,                  intent(out), optional :: isPresent
     logical,                  intent(out), optional :: isSet
     integer,                  intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Access the Attribute {\tt name} inside of {\tt comp} using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Unless {\tt isPresent} and/or {\tt isSet} are provided, return with error
     if the Attribute is not present or not set. {\tt isSet } will be 
     {\tt .false.} for not present Attributes and not set Attributes. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeIngest] {NUOPC\_CompAttributeIngest - Ingest free format NUOPC GridComp Attributes}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeIngest() 
   subroutine NUOPC_GridCompAttributeIng(comp, freeFormat, addFlag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp),    intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(in)            :: freeFormat
     logical,                intent(in),  optional :: addFlag
     integer,                intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Ingest the Attributes from a FreeFormat object onto the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
   
     If {\tt addFlag} is {\tt .false.} (default), an error will be returned if 
     an attribute is to be ingested that was not previously added to the 
     {\tt comp} object. If {\tt addFlag} is {\tt .true.}, all missing attributes
     will be added by this method automatically as needed.
  
     Each line in {\tt freeFormat} is of this format:
  
     \begin{verbatim}
       attributeName = attributeValue
     \end{verbatim}
  
     For example:
     \begin{verbatim}
       Verbosity  = 0
       Profiling  = 0
       Diagnostic = 0
     \end{verbatim}
     could directly be ingested as Attributes for any instance of the four 
     standard NUOPC component kinds. This is because {\tt Verbosity},
     {\tt Profiling}, and {\tt Diagnostic} are pre-defined Attributes of the 
     NUOPC component kinds according to sections \ref{DriverCompMeta}, 
     \ref{ModelCompMeta}, \ref{MediatorCompMeta}, and \ref{ConnectorCompMeta}.
  
     When Attributes are specified in {\tt freeFormat} that are not pre-defined
     for a specific component kind, they can still be ingested by a component
     instance using the {\tt addFlag=.true.} option. For instance:
     \begin{verbatim}
       ModelOutputChoice = 2
     \end{verbatim}
     specifies a user-level Attribute, which is not part of the pre-defined 
     Attributes of any of the standard NUOPC component kinds.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeIngest] {NUOPC\_CompAttributeIngest - Ingest free format NUOPC CplComp Attributes}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeIngest() 
   subroutine NUOPC_CplCompAttributeIng(comp, freeFormat, addFlag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),     intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(in)            :: freeFormat
     logical,                intent(in),  optional :: addFlag
     integer,                intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Ingest the Attributes from a FreeFormat object onto the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
   
     If {\tt addFlag} is {\tt .false.} (default), an error will be returned if 
     an attribute is to be ingested that was not previously added to the 
     {\tt comp} object. If {\tt addFlag} is {\tt .true.}, all missing attributes
     will be added by this method automatically as needed.
  
     Each line in {\tt freeFormat} is of this format:
  
     \begin{verbatim}
       attributeName = attributeValue
     \end{verbatim}
  
     For example:
     \begin{verbatim}
       Verbosity  = 0
       Profiling  = 0
       Diagnostic = 0
     \end{verbatim}
     could directly be ingested as Attributes for any instance of the four 
     standard NUOPC component kinds. This is because {\tt Verbosity},
     {\tt Profiling}, and {\tt Diagnostic} are pre-defined Attributes of the 
     NUOPC component kinds according to sections \ref{DriverCompMeta}, 
     \ref{ModelCompMeta}, \ref{MediatorCompMeta}, and \ref{ConnectorCompMeta}.
  
     When Attributes are specified in {\tt freeFormat} that are not pre-defined
     for a specific component kind, they can still be ingested by a component
     instance using the {\tt addFlag=.true.} option. For instance:
     \begin{verbatim}
       ModelOutputChoice = 2
     \end{verbatim}
     specifies a user-level Attribute, which is not part of the pre-defined 
     Attributes of any of the standard NUOPC component kinds.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeReset] {NUOPC\_CompAttributeReset - Reset NUOPC GridComp Attributes}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeReset() 
   subroutine NUOPC_GridCompAttributeReset(comp, attrList, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                       :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Reset Attributes on the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeReset] {NUOPC\_CompAttributeReset - Reset NUOPC CplComp Attributes}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeReset() 
   subroutine NUOPC_CplCompAttributeReset(comp, attrList, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                        :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Reset Attributes on the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeSet] {NUOPC\_CompAttributeSet - Set a NUOPC GridComp Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetS(comp, name, value, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set the Attribute {\tt name} inside of {\tt comp} on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Return with error if the Attribute is not present or not set. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeSet] {NUOPC\_CompAttributeSet - Set a NUOPC CplComp Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetS(comp, name, value, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set the Attribute {\tt name} inside of {\tt comp} on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Return with error if the Attribute is not present or not set. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeSet] {NUOPC\_CompAttributeSet - Set a NUOPC GridComp Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetI(comp, name, value, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     integer,      intent(in)              :: value
     integer,      intent(out), optional   :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set the Attribute {\tt name} inside of {\tt comp} on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Return with error if the Attribute is not present or not set. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeSet] {NUOPC\_CompAttributeSet - Set a NUOPC CplComp Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetI(comp, name, value, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     integer,      intent(in)              :: value
     integer,      intent(out), optional   :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set the Attribute {\tt name} inside of {\tt comp} on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Return with error if the Attribute is not present or not set. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeSet] {NUOPC\_CompAttributeSet - Set a NUOPC GridComp List Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetSL(comp, name, valueList, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: valueList(:)
     integer,      intent(out), optional   :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set the Attribute {\tt name} inside of {\tt comp} on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Return with error if the Attribute is not present or not set. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompAttributeSet] {NUOPC\_CompAttributeSet - Set a NUOPC CplComp List Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetSL(comp, name, valueList, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: valueList(:)
     integer,      intent(out), optional   :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set the Attribute {\tt name} inside of {\tt comp} on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").
  
     Return with error if the Attribute is not present or not set. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompCheckSetClock] {NUOPC\_CompCheckSetClock - Check Clock compatibility and set stopTime}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompCheckSetClock() 
   subroutine NUOPC_GridCompCheckSetClock(comp, externalClock, forceTimeStep, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp),     intent(inout)         :: comp
     type(ESMF_Clock),        intent(in)            :: externalClock
     logical,                 intent(in),  optional :: forceTimeStep
     integer,                 intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Compare {\tt externalClock} to the internal clock of {\tt comp} to make sure
     they match in their current time. Also ensure that the time step of the 
     external clock is a multiple of the time step of the internal clock. If 
     both conditions are satisfied then set the stop time of the internal clock
     so it is reached in one time step of the external clock. Otherwise leave the
     internal clock unchanged and return with error. The direction of
     the involved clocks is taking into account.
     Setting the {\tt forceTimeStep} argument to {\tt .true.} forces the 
     {\tt timeStep} of the {\tt externalClock} to be used to reset the
     {\tt timeStep} of the internal clock. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompDerive] {NUOPC\_CompDerive - Derive a GridComp from a generic component}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompDerive() 
   recursive subroutine NUOPC_GridCompDerive(comp, genericSetServicesRoutine, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp), intent(in)            :: comp
     interface
       subroutine genericSetServicesRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Derive a GridComp (i.e. Model, Mediator, or Driver) from a generic 
     component by calling into the specified {\tt SetServices()} routine of the
     generic component. This is typically the first call in the
     {\tt SetServices()} routine of the specializing component, and is followed
     by {\tt NUOPC\_CompSpecialize()} calls. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompDerive] {NUOPC\_CompDerive - Derive a CplComp from a generic component}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompDerive() 
   recursive subroutine NUOPC_CplCompDerive(comp, genericSetServicesRoutine, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),  intent(in)            :: comp
     interface
       subroutine genericSetServicesRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Derive a CplComp (i.e. Connector) from a generic
     component by calling into the specified {\tt SetServices()} routine of the
     generic component. This is typically the first call in the
     {\tt SetServices()} routine of the specializing component, and is followed
     by {\tt NUOPC\_CompSpecialize()} calls. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompFilterPhaseMap] {NUOPC\_CompFilterPhaseMap - Filter the Phase Map of a GridComp}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompFilterPhaseMap()
   subroutine NUOPC_GridCompFilterPhaseMap(comp, methodflag, acceptStringList, &
     rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                           :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in)            :: acceptStringList(:)
     integer,                intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Filter all PhaseMap entries in a GridComp (i.e. Model, Mediator, or Driver)
   that do {\em not} match any entry in the {\tt acceptStringList}. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompFilterPhaseMap] {NUOPC\_CompFilterPhaseMap - Filter the Phase Map of a CplComp}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompFilterPhaseMap()
   subroutine NUOPC_CplCompFilterPhaseMap(comp, methodflag, acceptStringList, &
     rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                            :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in)            :: acceptStringList(:)
     integer,                intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Filter all PhaseMap entries in a CplComp (i.e. Connector)
   that do {\em not} match any entry in the {\tt acceptStringList}. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompGet] {NUOPC\_CompGet - Access info from GridComp}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompGet()
   subroutine NUOPC_GridCompGet(comp, name, verbosity, profiling, diagnostic, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                       :: comp
     character(len=*),   intent(out), optional :: name
     integer,            intent(out), optional :: verbosity
     integer,            intent(out), optional :: profiling
     integer,            intent(out), optional :: diagnostic
     integer,            intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Access information from a GridComp. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompGet] {NUOPC\_CompGet - Access info from CplComp}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompGet()
   subroutine NUOPC_CplCompGet(comp, name, verbosity, profiling, diagnostic, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                        :: comp
     character(len=*),   intent(out), optional :: name
     integer,            intent(out), optional :: verbosity
     integer,            intent(out), optional :: profiling
     integer,            intent(out), optional :: diagnostic
     integer,            intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Access information from a CplComp. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompSearchPhaseMap] {NUOPC\_CompSearchPhaseMap - Search the Phase Map of a GridComp}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompSearchPhaseMap()
   subroutine NUOPC_GridCompSearchPhaseMap(comp, methodflag, internalflag, &
     phaseLabel, phaseIndex, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                           :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     logical,                intent(in),  optional :: internalflag
     character(len=*),       intent(in),  optional :: phaseLabel
     integer,                intent(out)           :: phaseIndex
     integer,                intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Search all PhaseMap entries in a GridComp (i.e. Model, Mediator, or Driver)
   to see if {\tt phaseLabel} is found. Return the associated ESMF
   {\tt phaseIndex}, or {\tt -1} if not found. If {\tt phaseLabel} is not
   specified, set {\tt phaseIndex} to the first entry in the PhaseMap, or 
   {\tt -1} if there are no entries. The {\tt internalflag} argument 
   allows to search the internal phase maps of driver components. The default
   is {\tt internalflag=.false.}. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompSearchPhaseMap] {NUOPC\_CompSearchPhaseMap - Search the Phase Map of a CplComp}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompSearchPhaseMap()
   subroutine NUOPC_CplCompSearchPhaseMap(comp, methodflag, phaseLabel, &
     phaseIndex, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                            :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in),  optional :: phaseLabel
     integer,                intent(out)           :: phaseIndex
     integer,                intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Search all PhaseMap entries in a CplComp (i.e. Connector)
   to see if {\tt phaseLabel} is found. Return the associated ESMF
   {\tt phaseIndex}, or {\tt -1} if not found. If {\tt phaseLabel} is not
   specified, set {\tt phaseIndex} to the first entry in the PhaseMap, or 
   {\tt -1} if there are no entries. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompSearchRevPhaseMap] {NUOPC\_CompSearchRevPhaseMap - Reverse Search the Phase Map of a GridComp}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompSearchRevPhaseMap()
   subroutine NUOPC_GridCompSearchRevPhaseMap(comp, methodflag, internalflag, &
     phaseIndex, phaseLabel, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                           :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     logical,                intent(in),  optional :: internalflag
     integer,                intent(in),  optional :: phaseIndex
     character(len=*),       intent(out)           :: phaseLabel
     integer,                intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Search all PhaseMap entries in a GridComp (i.e. Model, Mediator, or Driver)
   to see if the ESMF {\tt phaseIndex} is found. Return the associated
   {\tt phaseLabel}, or an empty string if not found. If {\tt phaseIndex} is not
   specified, set {\tt phaseLabel} to the first entry in the PhaseMap, or 
   an empty string if there are no entries. The {\tt internalflag} argument 
   allows to search the internal phase maps of driver components. The default
   is {\tt internalflag=.false.}. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompSearchRevPhaseMap] {NUOPC\_CompSearchRevPhaseMap - Reverse Search the Phase Map of a CplComp}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompSearchRevPhaseMap()
   subroutine NUOPC_CplCompSearchRevPhaseMap(comp, methodflag, phaseIndex, &
     phaseLabel, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                            :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     integer,                intent(in),  optional :: phaseIndex
     character(len=*),       intent(out)           :: phaseLabel
     integer,                intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Search all PhaseMap entries in a CplComp (i.e. Connector)
   to see if the ESMF {\tt phaseIndex} is found. Return the associated
   {\tt phaseLabel}, or an empty string if not found. If {\tt phaseIndex} is not
   specified, set {\tt phaseLabel} to the first entry in the PhaseMap, or 
   an empty string if there are no entries. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompSetClock] {NUOPC\_CompSetClock - Initialize and set the internal Clock of a GridComp}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompSetClock()
   subroutine NUOPC_GridCompSetClock(comp, externalClock, stabilityTimeStep, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp),     intent(inout)         :: comp
     type(ESMF_Clock),        intent(in)            :: externalClock
     type(ESMF_TimeInterval), intent(in),  optional :: stabilityTimeStep
     integer,                 intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     \label{NUOPC_GridCompSetClock}
  
     Set the component internal clock as a copy of {\tt externalClock}, but
     with a timeStep that is less than or equal to the stabilityTimeStep.
     At the same time ensure that the timeStep of the external clock is
     a multiple of the timeStep of the internal clock. If the stabilityTimeStep
     argument is not provided then the internal clock will simply be set
     as a copy of the external clock. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompSetEntryPoint] {NUOPC\_CompSetEntryPoint - Set entry point for a GridComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompSetEntryPoint()
   subroutine NUOPC_GridCompSetEntryPoint(comp, methodflag, phaseLabelList, &
     userRoutine, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                     :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(gridcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_GridComp)         :: gridcomp     ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Set an entry point for a GridComp (i.e. Model, Mediator, or Driver). Publish
   the new entry point in the correct {\tt PhaseMap} component attribute. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompSetEntryPoint] {NUOPC\_CompSetEntryPoint - Set entry point for a CplComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompSetEntryPoint()
   subroutine NUOPC_CplCompSetEntryPoint(comp, methodflag, phaseLabelList, &
     userRoutine, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                      :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(cplcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Set an entry point for a CplComp (i.e. Connector). Publish
   the new entry point in the correct {\tt PhaseMap} component attribute. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompSetInternalEntryPoint] {NUOPC\_CompSetInternalEntryPoint - Set internal entry point for a GridComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompSetInternalEntryPoint()
   subroutine NUOPC_GridCompSetIntEntryPoint(comp, methodflag, phaseLabelList, &
     userRoutine, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                     :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(gridcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_GridComp)         :: gridcomp     ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Set an {\em internal} entry point for a GridComp (i.e. Driver). Only Drivers 
   currently utilize internal entry points. Internal entry points allow user
   specialization on the driver level during initialization and run sequencing. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompSetServices] {NUOPC\_CompSetServices - Try to find and call SetServices in a shared object}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompSetServices()
   recursive subroutine NUOPC_GridCompSetServices(comp, sharedObj, userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp),     intent(inout)         :: comp
     character(len=*),        intent(in),  optional :: sharedObj
     integer,                 intent(out), optional :: userRc
     integer,                 intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Try to find a routine called "{\tt SetServices}" in the {\tt sharedObj} file
     and execute the routine. An attempt is made to find a routine that
     is close in name to "{\tt SetServices}", allowing for compiler name
     mangling, i.e. upper and lower case, as well as trailing underscores. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompSpecialize] {NUOPC\_CompSpecialize - Specialize a derived GridComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompSpecialize()
   subroutine NUOPC_GridCompSpecialize(comp, specLabel, specPhaseLabel, &
     specRoutine, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                     :: comp
     character(len=*), intent(in)            :: specLabel
     character(len=*), intent(in),  optional :: specPhaseLabel
     interface
       subroutine specRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Specialize a derived GridComp (i.e. Model, Mediator, or Driver). If
   {\tt specPhaseLabel} is specified, the specialization only applies to
   the associated phase. Otherwise the specialization applies to all phases. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CompSpecialize] {NUOPC\_CompSpecialize - Specialize a derived CplComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_CompSpecialize()
   subroutine NUOPC_CplCompSpecialize(comp, specLabel, specPhaseLabel, &
     specRoutine, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                      :: comp
     character(len=*), intent(in)            :: specLabel
     character(len=*), intent(in),  optional :: specPhaseLabel
     interface
       subroutine specRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Specialize a derived CplComp (i.e. Connector). If
   {\tt specPhaseLabel} is specified, the specialization only applies to
   the associated phase. Otherwise the specialization applies to all phases.
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
