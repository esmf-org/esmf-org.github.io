%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: NUOPC\_Base.F90,  Date: Tue May  5 21:00:28 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [NUOPC\_AddNamespace] {NUOPC\_AddNamespace - Add a nested state with Namespace to a State}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine NUOPC_AddNamespace(state, Namespace, nestedStateName, &
     nestedState, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State), intent(inout)         :: state
     character(len=*), intent(in)            :: Namespace
     character(len=*), intent(in),  optional :: nestedStateName
     type(ESMF_State), intent(out), optional :: nestedState
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Add a Namespace to {\tt state}. Namespaces are implemented via nested 
     states. This creates a nested state inside of {\tt state}. The nested state
     is returned as {\tt nestedState}. If provided, {\tt nestedStateName} will 
     be used to name the newly created nested state. The default name of the 
     nested state is equal to {\tt Namespace}.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object to which the Namespace is added.
     \item[Namespace]
       The Namespace string.
     \item[{[nestedStateName]}]
       Name of the nested state. Defaults to {\tt Namespace}.
     \item[{[nestedState]}]
       Optional return of the newly created nested state.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_AddNestedState] {NUOPC\_AddNestedState - Add a nested state to a state with NUOPC attributes}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine NUOPC_AddNestedState(state, Namespace, CplSet, nestedStateName, &
     nestedState, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State), intent(inout)         :: state
     character(len=*), intent(in),  optional :: Namespace
     character(len=*), intent(in),  optional :: CplSet
     character(len=*), intent(in),  optional :: nestedStateName
     type(ESMF_State), intent(out), optional :: nestedState
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Create a nested state inside of {\tt state}. The arguments {\tt Namespace}
     and {tt\ CplSet} are used to set NUOPC attributes on the newly created
     state. The nested state is returned as {\tt nestedState}. If provided,
     {\tt nestedStateName} will be used to name the newly created nested state.
     The default name of the nested state is equal to
     {\tt Namespace}\_{\tt CplSet}, {\tt Namespace}, or {\tt CplSet} if the
     arguments are provided.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object to which the namespace is added.
     \item[{[Namespace]}]
       Optional The Namespace string. Defaults to "\_\_UNSPECIFIED\_\_".
     \item[{[CplSet]}]
       Optional The CplSet string. Defaults to "\_\_UNSPECIFIED\_\_".
     \item[{[nestedStateName]}]
       Name of the nested state. Defaults to {\tt Namespace}\_{\tt CplSet},
       {\tt Namespace}, or {\tt CplSet} if arguments are provided.
     \item[{[nestedState]}]
       Optional return of the newly created nested state.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_Advertise] {NUOPC\_Advertise - Advertise a single Field in a State}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_Advertise() 
   subroutine NUOPC_AdvertiseField(state, StandardName, Units, &
     LongName, ShortName, name, TransferOfferGeomObject, SharePolicyField, &
     SharePolicyGeomObject, vm, field, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State), intent(inout)         :: state
     character(*),     intent(in)            :: StandardName
     character(*),     intent(in),  optional :: Units
     character(*),     intent(in),  optional :: LongName
     character(*),     intent(in),  optional :: ShortName
     character(*),     intent(in),  optional :: name
     character(*),     intent(in),  optional :: TransferOfferGeomObject
     character(*),     intent(in),  optional :: SharePolicyField
     character(*),     intent(in),  optional :: SharePolicyGeomObject
     type(ESMF_VM),    intent(in),  optional :: vm
     type(ESMF_Field), intent(out), optional :: field
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     \label{NUOPC_AdvertiseField}
     Advertise a field in a state. This creates an empty field and adds it to
     {\tt state}. The "StandardName", "Units", "LongName", "ShortName", and 
     "TransferOfferGeomObject" attributes of the field are set according to the
     provided input..
  
     The call checks the provided information against the NUOPC Field Dictionary
     to ensure correctness. Defaults are set according to the NUOPC Field 
     Dictionary.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object through which the field is advertised.
     \item[StandardName]
       The "StandardName" attribute of the advertised field. Must be a 
       StandardName found in the NUOPC Field Dictionary.\newline
       NOTE that if by below default rules, {\tt StandardName} is also used as
       the input for {\tt name}, then it must not contain the slash ("/")
       character.
     \item[{[Units]}]
       The "Units" attribute of the advertised field. Must be convertible to the
       canonical units specified in the NUOPC Field Dictionary for the specified
       StandardName. (Currently this is restricted to be identical to the 
       canonical untis specified in the NUOPC Field Dictionary.)
       If omitted, the default is to use the canonical units associated with
       the StandardName in the NUOPC Field Dictionary.
     \item[{[LongName]}]
       The "LongName" attribute of the advertised field. NUOPC does not restrict
       the value of this attribute.
       If omitted, the default is to use the StandardName.
     \item[{[ShortName]}]
       The "ShortName" attribute of the advertised field. NUOPC does not restrict
       the value of this attribute.
       If omitted, the default is to use the StandardName.\newline
       NOTE that if by below default rules, {\tt ShortName} is also used as
       the input for {\tt name}, then it must not contain the slash ("/")
       character.
     \item[{[name]}]
       The actual name of the advertised field by which it is accessed in the
       state object. The string provided for {\tt name} must not contain the
       slash ("/") character.
       If omitted, the default is to use the value of the ShortName.
     \item[{[TransferOfferGeomObject]}]
       If the state intent of {\tt state} is {\tt ESMF\_STATEINTENT\_EXPORT},
       the "ProducerTransferOffer" attribute of the advertised field is set.
       If the state intent of {\tt state} is {\tt ESMF\_STATEINTENT\_IMPORT},
       the "ConsumerTransferOffer" attribute of the advertised field is set.
       NUOPC controls the vocabulary of this attribute. Valid options are 
       "will provide", "can provide", "cannot provide".
       If omitted, the default is "will provide".
     \item[{[SharePolicyField]}]
       The "SharePolicyField" attribute of the advertised field. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is "not share".
     \item[{[SharePolicyGeomObject]}]
       The "SharePolicyGeomObject" attribute of the advertised field. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is equal to {\tt SharePolicyField}.
     \item[{[vm]}]
       If present, the Field object used during advertising is created on the
       specified {\tt ESMF\_VM} object. The default is to create the Field object
       on the VM of the current component context.
     \item[{[field]}]
       Returns the empty field object that was used to advertise.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_Advertise] {NUOPC\_Advertise - Advertise a list of Fields in a State}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_Advertise() 
   subroutine NUOPC_AdvertiseFields(state, StandardNames, &
     TransferOfferGeomObject, SharePolicyField, SharePolicyGeomObject, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State), intent(inout)         :: state
     character(*),     intent(in)            :: StandardNames(:)
     character(*),     intent(in),  optional :: TransferOfferGeomObject
     character(*),     intent(in),  optional :: SharePolicyField
     character(*),     intent(in),  optional :: SharePolicyGeomObject
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     \label{NUOPC_AdvertiseFields}
     Advertise a list of fields in a state. This creates a list of empty fields
     and adds it to the {\tt state}. The "StandardName", "TransferOfferGeomObject",
     "SharePolicyField", and "SharePolicyGeomObject" attributes of all the 
     fields are set according to the provided input. The "Units", "LongName",
     and "ShortName" attributes for each field are set according to the defaults
     documented under method \ref{NUOPC_AdvertiseField}
  
     The call checks the provided information against the NUOPC Field Dictionary
     to ensure correctness.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object through which the fields are advertised.
     \item[StandardNames]
       A list of "StandardName" attributes of the advertised fields. Must be 
       StandardNames found in the  NUOPC Field Dictionary.
     \item[{[TransferOfferGeomObject]}]
       The "TransferOfferGeomObject" attribute of the advertised fields. This 
       setting applies to all the fields advertised in this call. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "will provide", "can provide", "cannot provide".
       If omitted, the default is "will provide".
     \item[{[SharePolicyField]}]
       The "SharePolicyField" attribute of the advertised fields. This 
       setting applies to all the fields advertised in this call. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is "not share".
     \item[{[SharePolicyGeomObject]}]
       The "SharePolicyGeomObject" attribute of the advertised fields. This 
       setting applies to all the fields advertised in this call. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is equal to {\tt SharePolicyField}.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_AdjustClock] {NUOPC\_AdjustClock - Adjust the timestep in a clock}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine NUOPC_AdjustClock(clock, maxTimestep, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Clock)                               :: clock
     type(ESMF_TimeInterval), intent(in),  optional :: maxTimestep
     integer,                 intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Adjust the {\tt clock} to have a potentially smaller timestep. The timestep
     on the incoming {\tt clock} object is compared to the {\tt maxTimestep}, and
     reset to the smaller of the two.
  
     The arguments are:
     \begin{description}
     \item[clock]
       The clock to be adjusted.
     \item[{[maxTimestep]}]
       Upper bound of the timestep allowed in {\tt clock}. 
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_CheckSetClock] {NUOPC\_CheckSetClock - Check a Clock for compatibility and set its values}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine NUOPC_CheckSetClock(setClock, checkClock, setStartTimeToCurrent, &
     currTime, forceCurrTime, forceTimeStep, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Clock),        intent(inout)         :: setClock
     type(ESMF_Clock),        intent(in)            :: checkClock
     logical,                 intent(in),  optional :: setStartTimeToCurrent
     type(ESMF_Time),         intent(in),  optional :: currTime
     logical,                 intent(in),  optional :: forceCurrTime
     logical,                 intent(in),  optional :: forceTimeStep
     integer,                 intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     By default compare {\tt setClock} to {\tt checkClock} to ensure they match
     in their current time. Further ensure that the timeStep of {\tt checkClock}
     is a multiple of the timeStep of {\tt setClock}. If both conditions are 
     satisfied then the stopTime of the {\tt setClock} is set one 
     {\tt checkClock} timeStep, or {\tt setClock} runDuration, ahead of the
     current time, which ever is shorter. The direction of {\tt checkClock}
     is considered when setting the stopTime.
  
     By default the startTime of the {\tt setClock} is not modified. However, if
     {\tt setStartTimeToCurrent == .true.} the startTime of {\tt setClock} is set
     to the currentTime of {\tt checkClock}.
  
     The arguments are:
     \begin{description}
     \item[setClock]
       The {\tt ESMF\_Clock} object to be checked and set.
     \item[checkClock]
       The reference clock object.
     \item[{[setStartTimeToCurrent]}]
       If {\tt .true.} then also set the startTime in {\tt setClock} according to
       the startTime in {\tt checkClock}. The default is {\tt .false.}.
     \item[{[currTime]}]
       If provided, use {\tt currTime} instead of {\tt checkClock} when checking
       or setting the current time of {\tt setClock}.
     \item[{[forceCurrTime]}]
       If {\tt .true.} then do {\em not} check the current time of the
       {\tt setClock}, but instead force it to align with the {\tt checkClock},
       or {\tt currTime}, if it was provided. The default is {\tt .false.}.
     \item[{[forceTimeStep]}]
       If {\tt .true.} then do {\em not} use the {\tt timeStep} of the 
       {\tt setClock} to check if the next increment on the {\tt checkClock}
       can be reached in an integer number of steps. Instead set the
       {\tt timeStep} of the {\tt setClock} to the {\tt timeStep} of the
       {\tt checkClock}. The default is {\tt .false.}.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_GetAttribute] {NUOPC\_GetAttribute - Get the value of a NUOPC Field Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_GetAttribute()
   subroutine NUOPC_GetAttributeFieldVal(field, name, value, isPresent, isSet, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Field), intent(in)            :: field
     character(*),     intent(in)            :: name
     character(*),     intent(out)           :: value
     logical,          intent(out), optional :: isPresent
     logical,          intent(out), optional :: isSet
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Access the attribute {\tt name} inside of {\tt field} using the
     convention {\tt NUOPC} and purpose {\tt Instance}.
  
     Unless {\tt isPresent} and {\tt isSet} are provided, return with error if 
     the Attribute is not present or not set, respectively.
  
     The arguments are:
     \begin{description}
     \item[field]
       The {\tt ESMF\_Field} object to be queried.
     \item[name]
       The name of the queried attribute.
     \item[value]
       The value of the queried attribute.
     \item[{[isPresent]}]
       Set to {\tt .true.} if the queried attribute is present, {\tt .false.}
       otherwise.
     \item[{[isSet]}]
       Set to {\tt .true.} if the queried attribute is set, {\tt .false.}
       otherwise.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_GetAttribute] {NUOPC\_GetAttribute - Get the typekind of a NUOPC Field Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_GetAttribute()
   subroutine NUOPC_GetAttributeFieldTK(field, name, isPresent, isSet, &
     itemCount, typekind, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Field),         intent(in)            :: field
     character(*),             intent(in)            :: name
     logical,                  intent(out), optional :: isPresent
     logical,                  intent(out), optional :: isSet
     integer,                  intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Query the {\tt typekind} of the attribute {\tt name} inside of {\tt field}
     using the convention {\tt NUOPC} and purpose {\tt Instance}.
  
     Unless {\tt isPresent} is provided, return with error if the Attribute is
     not present.
  
     The arguments are:
     \begin{description}
     \item[field]
       The {\tt ESMF\_Field} object to be queried.
     \item[name]
       The name of the queried attribute.
     \item[{[isPresent]}]
       Set to {\tt .true.} if the queried attribute is present, {\tt .false.}
       otherwise.
     \item[{[isSet]}]
       Set to {\tt .true.} if the queried attribute is set, {\tt .false.}
       otherwise.
     \item[{[itemCount]}]
       Number of items in the attribute. Return 0 if not present or not set.
     \item[{[typekind]}]
       The typekind of the queried attribute.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_GetAttribute] {NUOPC\_GetAttribute - Get the value of a NUOPC State Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_GetAttribute()
   subroutine NUOPC_GetAttributeState(state, name, value, isPresent, isSet, &
     itemCount, typekind, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State),         intent(in)            :: state
     character(*),             intent(in)            :: name
     character(*),             intent(out), optional :: value
     logical,                  intent(out), optional :: isPresent
     logical,                  intent(out), optional :: isSet
     integer,                  intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Access the attribute {\tt name} inside of {\tt state} using the
     convention {\tt NUOPC} and purpose {\tt Instance}. Returns with error if
     the attribute is not present or not set.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object to be queried.
     \item[name]
       The name of the queried attribute.
     \item[{[value]}]
       The value of the queried attribute.
     \item[{[isPresent]}]
       Set to {\tt .true.} if the queried attribute is present, {\tt .false.}
       otherwise.
     \item[{[isSet]}]
       Set to {\tt .true.} if the queried attribute is set, {\tt .false.}
       otherwise.
     \item[{[itemCount]}]
       Number of items in the attribute. Return 0 if not present or not set.
     \item[{[typekind]}]
       The typekind of the queried attribute.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_GetStateMemberLists] {NUOPC\_GetStateMemberLists - Build lists of information of State members}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine NUOPC_GetStateMemberLists(state, StandardNameList, &
     ConnectedList, NamespaceList, CplSetList, itemNameList, fieldList, &
     stateList, nestedFlag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State),       intent(in)            :: state
     character(ESMF_MAXSTR), pointer, optional     :: StandardNameList(:)
     character(ESMF_MAXSTR), pointer, optional     :: ConnectedList(:)
     character(ESMF_MAXSTR), pointer, optional     :: NamespaceList(:)
     character(ESMF_MAXSTR), pointer, optional     :: CplSetList(:)
     character(ESMF_MAXSTR), pointer, optional     :: itemNameList(:)
     type(ESMF_Field),       pointer, optional     :: fieldList(:)
     type(ESMF_State),       pointer, optional     :: stateList(:)
     logical,                intent(in), optional  :: nestedFlag
     integer,                intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Construct lists containing the StandardNames, field names, and connected 
     status of the fields in {\tt state}. Return this information in the
     list arguments. Recursively parse through nested States.
  
     All pointer arguments present must enter this method unassociated. This
     means that the user code must explicitly call {\tt nullify()} or use the
     {\tt => null()} syntax on the variables passed in as any of the pointer
     arguments. On return, the pointer arguments may either be unassociated or
     associated. Consequently the user code must first check the status of any
     of the returned pointer arguments via the {\tt associated()} intrinsic
     before accessing the argument. The responsibility for deallocation of
     associated pointer arguments transfers to the caller.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object to be queried.
     \item[{[StandardNameList]}]
       If present, return a list of the "StandardName" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     \item[{[ConnectedList]}]
       If present, return a list of the "Connected" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     \item[{[NamespaceList]}]
       If present, return a list of the "Namespace" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     \item[{[CplSetList]}]
       If present, return a list of the "CplSet" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     \item[{[itemNameList]}]
       If present, return a list of each member name.
       See the note about pointer arguments in the description section above for
       correct usage.
     \item[{[fieldList]}]
       If present, return a list of the member fields.
       See the note about pointer arguments in the description section above for
       correct usage.
     \item[{[stateList]}]
       If present, return a list of the states corresonding to the owner of the
       fields returned under {\tt fieldList}.
       See the note about pointer arguments in the description section above for
       correct usage.
     \item[{[nestedFlag]}]
       When set to .true., returns information from nested States (default).
       When set to .false., returns information at the current State level only.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_GetTimestamp] {NUOPC\_GetTimestamp - Get the timestamp of a Field}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine NUOPC_GetTimestamp(field, isValid, time, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Field), intent(in)            :: field
     logical,          intent(out), optional :: isValid
     type(ESMF_Time),  intent(out), optional :: time
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Access the timestamp on {\tt field} in form of an {\tt ESMF\_Time} object.
  
     The arguments are:
     \begin{description}
     \item[field]
       The {\tt ESMF\_Field} object to be checked.
     \item[{[isValid]}]
       Set to {\tt .true.} if the timestamp is valid, {\tt .false.} otherwise.
     \item[{[time]}]
       The timestamp as {\tt ESMF\_Time} object.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_IsAtTime] {NUOPC\_IsAtTime - Check if a Field is at the given Time}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_IsAtTime()
   function NUOPC_IsAtTimeField(field, time, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: NUOPC_IsAtTimeField\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Field), intent(in)            :: field
     type(ESMF_Time),  intent(in)            :: time
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Returns {\tt .true.} if {\tt field} has a timestamp attribute
     that matches {\tt time}. Otherwise returns {\tt .false.}. On PETs 
     with only a proxy instance of the field, {\tt .true.} is returned
     regardless of the actual timestamp attribute.
  
     The arguments are:
     \begin{description}
     \item[field]
       The {\tt ESMF\_Field} object to be checked.
     \item[time]
       The time to compare against.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_IsAtTime] {NUOPC\_IsAtTime - Check if Field(s) in a State are at the given Time}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_IsAtTime()
   function NUOPC_IsAtTimeState(state, time, fieldName, count, fieldList, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: NUOPC_IsAtTimeState\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State),              intent(in)            :: state
     type(ESMF_Time),               intent(in)            :: time
     character(*),                  intent(in),  optional :: fieldName
     integer,                       intent(out), optional :: count
     type(ESMF_Field), allocatable, intent(out), optional :: fieldList(:)
     integer,                       intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Return {\tt .true.} if the field(s) in {\tt state} have a timestamp 
     attribute that matches {\tt time}. Otherwise return {\tt .false.}.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object to be checked.
     \item[time]
       The time to compare against.
     \item[{[fieldName]}]
       The name of the field in {\tt state} to be checked. If provided, and 
       the state does not contain a field with {\tt fieldName}, return an 
       error in {\tt rc}. If not provided, check {\em all} the fields contained
       in {\tt state} and return {\tt .true.} if all the fields are at the 
       correct time.
     \item[{[count]}]
       If provided, the number of fields that are at {\tt time} are returned. If 
       {\tt fieldName} is present then {\tt count} cannot be greater than 1.
     \item[{[fieldList]}]
       If provided, the fields that are {\em not} at {\tt time} are returned. If 
       {\tt fieldName} is present then {\tt fieldList} can contain a maximum of
       1 field.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_IsConnected] {NUOPC\_IsConnected - Check if a Field is connected}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_IsConnected()
   function NUOPC_IsConnectedField(field, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: NUOPC_IsConnectedField\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Return {\tt .true.} if the {\tt field} is connected.
     Otherwise return {\tt .false.}.
  
     The arguments are:
     \begin{description}
     \item[field]
       The {\tt ESMF\_Field} object to be checked.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_IsConnected] {NUOPC\_IsConnected - Check if Field(s) in a State are connected}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_IsConnected()
   function NUOPC_IsConnectedState(state, fieldName, count, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: NUOPC_IsConnectedState\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State), intent(in)            :: state
     character(*),     intent(in),  optional :: fieldName
     integer,          intent(out), optional :: count
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Return {\tt .true.} if the field(s) in {\tt state} are connected. Otherwise
     return {\tt .false.}.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object to be checked.
     \item[{[fieldName]}]
       The name of the field in {\tt state} to be checked. If provided, and 
       the state does not contain a field with {\tt fieldName}, return an 
       error in {\tt rc}. If not provided, check {\em all} the fields contained
       in {\tt state} and return {\tt .true.} if all the fields are connected.
     \item[{[count]}]
       If provided, the number of fields that are connected are returned. If 
       {\tt fieldName} is present then {\tt count} cannot be greater than 1.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_IsUpdated] {NUOPC\_IsUpdated - Check if a Field is marked as updated}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_IsUpdated()
   function NUOPC_IsUpdatedField(field, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: NUOPC_IsUpdatedField\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Return {\tt .true.} if the field has its "Updated"
     attribute set to "true". Otherwise return {\tt .false.}. 
  
     The arguments are:
     \begin{description}
     \item[field]
       The {\tt ESMF\_Field} object to be checked.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_IsUpdated] {NUOPC\_IsUpdated - Check if Field(s) in a State are marked as updated}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_IsUpdated()
   function NUOPC_IsUpdatedState(state, fieldName, count, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: NUOPC_IsUpdatedState\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State), intent(in)            :: state
     character(*),     intent(in),  optional :: fieldName
     integer,          intent(out), optional :: count
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Return {\tt .true.} if the field(s) in {\tt state} have the "Updated"
     attribute set to "true". Otherwise return {\tt .false.}. 
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object to be checked.
     \item[{[fieldName]}]
       The name of the field in {\tt state} to be checked. If provided, and 
       the state does not contain a field with {\tt fieldName}, return an 
       error in {\tt rc}. If not provided, check {\em all} the fields contained
       in {\tt state} and return {\tt .true.} if all the fields are updated.
     \item[{[count]}]
       If provided, the number of fields that are updated are returned. If 
       {\tt fieldName} is present then {\tt count} cannot be greater than 1.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_NoOp] {NUOPC\_NoOp - No-Operation attachable method for GridComp}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine NUOPC_NoOp(gcomp, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)   :: gcomp
     integer, intent(out)  :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     No-Op method with an interface that matches the
     requirements for a attachable method for ESMF\_GridComp objects.
  
     The arguments are:
     \begin{description}
     \item[gcomp]
       The {\tt ESMF\_GridComp} object to which this method is attached.
     \item[rc]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_Realize] {NUOPC\_Realize - Realize previously advertised Fields inside a State on a single Grid with internal allocation}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeCompleteG(state, grid, fieldName, typekind, &
     staggerloc, selection, dataFillScheme, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State)                                :: state
     type(ESMF_Grid),          intent(in)            :: grid
     character(*),             intent(in),  optional :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     type(ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
     character(len=*),         intent(in),  optional :: selection
     character(len=*),         intent(in),  optional :: dataFillScheme    
     integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     \label{NUOPC_RealizeCompleteG}
  
     Realize or remove fields inside of {\tt state} according to {\tt selection}.
     All of the fields that are realized are created internally on the same 
     {\tt grid} object, allocating memory for as many field dimensions as there 
     are grid dimensions.
  
     The type and kind of the created fields is according to argument 
     {\tt typekind}.
  
     Realized fields are filled with data according to the {\tt dataFillScheme}
     argument.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object in which the fields are realized.
     \item[grid]
       The {\tt ESMF\_Grid} object on which to realize the fields.
     \item[{[fieldName]}]
       The name of the field in {\tt state} to be realized, or removed, according
       to {\tt selection}. If provided, and the state does not contain a field
       with name {\tt fieldName}, return an error in {\tt rc}. If not provided,
       realize {\em all} the fields contained in {\tt state} according to 
       {\tt selection}.
     \item[{[typekind]}]
       The typekind of the internally created field(s). The valid options are
       {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
       {\tt ESMF\_TYPEKIND\_R4}, and {\tt ESMF\_TYPEKIND\_R8}.
       By default use the {\tt typekind} of the partially created field used
       during advertise, or {\tt ESMF\_TYPEKIND\_R8}, if the advertised field 
       did not have a {\tt typekind} defined.
     \item[{[staggerloc]}]
       Stagger location of data in grid cells. By default use the same
       stagger location as the advertising field, or 
       {\tt ESMF\_STAGGERLOC\_CENTER} if the advertising field was created empty.
     \item[{[selection]}]
       Selection of mode of operation:
       \begin{itemize}
       \item {\tt "realize\_all"} (default)
       \item {\tt "realize\_connected\_remove\_others"}
       \item {\tt "realize\_connected+provide\_remove\_others"}
       \end{itemize}
     \item[{[dataFillScheme]}]
       Realized fields will be filled according to the selected fill
       scheme. See \ref{NUOPC_FillField} for fill schemes. Default is to leave
       the data in realized fields uninitialized.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_Realize] {NUOPC\_Realize - Realize previously advertised Fields inside a State on a single LocStream with internal allocation}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeCompleteLS(state, locstream, fieldName, typekind, selection,&
     dataFillScheme, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State)                                :: state
     type(ESMF_LocStream),     intent(in)            :: locstream
     character(*),             intent(in),  optional :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     character(len=*),         intent(in),  optional :: selection
     character(len=*),         intent(in),  optional :: dataFillScheme    
     integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     \label{NUOPC_RealizeCompleteLS}
  
     Realize or remove fields inside of {\tt state} according to {\tt selection}.
     All of the fields that are realized are created internally on the same 
     {\tt locstream} object, allocating memory accordingly.
  
     The type and kind of the created fields is according to argument 
     {\tt typekind}.
  
     Realized fields are filled with data according to the {\tt dataFillScheme}
     argument.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object in which the fields are realized.
     \item[locstream]
       The {\tt ESMF\_LocStream} object on which to realize the fields.
     \item[{[fieldName]}]
       The name of the field in {\tt state} to be realized, or removed, according
       to {\tt selection}. If provided, and the state does not contain a field
       with name {\tt fieldName}, return an error in {\tt rc}. If not provided,
       realize {\em all} the fields contained in {\tt state} according to 
       {\tt selection}.
     \item[{[typekind]}]
       The typekind of the internally created field(s). The valid options are
       {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
       {\tt ESMF\_TYPEKIND\_R4}, and {\tt ESMF\_TYPEKIND\_R8}.
       By default use the {\tt typekind} of the partially created field used
       during advertise, or {\tt ESMF\_TYPEKIND\_R8}, if the advertised field 
       did not have a {\tt typekind} defined.
     \item[{[selection]}]
       Selection of mode of operation:
       \begin{itemize}
       \item {\tt "realize\_all"} (default)
       \item {\tt "realize\_connected\_remove\_others"}
       \end{itemize}
     \item[{[dataFillScheme]}]
       Realized fields will be filled according to the selected fill
       scheme. See \ref{NUOPC_FillField} for fill schemes. Default is to leave
       the data in realized fields uninitialized.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_Realize] {NUOPC\_Realize - Realize previously advertised Fields inside a State on a single Mesh with internal allocation}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeCompleteM(state, mesh, fieldName, typekind, &
     meshloc, selection, dataFillScheme, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State)                                :: state
     type(ESMF_Mesh),          intent(in)            :: mesh
     character(*),             intent(in),  optional :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     type(ESMF_MeshLoc),       intent(in),  optional :: meshloc
     character(len=*),         intent(in),  optional :: selection
     character(len=*),         intent(in),  optional :: dataFillScheme    
     integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     \label{NUOPC_RealizeCompleteM}
  
     Realize or remove fields inside of {\tt state} according to {\tt selection}.
     All of the fields that are realized are created internally on the same 
     {\tt mesh} object, allocating memory accordingly.
  
     The type and kind of the created fields is according to argument 
     {\tt typekind}.
  
     Realized fields are filled with data according to the {\tt dataFillScheme}
     argument.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object in which the fields are realized.
     \item[mesh]
       The {\tt ESMF\_Mesh} object on which to realize the fields.
     \item[{[fieldName]}]
       The name of the field in {\tt state} to be realized, or removed, according
       to {\tt selection}. If provided, and the state does not contain a field
       with name {\tt fieldName}, return an error in {\tt rc}. If not provided,
       realize {\em all} the fields contained in {\tt state} according to 
       {\tt selection}.
     \item[{[typekind]}]
       The typekind of the internally created field(s). The valid options are
       {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
       {\tt ESMF\_TYPEKIND\_R4}, and {\tt ESMF\_TYPEKIND\_R8}.
       By default use the {\tt typekind} of the partially created field used
       during advertise, or {\tt ESMF\_TYPEKIND\_R8}, if the advertised field 
       did not have a {\tt typekind} defined.
     \item[{[meshloc]}]
       Location of data in the mesh cell. By default use the same
       mesh location as the advertising field, or 
       {\tt ESMF\_STAGGERLOC\_NODE} if the advertising field was created empty.
     \item[{[selection]}]
       Selection of mode of operation:
       \begin{itemize}
       \item {\tt "realize\_all"} (default)
       \item {\tt "realize\_connected\_remove\_others"}
       \end{itemize}
     \item[{[dataFillScheme]}]
       Realized fields will be filled according to the selected fill
       scheme. See \ref{NUOPC_FillField} for fill schemes. Default is to leave
       the data in realized fields uninitialized.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_Realize] {NUOPC\_Realize - Realize a previously advertised Field in a State}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeField(state, field, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     \label{NUOPC_RealizeField}
  
     Realize a previously advertised field in {\tt state} by replacing the
     advertised field with {\tt field} of the same name.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object in which the fields are realized.
     \item[field]
       The new field to put in place of the previously advertised (empty) field.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_Realize] {NUOPC\_Realize - Realize a previously advertised Field in a State after Transfer of GeomObject}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeTransfer(state, fieldName, typekind, gridToFieldMap, &
     ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, &
     realizeOnlyConnected, removeNotConnected, realizeOnlyNotShared, &
     realizeOnlyNotComplete, field, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State)                                :: state
     character(*),             intent(in)            :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     integer, target,          intent(in),  optional :: gridToFieldMap(:)
     integer, target,          intent(in),  optional :: ungriddedLBound(:)
     integer, target,          intent(in),  optional :: ungriddedUBound(:)
     integer,                  intent(in),  optional :: totalLWidth(:)
     integer,                  intent(in),  optional :: totalUWidth(:)
     logical,                  intent(in),  optional :: realizeOnlyConnected
     logical,                  intent(in),  optional :: removeNotConnected
     logical,                  intent(in),  optional :: realizeOnlyNotShared
     logical,                  intent(in),  optional :: realizeOnlyNotComplete
     type(ESMF_Field),         intent(out), optional :: field
     integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     \label{NUOPC_RealizeTransfer}
  
     Realize a field where GeomObject has been set by the NUOPC GeomObject
     transfer protocol.
  
     The data of the realized field is left uninitialized by this method.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object in which the field is realized.
     \item[fieldName]
       The name of the field in {\tt state} to be realized. If {\tt state} does
       not contain a field with name {\tt fieldName}, return an error in 
       {\tt rc}.
     \item[{[typekind]}]
       The typekind of the internally created field(s). The valid options are
       {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
       {\tt ESMF\_TYPEKIND\_R4}, and {\tt ESMF\_TYPEKIND\_R8}.
       By default use the {\tt typekind} of the connected provider field.
     \item[{[gridToFieldMap]}]
       The mapping of grid/mesh dimensions against field dimensions. The argument
       is of rank 1 and with a size of dimCount. The elements correspond to the
       grid/mesh elements in order, and associates it with the indicated 
       field dimension. Only entries between 1 and the field rank are allowed.
       There must be no duplicate entries in {\tt gridToFieldMap}.
       By default use the {\tt gridToFieldMap} of the connected provider field.
     \item[{[ungriddedLBound]}]
       Lower bounds of the ungridded dimensions of the field. The number of
       elements defines the number of ungridded dimensions of the field and 
       must be consistent with {\tt ungriddedUBound}.
       By default use the {\tt ungriddedLBound} of the connected provider field.
     \item[{[ungriddedUBound]}]
       Upper bounds of the ungridded dimensions of the field. The number of
       elements defines the number of ungridded dimensions of the field and 
       must be consistent with {\tt ungriddedLBound}.
       By default use the {\tt ungriddedLBound} of the connected provider field.
     \item[{[totalLWidth]}]
       {\em This argument is only supported for fields defined on
       {\tt ESMF\_Grid}.}
       The number elements outside the lower bound of the exclusive region.
       The argument is of rank 1 and with a size of dimCount, the number of
       gridded dimensions of the field. The ordering of the dimensions is that
       of the field (considering {\tt gridToFieldMap}).
       By default a zero vector is used, resulting in no elements outside the
       exclusive region.
     \item[{[totalUWidth]}]
       {\em This argument is only supported for fields defined on
       {\tt ESMF\_Grid}.}
       The number elements outside the upper bound of the exclusive region.
       The argument is of rank 1 and with a size of dimCount, the number of
       gridded dimensions of the field. The ordering of the dimensions is that
       of the field (considering {\tt gridToFieldMap}).
       By default a zero vector is used, resulting in no elements outside the
       exclusive region.
     \item[{[realizeOnlyConnected]}]
       If set to {\tt .false.}, realize the specified field irregardless of the
       connected status. If set to {\tt .true.}, only a connected field will be
       realized. The default is {\tt .true.}.
     \item[{[removeNotConnected]}]
       If set to {\tt .false.}, do not remove a field from the state due to its
       connected status. If set to {\tt .true.}, remove the field if it is not
       connected. This requires {\tt realizeOnlyConnected} to be {\tt .true.},
       and a runtime error will be returned otherwise.
       The default is {\tt .true.}.
     \item[{[realizeOnlyNotShared]}]
       If set to {\tt .false.}, realize the specified field irregardless of its
       shared status. If set to {\tt .true.}, only a field that has 
       "ShareStatusField" set to "not shared" will be realized.
       The default is {\tt .true.}.
     \item[{[realizeOnlyNotComplete]}]
       If set to {\tt .false.}, realize the specified field irregardless of its
       complete status. If set to {\tt .true.}, only a field that has not yet
       been completed will be realized.
       The default is {\tt .true.}.
     \item[{[field]}]
       Returns the completed field that was realized by this method. An invalid
       field object will be returned if the conditions were such that the field
       was  not realized.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_SetAttribute] {NUOPC\_SetAttribute - Set the value of a NUOPC Field Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_SetAttribute()
   subroutine NUOPC_SetAttributeField(field, name, value, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Field)                      :: field
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set the attribute {\tt name} inside of {\tt field} using the
     convention {\tt NUOPC} and purpose {\tt Instance}.
  
     The arguments are:
     \begin{description}
     \item[field]
       The {\tt ESMF\_Field} object on which to set the attribute.
     \item[name]
       The name of the set attribute.
     \item[value]
       The value of the set attribute.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_SetAttribute] {NUOPC\_SetAttribute - Set the value of a NUOPC State Attribute}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_SetAttribute()
   subroutine NUOPC_SetAttributeState(state, name, value, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State)                      :: state
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set the attribute {\tt name} inside of {\tt state} using the
     convention {\tt NUOPC} and purpose {\tt Instance}.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object on which to set the attribute.
     \item[name]
       The name of the set attribute.
     \item[value]
       The value of the set attribute.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_SetTimestamp] {NUOPC\_SetTimestamp - Set the TimeStamp on a Field}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampField(field, time, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Field), intent(inout)         :: field
     type(ESMF_Time),  intent(in)            :: time
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set the "TimeStamp" attribute according to {\tt time} on {\tt field}.
  
     This call should rarely be needed in user written code.
  
     The arguments are:
     \begin{description}
     \item[field]
       The {\tt ESMF\_Field} object to be updated.
     \item[time]
       The {\tt ESMF\_Time} object defining the TimeStamp.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_SetTimestamp] {NUOPC\_SetTimestamp - Set the TimeStamp on all the Fields in a State}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampState(state, time, selective, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Time),  intent(in)            :: time
     logical,          intent(in),  optional :: selective
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set the "TimeStamp" attribute according to {\tt clock} on all the fields in
     {\tt state}. Depending on {\tt selective}, all or only some fields may be
     updated.
  
     This call should rarely be needed in user written code. It is used 
     by the generic Connector.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object holding the fields.
     \item[time]
       The {\tt ESMF\_Time} object defining the TimeStamp.
     \item[{[selective]}]
       If {\tt .true.}, then only set the "TimeStamp" attributes on those fields
       for which the "Updated" attribute is equal to "true". Otherwise set the
       "TimeStamp" attribute on all the fields. Default is {\tt .false.}.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [NUOPC\_SetTimestamp] {NUOPC\_SetTimestamp - Set the TimeStamp on all the Fields in a State from Clock}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampStateClk(state, clock, selective, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Clock), intent(in)            :: clock
     logical,          intent(in),  optional :: selective
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set the "TimeStamp" attribute according to {\tt clock} on all the fields in
     {\tt state}. Depending on {\tt selective}, all or only some fields may be
     updated.
  
     This call should rarely be needed in user written code. It is used 
     by the generic Connector.
  
     The arguments are:
     \begin{description}
     \item[state]
       The {\tt ESMF\_State} object holding the fields.
     \item[clock]
       The {\tt ESMF\_Clock} object defining the TimeStamp by its current time.
     \item[{[selective]}]
       If {\tt .true.}, then only set the "TimeStamp" attributes on those fields
       for which the "Updated" attribute is equal to "true". Otherwise set the
       "TimeStamp" attribute on all the fields. Default is {\tt .false.}.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
