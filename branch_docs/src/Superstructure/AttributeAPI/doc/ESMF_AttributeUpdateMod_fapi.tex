%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_AttributeUpdateMod.F90,  Date: Tue May  5 21:00:14 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

   In the first gridded Component initialize routine we need to create some
   Attribute packages and set all of the Attributes.  These Attributes will
   be attached to realistic Fields, containing a Grid, which are contained in a
   FieldBundle.  The first thing to do is declare variables and make the Grid. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
        type(ESMF_AttPack)       :: attpack
    type(ESMF_VM)            :: vm
    integer                  :: petCount, status, myPet
    character(ESMF_MAXSTR)   :: name1,name2,name3,name4,value1,value2, &
                                value3,value4,convESMF,purpGen,convCC
    type(ESMF_ArraySpec)     :: arrayspec
    type(ESMF_Grid)          :: grid
    type(ESMF_Field)         :: DPEDT,DTDT,DUDT,DVDT,PHIS,QTR,CNV,CONVCPT, &
                                CONVKE,CONVPHI
    type(ESMF_FieldBundle)   :: fieldbundle
    character(ESMF_MAXSTR),dimension(2)   :: attrList

    rc = ESMF_SUCCESS

    call ESMF_GridCompGet(comp, vm=vm, rc=status)
    call ESMF_VMGet(vm, petCount=petCount, localPet=myPet, rc=status)

    call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, &
           rc=rc)
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/100,150/), &
      regDecomp=(/1,petCount/), &
      gridEdgeLWidth=(/0,0/), gridEdgeUWidth=(/0,0/), &
      indexflag=ESMF_INDEX_GLOBAL, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   At this point the Fields will need to have Attribute packages attached to them, and the
   Attributes will be set with appropriate values. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    convCC = 'CustomConvention'
    convESMF = 'ESMF'
    purpGen = 'General'
    name1 = 'ShortName'
    name2 = 'StandardName'
    name3 = 'LongName'
    name4 = 'Units'

    value1 = 'DPEDT'
    value2 = 'tendency_of_air_pressure'
    value3 = 'Edge pressure tendency'
    value4 = 'Pa s-1'

    DPEDT = ESMF_FieldCreate(grid, arrayspec=arrayspec, &
              staggerloc=ESMF_STAGGERLOC_CENTER, rc=status)
    call ESMF_AttributeAdd(DPEDT, convention=convESMF, purpose=purpGen, &
      attpack=attpack, rc=status)
    call ESMF_AttributeSet(DPEDT, name=name1, value=value1, &
      attpack=attpack, rc=status)
    call ESMF_AttributeSet(DPEDT, name=name2, value=value2, &
      attpack=attpack, rc=status)
    call ESMF_AttributeSet(DPEDT, name=name3, value=value3, &
      attpack=attpack, rc=status)
    call ESMF_AttributeSet(DPEDT, name=name4, value=value4, &
      attpack=attpack, rc=status)

 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

       ... and so on for the other 9 Fields.
  
   Now the Fields will be added to the FieldBundle, at which point the Attribute
   hierarchies of the Fields will also be attached to the Attribute hierarchy of
   the FieldBundle.  After that, the FieldBundle will be attached to the export
   State, again at which time the Attribute hierarchy of the FieldBundle will be
   attached to the Attribute hierarchy of the export State. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    fieldbundle = ESMF_FieldBundleCreate(name="fieldbundle", rc=status)
    call ESMF_FieldBundleSet(fieldbundle, grid=grid, rc=status)

    call ESMF_FieldBundleAdd(fieldbundle, (/DPEDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/DTDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/DUDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/DVDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/PHIS/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/QTR/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CNV/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CONVCPT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CONVKE/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CONVPHI/), rc=status)

    call ESMF_StateAdd(exportState, fieldbundleList=(/fieldbundle/), rc=status)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   At this point, the driver of the model run will transfer control to the
   initialize phase of the second gridded Component. 
%/////////////////////////////////////////////////////////////

   In the second gridded Component initialize routine we don't have
   anything to do.  The data that was created in the initialize routine
   of the first gridded Component will be passed to this Component through
   the coupler Component.  The data will not be used in this Component
   until the run phase of the model.  So now the application driver transfers
   control to the initialize phase of the coupler Component. 
%/////////////////////////////////////////////////////////////

   In the coupler Component initialize routine all that is required
   is to ensure consistent data across the VM.  The data created
   in the first gridded Component on one set of the PETs in the VM is
   intended to be read and manipulated by the second gridded Component
   which runs on an exclusive set of the PETs of the VM for this
   application.  We need to first make that data consistent across the
   entire VM with the {\tt ESMF\_StateReconcile()} call.
   This State level call handles both the data -- Fields and FieldBundles,
   and the metadata -- Attribute and Attribute packages.  There is a flag in
   this call to allow the user to specify whether they want
   the metadata to be reconciled or not. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    type(ESMF_VM)         :: vm

    rc = ESMF_SUCCESS

    call ESMF_CplCompGet(comp, vm=vm, rc=rc)
    call ESMF_StateReconcile(importState, vm=vm, &
               attreconflag=ESMF_ATTRECONCILE_ON, rc=rc)
    call ESMF_StateReconcile(exportState, vm=vm, &
               attreconflag=ESMF_ATTRECONCILE_ON, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   At this point, the driver of the model run will transfer control to the
   run phase of the first gridded Component. 
%/////////////////////////////////////////////////////////////

   In the run phase of the first gridded Component is typically where the
   data contained in the Fields is manipulated.  For this simple example
   we will do no actual data manipulation because all we are interested in
   at this point is the metadata.  What we will do is add a nested Attribute
   package inside the currently existing Attribute package on each Field.  We
   will also change the value of one of the Attributes in the original Attribute
   package, and remove another of the Attributes from the original Attribute
   package on each of the Fields.  The first thing is to declare variables and
   get the Component, VM, State, and FieldBundle. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
        type(ESMF_AttPack)          :: attpack, attpackGen
    type(ESMF_VM)               :: vm
    integer                     :: petCount, status, myPet, k
    character(ESMF_MAXSTR)      :: name2,value2,convESMF,purpGen,purp2,name3
    character(ESMF_MAXSTR),dimension(2) :: attrList
    type(ESMF_Field)            :: field(10)
    type(ESMF_FieldBundle)      :: fieldbundle
    type(ESMF_Grid)             :: grid

    rc = ESMF_SUCCESS

    convESMF = 'ESMF'
    purpGen = 'General'
    name2 = 'StandardName'
    value2 = 'default_standard_name'
    name3 = 'LongName'

    purp2 = 'Extended'
    attrList(1) = 'Coordinates'
    attrList(2) = 'Mask'

    call ESMF_GridCompGet(comp, vm=vm, rc=status)
    call ESMF_VMGet(vm, petCount=petCount, localPet=myPet, rc=status)

    call ESMF_StateGet(exportState, "fieldbundle", fieldbundle, rc=rc)
    if (rc .ne. ESMF_SUCCESS) return
    call ESMF_FieldBundleGet(fieldbundle, grid=grid, rc=rc)
    if (rc .ne. ESMF_SUCCESS) return
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   At this point we will extract each of the Fields in the FieldBundle in turn
   and change the value of one Attribute in the original Attribute package,
   add a nested Attribute package, and delete one other of the Attributes in the
   original Attribute package.  These three changes represent, respectively, a
   value change and two structural changes to the Attribute hierarchy during
   run time, which must be reconciled across the VM before the second gridded
   Component can be allowed to further manipulate the Attribute hierarchy. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    call ESMF_FieldBundleGet(fieldbundle, fieldList=field, rc=rc)
    if (rc .ne. ESMF_SUCCESS) return
    do k = 1, 10
        call ESMF_AttributeGetAttPack(field(k), convESMF, purpGen, &
          attpack=attpackGen, rc=rc)
        if (rc .ne. ESMF_SUCCESS) return
        call ESMF_AttributeSet(field(k), name=name2, value=value2, &
          attpack=attpackGen, rc=status)
        if (rc .ne. ESMF_SUCCESS) return
        call ESMF_AttributeAdd(field(k), attrList=attrList, &
          convention=convESMF, purpose=purp2, &
          nestConvention=convESMF, nestPurpose=purpGen, &
          attpack=attpack, rc=rc)
        if (rc .ne. ESMF_SUCCESS) return
        call ESMF_AttributeSet(field(k), name='Coordinates', value='Latlon', &
          attpack=attpack, rc=rc)
        if (rc .ne. ESMF_SUCCESS) return
        call ESMF_AttributeSet(field(k), name='Mask', value='Yes', &
          attpack=attpack, rc=rc)
        if (rc .ne. ESMF_SUCCESS) return
        call ESMF_AttributeRemove(field(k), name=name3, &
          attpack=attpackGen, rc=status)
        if (rc .ne. ESMF_SUCCESS) return
    enddo
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   At this point, the driver of the model run will transfer control to the
   run phase of the coupler Component. 
%/////////////////////////////////////////////////////////////

   In the run phase of the coupler Component we must now ensure that the
   entire VM again has a consistent view of the Attribute hierarchy.  This
   is different from the communication done in the initialize phase of the
   model run because the only structural change that has occurred is in the
   Attribute hierarchy.  Therefore an {\tt ESMF\_AttributeUpdate()} call can
   be used at this point to reconcile these changes.  It should be noted that
   the {\tt ESMF\_AttributeUpdate()} call will reconcile value changes to the
   Attribute hierarchy as well as structural changes.
  
   The first thing to do is to retrieve the Component, VM, and States.  Then
   {\tt ESMF\_AttributeUpdate()} will be called on the import State to accomplish
   a VM wide communication.  Afterwards, the Attribute hierarchy can be transferred,
   in a local sense, from the import State to the export State using an
   {\tt ESMF\_AttributeCopy()} call. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    type(ESMF_VM)               :: vm
    integer                     :: myPet

    integer, dimension(2)       :: rootList

    rc = ESMF_SUCCESS

    call ESMF_CplCompGet(comp, vm=vm, rc=rc)

    call ESMF_VMGet(vm, localPet=myPet, rc=rc)

    call ESMF_StateGet(importState, rc=rc)
    call ESMF_StateGet(exportState, rc=rc)

    rootList = (/0,1/)
    call ESMF_AttributeUpdate(importState, vm, rootList=rootList, rc=rc)

    call ESMF_AttributeCopy(importState, exportState, &
      attcopy=ESMF_ATTCOPY_REFERENCE, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   At this point the entire VM has a consistent view of the Attribute hierarchy
   that was recently modified during {\it run time} in the first gridded component
   and the driver of the model run will transfer control to the
   run phase of the second gridded Component. 
%/////////////////////////////////////////////////////////////

   In the run phase of the second gridded Component is normally where
   a user model would again manipulate the data it was given.  In this
   simple example we are only dealing with the metadata, which has already
   been ensured for consistency across the VM, including the exclusive
   piece of which is being used in this Component.  Therefore we are free
   to use the metadata as we wish, considering only that any changes we
   make to it during run time will have to first be reconciled before other
   parts of the VM can use them.  However, this is not our concern at this
   point because we will now explore the capabilities of {\tt ESMF\_AttributeWrite()}.
  
   First we will get the Component and VM.  Then we will write out the
   Attribute hierarchy to an .xml file,
   after which we will write out the Attribute hierarchy to a more reader
   friendly tab-delimited format.  Both of these write calls will output their
   respective data into files in the execution directory, in either a .xml
   or .stdout file. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    type(ESMF_VM)               :: vm
    integer                     :: petCount, status, myPet
    character(ESMF_MAXSTR)      :: convESMF,purpGen

    rc = ESMF_SUCCESS

    call ESMF_GridCompGet(comp, vm=vm, rc=status)
    if (status .ne. ESMF_SUCCESS) return
    call ESMF_VMGet(vm, petCount=petCount, localPet=myPet, rc=status)
    if (status .ne. ESMF_SUCCESS) return

    convESMF = 'ESMF'
    purpGen = 'General'

    if (myPet .eq. 2) then
      call ESMF_AttributeWrite(importState,convESMF,purpGen, &
        attwriteflag=ESMF_ATTWRITE_XML, rc=rc)
      call ESMF_AttributeWrite(importState,convESMF,purpGen,rc=rc)
      if (rc .ne. ESMF_SUCCESS) return
    endif
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   At this point the driver of the model run would normally transfer control
   to the finalize phase of the first gridded Component.  However, there is
   not much of interest as far as metadata is concerned in this portion
   of the model run.  So with that we will conclude this example.
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
