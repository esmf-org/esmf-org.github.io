%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_WebServSecureSocket.C,  Date: Tue May  5 21:00:15 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection{ESMCI\_WebServSecureSocket::ESMCI\_WebServSecureSocket() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} ESMCI_WebServSecureSocket::ESMCI_WebServSecureSocket(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Setup the initial default values for the socket interface.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::~ESMCI\_WebServSecureSocket() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} ESMCI_WebServSecureSocket::~ESMCI_WebServSecureSocket(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Cleanup the socket interface.  For now, all this involves is making
      sure the socket is disconnected.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::nonblock() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServSecureSocket::nonblock(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the socket up to be non blocking.
      (KDS: Not sure how portable this command is, since it uses the fcntl
            system call.  However, I don't believe it's being used at all
            with the ESMF code... may want to remove later.)
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::serverConnect() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServSecureSocket::serverConnect(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     int  socket file descriptor if successful, ESMF_FAILURE otherwise.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int  port          // (in) port number on which socket service is setup
   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Sets up a socket service on which we listen for requests from clients.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::accept() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServSecureSocket::accept(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     int  return code - ESMF_SUCCESS for success, ESMF_FAILURE for failure\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Sets up a socket service on which we listen for requests from clients.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::clientConnect() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServSecureSocket::clientConnect(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     int  socket file descriptor if successful, ESMF_FAILURE otherwise.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   const char*   host,   // (in) name of the host to which we are connecting
   int                           port  // (in) port number on the host to which we are connecting
   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Sets up a socket service on which we listen for requests from clients.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::close() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void  ESMCI_WebServSecureSocket::close(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim} \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Close the communication socket (if it's open).
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::disconnect() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void  ESMCI_WebServSecureSocket::disconnect(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim} \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Close the communication socket and disconnect the server socket.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::send() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServSecureSocket::send(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     int  number of characters (bytes) sent\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int           size,  // (in) the size of the data to send
   void*  data   // (in) the data to send
   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Transmits the specified data across the socket.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::recv() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServSecureSocket::recv(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     int  number of characters (bytes) received if successful, 0 if the peer
          has performed an orderly shutdown, and ESMF_FAILURE otherwise.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int           size,  // (in) the max size of the data to receive
   void*  data   // (inout) the buffer where the data is put; must have memory
                 // allocated at least the specified size
   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Retrieves the specified amount of data from the communication socket.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::read() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServSecureSocket::read(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     int  number of characters (bytes) read (not including the packet header)
          if successful, ESMF_FAILURE otherwise.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int&          size,  // (out) the size of the data according to the packet header
   void*  data   // (out) the buffer to contain the data (enough memory must
                 // be allocated ahead of time)
   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Retrieves data from the communication socket.  First, the packet header
      is read, which specifies the amount of data to be transmitted, and then
      the actual data is read.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::write() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServSecureSocket::write(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     int  number of characters (bytes) written (not including the packet
          header) if successful, ESMF_FAILURE otherwise.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int           size,  // (in) the size of the data to send
   void*  data   // (in) the data to send
   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Transmits the specified data across the socket.  First, it creates and
      sends a packet header that includes the magic number and the size of the
      data, and then it sends the actual data.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServSecureSocket::send() (Source File: ESMCI\_WebServSecureSocket.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServSecureSocket::send(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     int  number of characters (bytes) written (not including the packet
          header) if successful, ESMF_FAILURE otherwise.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   const char    msg[]   // (in) the string to send
   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Convenience method to send a string across the communication network.
      This method determines the data size by getting the string length (plus
      one) and passes it on, along with the string data, to the write method.
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
