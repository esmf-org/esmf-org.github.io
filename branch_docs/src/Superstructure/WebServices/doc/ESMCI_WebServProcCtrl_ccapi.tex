%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_WebServProcCtrl.C,  Date: Tue May  5 21:00:15 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection{ESMCI\_WebServProcCtrl::ESMCI\_WebServProcCtrl() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} ESMCI_WebServProcCtrl::ESMCI_WebServProcCtrl(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int              procCtrlPort,       // (in) the port number on which to
                                        //   setup the socket service to listen
                                        //   for requests
   string           registrarHost,      // (in) the host name on which the
                                        //   Registrar is running
   int              registrarPort,      // (in) the port number of the Registrar
   string           compSvrHost,        // (in) the host name of the component
                                        //   svc to which we'll be connecting
   int              compSvrStartPort,   // (in) the starting port number of pool
                                        //   of ports on which the component
                                        //   services will be listening
   int              portPoolSize,       // (in) the size of the pool of ports
   string           compSvrScriptDir,   // (in) the directory that contains the
                                        //   script that is used to startup the
                                        //   component svc
   string           compSvrScriptName,  // (in) the name of the script that is
                                        //   used to startup the component svc
   ESMC_JobMgrType  jobMgrType          // (in) the type of tool used to manage
                                        //   component svc jobs
   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Initialize the ESMF Process Controller service with the default values
      as well as the specified port number and output file directory.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::~ESMCI\_WebServProcCtrl() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} ESMCI_WebServProcCtrl::~ESMCI_WebServProcCtrl(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Cleanup the process controller service.  For now, all this involves is
      making sure the socket is disconnected.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::requestLoop() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::requestLoop(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Sets up a socket service for a process controller server to handle
      client requests.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::getNextRequest() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::getNextRequest(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int  id of the client request (defined in ESMCI_WebServNetEsmf.h);
           ESMF_FAILURE if error\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Listens on a server socket for client requests, and as the requests
      arrive, reads the request id from the socket and returns it.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::serviceRequest() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::serviceRequest(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int  id of the client request (the same value that's passed in)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int  request    // id of the client request
   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Calls the appropriate process method based on the client request id.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::processNew() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::processNew(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ESMF_SUCCESS if successful; ESMF_FAILURE otherwise;\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Processes the request for a new client session.  This method reads the
      client name from the socket, generates a new client id, creates a new
      client info object and adds it to the list of clients, and then writes
      the new client id to the socket to complete the transaction.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::processState() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::processState(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ESMF_SUCCESS if successful; ESMF_FAILURE otherwise;\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Processes the request to retrieve the component state.  This method
      reads the client id from the socket and uses it to lookup the client
      information.  The Registrar is then used to fetch the current status
      of the component server, and finally, the component status is written
      to the socket to complete the transaction.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::processInit() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::processInit(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Processes the request to initialize the component.  This method reads the
      client id from the socket and uses it to lookup the client information.
      It then reads the names of input files (if any) from the socket.  The
      request and its parameters are then passed on to the component server,
      and finally, the component status is written to the socket to complete
      the transaction.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::processRun() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::processRun(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Processes the request to run the component.  This method reads the
      client id from the socket and uses it to lookup the client information.
      The request and its parameters are then passed on to the component
      server, and finally, the component status is written to the socket
      to complete the transaction.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::processTimestep() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::processTimestep(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Processes the request to timestep the component.  This method reads the
      client id from the socket and uses it to lookup the client information.
      It then reads the number of timesteps parameter from the socket.
      The request and its parameters are then passed on to the component
      server, and finally, the component status is written to the socket
      to complete the transaction.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::processFinal() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::processFinal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Processes the request to finalize the component.  This method reads the
      client id from the socket and uses it to lookup the client information.
      The request and its parameters are then passed on to the component
      server, and finally, the component status is written to the socket
      to complete the transaction.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::processGetDataDesc() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::processGetDataDesc(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Processes the request to retrieve the description of the output data.
      This method reads the client id from the socket and uses it to lookup
      the client information.  It then gets the data description from the
      component server and writes that information back to the client.
      Finally, the component status is written back to the socket to complete
      the transaction.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::processGetData() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::processGetData(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Processes the request to retrieve the export data.  This method
      reads the client id from the socket and uses it to lookup the client
      information.  It then reads the data parameters (variable name, time,
      lat and lon) from the socket and uses that information to read the
      data from the socket.  The data and the component status are then
      written back to the socket to complete the transaction.
  
      (KDS: This design is very specific to CCSM/CAM and is hardcoded for
            that prototype.  This needs to be redesigned to be more generic.)
      (KDS: Also, getting one value for a specific time/lat/lon is really
            inefficient and not practical.  There needs to be a way to handle
            more data values at a time.)
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::processEnd() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::processEnd(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Processes the request to end a client session.  This method reads the
      client id from the socket and uses it to lookup the client information.
      The client information is deleted from the list of clients, and finally,
      the component status is written to the socket to complete the
      transaction.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::processExit() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::processExit(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or ESMF_FAILURE on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Processes the request to exit the Process Controller.  Exiting the
      Process Controller means exiting all of the Component Services associate
      with the process controller.  This is a very powerful operation, and
      I should probably do some security checking before allowing it... later.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::processPing() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::processPing(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Processes the request to ping the service.  Doesn't actually do anything.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection{ESMCI\_WebServProcCtrl::getNextClientId() (Source File: ESMCI\_WebServProcCtrl.C)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int  ESMCI_WebServProcCtrl::getNextClientId(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int  the next available client identifier\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Increments the next client identifier value by one and returns the
      new value.
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
