%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_StateAPI.F90,  Date: Tue May  5 21:00:08 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_StateAssignment(=)] {ESMF\_StateAssignment(=) - State assignment}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface assignment(=)
   state1 = state2\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_State) :: state1
   type(ESMF_State) :: state2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Assign state1 as an alias to the same ESMF State object in memory
   as state2. If state2 is invalid, then state1 will be equally invalid after
   the assignment.
  
   The arguments are:
   \begin{description}
   \item[state1]
   The {\tt ESMF\_State} object on the left hand side of the assignment.
   \item[state2]
   The {\tt ESMF\_State} object on the right hand side of the assignment.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StateOperator(==)] {ESMF\_StateOperator(==) - State equality operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(==)
   if (state1 == state2) then ... endif
   OR
   result = (state1 == state2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_State), intent(in) :: state1
   type(ESMF_State), intent(in) :: state2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Test whether state1 and state2 are valid aliases to the same ESMF
   State object in memory. For a more general comparison of two ESMF States,
   going beyond the simple alias test, the ESMF\_StateMatch() function (not yet
   implemented) must be used.
  
   The arguments are:
   \begin{description}
   \item[state1]
   The {\tt ESMF\_State} object on the left hand side of the equality
   operation.
   \item[state2]
   The {\tt ESMF\_State} object on the right hand side of the equality
   operation.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StateOperator(/=)] {ESMF\_StateOperator(/=) - State not equal operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(/=)
   if (state1 /= state2) then ... endif
   OR
   result = (state1 /= state2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_State), intent(in) :: state1
   type(ESMF_State), intent(in) :: state2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Test whether state1 and state2 are {\it not} valid aliases to the
   same ESMF State object in memory. For a more general comparison of two ESMF
   States, going beyond the simple alias test, the ESMF\_StateMatch() function
   (not yet implemented) must be used.
  
   The arguments are:
   \begin{description}
   \item[state1]
   The {\tt ESMF\_State} object on the left hand side of the non-equality
   operation.
   \item[state2]
   The {\tt ESMF\_State} object on the right hand side of the non-equality
   operation.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StateAdd] {ESMF\_StateAdd - Add a list of items to a State}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_StateAdd(state, <itemList>, relaxedFlag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_State), intent(inout) :: state
   <itemList>, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   logical, intent(in), optional :: relaxedFlag
   integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Add a list of items to a {\tt ESMF\_State}. It is an error if any item in
   <itemlist> already matches, by name, an item already contained in {\tt state}.
  
   Supported values for <itemList> are:
   \begin{description}
   \item type(ESMF\_Array), intent(in) :: arrayList(:)
   \item type(ESMF\_ArrayBundle), intent(in) :: arraybundleList(:)
   \item type(ESMF\_Field), intent(in) :: fieldList(:)
   \item type(ESMF\_FieldBundle), intent(in) :: fieldbundleList(:)
   \item type(ESMF\_RouteHandle), intent(in) :: routehandleList(:)
   \item type(ESMF\_State), intent(in) :: nestedStateList(:)
   \end{description}
  
   The arguments are:
   \begin{description}
   \item[state]
   An {\tt ESMF\_State} to which the <itemList> will be added.
   \item[<itemList>]
   The list of items to be added.
   This is a reference only; when
   the {\tt ESMF\_State} is destroyed the <itemList> items contained within it will
   not be destroyed. Also, the items in the <itemList> cannot be safely
   destroyed before the {\tt ESMF\_State} is destroyed.
   Since <itemList> items can be added to multiple containers, it remains
   the responsibility of the user to manage their
   destruction when they are no longer in use.
   \item[{[relaxedflag]}]
   A setting of {\tt .true.} indicates a relaxed definition of "add",
   where it is {\em not} an error if {\tt <itemList>} contains items
   with names that are found in {\tt state}. The {\tt State}
   is left unchanged for these items. For {\tt .false.} this is treated
   as an error condition. The default setting is {\tt .false.}.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StateAddReplace] {ESMF\_StateAddReplace - Add or replace a list of items to a State}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_StateAddReplace(state, <itemList>, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_State), intent(inout) :: state
   <itemList>, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Add or replace a list of items to an {\tt ESMF\_State}. If an item in
   <itemList> does not match any items already present in {\tt state}, it is
   added. Items with names already present in the {\tt state} replace the
   existing item.
  
   Supported values for <itemList> are:
   \begin{description}
   \item type(ESMF\_Array), intent(in) :: arrayList(:)
   \item type(ESMF\_ArrayBundle), intent(in) :: arraybundleList(:)
   \item type(ESMF\_Field), intent(in) :: fieldList(:)
   \item type(ESMF\_FieldBundle), intent(in) :: fieldbundleList(:)
   \item type(ESMF\_RouteHandle), intent(in) :: routehandleList(:)
   \item type(ESMF\_State), intent(in) :: nestedStateList(:)
   \end{description}
  
   The arguments are:
   \begin{description}
   \item[state]
   An {\tt ESMF\_State} to which the <itemList> will be added or replaced.
   \item[<itemList>]
   The list of items to be added or replaced.
   This is a reference only; when
   the {\tt ESMF\_State} is destroyed the <itemList> items contained within it will
   not be destroyed. Also, the items in the <itemList> cannot be safely
   destroyed before the {\tt ESMF\_State} is destroyed.
   Since <itemList> items can be added to multiple containers, it remains
   the responsibility of the user to manage their
   destruction when they are no longer in use.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StateCreate] {ESMF\_StateCreate - Create a new State}


\bigskip{\sf INTERFACE:}
\begin{verbatim}       function ESMF_StateCreate(stateintent, &
                    arrayList, arraybundleList, &
                    fieldList, fieldbundleList, &
                    nestedStateList, &
                    routehandleList, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_State) :: ESMF_StateCreate\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_StateIntent_Flag), intent(in), optional :: stateintent
       type(ESMF_Array), intent(in), optional :: arrayList(:)
       type(ESMF_ArrayBundle), intent(in), optional :: arraybundleList(:)
       type(ESMF_Field), intent(in), optional :: fieldList(:)
       type(ESMF_FieldBundle), intent(in), optional :: fieldbundleList(:)
       type(ESMF_State), intent(in), optional :: nestedStateList(:)
       type(ESMF_RouteHandle), intent(in), optional :: routehandleList(:)
       character(len=*), intent(in), optional :: name
       integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Create a new {\tt ESMF\_State}, set default characteristics for
   objects added to it, and optionally add initial objects to it.
  
   The arguments are:
   \begin{description}
   \item[{[stateintent]}]
   Import or Export {\tt ESMF\_State}. Valid values are
   {\tt ESMF\_STATEINTENT\_IMPORT}, {\tt ESMF\_STATEINTENT\_EXPORT},
   or {\tt ESMF\_STATEINTENT\_UNSPECIFIED} The default
   is {\tt ESMF\_STATEINTENT\_UNSPECIFIED}.
   \item[{[arrayList]}]
   A list (Fortran array) of {\tt ESMF\_Array}s.
   \item[{[arraybundleList]}]
   A list (Fortran array) of {\tt ESMF\_ArrayBundle}s.
   \item[{[fieldList]}]
   A list (Fortran array) of {\tt ESMF\_Field}s.
   \item[{[fieldbundleList]}]
   A list (Fortran array) of {\tt ESMF\_FieldBundle}s.
   \item[{[nestedStateList]}]
   A list (Fortran array) of {\tt ESMF\_State}s to be nested
   inside the outer {\tt ESMF\_State}.
   \item[{[routehandleList]}]
   A list (Fortran array) of {\tt ESMF\_RouteHandle}s.
   \item[{[name]}]
   Name of this {\tt ESMF\_State} object. A default name will be generated
   if none is specified.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StateDestroy] {ESMF\_StateDestroy - Release resources for a State}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       recursive subroutine ESMF_StateDestroy(state, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(inout) :: state
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Releases resources associated with this {\tt ESMF\_State}. Actual
   objects added to {\tt ESMF\_State}s will not be destroyed, it
   remains the responsibility of the user to destroy these objects in the correct
   context.
  
   The arguments are:
   \begin{description}
   \item[state]
   Destroy contents of this {\tt ESMF\_State}.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StateGet] {ESMF\_StateGet - Get object-wide information from a State}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_StateGet()
       subroutine ESMF_StateGetInfo(state, &
             itemSearch, itemorderflag, nestedFlag, &
             stateintent, itemCount, itemNameList, itemTypeList, name, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(in) :: state
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*), intent(in), optional :: itemSearch
       type(ESMF_ItemOrder_Flag), intent(in), optional :: itemorderflag
       logical, intent(in), optional :: nestedFlag
       type(ESMF_StateIntent_Flag), intent(out), optional :: stateintent
       integer, intent(out), optional :: itemCount
       character (len=*), intent(out), optional :: itemNameList(:)
       type(ESMF_StateItem_Flag), intent(out), optional :: itemTypeList(:)
       character (len=*), intent(out), optional :: name
       integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[6.1.0] Added argument {\tt itemorderflag}.
   The new argument gives the user control over the order in which
   the items are returned.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Returns the requested information about this {\tt ESMF\_State}.
   The optional {\tt itemSearch} argument may specify the name of
   an individual item to search for. When used in conjunction with
   the {\tt nestedFlag}, nested States will also be searched.
  
   Typically, an {\tt ESMF\_StateGet()} information request will be performed
   twice. The first time, the {\tt itemCount} argument will be used to
   query the size of arrays that are needed. Arrays can then be allocated
   to the correct size for {\tt itemNameList} and {\tt itemtypeList}
   as needed. A second call to {\tt ESMF\_StateGet()} will then fill in the
   values.
  
   The arguments are:
   \begin{description}
   \item[state]
   An {\tt ESMF\_State} object to be queried.
   \item[{[itemSearch]}]
   Query objects by name in the State. When the {\tt nestedFlag}
   option is set to .true., all nested States will also be searched
   for the specified name.
   \item[{[itemorderflag]}]
   Specifies the order of the returned items in the {\tt itemNameList}
   and {\tt itemTypeList}. The default is {\tt ESMF\_ITEMORDER\_ABC}.
   See \ref{const:itemorderflag} for a full list of options.
   \item[{[nestedFlag]}]
   When set to {\tt .false.}, returns information at the current
   State level only (default)
   When set to {\tt .true.}, additionally returns information from
   nested States
   \item[{[stateintent]}]
   Returns the type, e.g., Import or Export, of this {\tt ESMF\_State}.
   Possible values are listed in Section~\ref{const:stateintent}.
   \item[{[itemCount]}]
   Count of items in this {\tt ESMF\_State}.
   When the {\tt nestedFlag} option is
   set to {\tt .true.}, the count will include items present in nested
   States. When using {\tt itemSearch}, it will count the number of
   items matching the specified name.
   \item[{[itemNameList]}]
   Array of item names in this {\tt ESMF\_State}.
   When the {\tt nestedFlag} option is
   set to {\tt .true.}, the list will include items present in nested
   States. When using {\tt itemSearch}, it will return the names of
   items matching the specified name. {\tt itemNameList} must be at least
   {\tt itemCount} long.
   \item[{[itemTypeList]}]
   Array of possible item object types in this {\tt ESMF\_State}.
   When the {\tt nestedFlag} option is
   set to {\tt .true.}, the list will include items present in nested
   States. When using {\tt itemSearch}, it will return the types of
   items matching the specified name. Must be at least {\tt itemCount}
   long. Return values are listed in Section~\ref{const:stateitem}.
   \item[{[name]}]
   Returns the name of this {\tt ESMF\_State}.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StateGet] {ESMF\_StateGet - Get information about an item in a State by item name}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_StateGet()
       subroutine ESMF_StateGetItemInfo(state, itemName, itemType, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(in) :: state
       character (len=*), intent(in) :: itemName
       type(ESMF_StateItem_Flag), intent(out) :: itemType
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Returns the type for the item named
   {\tt name} in this {\tt ESMF\_State}. If no item with this name
   exists, the value {\tt ESMF\_STATEITEM\_NOTFOUND} will be returned
   and the error code will not be set to an error. Thus this routine
   can be used to safely query for the existence of items by name
   whether or not they are expected to be there. The error code will
   be set in case of other errors, for example if the {\tt ESMF\_State}
   itself is invalid.
  
   The arguments are:
   \begin{description}
   \item[state]
   {\tt ESMF\_State} to be queried.
   \item[itemName]
   Name of the item to return information about.
   \item[itemType]
   Returned item types for the item with the given name, including
   placeholder names. Options are
   listed in Section~\ref{const:stateitem}. If no item with the
   given name is found, {\tt ESMF\_STATEITEM\_NOTFOUND} will be returned
   and {\tt rc} will {\bf not} be set to an error.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StateGet] {ESMF\_StateGet - Get an item from a State by item name}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_StateGet(state, itemName, <item>, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_State), intent(in) :: state
   character (len=*), intent(in) :: itemName
   <item>, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   \begin{sloppypar}
   Returns an <item> from an {\tt ESMF\_State} by item name.
   If the {\tt ESMF\_State} contains the <item> directly, only
   {\tt itemName} is required.
   \end{sloppypar}
  
   If the {\tt state} contains nested {\tt ESMF\_State}s,
   the {\tt itemName} argument may specify a fully qualified name
   to access the desired item with a single call. This is performed
   using the '/' character to separate the names of the intermediate
   State names leading to the desired item. (E.g.,
   {\tt itemName='state1/state12/item'}).
  
   Supported values for <item> are:
   \begin{description}
   \item type(ESMF\_Array), intent(out) :: array
   \item type(ESMF\_ArrayBundle), intent(out) :: arraybundle
   \item type(ESMF\_Field), intent(out) :: field
   \item type(ESMF\_FieldBundle), intent(out) :: fieldbundle
   \item type(ESMF\_RouteHandle), intent(out) :: routehandle
   \item type(ESMF\_State), intent(out) :: nestedState
   \end{description}
  
   The arguments are:
   \begin{description}
   \item[state]
   State to query for an <item> named {\tt itemName}.
   \item[itemName]
   Name of <item> to be returned. This name may be fully
   qualified in order to access nested State items.
   \item[<item>]
   Returned reference to the <item>.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StateIsCreated] {ESMF\_StateIsCreated - Check whether an State object has been created}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   function ESMF_StateIsCreated(state, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: ESMF_StateIsCreated\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State), intent(in) :: state
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Return {\tt .true.} if the {\tt state} has been created. Otherwise return
   {\tt .false.}. If an error occurs, i.e. {\tt rc /= ESMF\_SUCCESS} is
   returned, the return value of the function will also be {\tt .false.}.
  
   The arguments are:
   \begin{description}
   \item[state]
   {\tt ESMF\_State} queried.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StatePrint] {ESMF\_StatePrint - Print State information}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StatePrint(state, options, nestedFlag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(in) :: state
       character(len=*), intent(in), optional :: options
       logical, intent(in), optional :: nestedFlag
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Prints information about the {\tt state} to {\tt stdout}.
  
   The arguments are:
   \begin{description}
   \item[state]
   The {\tt ESMF\_State} to print.
   \item[{[options]}]
   Print options:
   " ", or "brief" - print names and types of the objects within the state (default),
   "long" - print additional information, such as proxy flags
   \item[{[nestedFlag]}]
   When set to {\tt .false.}, prints information about the current
   State level only (default),
   When set to {\tt .true.}, additionally prints information from
   nested States
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_StateRead] {ESMF\_StateRead -- Read data items from a file into a State}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_StateRead(state, fileName, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_State), intent(inout) :: state
       character (len=*), intent(in) :: fileName
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Currently limited to read in all Arrays from a NetCDF file and add them
   to a State object. Future releases will enable more items of a State
   to be read from a file of various formats.
  
   Only PET 0 reads the file; the States in other PETs remain empty.
   Currently, the data is not decomposed or distributed; each PET
   has only 1 DE and only PET 0 contains data after reading the file.
   Future versions of ESMF will support data decomposition and distribution
   upon reading a file. See Section~\ref{example:StateRdWr} for
   an example.
  
   Note that the third party NetCDF library must be installed. For more
   details, see the "ESMF Users Guide",
   "Building and Installing the ESMF, Third Party Libraries, NetCDF" and
   the website http://www.unidata.ucar.edu/software/netcdf.
  
   The arguments are:
   \begin{description}
   \item[state]
   The {\tt ESMF\_State} to add items read from file. Currently only
   Arrays are supported.
   \item[fileName]
   File to be read.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   Equals {\tt ESMF\_RC\_LIB\_NOT\_PRESENT} if the NetCDF library is
   not present.
   \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
