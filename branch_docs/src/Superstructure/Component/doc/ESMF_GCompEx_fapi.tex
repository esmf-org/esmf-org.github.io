%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_GCompEx.F90,  Date: Tue May  5 21:00:11 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

  \subsubsection{Implement a user-code {\tt SetServices} routine}
   
   \label{sec:GridSetServ}
  
   Every {\tt ESMF\_GridComp} is required to provide and document
   a public set services routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   {\tt ESMF\_GridComp} as the first argument, and
   an integer return code as the second.
   Both arguments are required and must {\em not} be declared as 
   {\tt optional}. If an intent is specified in the interface it must be 
   {\tt intent(inout)} for the first and {\tt intent(out)} for the 
   second argument.
  
   The set services routine must call the ESMF method 
   {\tt ESMF\_GridCompSetEntryPoint()} to
   register with the framework what user-code subroutines should be called 
   to initialize, run, and finalize the component.  There are
   additional routines which can be registered as well, for checkpoint
   and restart functions.
  
   Note that the actual subroutines being registered do not have to be
   public to this module; only the set services routine itself must
   be available to be used by other code. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    ! Example Gridded Component
    module ESMF_GriddedCompEx
    
    ! ESMF Framework module
    use ESMF
    implicit none
    public GComp_SetServices
    public GComp_SetVM

    contains

    subroutine GComp_SetServices(comp, rc)
      type(ESMF_GridComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional

      ! Set the entry points for standard ESMF Component methods
      call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_INITIALIZE, &
                                userRoutine=GComp_Init, rc=rc)
      call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_RUN, &
                                userRoutine=GComp_Run, rc=rc)
      call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_FINALIZE, &
                                userRoutine=GComp_Final, rc=rc)

      rc = ESMF_SUCCESS

    end subroutine
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \subsubsection{Implement a user-code {\tt Initialize} routine}
   
   \label{sec:GridInitialize}
  
  
   When a higher level component is ready to begin using an 
   {\tt ESMF\_GridComp}, it will call its initialize routine.
  
   The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.
  
   At initialization time the component can allocate data space, open
   data files, set up initial conditions; anything it needs to do to
   prepare to run.
  
   The {\tt rc} return code should be set if an error occurs, otherwise
   the value {\tt ESMF\_SUCCESS} should be returned. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    subroutine GComp_Init(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                   ! must not be optional
      type(ESMF_State)      :: importState            ! must not be optional
      type(ESMF_State)      :: exportState            ! must not be optional
      type(ESMF_Clock)      :: clock                  ! must not be optional
      integer, intent(out)  :: rc                     ! must not be optional

      print *, "Gridded Comp Init starting"

      ! This is where the model specific setup code goes.  
 
      ! If the initial Export state needs to be filled, do it here.
      !call ESMF_StateAdd(exportState, field, rc)
      !call ESMF_StateAdd(exportState, bundle, rc)
      print *, "Gridded Comp Init returning"
   
      rc = ESMF_SUCCESS

    end subroutine GComp_Init
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \subsubsection{Implement a user-code {\tt Run} routine}
   
   \label{sec:GridRun}
  
   During the execution loop, the run routine may be called many times.
   Each time it should read data from the {\tt importState}, use the
   {\tt clock} to determine what the current time is in the calling
   component, compute new values or process the data,
   and produce any output and place it in the {\tt exportState}. 
   
   When a higher level component is ready to use the {\tt ESMF\_GridComp}
   it will call its run routine.
  
   The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.
  
   It is expected that this is where the bulk of the model computation
   or data analysis will occur.
     
   The {\tt rc} return code should be set if an error occurs, otherwise
   the value {\tt ESMF\_SUCCESS} should be returned. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    subroutine GComp_Run(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                   ! must not be optional
      type(ESMF_State)      :: importState            ! must not be optional
      type(ESMF_State)      :: exportState            ! must not be optional
      type(ESMF_Clock)      :: clock                  ! must not be optional
      integer, intent(out)  :: rc                     ! must not be optional

      print *, "Gridded Comp Run starting"
      ! call ESMF_StateGet(), etc to get fields, bundles, arrays
      !  from import state.

      ! This is where the model specific computation goes.

      ! Fill export state here using ESMF_StateAdd(), etc

      print *, "Gridded Comp Run returning"

      rc = ESMF_SUCCESS

    end subroutine GComp_Run
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \subsubsection{Implement a user-code {\tt Finalize} routine}
   
   \label{sec:GridFinalize}
  
   At the end of application execution, each {\tt ESMF\_GridComp} should
   deallocate data space, close open files, and flush final results.
   These functions should be placed in a finalize routine.
  
   The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.
  
   The {\tt rc} return code should be set if an error occurs, otherwise
   the value {\tt ESMF\_SUCCESS} should be returned.
   
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    subroutine GComp_Final(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                   ! must not be optional
      type(ESMF_State)      :: importState            ! must not be optional
      type(ESMF_State)      :: exportState            ! must not be optional
      type(ESMF_Clock)      :: clock                  ! must not be optional
      integer, intent(out)  :: rc                     ! must not be optional

      print *, "Gridded Comp Final starting"
    
      ! Add whatever code here needed

      print *, "Gridded Comp Final returning"
   
      rc = ESMF_SUCCESS

    end subroutine GComp_Final
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \subsubsection{Implement a user-code {\tt SetVM} routine}
   
   \label{sec:GridSetVM}
  
   Every {\tt ESMF\_GridComp} can optionally provide and document
   a public set vm routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   {\tt ESMF\_GridComp} as the first argument, and
   an integer return code as the second.
   Both arguments are required and must {\em not} be declared as 
   {\tt optional}. If an intent is specified in the interface it must be 
   {\tt intent(inout)} for the first and {\tt intent(out)} for the 
   second argument.
  
   The set vm routine is the only place where the child component can
   use the {\tt ESMF\_GridCompSetVMMaxPEs()}, or
   {\tt ESMF\_GridCompSetVMMaxThreads()}, or 
   {\tt ESMF\_GridCompSetVMMinThreads()} call to modify aspects of its own VM.
  
   A component's VM is started up right before its set services routine is
   entered. {\tt ESMF\_GridCompSetVM()} is executing in the parent VM, and must
   be called {\em before} {\tt ESMF\_GridCompSetServices()}. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    subroutine GComp_SetVM(comp, rc)
      type(ESMF_GridComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional
      
      type(ESMF_VM) :: vm
      logical :: pthreadsEnabled
      
      ! Test for Pthread support, all SetVM calls require it
      call ESMF_VMGetGlobal(vm, rc=rc)
      call ESMF_VMGet(vm, pthreadsEnabledFlag=pthreadsEnabled, rc=rc)

      if (pthreadsEnabled) then
        ! run PETs single-threaded
        call ESMF_GridCompSetVMMinThreads(comp, rc=rc)
      endif

      rc = ESMF_SUCCESS

    end subroutine

    end module ESMF_GriddedCompEx
 
\end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
