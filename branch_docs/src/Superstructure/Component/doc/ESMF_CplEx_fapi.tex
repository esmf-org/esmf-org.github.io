%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_CplEx.F90,  Date: Tue May  5 21:00:11 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

  \subsubsection{Implement a user-code {\tt SetServices} routine}
   
   \label{sec:CplSetServ}
  
   Every {\tt ESMF\_CplComp} is required to provide and document
   a public set services routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an 
   {\tt ESMF\_CplComp} as the first argument, and 
   an integer return code as the second.
   Both arguments are required and must {\em not} be declared as 
   {\tt optional}. If an intent is specified in the interface it must be 
   {\tt intent(inout)} for the first and {\tt intent(out)} for the 
   second argument.
  
   The set services routine must call the ESMF method 
   {\tt ESMF\_CplCompSetEntryPoint()} to
   register with the framework what user-code subroutines should be called
   to initialize, run, and finalize the component.  There are
   additional routines which can be registered as well, for checkpoint
   and restart functions.
  
   Note that the actual subroutines being registered do not have to be
   public to this module; only the set services routine itself must
   be available to be used by other code. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    ! Example Coupler Component
    module ESMF_CouplerEx
    
    ! ESMF Framework module
    use ESMF
    implicit none
    public CPL_SetServices

    contains

    subroutine CPL_SetServices(comp, rc)
      type(ESMF_CplComp)    :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional

      ! Set the entry points for standard ESMF Component methods
      call ESMF_CplCompSetEntryPoint(comp, ESMF_METHOD_INITIALIZE, &
                          userRoutine=CPL_Init, rc=rc)
      call ESMF_CplCompSetEntryPoint(comp, ESMF_METHOD_RUN, &
                          userRoutine=CPL_Run, rc=rc)
      call ESMF_CplCompSetEntryPoint(comp, ESMF_METHOD_FINALIZE, &
                          userRoutine=CPL_Final, rc=rc)

      rc = ESMF_SUCCESS
    end subroutine
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \subsubsection{Implement a user-code {\tt Initialize} routine}
   
   \label{sec:CplInitialize}
  
   When a higher level component is ready to begin using an 
   {\tt ESMF\_CplComp}, it will call its initialize routine.
  
   The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.
  
   At initialization time the component can allocate data space, open
   data files, set up initial conditions; anything it needs to do to
   prepare to run.
  
   The {\tt rc} return code should be set if an error occurs, otherwise
   the value {\tt ESMF\_SUCCESS} should be returned. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    subroutine CPL_Init(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp               ! must not be optional
      type(ESMF_State)      :: importState        ! must not be optional
      type(ESMF_State)      :: exportState        ! must not be optional
      type(ESMF_Clock)      :: clock              ! must not be optional
      integer, intent(out)  :: rc                 ! must not be optional

      print *, "Coupler Init starting"
    
      ! Add whatever code here needed
      ! Precompute any needed values, fill in any inital values
      !  needed in Import States

      rc = ESMF_SUCCESS

      print *, "Coupler Init returning"
   
    end subroutine CPL_Init
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \subsubsection{Implement a user-code {\tt Run} routine}
   
   \label{sec:CplRun}
  
   During the execution loop, the run routine may be called many times.
   Each time it should read data from the {\tt importState}, use the
   {\tt clock} to determine what the current time is in the calling
   component, compute new values or process the data, 
   and produce any output and place it in the {\tt exportState}.
  
   When a higher level component is ready to use the {\tt ESMF\_CplComp}
   it will call its run routine.
  
   The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.
  
   It is expected that this is where the bulk of the model computation
   or data analysis will occur.
  
   The {\tt rc} return code should be set if an error occurs, otherwise
   the value {\tt ESMF\_SUCCESS} should be returned. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    subroutine CPL_Run(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp              ! must not be optional
      type(ESMF_State)      :: importState       ! must not be optional
      type(ESMF_State)      :: exportState       ! must not be optional
      type(ESMF_Clock)      :: clock             ! must not be optional
      integer, intent(out)  :: rc                ! must not be optional

      print *, "Coupler Run starting"

      ! Add whatever code needed here to transform Export state data
      !  into Import states for the next timestep.  

      rc = ESMF_SUCCESS

      print *, "Coupler Run returning"

    end subroutine CPL_Run
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \subsubsection{Implement a user-code {\tt Finalize} routine}
   
   \label{sec:CplFinalize}
  
   At the end of application execution, each {\tt ESMF\_CplComp} should
   deallocate data space, close open files, and flush final results.
   These functions should be placed in a finalize routine.
  
   The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.
  
   The {\tt rc} return code should be set if an error occurs, otherwise
   the value {\tt ESMF\_SUCCESS} should be returned.
   
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    subroutine CPL_Final(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp                ! must not be optional
      type(ESMF_State)      :: importState         ! must not be optional
      type(ESMF_State)      :: exportState         ! must not be optional
      type(ESMF_Clock)      :: clock               ! must not be optional
      integer, intent(out)  :: rc                  ! must not be optional

      print *, "Coupler Final starting"
    
      ! Add whatever code needed here to compute final values and
      !  finish the computation.

      rc = ESMF_SUCCESS

      print *, "Coupler Final returning"
   
    end subroutine CPL_Final

 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \subsubsection{Implement a user-code {\tt SetVM} routine}
   
   \label{sec:CplSetVM}
  
   Every {\tt ESMF\_CplComp} can optionally provide and document
   a public set vm routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   {\tt ESMF\_CplComp} as the first argument, and
   an integer return code as the second.
   Both arguments are required and must {\em not} be declared as 
   {\tt optional}. If an intent is specified in the interface it must be 
   {\tt intent(inout)} for the first and {\tt intent(out)} for the 
   second argument.
  
   The set vm routine is the only place where the child component can
   use the {\tt ESMF\_CplCompSetVMMaxPEs()}, or
   {\tt ESMF\_CplCompSetVMMaxThreads()}, or 
   {\tt ESMF\_CplCompSetVMMinThreads()} call to modify aspects of its own VM.
  
   A component's VM is started up right before its set services routine is
   entered. {\tt ESMF\_CplCompSetVM()} is executing in the parent VM, and must
   be called {\em before} {\tt ESMF\_CplCompSetServices()}. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    subroutine GComp_SetVM(comp, rc)
      type(ESMF_CplComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional
      
      type(ESMF_VM) :: vm
      logical :: pthreadsEnabled
      
      ! Test for Pthread support, all SetVM calls require it
      call ESMF_VMGetGlobal(vm, rc=rc)
      call ESMF_VMGet(vm, pthreadsEnabledFlag=pthreadsEnabled, rc=rc)

      if (pthreadsEnabled) then
        ! run PETs single-threaded
        call ESMF_CplCompSetVMMinThreads(comp, rc=rc)
      endif

      rc = ESMF_SUCCESS

    end subroutine

    end module ESMF_CouplerEx
 
\end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
