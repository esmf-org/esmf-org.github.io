%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_CplComp.F90,  Date: Tue May  5 21:00:10 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_CplCompAssignment(=)] {ESMF\_CplCompAssignment(=) - CplComp assignment}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     interface assignment(=)
     cplcomp1 = cplcomp2\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp) :: cplcomp1
     type(ESMF_CplComp) :: cplcomp2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Assign cplcomp1 as an alias to the same ESMF CplComp object in memory
     as cplcomp2. If cplcomp2 is invalid, then cplcomp1 will be equally invalid after
     the assignment.
  
     The arguments are:
     \begin{description}
     \item[cplcomp1]
       The {\tt ESMF\_CplComp} object on the left hand side of the assignment.
     \item[cplcomp2]
       The {\tt ESMF\_CplComp} object on the right hand side of the assignment.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompOperator(==)] {ESMF\_CplCompOperator(==) - CplComp equality operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(==)
     if (cplcomp1 == cplcomp2) then ... endif
               OR
     result = (cplcomp1 == cplcomp2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(in) :: cplcomp1
     type(ESMF_CplComp), intent(in) :: cplcomp2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Test whether cplcomp1 and cplcomp2 are valid aliases to the same ESMF
     CplComp object in memory. For a more general comparison of two ESMF CplComps,
     going beyond the simple alias test, the ESMF\_CplCompMatch() function (not yet
     implemented) must be used.
  
     The arguments are:
     \begin{description}
     \item[cplcomp1]
       The {\tt ESMF\_CplComp} object on the left hand side of the equality
       operation.
     \item[cplcomp2]
       The {\tt ESMF\_CplComp} object on the right hand side of the equality
       operation.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompOperator(/=)] {ESMF\_CplCompOperator(/=) - CplComp not equal operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(/=)
     if (cplcomp1 /= cplcomp2) then ... endif
               OR
     result = (cplcomp1 /= cplcomp2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(in) :: cplcomp1
     type(ESMF_CplComp), intent(in) :: cplcomp2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Test whether cplcomp1 and cplcomp2 are {\it not} valid aliases to the
     same ESMF CplComp object in memory. For a more general comparison of two ESMF
     CplComps, going beyond the simple alias test, the ESMF\_CplCompMatch() function
     (not yet implemented) must be used.
  
     The arguments are:
     \begin{description}
     \item[cplcomp1]
       The {\tt ESMF\_CplComp} object on the left hand side of the non-equality
       operation.
     \item[cplcomp2]
       The {\tt ESMF\_CplComp} object on the right hand side of the non-equality
       operation.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompCreate] {ESMF\_CplCompCreate - Create a CplComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive function ESMF_CplCompCreate(config, configFile, &
     clock, petList, contextflag, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_CplComp) :: ESMF_CplCompCreate\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Config),       intent(in),  optional :: config
     character(len=*),        intent(in),  optional :: configFile
     type(ESMF_Clock),        intent(in),  optional :: clock
     integer,                 intent(in),  optional :: petList(:)
     type(ESMF_Context_Flag), intent(in),  optional :: contextflag
     character(len=*),        intent(in),  optional :: name
     integer,                 intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   This interface creates an {\tt ESMF\_CplComp} object. By default, a
   separate VM context will be created for each component.  This implies
   creating a new MPI communicator and allocating additional memory to
   manage the VM resources. When running on a large number of processors,
   creating a separate VM for each component could be both time and memory
   inefficient.  If the application is sequential, i.e., each component is
   running on all the PETs of the global VM, it will be more efficient to use
   the global VM instead of creating a new one.  This can be done by setting
   {\tt contextflag} to ESMF\_CONTEXT\_PARENT\_VM.
  
   The return value is the new {\tt ESMF\_CplComp}.
  
   The arguments are:
   \begin{description}
   \item[{[config]}]
     An already-created {\tt ESMF\_Config} object to be attached to the newly
     created component.
     If both {\tt config} and {\tt configFile} arguments are specified,
     {\tt config} takes priority.
   \item[{[configFile]}]
     The filename of an {\tt ESMF\_Config} format file.
     If specified, a new {\tt ESMF\_Config} object is created and attached to the
     newly created component. The {\tt configFile} file is opened and associated
     with the new config object.
     If both {\tt config} and {\tt configFile} arguments are specified,
     {\tt config} takes priority.
   \item[{[clock]}]
     \begin{sloppypar}
     Component-specific {\tt ESMF\_Clock}.  This clock is available to be
     queried and updated by the new {\tt ESMF\_CplComp} as it chooses.
     This should
     not be the parent component clock, which should be maintained and passed
     down to the initialize/run/finalize routines separately.
     \end{sloppypar}
   \item[{[petList]}]
     List of parent {\tt PET}s given to the created child component by the
     parent component. If {\tt petList} is not specified all of the
     parent {\tt PET}s will be given to the child component. The order of
     PETs in {\tt petList} determines how the child local PETs refer back to
     the parent PETs.
   \item[{[contextflag]}]
     Specify the component's VM context. The default context is
     {\tt ESMF\_CONTEXT\_OWN\_VM}. See section \ref{const:contextflag} for a
     complete list of valid flags.
   \item[{[name]}]
     Name of the newly-created {\tt ESMF\_CplComp}.  This name can be altered
     from within the {\tt ESMF\_CplComp} code once the initialization routine
     is called.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompDestroy] {ESMF\_CplCompDestroy - Release resources associated with a CplComp}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine ESMF_CplCompDestroy(cplcomp, &
     timeout, timeoutFlag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(inout)          :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),   optional :: timeout
     logical,            intent(out),  optional :: timeoutFlag
     integer,            intent(out),  optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[5.3.0] Added argument {\tt timeout}.
                Added argument {\tt timeoutFlag}.
                The new arguments provide access to the fault-tolerant component
                features.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Destroys an {\tt ESMF\_CplComp}, releasing the resources associated
   with the object.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     Release all resources associated with this {\tt ESMF\_CplComp}
     and mark the object as invalid.  It is an error to pass this
     object into any other routines after being destroyed.
   \item[{[timeout]}]
     The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The {\tt timeout} argument is only
     supported for connected dual components.
   \item[{[timeoutFlag]}]
     Returns {\tt .true.} if the timeout was reached, {\tt .false.} otherwise.
     If {\tt timeoutFlag} was {\em not} provided, a timeout condition will lead
     to a return code of {\tt rc \textbackslash = ESMF\_SUCCESS}. Otherwise the
     return value of {\tt timeoutFlag} is the sole indicator of a timeout
     condition.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompFinalize] {ESMF\_CplCompFinalize - Call the CplComp's finalize routine}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine ESMF_CplCompFinalize(cplcomp, &
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &
     userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[5.3.0] Added argument {\tt timeout}.
                Added argument {\tt timeoutFlag}.
                The new arguments provide access to the fault-tolerant component
                features.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Call the associated user-supplied finalization routine for
   an {\tt ESMF\_CplComp}.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     The {\tt ESMF\_CplComp} to call finalize routine for.
   \item[{[importState]}]
     {\tt ESMF\_State} containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   \item[{[exportState]}]
     {\tt ESMF\_State} containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   \item[{[clock]}]
     External {\tt ESMF\_Clock} for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   \item[{[syncflag]}]
     Blocking behavior of this method call. See section \ref{const:sync}
     for a list of valid blocking options. Default option is
     {\tt ESMF\_SYNC\_VASBLOCKING} which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   \item[{[phase]}]
     Component providers must document whether each of their
     routines are {\em single-phase} or {\em multi-phase}.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   \item[{[timeout]}]
     The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The {\tt timeout} argument is only
     supported for connected dual components.
   \item[{[timeoutFlag]}]
     Returns {\tt .true.} if the timeout was reached, {\tt .false.} otherwise.
     If {\tt timeoutFlag} was {\em not} provided, a timeout condition will lead
     to a return code of {\tt rc \textbackslash = ESMF\_SUCCESS}. Otherwise the
     return value of {\tt timeoutFlag} is the sole indicator of a timeout
     condition.
   \item[{[userRc]}]
     Return code set by {\tt userRoutine} before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompGet] {ESMF\_CplCompGet - Get CplComp information}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_CplCompGet(cplcomp, configIsPresent, config, &
     configFileIsPresent, configFile, clockIsPresent, clock, localPet, &
     petCount, contextflag, currentMethod, currentPhase, vmIsPresent, &
     vm, name, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),      intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                 intent(out), optional :: configIsPresent
     type(ESMF_Config),       intent(out), optional :: config
     logical,                 intent(out), optional :: configFileIsPresent
     character(len=*),        intent(out), optional :: configFile
     logical,                 intent(out), optional :: clockIsPresent
     type(ESMF_Clock),        intent(out), optional :: clock
     integer,                 intent(out), optional :: localPet
     integer,                 intent(out), optional :: petCount
     type(ESMF_Context_Flag), intent(out), optional :: contextflag
     type(ESMF_Method_Flag),  intent(out), optional :: currentMethod
     integer,                 intent(out), optional :: currentPhase
     logical,                 intent(out), optional :: vmIsPresent
     type(ESMF_VM),           intent(out), optional :: vm
     character(len=*),        intent(out), optional :: name
     integer,                 intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Get information about an {\tt ESMF\_CplComp} object.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     The {\tt ESMF\_CplComp} object being queried.
   \item[{[configIsPresent]}]
     {\tt .true.} if {\tt config} was set in CplComp object,
     {\tt .false.} otherwise.
   \item[{[config]}]
     Return the associated Config.
     It is an error to query for the Config if none is associated with
     the CplComp. If unsure, get {\tt configIsPresent} first to determine
     the status.
   \item[{[configFileIsPresent]}]
     {\tt .true.} if {\tt configFile} was set in CplComp object,
     {\tt .false.} otherwise.
   \item[{[configFile]}]
     Return the associated configuration filename.
     It is an error to query for the configuration filename if none is associated with
     the CplComp. If unsure, get {\tt configFileIsPresent} first to determine
     the status.
   \item[{[clockIsPresent]}]
     {\tt .true.} if {\tt clock} was set in CplComp object,
     {\tt .false.} otherwise.
   \item[{[clock]}]
     Return the associated Clock.
     It is an error to query for the Clock if none is associated with
     the CplComp. If unsure, get {\tt clockIsPresent} first to determine
     the status.
   \item[{[localPet]}]
     Return the local PET id within the {\tt ESMF\_CplComp} object.
   \item[{[petCount]}]
     Return the number of PETs in the the {\tt ESMF\_CplComp} object.
   \item[{[contextflag]}]
     Return the {\tt ESMF\_Context\_Flag} for this {\tt ESMF\_CplComp}.
     See section \ref{const:contextflag} for a complete list of valid flags.
   \item[{[currentMethod]}]
     Return the current {\tt ESMF\_Method\_Flag} of the {\tt ESMF\_CplComp} execution.
     See section \ref{const:method}  for a complete list of valid options.
   \item[{[currentPhase]}]
     Return the current {\tt phase} of the {\tt ESMF\_CplComp} execution.
   \item[{[vmIsPresent]}]
     {\tt .true.} if {\tt vm} was set in CplComp object,
     {\tt .false.} otherwise.
   \item[{[vm]}]
     Return the associated VM.
     It is an error to query for the VM if none is associated with
     the CplComp. If unsure, get {\tt vmIsPresent} first to determine
     the status.
   \item[{[name]}]
     Return the name of the {\tt ESMF\_CplComp}.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompGetInternalState] {ESMF\_CplCompGetInternalState - Get private data block pointer}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_CplCompGetInternalState(cplcomp, wrappedDataPointer, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)              :: cplcomp
     type(wrapper)                   :: wrappedDataPointer
     integer,            intent(out) :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Available to be called by an {\tt ESMF\_CplComp} at any time after
   {\tt ESMF\_CplCompSetInternalState} has been called.
   Since init, run, and finalize must be separate subroutines, data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by this call.
   When running multiple instantiations of an {\tt ESMF\_CplComp},
   for example during ensemble runs,
   it may be simpler to maintain private data specific to
   each run with private data blocks.  A corresponding
   {\tt ESMF\_CplCompSetInternalState} call sets the data pointer to
   this block, and this call retrieves the data pointer.
   Note that the {\tt wrappedDataPointer} argument needs to be a derived type
   which contains only a pointer of the type of the data block defined
   by the user.  When making this call the pointer needs to be unassociated.
   When the call returns, the pointer will now reference the original
   data block which was set during the previous call to
   {\tt ESMF\_CplCompSetInternalState}.
  
   Only the {\em last} data block set via
   {\tt ESMF\_CplCompSetInternalState} will be accessible.
  
   CAUTION: This method does not have an explicit Fortran interface. Do not
   specify argument keywords when calling this method!
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     An {\tt ESMF\_CplComp} object.
   \item[wrappedDataPointer]
     A derived type (wrapper), containing only an unassociated pointer
     to the private data block.
     The framework will fill in the pointer. When this call returns, the
     pointer is set to the same address set during the last
     {\tt ESMF\_CplCompSetInternalState} call.
     This level of indirection is needed to reliably set and retrieve
     the data block no matter which architecture or compiler is used.
   \item[rc]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompInitialize] {ESMF\_CplCompInitialize - Call the CplComp's initialize routine}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine ESMF_CplCompInitialize(cplcomp, &
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &
     userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[5.3.0] Added argument {\tt timeout}.
                Added argument {\tt timeoutFlag}.
                The new arguments provide access to the fault-tolerant component
                features.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Call the associated user initialization routine for
   an {\tt ESMF\_CplComp}.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to call initialize routine for.
   \item[{[importState]}]
     {\tt ESMF\_State} containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   \item[{[exportState]}]
     {\tt ESMF\_State} containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   \item[{[clock]}]
     External {\tt ESMF\_Clock} for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   \item[{[syncflag]}]
     Blocking behavior of this method call. See section \ref{const:sync}
     for a list of valid blocking options. Default option is
     {\tt ESMF\_SYNC\_VASBLOCKING} which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   \item[{[phase]}]
     Component providers must document whether each of their
     routines are {\em single-phase} or {\em multi-phase}.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   \item[{[timeout]}]
     The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The {\tt timeout} argument is only
     supported for connected dual components.
   \item[{[timeoutFlag]}]
     Returns {\tt .true.} if the timeout was reached, {\tt .false.} otherwise.
     If {\tt timeoutFlag} was {\em not} provided, a timeout condition will lead
     to a return code of {\tt rc \textbackslash = ESMF\_SUCCESS}. Otherwise the
     return value of {\tt timeoutFlag} is the sole indicator of a timeout
     condition.
   \item[{[userRc]}]
     Return code set by {\tt userRoutine} before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompIsCreated] {ESMF\_CplCompIsCreated - Check whether a CplComp object has been created}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   function ESMF_CplCompIsCreated(cplcomp, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: ESMF_CplCompIsCreated\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     Return {\tt .true.} if the {\tt cplcomp} has been created. Otherwise return
     {\tt .false.}. If an error occurs, i.e. {\tt rc /= ESMF\_SUCCESS} is
     returned, the return value of the function will also be {\tt .false.}.
  
   The arguments are:
     \begin{description}
     \item[cplcomp]
       {\tt ESMF\_CplComp} queried.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompIsPetLocal] {ESMF\_CplCompIsPetLocal - Inquire if this CplComp is to execute on the calling PET}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive function ESMF_CplCompIsPetLocal(cplcomp, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: ESMF_CplCompIsPetLocal\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Inquire if this {\tt ESMF\_CplComp} object is to execute on the calling PET.
  
   The return value is {\tt .true.} if the component is to execute on the
   calling PET, {\tt .false.} otherwise.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} queried.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompPrint] {ESMF\_CplCompPrint - Print CplComp information}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_CplCompPrint(cplcomp, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Prints information about an {\tt ESMF\_CplComp} to {\tt stdout}. \\
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to print.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompReadRestart] {ESMF\_CplCompReadRestart -- Call the CplComp's read restart routine}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine ESMF_CplCompReadRestart(cplcomp, &
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &
     userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[5.3.0] Added argument {\tt timeout}.
                Added argument {\tt timeoutFlag}.
                The new arguments provide access to the fault-tolerant component
                features.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Call the associated user read restart routine for
   an {\tt ESMF\_CplComp}.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to call run routine for.
   \item[{[importState]}]
     {\tt ESMF\_State} containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   \item[{[exportState]}]
     {\tt ESMF\_State} containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   \item[{[clock]}]
     External {\tt ESMF\_Clock} for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   \item[{[syncflag]}]
     Blocking behavior of this method call. See section \ref{const:sync}
     for a list of valid blocking options. Default option is
     {\tt ESMF\_SYNC\_VASBLOCKING} which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   \item[{[phase]}]
     Component providers must document whether each of their
     routines are {\em single-phase} or {\em multi-phase}.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   \item[{[timeout]}]
     The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The {\tt timeout} argument is only
     supported for connected dual components.
   \item[{[timeoutFlag]}]
     Returns {\tt .true.} if the timeout was reached, {\tt .false.} otherwise.
     If {\tt timeoutFlag} was {\em not} provided, a timeout condition will lead
     to a return code of {\tt rc \textbackslash = ESMF\_SUCCESS}. Otherwise the
     return value of {\tt timeoutFlag} is the sole indicator of a timeout
     condition.
   \item[{[userRc]}]
     Return code set by {\tt userRoutine} before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompRun] {ESMF\_CplCompRun - Call the CplComp's run routine}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine ESMF_CplCompRun(cplcomp, &
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &
     userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[5.3.0] Added argument {\tt timeout}.
                Added argument {\tt timeoutFlag}.
                The new arguments provide access to the fault-tolerant component
                features.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Call the associated user run routine for
   an {\tt ESMF\_CplComp}.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to call run routine for.
   \item[{[importState]}]
     {\tt ESMF\_State} containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   \item[{[exportState]}]
     {\tt ESMF\_State} containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   \item[{[clock]}]
     External {\tt ESMF\_Clock} for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   \item[{[syncflag]}]
     Blocking behavior of this method call. See section \ref{const:sync}
     for a list of valid blocking options. Default option is
     {\tt ESMF\_SYNC\_VASBLOCKING} which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   \item[{[phase]}]
     Component providers must document whether each of their
     routines are {\em single-phase} or {\em multi-phase}.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   \item[{[timeout]}]
     The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The {\tt timeout} argument is only
     supported for connected dual components.
   \item[{[timeoutFlag]}]
     Returns {\tt .true.} if the timeout was reached, {\tt .false.} otherwise.
     If {\tt timeoutFlag} was {\em not} provided, a timeout condition will lead
     to a return code of {\tt rc \textbackslash = ESMF\_SUCCESS}. Otherwise the
     return value of {\tt timeoutFlag} is the sole indicator of a timeout
     condition.
   \item[{[userRc]}]
     Return code set by {\tt userRoutine} before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompServiceLoop] {ESMF\_CplCompServiceLoop - Call the CplComp's service loop routine}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine ESMF_CplCompServiceLoop(cplcomp, &
     importState, exportState, clock, syncflag, port, timeout, timeoutFlag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: port
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Call the ServiceLoop routine for an {\tt ESMF\_CplComp}.
   This tries to establish a "component tunnel" between the {\em actual}
   Component (calling this routine) and a {\tt dual} Component connecting to it
   through a matching SetServices call.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to call service loop routine for.
   \item[{[importState]}]
     {\tt ESMF\_State} containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   \item[{[exportState]}]
     {\tt ESMF\_State} containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   \item[{[clock]}]
     External {\tt ESMF\_Clock} for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   \item[{[syncflag]}]
     Blocking behavior of this method call. See section \ref{const:sync}
     for a list of valid blocking options. Default option is
     {\tt ESMF\_SYNC\_VASBLOCKING} which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   \item[{[port]}]
     In case a port number is provided, the "component tunnel" is established
     using sockets. The actual component side, i.e. the side that calls into
     {\tt ESMF\_CplCompServiceLoop()}, starts to listen on the specified port
     as the server. The valid port range is [1024, 65535].
     In case the {\tt port} argument is {\em not} specified, the "component
     tunnel" is established within the same executable using local communication
     methods (e.g. MPI).
   \item[{[timeout]}]
     The maximum period in seconds that this call will wait for communications
     with the dual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour.
     (NOTE: Currently this option is only available for socket based component
     tunnels.)
   \item[{[timeoutFlag]}]
     Returns {\tt .true.} if the timeout was reached, {\tt .false.} otherwise.
     If {\tt timeoutFlag} was {\em not} provided, a timeout condition will lead
     to a return code of {\tt rc \textbackslash = ESMF\_SUCCESS}. Otherwise the
     return value of {\tt timeoutFlag} is the sole indicator of a timeout
     condition.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSet] {ESMF\_CplCompSet - Set or reset information about the CplComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_CplCompSet(cplcomp, config, configFile, &
     clock, name, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Config),  intent(in),  optional :: config
     character(len=*),   intent(in),  optional :: configFile
     type(ESMF_Clock),   intent(in),  optional :: clock
     character(len=*),   intent(in),  optional :: name
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Sets or resets information about an {\tt ESMF\_CplComp}.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to change.
   \item[{[name]}]
     Set the name of the {\tt ESMF\_CplComp}.
   \item[{[config]}]
     An already-created {\tt ESMF\_Config} object to be attached to the
     component.
     If both {\tt config} and {\tt configFile} arguments are specified,
     {\tt config} takes priority.
   \item[{[configFile]}]
     The filename of an {\tt ESMF\_Config} format file.
     If specified, a new {\tt ESMF\_Config} object is created and attached to the
     component. The {\tt configFile} file is opened and associated
     with the new config object.
     If both {\tt config} and {\tt configFile} arguments are specified,
     {\tt config} takes priority.
   \item[{[clock]}]
     Set the private clock for this {\tt ESMF\_CplComp}.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSetEntryPoint] {ESMF\_CplCompSetEntryPoint - Set user routine as entry point for standard Component method}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine ESMF_CplCompSetEntryPoint(cplcomp, methodflag, &
     userRoutine, phase, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),     intent(inout)         :: cplcomp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     interface
       subroutine userRoutine(cplcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: phase
     integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Registers a user-supplied {\tt userRoutine} as the entry point for one of the
   predefined Component {\tt methodflag}s. After this call the {\tt userRoutine}
   becomes accessible via the standard Component method API.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     An {\tt ESMF\_CplComp} object.
   \item[methodflag]
     \begin{sloppypar}
     One of a set of predefined Component methods - e.g.
     {\tt ESMF\_METHOD\_INITIALIZE}, {\tt ESMF\_METHOD\_RUN},
     {\tt ESMF\_METHOD\_FINALIZE}. See section \ref{const:method}
     for a complete list of valid method options.
     \end{sloppypar}
   \item[userRoutine]
     The user-supplied subroutine to be associated for this {\tt methodflag}.
     The Component writer must supply a subroutine with the exact interface
     shown above for the {\tt userRoutine} argument. Arguments in {\tt userRoutine}
     must not be declared as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: \ref{sec:AppDriverIntProc}
   \item[{[phase]}]
     The {\tt phase} number for multi-phase methods. For single phase
     methods the {\tt phase} argument can be omitted. The default setting
     is 1.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSetInternalState] {ESMF\_CplCompSetInternalState - Set private data block pointer}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_CplCompSetInternalState(cplcomp, wrappedDataPointer, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)              :: cplcomp
     type(wrapper)                   :: wrappedDataPointer
     integer,            intent(out) :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Available to be called by an {\tt ESMF\_CplComp} at any time, but
   expected to be
   most useful when called during the registration process, or initialization.
   Since init, run, and finalize must be separate subroutines data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by subsequent calls.
   When running multiple instantiations of an {\tt ESMF\_CplComp},
   for example during
   ensemble runs, it may be simpler to maintain private data specific to
   each run with private data blocks.  A corresponding
   {\tt ESMF\_CplCompGetInternalState} call retrieves the data pointer.
  
   Only the {\em last} data block set via
   {\tt ESMF\_CplCompSetInternalState} will be accessible.
  
   CAUTION: This method does not have an explicit Fortran interface. Do not
   specify argument keywords when calling this method!
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     An {\tt ESMF\_CplComp} object.
   \item[wrappedDataPointer]
     A pointer to the private data block, wrapped in a derived type which
     contains only a pointer to the block.  This level of indirection is
     needed to reliably set and retrieve the data block no matter which
     architecture or compiler is used.
   \item[rc]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSetServices] {ESMF\_CplCompSetServices - Call user routine to register CplComp methods}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine ESMF_CplCompSetServices(cplcomp, userRoutine, &
      userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(inout)         :: cplcomp
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: userRc
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   \label{CplComp:SetServices}
   Call into user provided {\tt userRoutine} which is responsible
   for setting Component's Initialize(), Run(), and Finalize() services.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     Coupler Component.
   \item[userRoutine]
    The Component writer must supply a subroutine with the exact interface
    shown above for the {\tt userRoutine} argument. Arguments in {\tt userRoutine}
    must not be declared as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: \ref{sec:AppDriverIntProc}
  
    \begin{sloppypar}
    The {\tt userRoutine}, when called by the framework, must make successive calls to
    {\tt ESMF\_CplCompSetEntryPoint()} to preset callback routines for standard
    Component Initialize(), Run(), and Finalize() methods.
    \end{sloppypar}
   \item[{[userRc]}]
     Return code set by {\tt userRoutine} before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSetServices] {ESMF\_CplCompSetServices - Call user routine through name lookup, to register CplComp methods}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_CplCompSetServices()
   recursive subroutine ESMF_CplCompSetServicesShObj(cplcomp, userRoutine, &
     sharedObj, userRoutineFound, userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),  intent(inout)         :: cplcomp
     character(len=*),    intent(in)            :: userRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: sharedObj
     logical,             intent(out), optional :: userRoutineFound
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[6.3.0r] Added argument {\tt userRoutineFound}.
                The new argument provides a way to test availability without
                causing error conditions.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   \label{CplComp:SetServicesShObj}
   Call into a user provided routine which is responsible for setting
   Component's Initialize(), Run(), and Finalize() services. The named
   {\tt userRoutine} must exist in the executable, or in the shared object
   specified by {\tt sharedObj}. In the latter case all of the platform
   specific details about dynamic linking and loading apply.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     Coupler Component.
   \item[userRoutine]
     Name of routine to be called, specified as a character string.
     The Component writer must supply a subroutine with the exact interface
     shown for {\tt userRoutine} below. Arguments must not be declared
     as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: \ref{sec:AppDriverIntProc}
  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface
         subroutine userRoutine(cplcomp, rc)
           type(ESMF_CplComp)   :: cplcomp    ! must not be optional
           integer, intent(out) :: rc         ! must not be optional
         end subroutine
       end interface\end{verbatim}
{\sf DESCRIPTION:\\ }


     \begin{sloppypar}
     The {\tt userRoutine}, when called by the framework, must make successive
     calls to {\tt ESMF\_CplCompSetEntryPoint()} to preset callback routines for
     standard Component Initialize(), Run(), and Finalize() methods.
     \end{sloppypar}
   \item[{[sharedObj]}]
     Name of shared object that contains {\tt userRoutine}. If the
     {\tt sharedObj} argument is not provided the executable itself will be
     searched for {\tt userRoutine}.
   \item[{[userRoutineFound]}]
     Report back whether the specified {\tt userRoutine} was found and executed,
     or was not available. If this argument is present, not finding the
     {\tt userRoutine} will not result in returning an error in {\tt rc}.
     The default is to return an error if the {\tt userRoutine} cannot be found.
   \item[{[userRc]}]
     Return code set by {\tt userRoutine} before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSetServices] {ESMF\_CplCompSetServices - Set to serve as Dual Component for an Actual Component}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_CplCompSetServices()
   recursive subroutine ESMF_CplCompSetServicesComp(cplcomp, &
     actualCplcomp, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(inout)         :: cplcomp
     type(ESMF_CplComp), intent(in)            :: actualCplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Set the services of a Coupler Component to serve a "dual" Component for an
   "actual" Component. The component tunnel is VM based.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     Dual Coupler Component.
   \item[actualCplcomp]
     Actual Coupler Component.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSetServices] {ESMF\_CplCompSetServices - Set to serve as Dual Component for an Actual Component through sockets}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_CplCompSetServices()
   recursive subroutine ESMF_CplCompSetServicesSock(cplcomp, port, &
     server, timeout, timeoutFlag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(inout)         :: cplcomp
     integer,            intent(in)            :: port
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),   intent(in),  optional :: server
     integer,            intent(in),  optional :: timeout
     logical,            intent(out), optional :: timeoutFlag
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Set the services of a Coupler Component to serve a "dual" Component for an
   "actual" Component. The component tunnel is socket based.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     Dual Coupler Component.
   \item[port]
     Port number under which the actual component is being served. The valid
     port range is [1024, 65535].
   \item[{[server]}]
     Server name where the actual component is being served. The default, i.e.
     if the {\tt server} argument was not provided, is {\tt localhost}.
   \item[{[timeout]}]
     The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour.
   \item[{[timeoutFlag]}]
     Returns {\tt .true.} if the timeout was reached, {\tt .false.} otherwise.
     If {\tt timeoutFlag} was {\em not} provided, a timeout condition will lead
     to a return code of {\tt rc \textbackslash = ESMF\_SUCCESS}. Otherwise the
     return value of {\tt timeoutFlag} is the sole indicator of a timeout
     condition.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSetVM] {ESMF\_CplCompSetVM - Call user routine to set CplComp VM properties}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine ESMF_CplCompSetVM(cplcomp, userRoutine, &
     userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(inout)         :: cplcomp
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: userRc
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Optionally call into user provided {\tt userRoutine} which is responsible
   for setting Component's VM properties.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     Coupler Component.
   \item[userRoutine]
     The Component writer must supply a subroutine with the exact interface
     shown above for the {\tt userRoutine} argument. Arguments in {\tt userRoutine}
     must not be declared as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: \ref{sec:AppDriverIntProc}
  
     The subroutine, when called by the framework, is expected to use any of the
     {\tt ESMF\_CplCompSetVMxxx()} methods to set the properties of the VM
     associated with the Coupler Component.
   \item[{[userRc]}]
     Return code set by {\tt userRoutine} before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSetVM] {ESMF\_CplCompSetVM - Call user routine through name lookup, to set CplComp VM properties}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_CplCompSetVM()
   recursive subroutine ESMF_CplCompSetVMShObj(cplcomp, userRoutine, &
     sharedObj, userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),  intent(inout)         :: cplcomp
     character(len=*),    intent(in)            :: userRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Optionally call into user provided {\tt userRoutine} which is responsible
   for setting Component's VM properties. The named
   {\tt userRoutine} must exist in the executable, or in the shared object
   specified by {\tt sharedObj}. In the latter case all of the platform
   specific details about dynamic linking and loading apply.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     Coupler Component.
   \item[userRoutine]
     Routine to be called, specified as a character string.
     The Component writer must supply a subroutine with the exact interface
     shown for {\tt userRoutine} below. Arguments must not be declared
     as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: \ref{sec:AppDriverIntProc}
  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface
         subroutine userRoutine(cplcomp, rc)
           type(ESMF_CplComp)   :: cplcomp     ! must not be optional
           integer, intent(out) :: rc          ! must not be optional
         end subroutine
       end interface\end{verbatim}
{\sf DESCRIPTION:\\ }


     The subroutine, when called by the framework, is expected to use any of the
     {\tt ESMF\_CplCompSetVMxxx()} methods to set the properties of the VM
     associated with the Coupler Component.
   \item[{[sharedObj]}]
     Name of shared object that contains {\tt userRoutine}. If the
     {\tt sharedObj} argument is not provided the executable itself will be
     searched for {\tt userRoutine}.
   \item[{[userRc]}]
     Return code set by {\tt userRoutine} before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSetVMMaxPEs] {ESMF\_CplCompSetVMMaxPEs - Associate PEs with PETs in CplComp VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_CplCompSetVMMaxPEs(cplcomp, &
     maxPeCountPerPet, prefIntraProcess, prefIntraSsi, prefInterSsi, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),  intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPeCountPerPet
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set characteristics of the {\tt ESMF\_VM} for this {\tt ESMF\_CplComp}.
     Attempts to associate up to {\tt maxPeCountPerPet} PEs with each PET. Only
     PEs that are located on the same single system image (SSI) can be associated
     with the same PET. Within this constraint the call tries to get as close as
     possible to the number specified by {\tt maxPeCountPerPet}.
  
     The other constraint to this call is that the number of PEs is preserved.
     This means that the child Component in the end is associated with as many
     PEs as the parent Component provided to the child. The number of child PETs
     however is adjusted according to the above rule.
  
     The typical use of {\tt ESMF\_CplCompSetVMMaxPEs()} is to allocate
     multiple PEs per PET in a Component for user-level threading, e.g. OpenMP.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to set the {\tt ESMF\_VM} for.
   \item[{[maxPeCountPerPet]}]
     Maximum number of PEs on each PET.
     Default for each SSI is the local number of PEs.
   \item[{[prefIntraProcess]}]
     Communication preference within a single process.
     {\em Currently options not documented. Use default.}
   \item[{[prefIntraSsi]}]
     Communication preference within a single system image (SSI).
     {\em Currently options not documented. Use default.}
   \item[{[prefInterSsi]}]
     Communication preference between different single system images (SSIs).
     {\em Currently options not documented. Use default.}
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSetVMMaxThreads] {ESMF\_CplCompSetVMMaxThreads - Set multi-threaded PETs in CplComp VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_CplCompSetVMMaxThreads(cplcomp, &
     maxPetCountPerVas, prefIntraProcess, prefIntraSsi, prefInterSsi, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),  intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPetCountPerVas
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set characteristics of the {\tt ESMF\_VM} for this {\tt ESMF\_CplComp}.
     Attempts to provide {\tt maxPetCountPerVas} threaded PETs in each
     virtual address space (VAS). Only as many threaded PETs as there are PEs
     located on the single system image (SSI) can be associated with the VAS.
     Within this constraint the call tries to get as close as possible to the
     number specified by {\tt maxPetCountPerVas}.
  
     The other constraint to this call is that the number of PETs is preserved.
     This means that the child Component in the end is associated with as many
     PETs as the parent Component provided to the child. The threading level of
     the child PETs however is adjusted according to the above rule.
  
     The typical use of {\tt ESMF\_CplCompSetVMMaxThreads()} is to run a
     Component multi-threaded with groups of PETs executing within a common
     virtual address space.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to set the {\tt ESMF\_VM} for.
   \item[{[maxPetCountPerVas]}]
     Maximum number of threaded PETs in each virtual address space (VAS).
     Default for each SSI is the local number of PEs.
   \item[{[prefIntraProcess]}]
     Communication preference within a single process.
     {\em Currently options not documented. Use default.}
   \item[{[prefIntraSsi]}]
     Communication preference within a single system image (SSI).
     {\em Currently options not documented. Use default.}
   \item[{[prefInterSsi]}]
     Communication preference between different single system images (SSIs).
     {\em Currently options not documented. Use default.}
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompSetVMMinThreads] {ESMF\_CplCompSetVMMinThreads - Set a reduced threading level in CplComp VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_CplCompSetVMMinThreads(cplcomp, &
     maxPeCountPerPet, prefIntraProcess, prefIntraSsi, prefInterSsi, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),  intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPeCountPerPet
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set characteristics of the {\tt ESMF\_VM} for this {\tt ESMF\_CplComp}.
     Reduces the number of threaded PETs in each VAS. The {\tt max} argument
     may be specified to limit the maximum number of PEs that a single PET
     can be associated with.
  
     Several constraints apply: 1) the number of PEs cannot change, 2) PEs
     cannot migrate between single system images (SSIs), 3) the number of PETs
     cannot increase, only decrease, 4) PETs cannot migrate between virtual
     address spaces (VASs), nor can VASs migrate between SSIs.
  
     The typical use of {\tt ESMF\_CplCompSetVMMinThreads()} is to run a
     Component across a set of single-threaded PETs.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to set the {\tt ESMF\_VM} for.
   \item[{[maxPeCountPerPet]}]
     Maximum number of PEs on each PET.
     Default for each SSI is the local number of PEs.
   \item[{[prefIntraProcess]}]
     Communication preference within a single process.
     {\em Currently options not documented. Use default.}
   \item[{[prefIntraSsi]}]
     Communication preference within a single system image (SSI).
     {\em Currently options not documented. Use default.}
   \item[{[prefInterSsi]}]
     Communication preference between different single system images (SSIs).
     {\em Currently options not documented. Use default.}
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompValidate] {ESMF\_CplCompValidate -- Ensure the CplComp is internally consistent}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_CplCompValidate(cplcomp, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp), intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Currently all this method does is to check that the {\tt cplcomp}
   was created.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to validate.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompWait] {ESMF\_CplCompWait - Wait for a CplComp to return}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_CplCompWait(cplcomp, syncflag, &
     timeout, timeoutFlag, userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),   intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Sync_Flag), intent(in),  optional :: syncflag
     integer,              intent(in),  optional :: timeout
     logical,              intent(out), optional :: timeoutFlag
     integer,              intent(out), optional :: userRc
     integer,              intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[5.3.0] Added argument {\tt timeout}.
                Added argument {\tt timeoutFlag}.
                The new arguments provide access to the fault-tolerant component
                features.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   When executing asynchronously, wait for an {\tt ESMF\_CplComp} to return.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to wait for.
   \item[{[syncflag]}]
     Blocking behavior of this method call. See section \ref{const:sync}
     for a list of valid blocking options. Default option is
     {\tt ESMF\_SYNC\_VASBLOCKING} which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   \item[{[timeout]}]
     The maximum period in seconds the actual component is allowed to execute
     a previously invoked component method before it must communicate back to
     the dual component. If the actual component does not communicate back in
     the specified time, a timeout condition is raised on the dual side (this
     side). The default is 3600, i.e. 1 hour. The {\tt timeout} argument is only
     supported for connected dual components.
   \item[{[timeoutFlag]}]
     Returns {\tt .true.} if the timeout was reached, {\tt .false.} otherwise.
     If {\tt timeoutFlag} was {\em not} provided, a timeout condition will lead
     to a return code of {\tt rc \textbackslash = ESMF\_SUCCESS}. Otherwise the
     return value of {\tt timeoutFlag} is the sole indicator of a timeout
     condition.
   \item[{[userRc]}]
     Return code set by {\tt userRoutine} before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_CplCompWriteRestart] {ESMF\_CplCompWriteRestart -- Call the CplComp's write restart routine}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine ESMF_CplCompWriteRestart(cplcomp, &
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &
     userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[5.3.0] Added argument {\tt timeout}.
                Added argument {\tt timeoutFlag}.
                The new arguments provide access to the fault-tolerant component
                features.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Call the associated user write restart routine for
   an {\tt ESMF\_CplComp}.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     {\tt ESMF\_CplComp} to call run routine for.
   \item[{[importState]}]
     {\tt ESMF\_State} containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   \item[{[exportState]}]
     {\tt ESMF\_State} containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   \item[{[clock]}]
     External {\tt ESMF\_Clock} for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   \item[{[syncflag]}]
     Blocking behavior of this method call. See section \ref{const:sync}
     for a list of valid blocking options. Default option is
     {\tt ESMF\_SYNC\_VASBLOCKING} which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   \item[{[phase]}]
     Component providers must document whether each of their
     routines are {\em single-phase} or {\em multi-phase}.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   \item[{[timeout]}]
     The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The {\tt timeout} argument is only
     supported for connected dual components.
   \item[{[timeoutFlag]}]
     Returns {\tt .true.} if the timeout was reached, {\tt .false.} otherwise.
     If {\tt timeoutFlag} was {\em not} provided, a timeout condition will lead
     to a return code of {\tt rc \textbackslash = ESMF\_SUCCESS}. Otherwise the
     return value of {\tt timeoutFlag} is the sole indicator of a timeout
     condition.
   \item[{[userRc]}]
     Return code set by {\tt userRoutine} before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
