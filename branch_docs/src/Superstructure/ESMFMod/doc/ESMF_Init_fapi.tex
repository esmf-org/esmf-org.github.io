%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_Init.F90,  Date: Tue May  5 21:00:19 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_Initialize] {ESMF\_Initialize - Initialize ESMF}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_Initialize(defaultConfigFileName, defaultCalKind, &
         defaultLogFileName, logappendflag, logkindflag, mpiCommunicator,  &
         ioUnitLBound, ioUnitUBound, vm, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),        intent(in),  optional :: defaultConfigFileName
       type(ESMF_CalKind_Flag), intent(in),  optional :: defaultCalKind
       character(len=*),        intent(in),  optional :: defaultLogFileName
       logical,                 intent(in),  optional :: logappendflag
       type(ESMF_LogKind_Flag), intent(in),  optional :: logkindflag
       integer,                 intent(in),  optional :: mpiCommunicator
       integer,                 intent(in),  optional :: ioUnitLBound
       integer,                 intent(in),  optional :: ioUnitUBound
       type(ESMF_VM),           intent(out), optional :: vm
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.0.0] Added argument {\tt logappendflag} to allow specifying that the existing
                log files will be overwritten.\newline
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       This method must be called once on each PET before
       any other ESMF methods are used.  The method contains a
       barrier before returning, ensuring that all processes
       made it successfully through initialization.
  
       Typically {\tt ESMF\_Initialize()} will call {\tt MPI\_Init()} 
       internally unless MPI has been initialized by the user code before
       initializing the framework. If the MPI initialization is left to
       {\tt ESMF\_Initialize()} it inherits all of the MPI implementation 
       dependent limitations of what may or may not be done before 
       {\tt MPI\_Init()}. For instance, it is unsafe for some MPI
       implementations, such as MPICH, to do I/O before the MPI environment
       is initialized. Please consult the documentation of your MPI
       implementation for details.
  
       Note that when using MPICH as the MPI library, ESMF needs to use
       the application command line arguments for {\tt MPI\_Init()}. However,
       ESMF acquires these arguments internally and the user does not need
       to worry about providing them. Also, note that ESMF does not alter
       the command line arguments, so that if the user obtains them they will
       be as specified on the command line (including those which MPICH would
       normally strip out).
  
       {\tt ESMF\_Initialize()} supports running ESMF inside a user MPI program.
       Details of this feature are discussed under the VM example 
       \ref{vm_inside_user_mpi}. It is not necessary that all MPI ranks are
       handed to ESMF. Section \ref{vm_nesting_esmf} shows how an MPI
       communicator can be used to execute ESMF on a subset of MPI ranks.
       Finally {\tt ESMF\_Initialize()} supports running multiple concurrent
       instances of ESMF under the same user MPI program. This feature is
       discussed under \ref{vm_multi_instance_esmf}.
  
       By default, {\tt ESMF\_Initialize()} will open multiple error log files,
       one per processor.  This is very useful for debugging purpose.  However,
       when running the application on a large number of processors, opening a
       large number of log files and writing log messages from all the processors
       could become a performance bottleneck.  Therefore, it is recommended
       to turn the Error Log feature off in these situations by setting
       {\tt logkindflag} to ESMF\_LOGKIND\_NONE.
  
       When integrating ESMF with applications where Fortran unit number conflicts
       exist, the optional {\tt ioUnitLBound} and {\tt ioUnitUBound} arguments may be
       used to specify an alternate unit number range.  See section \ref{fio:unitnumbers}
       for more information on how ESMF uses Fortran unit numbers.
  
       Before exiting the application the user must call {\tt ESMF\_Finalize()}
       to release resources and clean up ESMF gracefully.
  
       The arguments are:
       \begin{description}
       \item [{[defaultConfigFilename]}]
             Name of the default configuration file for the entire application.
       \item [{[defaultCalKind]}]
             Sets the default calendar to be used by ESMF Time Manager.
             See section \ref{const:calkindflag} for a list of valid options.
             If not specified, defaults to {\tt ESMF\_CALKIND\_NOCALENDAR}.
       \item [{[defaultLogFileName]}]
             Name of the default log file for warning and error messages.
             If not specified, defaults to {\tt ESMF\_ErrorLog}.
       \item [{[logappendflag]}]
             If the default log file already exists, a value of {\tt .false.}
             will set the file position to the beginning of the file.  A value
             of {\tt .true.} sets the position to the end of the file.
             If not specified, defaults to {\tt .true.}.
       \item [{[logkindflag]}]
             Sets the default Log Type to be used by ESMF Log Manager.
             See section \ref{const:logkindflag} for a list of valid options.
             If not specified, defaults to {\tt ESMF\_LOGKIND\_MULTI}.
       \item [{[mpiCommunicator]}]
             MPI communicator defining the group of processes on which the
             ESMF application is running.
             See section \ref{vm_nesting_esmf} and \ref{vm_multi_instance_esmf}
             for details.
             If not specified, defaults to {\tt MPI\_COMM\_WORLD}.
       \item [{[ioUnitLBound]}]
             Lower bound for Fortran unit numbers used within the ESMF library.
             Fortran units are primarily used for log files.  Legal unit numbers
             are positive integers.  A value higher than 10 is recommended
             in order to avoid the compiler-specific
             reservations which are typically found on the first few units.
             If not specified, defaults to {\tt ESMF\_LOG\_FORT\_UNIT\_NUMBER},
             which is distributed with a value of 50.
       \item [{[ioUnitUBound]}]
             Upper bound for Fortran unit numbers used within the ESMF library.
             Must be set to a value at least 5 units higher than {\tt ioUnitLBound}.
             If not specified, defaults to {\tt ESMF\_LOG\_UPPER}, which is
             distributed with a value of 99.
       \item [{[vm]}]
             Returns the global {\tt ESMF\_VM} that was created 
             during initialization.
       \item [{[rc]}]
             Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
       \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_IsInitialized] {ESMF\_IsInitialized - Query Initialized status of ESMF}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     function ESMF_IsInitialized(rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       logical :: ESMF_IsInitialized\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


       Returns {\tt .true.} if the framework has been initialized. This means 
       that {\tt ESMF\_Initialize()} has been called. Otherwise returns
       {\tt .false.}. If an error occurs, i.e. {\tt rc /= ESMF\_SUCCESS} is 
       returned, the return value of the function will also be {\tt .false.}.
  
       The arguments are:
       \begin{description}
       \item [{[rc]}]
             Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
       \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_IsFinalized] {ESMF\_IsFinalized - Query Finalized status of ESMF}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     function ESMF_IsFinalized(rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       logical :: ESMF_IsFinalized\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


       Returns {\tt .true.} if the framework has been finalized. This means 
       that {\tt ESMF\_Finalize()} has been called. Otherwise returns
       {\tt .false.}. If an error occurs, i.e. {\tt rc /= ESMF\_SUCCESS} is 
       returned, the return value of the function will also be {\tt .false.}.
  
       The arguments are:
       \begin{description}
       \item [{[rc]}]
             Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
       \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_Finalize] {ESMF\_Finalize - Clean up and shut down ESMF}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_Finalize(endflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_End_Flag), intent(in), optional  :: endflag
       integer,             intent(out), optional :: rc
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       This must be called once on each PET before the application exits
       to allow ESMF to flush buffers, close open connections, and 
       release internal resources cleanly. The optional argument 
       {\tt endflag} may be used to indicate the mode of termination.  
       Note that this call must be issued only once per PET with 
       {\tt endflag=ESMF\_END\_NORMAL}, and that this call may not be followed
       by {\tt ESMF\_Initialize()}.  This last restriction means that it is not
       possible to restart ESMF within the same execution.
  
       The arguments are:
       \begin{description}
       \item [{[endflag]}]
             Specify mode of termination. The default is {\tt ESMF\_END\_NORMAL}
             which waits for all PETs of the global VM to reach 
             {\tt ESMF\_Finalize()} before termination. See section 
             \ref{const:endflag} for a complete list and description of
             valid flags.
       \item [{[rc]}]
             Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
