%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_AttachMethods.F90,  Date: Tue May  5 21:00:11 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_MethodAdd] {ESMF\_MethodAdd - Attach user method to State}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodStateAdd(state, label, index, userRoutine, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     interface
       subroutine userRoutine(state, rc)
         use ESMF_StateMod
         implicit none
         type(ESMF_State)            :: state        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Attach {\tt userRoutine}.
  
   The arguments are:
   \begin{description}
   \item[state]
     The {\tt ESMF\_State} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[userRoutine]
     The user-supplied subroutine to be associated with the {\tt label}.
  
     The subroutine must have the exact interface shown above
     for the {\tt userRoutine} argument. Arguments in {\tt userRoutine}
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: \ref{sec:AppDriverIntProc}
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_MethodAdd] {ESMF\_MethodAdd - Attach user method, located in shared object, to State}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodStateAddShObj(state, label, index, userRoutine, &
     sharedObj, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Attach {\tt userRoutine}.
  
   The arguments are:
   \begin{description}
   \item[state]
     The {\tt ESMF\_State} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[userRoutine]
     Name of user-supplied subroutine to be associated with the {\tt label},
     specified as a character string.
  
     The subroutine must have the exact interface shown in {\tt ESMF\_MethodStateAdd}
     for the {\tt userRoutine} argument. Arguments in {\tt userRoutine}
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: \ref{sec:AppDriverIntProc}
 
   \item[{[sharedObj]}]
     Name of shared object that contains {\tt userRoutine}. If the
     {\tt sharedObj} argument is not provided the executable itself will be
     searched for {\tt userRoutine}.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_MethodExecute] {ESMF\_MethodExecute - Execute user method attached to State}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodExecute()
   recursive subroutine ESMF_MethodStateExecute(state, label, index, existflag, &
     userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     logical,          intent(out), optional :: existflag
     integer,          intent(out), optional :: userRc
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Execute attached method.
  
   The arguments are:
   \begin{description}
   \item[state]
     The {\tt ESMF\_State} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[{[existflag]}]
     Returned {\tt .true.} indicates that the method specified by {\tt label}
     exists and was executed. A return value of {\tt .false.} indicates that
     the method does not exist and consequently was not executed. By default,
     i.e. if {\tt existflag} was not specified, the latter condition will lead
     to {\tt rc} not equal {\tt ESMF\_SUCCESS} being returned. However, if
     {\tt existflag} was specified, a method not existing is not an error
     condition.
   \item[{[userRc]}]
     Return code set by attached method before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_MethodRemove] {ESMF\_MethodRemove - Remove user method attached to State}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodRemove()
   subroutine ESMF_MethodStateRemove(state, label, index, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Remove attached method.
  
   The arguments are:
   \begin{description}
   \item[state]
     The {\tt ESMF\_State} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_MethodAdd] {ESMF\_MethodAdd - Attach user method to GridComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodGridCompAdd(gcomp, label, index, userRoutine, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     interface
       subroutine userRoutine(gcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_GridComp)         :: gcomp        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Attach {\tt userRoutine}.
  
   The arguments are:
   \begin{description}
   \item[gcomp]
     The {\tt ESMF\_GridComp} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[userRoutine]
     The user-supplied subroutine to be associated with the {\tt label}.
  
     The subroutine must have the exact interface shown above
     for the {\tt userRoutine} argument. Arguments in {\tt userRoutine}
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: \ref{sec:AppDriverIntProc}
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_MethodAdd] {ESMF\_MethodAdd - Attach user method, located in shared object, to GridComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodGridCompAddShObj(gcomp, label, index, userRoutine, &
     sharedObj, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Attach {\tt userRoutine}.
  
   The arguments are:
   \begin{description}
   \item[gcomp]
     The {\tt ESMF\_GridComp} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[userRoutine]
     Name of user-supplied subroutine to be associated with the {\tt label},
     specified as a character string.
  
     The subroutine must have the exact interface shown in {\tt ESMF\_MethodGridCompAdd}
     for the {\tt userRoutine} argument. Arguments in {\tt userRoutine}
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: \ref{sec:AppDriverIntProc}
   \item[{[sharedObj]}]
     Name of shared object that contains {\tt userRoutine}. If the
     {\tt sharedObj} argument is not provided the executable itself will be
     searched for {\tt userRoutine}.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_MethodAdd] {ESMF\_MethodAdd - Attach user method to CplComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodCplCompAdd(cplcomp, label, index, userRoutine, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Attach {\tt userRoutine}.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     The {\tt ESMF\_CplComp} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[userRoutine]
     The user-supplied subroutine to be associated with the {\tt label}.
  
     The subroutine must have the exact interface shown above
     for the {\tt userRoutine} argument. Arguments in {\tt userRoutine}
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: \ref{sec:AppDriverIntProc}
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_MethodAdd] {ESMF\_MethodAdd - Attach user method, located in shared object, to CplComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodCplCompAddShObj(cplcomp, label, index, userRoutine, &
     sharedObj, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Attach {\tt userRoutine}.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     The {\tt ESMF\_CplComp} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[userRoutine]
     Name of user-supplied subroutine to be associated with the {\tt label},
     specified as a character string.
  
     The subroutine must have the exact interface shown in {\tt ESMF\_MethodCplCompAdd}
     for the {\tt userRoutine} argument. Arguments in {\tt userRoutine}
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: \ref{sec:AppDriverIntProc}
   \item[{[sharedObj]}]
     Name of shared object that contains {\tt userRoutine}. If the
     {\tt sharedObj} argument is not provided the executable itself will be
     searched for {\tt userRoutine}.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_MethodExecute] {ESMF\_MethodExecute - Execute user method attached to GridComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodExecute()
   recursive subroutine ESMF_MethodGridCompExecute(gcomp, label, index, existflag, &
     userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     logical,          intent(out), optional :: existflag
     integer,          intent(out), optional :: userRc
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Execute attached method.
  
   The arguments are:
   \begin{description}
   \item[gcomp]
     The {\tt ESMF\_GridComp} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[{[existflag]}]
     Returned {\tt .true.} indicates that the method specified by {\tt label}
     exists and was executed. A return value of {\tt .false.} indicates that
     the method does not exist and consequently was not executed. By default,
     i.e. if {\tt existflag} was not specified, the latter condition will lead
     to {\tt rc} not equal {\tt ESMF\_SUCCESS} being returned. However, if
     {\tt existflag} was specified, a method not existing is not an error
     condition.
   \item[{[userRc]}]
     Return code set by attached method before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_MethodExecute] {ESMF\_MethodExecute - Execute user method attached to CplComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodExecute()
   recursive subroutine ESMF_MethodCplCompExecute(cplcomp, label, index, existflag, &
     userRc, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     logical,          intent(out), optional :: existflag
     integer,          intent(out), optional :: userRc
     integer,          intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Execute attached method.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     The {\tt ESMF\_CplComp} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[{[existflag]}]
     Returned {\tt .true.} indicates that the method specified by {\tt label}
     exists and was executed. A return value of {\tt .false.} indicates that
     the method does not exist and consequently was not executed. By default,
     i.e. if {\tt existflag} was not specified, the latter condition will lead
     to {\tt rc} not equal {\tt ESMF\_SUCCESS} being returned. However, if
     {\tt existflag} was specified, a method not existing is not an error
     condition.
   \item[{[userRc]}]
     Return code set by attached method before returning.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_MethodRemove] {ESMF\_MethodRemove - Remove user method attached to GridComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodRemove()
   subroutine ESMF_MethodGridCompRemove(gcomp, label, index, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_GridComp)                      :: gcomp
     character(len=*),  intent(in)            :: label
      integer,          intent(in),  optional :: index
    integer,            intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Remove attached method.
  
   The arguments are:
   \begin{description}
   \item[gcomp]
     The {\tt ESMF\_GridComp} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_MethodRemove] {ESMF\_MethodRemove - Remove user method attached to CplComp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_MethodRemove()
   subroutine ESMF_MethodCplCompRemove(cplcomp, label, index, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     integer,          intent(out), optional :: rc \end{verbatim}
{\sf DESCRIPTION:\\ }


   Remove attached method.
  
   The arguments are:
   \begin{description}
   \item[cplcomp]
     The {\tt ESMF\_CplComp} to attach to.
   \item[label]
     Label of method.
   \item[{[index]}]
     Integer modifier to distinguish multiple entries with the same {\tt label}.
   \item[{[rc]}]
     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
