%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_OTree.C,  Date: Tue May  5 20:59:52 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [OTree] {OTree}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} OTree::OTree(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Pointer to a new OTree\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} 
              int max_size
 
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Construct OTree 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [~OTree] {~OTree}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}  OTree::~OTree(void){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   none\end{verbatim}
{\sf DESCRIPTION:\\ }


    Destructor for OTree, deallocates all internal memory, etc.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [add] {add}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void OTree::add(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                double min[3],
                double max[3],
                void *data
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


   Add an item to the OTree min,max gives the boundaries of the item and data
   represents the item. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [commit] {commit}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void OTree::commit(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    none
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


   Build tree from previously added items 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [add\_commit] {add\_commit}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void OTree::add_commit(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                double min[3],
                double max[3],
                void *data
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


   Add an item to the OTree min,max gives the boundaries of the item and data
   represents the item, also commit the item to the tree. This is in contrast
   to the add() function which just adds an item in preparation for the commit
   which adds all of the items which have been previously added to the tree. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [runon] {runon}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int OTree::runon(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    user func return\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                double min[3],
                double max[3],
                int (*func)(void *data,void *func_data),
                void *func_data
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


   Run func on each object in the tree whose min-max box overlaps the input min-max.
   If func returns anything but 0, then the process stops and runon returns what func returned. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [runon\_mm\_chng] {runon\_mm\_chng}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int OTree::runon_mm_chng(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    user func return\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                double init_min[3],
                double init_max[3],
                int (*func)(void *data,void *func_data, double *min, double *max),
                void *func_data
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


   Run func on each object in the tree whose min-max box overlaps the min-max.
   The min-max can change over the run, as output from func.  The initial min-max
   used to find the first node is init_min, init_max.
   If func returns anything but 0, then the process stops and runon returns what func returned.
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
