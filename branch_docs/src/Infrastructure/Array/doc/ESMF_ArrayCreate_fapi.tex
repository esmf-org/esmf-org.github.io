%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_ArrayCreate.F90,  Date: Tue May  5 20:59:42 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_ArrayAssignment(=)] {ESMF\_ArrayAssignment(=) - Array assignment}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface assignment(=)
   array1 = array2\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Array) :: array1
   type(ESMF_Array) :: array2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Assign array1 as an alias to the same ESMF Array object in memory
   as array2. If array2 is invalid, then array1 will be equally invalid after
   the assignment.
  
   The arguments are:
   \begin{description}
   \item[array1]
   The {\tt ESMF\_Array} object on the left hand side of the assignment.
   \item[array2]
   The {\tt ESMF\_Array} object on the right hand side of the assignment.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayOperator(==)] {ESMF\_ArrayOperator(==) - Array equality operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(==)
   if (array1 == array2) then ... endif
   OR
   result = (array1 == array2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Array), intent(in) :: array1
   type(ESMF_Array), intent(in) :: array2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Test whether array1 and array2 are valid aliases to the same ESMF
   Array object in memory. For a more general comparison of two ESMF Arrays,
   going beyond the simple alias test, the ESMF\_ArrayMatch() function (not yet
   implemented) must be used.
  
   The arguments are:
   \begin{description}
   \item[array1]
   The {\tt ESMF\_Array} object on the left hand side of the equality
   operation.
   \item[array2]
   The {\tt ESMF\_Array} object on the right hand side of the equality
   operation.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayOperator(/=)] {ESMF\_ArrayOperator(/=) - Array not equal operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(/=)
   if (array1 /= array2) then ... endif
   OR
   result = (array1 /= array2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Array), intent(in) :: array1
   type(ESMF_Array), intent(in) :: array2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Test whether array1 and array2 are {\it not} valid aliases to the
   same ESMF Array object in memory. For a more general comparison of two ESMF
   Arrays, going beyond the simple alias test, the ESMF\_ArrayMatch() function
   (not yet implemented) must be used.
  
   The arguments are:
   \begin{description}
   \item[array1]
   The {\tt ESMF\_Array} object on the left hand side of the non-equality
   operation.
   \item[array2]
   The {\tt ESMF\_Array} object on the right hand side of the non-equality
   operation.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCopy] {ESMF\_ArrayCopy - Copy data from one Array object to another}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_ArrayCopy(arrayOut, arrayIn, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type(ESMF_Array), intent(inout) :: arrayOut
        type(ESMF_Array), intent(in) :: arrayIn
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Copy data from one {\tt ESMF\_Array} object to another.
  
   The arguments are:
   \begin{description}
   \item[arrayOut]
   {\tt ESMF\_Array} object into which to copy the data. The incoming
   {\tt arrayOut} must already references a matching memory allocation.
   \item[arrayIn]
   {\tt ESMF\_Array} object that holds the data to be copied.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate - Create Array object from Fortran array pointer }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateFrmPtr<rank><type><kind>(distgrid, farrayPtr, & 
   datacopyflag, distgridToArrayMap, computationalEdgeLWidth, & 
   computationalEdgeUWidth, computationalLWidth, & 
   computationalUWidth, totalLWidth, & 
   totalUWidth, name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Array) :: ESMF_ArrayCreateDataPtr<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_DistGrid), intent(in) :: distgrid 
   <type> (ESMF_KIND_<kind>), pointer :: farrayPtr(<rank>) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   integer, intent(in), optional :: computationalEdgeLWidth(:) 
   integer, intent(in), optional :: computationalEdgeUWidth(:) 
   integer, intent(in), optional :: computationalLWidth(:) 
   integer, intent(in), optional :: computationalUWidth(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf STATUS:}
   \begin{itemize} 
   \item\apiStatusCompatibleVersion{5.2.0r} 
   \end{itemize} 
   
{\sf DESCRIPTION:\\ }

 
   Create an {\tt ESMF\_Array} object from existing local native Fortran 
   arrays with pointer attribute. The decomposition and distribution is 
   specified by the {\tt distgrid} argument. Each PET must issue this call 
   with identical arguments in order to create a consistent Array object. 
   The only exception is the {\tt farrayPtr} argument which will be different 
   on each PET. The bounds of the local arrays are preserved by this call and 
   determine the bounds of the total region of the 
   resulting Array object. Bounds of the DE-local exclusive regions are set 
   to be consistent with the total regions and the specified {\tt distgrid} 
   argument. Bounds for Array dimensions that are not distributed are 
   automatically set to the bounds provided by {\tt farrayPtr}. 
   
   This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 
   
   The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   {\tt ESMF\_ArraySet()} to change these default settings after the 
   Array object has been created. 
   
   The return value is the newly created {\tt ESMF\_Array} object. 
   
   The arguments are: 
   \begin{description} 
   \item[distgrid] 
   {\tt ESMF\_DistGrid} object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of {\tt farrayPtr}. 
   \item[farrayPtr] 
   Valid native Fortran array with pointer attribute. Memory must be 
   associated with the actual argument. The type/kind/rank information of 
   {\tt farrayPtr} will be used to set {\tt Array}'s properties 
   accordingly. The shape of {\tt farrayPtr} will be checked against the 
   information contained in the {\tt distgrid}. The bounds of 
   {\tt farrayPtr} will be preserved by this call and the bounds of the 
   resulting Array object are set accordingly. 
   \item[{[datacopyflag]}] 
   Specifies whether the Array object will reference the memory allocation 
   provided by {\tt farrayPtr} directly or will copy the data from 
   {\tt farrayPtr} into a new memory allocation. For valid values see 
   \ref{const:datacopyflag}. The default is {\tt ESMF\_DATACOPY\_REFERENCE}. 
   Note that the {\tt ESMF\_DATACOPY\_REFERENCE} option may not be safe 
   when providing an array slice in {\tt farrayPtr}. 
   \item[{[distgridToArrayMap]}] 
   List that contains as many elements as is indicated by 
   {\tt distgrids}'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in {\tt farrayPtr} by specifying the 
   appropriate Array dimension index. The default is to map all of 
   {\tt distgrid}'s dimensions against the lower dimensions of the 
   {\tt farrayPtr} argument in sequence, i.e. {\tt distgridToArrayMap = 
   (/1, 2, .../)}. 
   Unmapped {\tt farrayPtr} dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All {\tt distgridToArrayMap} entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the {\tt distgridToArrayMap} 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   \item[{[computationalEdgeLWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   \item[{[computationalEdgeUWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   \item[{[computationalLWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region. 
   The default is a zero vector. 
   \item[{[computationalUWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region. 
   The default is a zero vector. 
   \item[{[totalLWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the total memory 
   region with respect to the lower corner of the exclusive region. 
   The default is to accommodate the union of exclusive and computational 
   region exactly. 
   \item[{[totalUWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the total memory 
   region with respect to the upper corner of the exclusive region. 
   The default is a vector that contains the remaining number of elements 
   in each direction as to fit the union of exclusive and computational 
   region into the memory region provided by the {\tt farrayPtr} argument. 
   \item[{[name]}] 
   Name of the Array object. 
   \item[{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate - Create Array object from Fortran array pointer w/ arbitrary seqIndices for halo}


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateFrmPtrArb<indexkind><rank><type><kind>(distgrid, & 
   farrayPtr, haloSeqIndexList, datacopyflag, & 
   distgridToArrayMap, name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Array) :: ESMF_ArrayCreateDataPtrArb<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_DistGrid), intent(in) :: distgrid 
   <type> (ESMF_KIND_<kind>), pointer :: farrayPtr(<rank>) 
   integer(ESMF_KIND_<indexkind>), intent(in) :: haloSeqIndexList(:) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf STATUS:}
   \begin{itemize} 
   \item\apiStatusCompatibleVersion{5.2.0r} 
   \end{itemize} 
   
{\sf DESCRIPTION:\\ }

 
   Create an {\tt ESMF\_Array} object from existing local native Fortran 
   arrays with pointer attribute, according to distgrid. Besides 
   {\tt farrayPtr} each PET must issue this call with identical arguments in 
   order to create a consistent Array object. The bounds of the local arrays 
   are preserved by this call and determine the bounds of the total region of 
   the resulting Array object. Bounds of the DE-local exclusive regions are 
   set to be consistent with the total regions and the specified distgrid 
   argument. Bounds for Array dimensions that are not distributed are 
   automatically set to the bounds provided by {\tt farrayPtr}. 
   
   This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 
   
   The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   {\tt ESMF\_ArraySet()} to change these default settings after the 
   Array object has been created. 
   
   The return value is the newly created {\tt ESMF\_Array} object. 
   
   The arguments are: 
   \begin{description} 
   \item[distgrid] 
   {\tt ESMF\_DistGrid} object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of {\tt farrayPtr}. 
   \item[farrayPtr] 
   Valid native Fortran array with pointer attribute. Memory must be 
   associated with the actual argument. The type/kind/rank information of 
   {\tt farrayPtr} will be used to set {\tt Array}'s properties 
   accordingly. The shape of {\tt farrayPtr} will be checked against the 
   information contained in the {\tt distgrid}. The bounds of 
   {\tt farrayPtr} will be preserved by this call and the bounds of the 
   resulting Array object are set accordingly. 
   \item[haloSeqIndexList] 
   One dimensional array containing sequence indices of local halo region. 
   The size (and content) of {\tt haloSeqIndexList} can (and typically will) 
   be different on each PET. 
   The {\tt haloSeqIndexList} argument is of integer type, but can be of 
   different kind in order to support both 32-bit ({\tt ESMF\_KIND\_I4}) 
   and 64-bit ({\tt ESMF\_KIND\_I8}) indexing. 
   \item[{[datacopyflag]}] 
   Specifies whether the Array object will reference the memory allocation 
   provided by {\tt farrayPtr} directly or will copy the data from 
   {\tt farrayPtr} into a new memory allocation. For valid values see 
   \ref{const:datacopyflag}. The default is {\tt ESMF\_DATACOPY\_REFERENCE}. 
   Note that the {\tt ESMF\_DATACOPY\_REFERENCE} option may not be safe 
   when providing an array slice in {\tt farrayPtr}. 
   \item[{[distgridToArrayMap]}] 
   List that contains as many elements as is indicated by 
   {\tt distgrids}'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in {\tt farrayPtr} by specifying the 
   appropriate Array dimension index. The default is to map all of 
   {\tt distgrid}'s dimensions against the lower dimensions of the 
   {\tt farrayPtr} argument in sequence, i.e. {\tt distgridToArrayMap = 
   (/1, 2, .../)}. 
   Unmapped {\tt farrayPtr} dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All {\tt distgridToArrayMap} entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the {\tt distgridToArrayMap} 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   \item[{[name]}] 
   Name of the Array object. 
   \item[{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate - Create Array object from Fortran array }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateAsmdSp<rank><type><kind>(distgrid, farray, & 
   indexflag, datacopyflag, distgridToArrayMap, & 
   computationalEdgeLWidth, computationalEdgeUWidth, computationalLWidth, & 
   computationalUWidth, totalLWidth, & 
   totalUWidth, undistLBound, undistUBound, name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Array) :: ESMF_ArrayCreateDataAssmdShape<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_DistGrid), intent(in) :: distgrid 
   <type> (ESMF_KIND_<kind>), intent(in), target :: farray(<rank>) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   integer, intent(in), optional :: computationalEdgeLWidth(:) 
   integer, intent(in), optional :: computationalEdgeUWidth(:) 
   integer, intent(in), optional :: computationalLWidth(:) 
   integer, intent(in), optional :: computationalUWidth(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(in), optional :: undistLBound(:) 
   integer, intent(in), optional :: undistUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf STATUS:}
   \begin{itemize} 
   \item\apiStatusCompatibleVersion{5.2.0r} 
   \end{itemize} 
   
{\sf DESCRIPTION:\\ }

 
   Create an {\tt ESMF\_Array} object from an existing local native Fortran 
   array. The decomposition and distribution is 
   specified by the {\tt distgrid} argument. Each PET must issue this call 
   with identical arguments in order to create a consistent Array object. 
   The only exception is the {\tt farray} argument which will be different 
   on each PET. The local arrays provided must be dimensioned according to 
   the DE-local total region. Bounds of the exclusive regions are set as 
   specified in the {\tt distgrid} argument. Bounds for Array dimensions 
   that are not distributed can be chosen freely using the 
   {\tt undistLBound} and {\tt undistUBound} arguments. 
   
   This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 
   
   The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   {\tt ESMF\_ArraySet()} to change these default settings after the 
   Array object has been created. 
   
   The return value is the newly created {\tt ESMF\_Array} object. 
   
   The arguments are: 
   \begin{description} 
   \item[distgrid] 
   {\tt ESMF\_DistGrid} object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of farray. 
   \item[farray] 
   Valid native Fortran array, i.e. memory must be associated with the 
   actual argument. The type/kind/rank information of {\tt farray} will be 
   used to set {\tt Array}'s properties accordingly. The shape of 
   {\tt farray} will be checked against the information contained in the 
   {\tt distgrid}. 
   \item[indexflag] 
   Indicate how DE-local indices are defined. See section 
   \ref{const:indexflag} for a list of valid indexflag options. 
   \item[{[datacopyflag]}] 
   Specifies whether the Array object will reference the memory allocation 
   provided by {\tt farray} directly or will copy the data from 
   {\tt farray} into a new memory allocation. For valid values see 
   \ref{const:datacopyflag}. The default is {\tt ESMF\_DATACOPY\_REFERENCE}. 
   Note that the {\tt ESMF\_DATACOPY\_REFERENCE} option may not be safe 
   when providing an array slice in {\tt farray}. 
   \item[{[distgridToArrayMap]}] 
   List that contains as many elements as is indicated by 
   {\tt distgrids}'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in {\tt farray} by specifying the 
   appropriate Array dimension index. The default is to map all of 
   {\tt distgrid}'s dimensions against the lower dimensions of the 
   {\tt farray} argument in sequence, i.e. {\tt distgridToArrayMap = 
   (/1, 2, .../)}. 
   Unmapped {\tt farray} dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All {\tt distgridToArrayMap} entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the {\tt distgridToArrayMap} 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   \item[{[computationalEdgeLWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   \item[{[computationalEdgeUWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   \item[{[computationalLWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region. 
   The default is a zero vector. 
   \item[{[computationalUWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region. 
   The default is a zero vector. 
   \item[{[totalLWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the total memory 
   region with respect to the lower corner of the exclusive region. 
   The default is to accommodate the union of exclusive and computational 
   region exactly. 
   \item[{[totalUWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the total memory 
   region with respect to the upper corner of the exclusive region. 
   The default is a vector that contains the remaining number of elements 
   in each direction as to fit the union of exclusive and computational 
   region into the memory region provided by the {\tt farray} argument. 
   \item[{[undistLBound]}] 
   Lower bounds for the array dimensions that are not distributed. 
   By default lbound is 1. 
   \item[{[undistUBound]}] 
   Upper bounds for the array dimensions that are not distributed. 
   By default ubound is equal to the extent of the corresponding 
   dimension in {\tt farray}. 
   \item[{[name]}] 
   Name of the Array object. 
   \item[{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate - Create Array object from Fortran array w/ arbitrary seqIndices for halo}


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateAsmdSpArb<indexkind><rank><type><kind>(distgrid, & 
   farray, indexflag, haloSeqIndexList, datacopyflag, & 
   distgridToArrayMap, computationalEdgeLWidth, computationalEdgeUWidth, & 
   computationalLWidth, computationalUWidth, totalLWidth, totalUWidth, & 
   undistLBound, undistUBound, name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Array) :: ESMF_ArrayCreateDataAssmdShapeArb<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_DistGrid), intent(in) :: distgrid 
   <type> (ESMF_KIND_<kind>), intent(in), target :: farray(<rank>) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
   integer(ESMF_KIND_<indexkind>), intent(in) :: haloSeqIndexList(:) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   integer, intent(in), optional :: computationalEdgeLWidth(:) 
   integer, intent(in), optional :: computationalEdgeUWidth(:) 
   integer, intent(in), optional :: computationalLWidth(:) 
   integer, intent(in), optional :: computationalUWidth(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(in), optional :: undistLBound(:) 
   integer, intent(in), optional :: undistUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf STATUS:}
   \begin{itemize} 
   \item\apiStatusCompatibleVersion{5.2.0r} 
   \end{itemize} 
   
{\sf DESCRIPTION:\\ }

 
   Create an {\tt ESMF\_Array} object from an existing local native Fortran 
   array. The decomposition and distribution is 
   specified by the {\tt distgrid} argument. Each PET must issue this call 
   with identical arguments in order to create a consistent Array object. 
   The only exception is the {\tt farray} argument which will be different 
   on each PET. The local arrays provided must be dimensioned according to 
   the DE-local total region. Bounds of the exclusive regions are set as 
   specified in the {\tt distgrid} argument. Bounds for Array dimensions 
   that are not distributed can be chosen freely using the 
   {\tt undistLBound} and {\tt undistUBound} arguments. 
   
   This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 
   
   The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   {\tt ESMF\_ArraySet()} to change these default settings after the 
   Array object has been created. 
   
   The return value is the newly created {\tt ESMF\_Array} object. 
   
   The arguments are: 
   \begin{description} 
   \item[distgrid] 
   {\tt ESMF\_DistGrid} object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of farray. 
   \item[farray] 
   Valid native Fortran array, i.e. memory must be associated with the 
   actual argument. The type/kind/rank information of {\tt farray} will be 
   used to set {\tt Array}'s properties accordingly. The shape of 
   {\tt farray} will be checked against the information contained in the 
   {\tt distgrid}. 
   \item[indexflag] 
   Indicate how DE-local indices are defined. See section 
   \ref{const:indexflag} for a list of valid indexflag options. 
   \item[haloSeqIndexList] 
   One dimensional array containing sequence indices of local halo region. 
   The size (and content) of {\tt haloSeqIndexList} can (and typically will) 
   be different on each PET. 
   The {\tt haloSeqIndexList} argument is of integer type, but can be of 
   different kind in order to support both 32-bit ({\tt ESMF\_KIND\_I4}) 
   and 64-bit ({\tt ESMF\_KIND\_I8}) indexing. 
   \item[{[datacopyflag]}] 
   Specifies whether the Array object will reference the memory allocation 
   provided by {\tt farray} directly or will copy the data from 
   {\tt farray} into a new memory allocation. For valid values see 
   \ref{const:datacopyflag}. The default is {\tt ESMF\_DATACOPY\_REFERENCE}. 
   Note that the {\tt ESMF\_DATACOPY\_REFERENCE} option may not be safe 
   when providing an array slice in {\tt farray}. 
   \item[{[distgridToArrayMap]}] 
   List that contains as many elements as is indicated by 
   {\tt distgrids}'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in {\tt farray} by specifying the 
   appropriate Array dimension index. The default is to map all of 
   {\tt distgrid}'s dimensions against the lower dimensions of the 
   {\tt farray} argument in sequence, i.e. {\tt distgridToArrayMap = 
   (/1, 2, .../)}. 
   Unmapped {\tt farray} dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All {\tt distgridToArrayMap} entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the {\tt distgridToArrayMap} 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   \item[{[computationalEdgeLWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   \item[{[computationalEdgeUWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   \item[{[computationalLWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region. 
   The default is a zero vector. 
   \item[{[computationalUWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region. 
   The default is a zero vector. 
   \item[{[totalLWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the total memory 
   region with respect to the lower corner of the exclusive region. 
   The default is to accommodate the union of exclusive and computational 
   region exactly. 
   \item[{[totalUWidth]}] 
   This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the total memory 
   region with respect to the upper corner of the exclusive region. 
   The default is a vector that contains the remaining number of elements 
   in each direction as to fit the union of exclusive and computational 
   region into the memory region provided by the {\tt farray} argument. 
   \item[{[undistLBound]}] 
   Lower bounds for the array dimensions that are not distributed. 
   By default lbound is 1. 
   \item[{[undistUBound]}] 
   Upper bounds for the array dimensions that are not distributed. 
   By default ubound is equal to the extent of the corresponding 
   dimension in {\tt farray}. 
   \item[{[name]}] 
   Name of the Array object. 
   \item[{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate - Create Array object from a list of LocalArray objects}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateLocalArray(distgrid, localarrayList, &
     indexflag, datacopyflag, distgridToArrayMap, computationalEdgeLWidth, &
     computationalEdgeUWidth, computationalLWidth, computationalUWidth, &
     totalLWidth, totalUWidth, undistLBound, undistUBound, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Array) :: ESMF_ArrayCreateLocalArray\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_LocalArray), intent(in) :: localarrayList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_Index_Flag), intent(in), optional :: indexflag
        type(ESMF_DataCopy_Flag),intent(in), optional :: datacopyflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: computationalEdgeLWidth(:)
        integer, intent(in), optional :: computationalEdgeUWidth(:)
        integer, intent(in), optional :: computationalLWidth(:)
        integer, intent(in), optional :: computationalUWidth(:)
        integer, intent(in), optional :: totalLWidth(:)
        integer, intent(in), optional :: totalUWidth(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   \begin{sloppypar}
   Create an {\tt ESMF\_Array} object from existing {\tt ESMF\_LocalArray}
   objects. The decomposition and distribution is
   specified by the {\tt distgrid} argument. Each PET must issue this call
   with identical arguments in order to create a consistent Array object.
   The only exception is the {\tt localarrayList} argument which will be
   different on each PET. The local arrays provided must be dimensioned
   according to the DE-local total region. Bounds of the exclusive regions
   are set as specified in the {\tt distgrid} argument. Bounds for Array
   dimensions that are not distributed can be chosen freely using the
   {\tt undistLBound} and {\tt undistUBound} arguments.
   \end{sloppypar}
  
   This interface is able to handle multiple DEs per PET.
  
   The not distributed Array dimensions form a tensor of rank = array.rank -
   distgrid.dimCount. The widths of the computational region are set to
   the provided value, or zero by default, for all tensor elements. Use
   {\tt ESMF\_ArraySet()} to change these default settings after the
   Array object has been created.
  
   The return value is the newly created {\tt ESMF\_Array} object.
  
   The arguments are:
   \begin{description}
   \item[distgrid]
   {\tt ESMF\_DistGrid} object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   \item[localarrayList]
   List of valid {\tt ESMF\_LocalArray} objects, i.e. memory must be
   associated with the actual arguments. The type/kind/rank information of
   all {\tt localarrayList} elements must be identical and will
   be used to set {\tt Array}'s properties accordingly. The shape of each
   {\tt localarrayList} element will be checked against the information
   contained in the {\tt distgrid}.
   \item[{[indexflag]}]
   Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section \ref{const:indexflag}
   for a list of valid indexflag options.
   \item[{[datacopyflag]}]
   Specifies whether the Array object will reference the memory allocation
   of the arrays provided in {\tt localarrayList} directly, or will copy
   the actual data into new memory allocations. For valid values see
   \ref{const:datacopyflag}. The default is {\tt ESMF\_DATACOPY\_REFERENCE}.
   \item[{[distgridToArrayMap]}]
   List that contains as many elements as is indicated by
   {\tt distgrids}'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the {\tt localarrayList} elements
   by specifying the appropriate Array dimension index. The default is
   to map all of {\tt distgrid}'s dimensions against the lower dimensions
   of the {\tt localarrayList} elements in sequence, i.e.
   {\tt distgridToArrayMap = (/1, 2, .../)}.
   Unmapped dimensions in the {\tt localarrayList} elements are not
   decomposed dimensions and form a tensor of
   rank = Array.rank - DistGrid.dimCount.
   All {\tt distgridToArrayMap} entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the {\tt distgridToArrayMap}
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   \item[{[computationalEdgeLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a tile.
   \item[{[computationalEdgeUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a tile.
   \item[{[computationalLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   \item[{[computationalUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   \item[{[totalLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region exactly.
   \item[{[totalUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the exclusive region.
   The default is a vector that contains the remaining number of elements
   in each direction as to fit the union of exclusive and computational
   region into the memory region provided by the {\tt localarrayList} argument.
   \item[{[undistLBound]}]
   Lower bounds for the array dimensions that are not distributed.
   By default lbound is 1.
   \item[{[undistUBound]}]
   Upper bounds for the array dimensions that are not distributed.
   By default ubound is equal to the extent of the corresponding
   dimension in {\tt localarrayList}.
   \item[{[name]}]
   Name of the Array object.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate - Create Array object from a list of LocalArray objects w/ arbitrary seqIndices for halo}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateLocalArrayArb<indexkind>(distgrid, localarrayList, &
   haloSeqIndexList, indexflag, datacopyflag, &
   distgridToArrayMap, computationalEdgeLWidth, computationalEdgeUWidth, &
   computationalLWidth, computationalUWidth, &
   totalLWidth, totalUWidth, undistLBound, undistUBound, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Array) :: ESMF_ArrayCreateLocalArrayArb\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_DistGrid), intent(in) :: distgrid
   type(ESMF_LocalArray), intent(in) :: localarrayList(:)
   integer(ESMF_KIND_<indexkind>), intent(in) :: haloSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_Index_Flag), intent(in), optional :: indexflag
   type(ESMF_DataCopy_Flag),intent(in), optional :: datacopyflag
   integer, intent(in), optional :: distgridToArrayMap(:)
   integer, intent(in), optional :: computationalEdgeLWidth(:)
   integer, intent(in), optional :: computationalEdgeUWidth(:)
   integer, intent(in), optional :: computationalLWidth(:)
   integer, intent(in), optional :: computationalUWidth(:)
   integer, intent(in), optional :: totalLWidth(:)
   integer, intent(in), optional :: totalUWidth(:)
   integer, intent(in), optional :: undistLBound(:)
   integer, intent(in), optional :: undistUBound(:)
   character (len=*), intent(in), optional :: name
   integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.0.0] Added arguments {\tt indexflag}, {\tt computationalEdgeLWidth},
   {\tt computationalEdgeUWidth}, {\tt computationalLWidth},
   {\tt computationalUWidth}, {\tt totalLWidth}, {\tt totalUWidth}. These
   arguments were missed in previous versions by mistake.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Array} object from existing {\tt ESMF\_LocalArray}
   objects according to distgrid. Each PET must issue this call in unison
   in order to create a consistent Array object. The local arrays provided must
   be dimensioned according to the DE-local total region. Bounds of the
   exclusive regions are set as specified in the distgrid argument. Bounds
   for array dimensions that are not distributed can be chosen freely using
   the {\tt undistLBound} and {\tt undistUBound} arguments.
  
   The return value is the newly created {\tt ESMF\_Array} object.
  
   The arguments are:
   \begin{description}
   \item[distgrid]
   {\tt ESMF\_DistGrid} object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   \item[localarrayList]
   List of valid {\tt ESMF\_LocalArray} objects, i.e. memory must be
   associated with the actual arguments. The type/kind/rank information of
   all {\tt localarrayList} elements must be identical and will
   be used to set {\tt Array}'s properties accordingly. The shape of each
   {\tt localarrayList} element will be checked against the information
   contained in the {\tt distgrid}.
   \item[haloSeqIndexList]
   One dimensional array containing sequence indices of local halo region.
   The size (and content) of {\tt haloSeqIndexList} can (and typically will)
   be different on each PET.
   The {\tt haloSeqIndexList} argument is of integer type, but can be of
   different kind in order to support both 32-bit ({\tt ESMF\_KIND\_I4})
   and 64-bit ({\tt ESMF\_KIND\_I8}) indexing.
   \item[{[indexflag]}]
   Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section \ref{const:indexflag}
   for a list of valid indexflag options.
   \item[{[datacopyflag]}]
   Specifies whether the Array object will reference the memory allocation
   of the arrays provided in {\tt localarrayList} directly, or will copy
   the actual data into new memory allocations. For valid values see
   \ref{const:datacopyflag}. The default is {\tt ESMF\_DATACOPY\_REFERENCE}.
   \item[{[distgridToArrayMap]}]
   List that contains as many elements as is indicated by
   {\tt distgrids}'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the {\tt localarrayList} elements
   by specifying the appropriate Array dimension index. The default is
   to map all of {\tt distgrid}'s dimensions against the lower dimensions
   of the {\tt localarrayList} elements in sequence, i.e.
   {\tt distgridToArrayMap = (/1, 2, .../)}.
   Unmapped dimensions in the {\tt localarrayList} elements are not
   decomposed dimensions and form a tensor of
   rank = Array.rank - DistGrid.dimCount.
   All {\tt distgridToArrayMap} entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the {\tt distgridToArrayMap}
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   \item[{[computationalEdgeLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a tile.
   \item[{[computationalEdgeUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a tile.
   \item[{[computationalLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   \item[{[computationalUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   \item[{[totalLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region exactly.
   \item[{[totalUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the exclusive region.
   The default is a vector that contains the remaining number of elements
   in each direction as to fit the union of exclusive and computational
   region into the memory region provided by the {\tt localarrayList} argument.
   \item[{[undistLBound]}]
   Lower bounds for the array dimensions that are not distributed.
   By default lbound is 1.
   \item[{[undistUBound]}]
   Upper bounds for the array dimensions that are not distributed.
   By default ubound is equal to the extent of the corresponding
   dimension in {\tt localarrayList}.
   \item[{[name]}]
   Name of the Array object.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate - Create Array object from typekind (allocate memory)}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocate(distgrid, typekind, &
     indexflag, pinflag, distgridToArrayMap, computationalEdgeLWidth, &
     computationalEdgeUWidth, computationalLWidth, computationalUWidth, &
     totalLWidth, totalUWidth, undistLBound, undistUBound, name, vm, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Array) :: ESMF_ArrayCreateAllocate\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_TypeKind_Flag), intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_Index_Flag), intent(in), optional :: indexflag
        type(ESMF_Pin_Flag), intent(in), optional :: pinflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: computationalEdgeLWidth(:)
        integer, intent(in), optional :: computationalEdgeUWidth(:)
        integer, intent(in), optional :: computationalLWidth(:)
        integer, intent(in), optional :: computationalUWidth(:)
        integer, intent(in), optional :: totalLWidth(:)
        integer, intent(in), optional :: totalUWidth(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        type(ESMF_VM), intent(in), optional :: vm
        integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[6.3.0r] Added argument {\tt vm} to support object creation on a
   different VM than that of the current context.
   \item[8.0.0] Added argument {\tt pinflag} to provide access to DE sharing
   between PETs.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Array} object and allocate uninitialized data space
   according to typekind and distgrid. The Array rank is indirectly determined
   by the incoming information. Each PET must issue this call in unison in order
   to create a consistent Array object. DE-local allocations are made according
   to the total region defined by the {\tt distgrid} and the optional {\tt Width}
   arguments.
  
   The return value is the newly created {\tt ESMF\_Array} object.
  
   The arguments are:
   \begin{description}
   \item[distgrid]
   {\tt ESMF\_DistGrid} object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   \item[typekind]
   The typekind of the Array. See section \ref{const:typekind}
   for a list of valid typekind options.
   \item[{[indexflag]}]
   Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section \ref{const:indexflag}
   for a list of valid indexflag options.
   \item[{[pinflag]}]
   Specify which type of resource DEs are pinned to. See section
   \ref{const:pin_flag} for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   \item[{[distgridToArrayMap]}]
   List that contains as many elements as is indicated by
   {\tt distgrids}'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of {\tt distgrid}'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. {\tt distgridToArrayMap =
   (/1, 2, .../)}.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All {\tt distgridToArrayMap} entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the {\tt distgridToArrayMap}
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   \item[{[computationalEdgeLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a tile.
   \item[{[computationalEdgeUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a tile.
   \item[{[computationalLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   \item[{[computationalUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   \item[{[totalLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region.
   \item[{[totalUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region.
   \item[{[undistLBound]}]
   Lower bounds for the array dimensions that are not distributed.
   \item[{[undistUBound]}]
   Upper bounds for the array dimensions that are not distributed.
   \item[{[name]}]
   Name of the Array object.
   \item[{[vm]}]
   If present, the Array object is created on the specified
   {\tt ESMF\_VM} object. The default is to create on the VM of the
   current context.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate - Create Array object from typekind (allocate memory) w/ arbitrary seqIndices for halo}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocateArb<indexkind>(distgrid, typekind, &
   haloSeqIndexList, pinflag, distgridToArrayMap, &
   undistLBound, undistUBound, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Array) :: ESMF_ArrayCreateAllocateArb\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_DistGrid), intent(in) :: distgrid
   type(ESMF_TypeKind_Flag), intent(in) :: typekind
   integer(ESMF_KIND_<indexkind>), intent(in) :: haloSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_Pin_Flag), intent(in), optional :: pinflag
   integer, intent(in), optional :: distgridToArrayMap(:)
   integer, intent(in), optional :: undistLBound(:)
   integer, intent(in), optional :: undistUBound(:)
   character (len=*), intent(in), optional :: name
   integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[8.0.0] Added argument {\tt pinflag} to provide access to DE sharing
   between PETs.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Array} object and allocate uninitialized data space
   according to typekind and distgrid. The Array rank is indirectly determined
   by the incoming information. Each PET must issue this call in unison in order
   to create a consistent Array object. DE-local allocations are made according
   to the total region defined by the {\tt distgrid} and {\tt haloSeqIndexList}
   arguments.
  
   The return value is the newly created {\tt ESMF\_Array} object.
  
   The arguments are:
   \begin{description}
   \item[distgrid]
   {\tt ESMF\_DistGrid} object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   \item[typekind]
   The typekind of the Array. See section \ref{const:typekind}
   for a list of valid typekind options.
   \item[haloSeqIndexList]
   One dimensional array containing sequence indices of local halo region.
   The size (and content) of {\tt haloSeqIndexList} can (and typically will)
   be different on each PET.
   The {\tt haloSeqIndexList} argument is of integer type, but can be of
   different kind in order to support both 32-bit ({\tt ESMF\_KIND\_I4})
   and 64-bit ({\tt ESMF\_KIND\_I8}) indexing.
   \item[{[pinflag]}]
   Specify which type of resource DEs are pinned to. See section
   \ref{const:pin_flag} for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   \item[{[distgridToArrayMap]}]
   List that contains as many elements as is indicated by
   {\tt distgrids}'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of {\tt distgrid}'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. {\tt distgridToArrayMap =
   (/1, 2, .../)}.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All {\tt distgridToArrayMap} entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the {\tt distgridToArrayMap}
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   \item[{[undistLBound]}]
   Lower bounds for the array dimensions that are not distributed.
   \item[{[undistUBound]}]
   Upper bounds for the array dimensions that are not distributed.
   \item[{[name]}]
   Name of the Array object.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate - Create Array object from ArraySpec (allocate memory)}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocateAS(distgrid, arrayspec, &
     indexflag, pinflag, distgridToArrayMap, computationalEdgeLWidth, &
     computationalEdgeUWidth, computationalLWidth, computationalUWidth, &
     totalLWidth, totalUWidth, undistLBound, undistUBound, name, vm, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Array) :: ESMF_ArrayCreateAllocateAS\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_Index_Flag), intent(in), optional :: indexflag
        type(ESMF_Pin_Flag), intent(in), optional :: pinflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: computationalEdgeLWidth(:)
        integer, intent(in), optional :: computationalEdgeUWidth(:)
        integer, intent(in), optional :: computationalLWidth(:)
        integer, intent(in), optional :: computationalUWidth(:)
        integer, intent(in), optional :: totalLWidth(:)
        integer, intent(in), optional :: totalUWidth(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        type(ESMF_VM), intent(in), optional :: vm
        integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[6.3.0r] Added argument {\tt vm} to support object creation on a
   different VM than that of the current context.
   \item[8.0.0] Added argument {\tt pinflag} to provide access to DE sharing
   between PETs.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Array} object and allocate uninitialized data space
   according to arrayspec and distgrid. Each PET must issue
   this call with identical arguments in order to create a consistent Array
   object. DE-local allocations are made according to the total region defined
   by the arguments to this call: {\tt distgrid} and the optional {\tt Width}
   arguments.
  
   The return value is the newly created {\tt ESMF\_Array} object.
  
   The arguments are:
   \begin{description}
   \item[distgrid]
   {\tt ESMF\_DistGrid} object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   \item[arrayspec]
   {\tt ESMF\_ArraySpec} object containing the type/kind/rank information.
   \item[{[indexflag]}]
   Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section \ref{const:indexflag}
   for a list of valid indexflag options.
   \item[{[pinflag]}]
   Specify which type of resource DEs are pinned to. See section
   \ref{const:pin_flag} for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   \item[{[distgridToArrayMap]}]
   List that contains as many elements as is indicated by
   {\tt distgrids}'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of {\tt distgrid}'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. {\tt distgridToArrayMap =
   (/1, 2, .../)}.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All {\tt distgridToArrayMap} entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the {\tt distgridToArrayMap}
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   \item[{[computationalEdgeLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a tile.
   \item[{[computationalEdgeUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a tile.
   \item[{[computationalLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   \item[{[computationalUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   \item[{[totalLWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region.
   \item[{[totalUWidth]}]
   This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region.
   \item[{[undistLBound]}]
   Lower bounds for the array dimensions that are not distributed.
   \item[{[undistUBound]}]
   Upper bounds for the array dimensions that are not distributed.
   \item[{[name]}]
   Name of the Array object.
   \item[{[vm]}]
   If present, the Array object is created on the specified
   {\tt ESMF\_VM} object. The default is to create on the VM of the
   current context.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate - Create Array object from ArraySpec (allocate memory) w/ arbitrary seqIndices for halo}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocateASArb<indexkind>(distgrid, arrayspec, &
   haloSeqIndexList, pinflag, distgridToArrayMap, &
   undistLBound, undistUBound, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Array) :: ESMF_ArrayCreateAllocateASArb\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_DistGrid), intent(in) :: distgrid
   type(ESMF_ArraySpec), intent(in) :: arrayspec
   integer(ESMF_KIND_<indexkind>), intent(in) :: haloSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_Pin_Flag), intent(in), optional :: pinflag
   integer, intent(in), optional :: distgridToArrayMap(:)
   integer, intent(in), optional :: undistLBound(:)
   integer, intent(in), optional :: undistUBound(:)
   character (len=*), intent(in), optional :: name
   integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[8.0.0] Added argument {\tt pinflag} to provide access to DE sharing
   between PETs.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Array} object and allocate uninitialized data space
   according to arrayspec and distgrid. Each PET must issue this call in unison
   in order to create a consistent Array object. DE-local allocations are made
   according to the total region defined by the arguments to this call:
   {\tt distgrid} and {\tt haloSeqIndexList} arguments.
  
   The return value is the newly created {\tt ESMF\_Array} object.
  
   The arguments are:
   \begin{description}
   \item[distgrid]
   {\tt ESMF\_DistGrid} object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   \item[arrayspec]
   {\tt ESMF\_ArraySpec} object containing the type/kind/rank information.
   \item[haloSeqIndexList]
   One dimensional array containing sequence indices of local halo region.
   The size (and content) of {\tt haloSeqIndexList} can (and typically will)
   be different on each PET.
   The {\tt haloSeqIndexList} argument is of integer type, but can be of
   different kind in order to support both 32-bit ({\tt ESMF\_KIND\_I4})
   and 64-bit ({\tt ESMF\_KIND\_I8}) indexing.
   \item[{[pinflag]}]
   Specify which type of resource DEs are pinned to. See section
   \ref{const:pin_flag} for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   \item[{[distgridToArrayMap]}]
   List that contains as many elements as is indicated by
   {\tt distgrids}'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of {\tt distgrid}'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. {\tt distgridToArrayMap =
   (/1, 2, .../)}.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All {\tt distgridToArrayMap} entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the {\tt distgridToArrayMap}
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   \item[{[undistLBound]}]
   Lower bounds for the array dimensions that are not distributed.
   \item[{[undistUBound]}]
   Upper bounds for the array dimensions that are not distributed.
   \item[{[name]}]
   Name of the Array object.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayCreate] {ESMF\_ArrayCreate - Create Array object as copy of existing Array object}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateCopy(array, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Array) :: ESMF_ArrayCreateCopy\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Array} object as the copy of an existing Array.
  
   The return value is the newly created {\tt ESMF\_Array} object.
  
   The arguments are:
   \begin{description}
   \item[array]
   {\tt ESMF\_Array} object to be copied.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayDestroy] {ESMF\_ArrayDestroy - Release resources associated with an Array object}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_ArrayDestroy(array, noGarbage, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Array), intent(inout) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: noGarbage
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.0.0] Added argument {\tt noGarbage}.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Destroy an {\tt ESMF\_Array}, releasing the resources associated with
   the object.
  
   By default a small remnant of the object is kept in memory in order to
   prevent problems with dangling aliases. The default garbage collection
   mechanism can be overridden with the {\tt noGarbage} argument.
  
   The arguments are:
   \begin{description}
   \item[array]
   {\tt ESMF\_Array} object to be destroyed.
   \item[{[noGarbage]}]
   If set to {\tt .TRUE.} the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases -- a situation which may lead to hard to debug
   application crashes.
  
   It is generally recommended to leave the {\tt noGarbage} argument
   set to {\tt .FALSE.} (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully
   removing the entire temporary object from memory.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
