%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_Array.C,  Date: Tue May  5 20:59:42 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMCI::Array::Array] {ESMCI::Array::Array - constructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Array::Array(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim} \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ESMC_TypeKind_Flag typekindArg,         // (in)
   int rankArg,                            // (in)
   LocalArray **larrayListArg,             // (in)
   VM::memhandle *mhArg,                   // (in)
   int vasLocalDeCountArg,                 // (in)
   int ssiLocalDeCountArg,                 // (in)
   int *localDeToDeMapArg,                 // (in)
   DistGrid *distgridArg,                  // (in)
   bool distgridCreatorArg,                // (in)
   int *exclusiveLBoundArg,                // (in)
   int *exclusiveUBoundArg,                // (in)
   int *computationalLBoundArg,            // (in)
   int *computationalUBoundArg,            // (in)
   int *totalLBoundArg,                    // (in)
   int *totalUBoundArg,                    // (in)
   int tensorCountArg,                     // (in)
   int tensorElementCountArg,              // (in)
   int *undistLBoundArray,                 // (in)
   int *undistUBoundArray,                 // (in)
   int *distgridToArrayMapArray,           // (in)
   int *arrayToDistGridMapArray,           // (in)
   int *distgridToPackedArrayMapArray,     // (in)
   ESMC_IndexFlag indexflagArg,            // (in)
   int *rc,                                // (out)
   VM *vm                                  // (in)
   ):ESMC_Base(vm){    // allow specific VM instead default\end{verbatim}
{\sf DESCRIPTION:\\ }


      Construct the internal information structure of an ESMCI::Array object.
      No error checking wrt consistency of input arguments is needed because
      Array constructor is only to be called by Array::create() interfaces which
      are responsible for providing consistent arguments to this layer.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::destruct] {ESMCI::Array::destruct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void Array::destruct(bool followCreator, bool noGarbage){
   TODO: The followCreator flag is only needed until we have reference counting
   TODO: For now followCreator, which by default is true, will be coming in as
   TODO: false when calling through the native destructor. This prevents
   TODO: sequence problems during automatic garbage collection until reference
   TODO: counting comes in to solve this problem in the final manner.\end{verbatim}
{\sf DESCRIPTION:\\ }


      Destruct the internal information structure of an ESMCI::Array object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::constructContiguousFlag] {ESMCI::Array::constructContiguousFlag}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::constructContiguousFlag(int redDimCount){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Fill the contiguousFlag member in an ESMCI::Array object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::create] {ESMCI::Array::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Array *Array::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ESMC_Array * to newly allocated ESMC_Array\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   LocalArray      **larrayListArg,              // (in)
   int             larrayCount,                  // (in)
   DistGrid        *distgrid,                    // (in)
   CopyFlag        copyflag,                     // (in)
   InterArray<int> *distgridToArrayMap,          // (in)
   InterArray<int> *computationalEdgeLWidthArg,  // (in)
   InterArray<int> *computationalEdgeUWidthArg,  // (in)
   InterArray<int> *computationalLWidthArg,      // (in)
   InterArray<int> *computationalUWidthArg,      // (in)
   InterArray<int> *totalLWidthArg,              // (in)
   InterArray<int> *totalUWidthArg,              // (in)
   ESMC_IndexFlag  *indexflagArg,                // (in)
   InterArray<int> *undistLBoundArg,             // (in)
   InterArray<int> *undistUBoundArg,             // (in)
   int             *rc                           // (out) return code
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Create an {\tt ESMCI::Array} object from list if LocalArrays and DistGrid. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::create] {ESMCI::Array::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Array *Array::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ESMCI::Array * to newly allocated ESMCI::Array\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ArraySpec       *arrayspec,                   // (in)
   DistGrid        *distgrid,                    // (in)
   InterArray<int> *distgridToArrayMap,          // (in)
   InterArray<int> *computationalEdgeLWidthArg,  // (in)
   InterArray<int> *computationalEdgeUWidthArg,  // (in)
   InterArray<int> *computationalLWidthArg,      // (in)
   InterArray<int> *computationalUWidthArg,      // (in)
   InterArray<int> *totalLWidthArg,              // (in)
   InterArray<int> *totalUWidthArg,              // (in)
   ESMC_IndexFlag  *indexflagArg,                // (in)
   ESMC_Pin_Flag   *pinflagArg,                  // (in)
   InterArray<int> *distLBoundArg,               // (in)
   InterArray<int> *undistLBoundArg,             // (in)
   InterArray<int> *undistUBoundArg,             // (in)
   int             *rc,                          // (out) return code
   VM              *vm                           // (in, optional)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Create an {\tt ESMCI::Array} object from ArraySpec and DistGrid. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::create] {ESMCI::Array::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Array *Array::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ESMC_Array * to newly allocated ESMC_Array\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *arrayIn,                             // (in) Array to copy
   int rmLeadingTensors,                       // (in) leading tensors to remove
   int *rc                                     // (out) return code
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Create an {\tt ESMCI::Array} object as copy of an existing
      {\tt ESMCI::Array} object. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::create] {ESMCI::Array::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Array *Array::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ESMC_Array * to newly allocated ESMC_Array\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *arrayIn,                             // (in) Array to copy
   bool rmTensorFlag,                          // (in) if true remove all tensors
   int *rc                                     // (out) return code
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Create an {\tt ESMCI::Array} object as copy of an existing
      {\tt ESMCI::Array} object. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::destroy] {ESMCI::Array::destroy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::destroy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array **array,                // in - ESMC_Array to destroy
   bool noGarbage){              // in - remove from garbage collection\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::copy] {ESMCI::Array::copy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::copy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array const *arrayIn                // (in) Array to copy data from
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Copy data from one Array object to another
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::getLinearIndexExclusive] {ESMCI::Array::getLinearIndexExclusive}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::getLinearIndexExclusive(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int linear index\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int localDe,                      // in - local DE
   int const *index                  // in - DE-local index tuple in exclusive
                                     //      region basis 0
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get linear index - assuming index input to be basis 0 in excl. region
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::getSequenceIndexExclusive] {ESMCI::Array::getSequenceIndexExclusive}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename IT> int Array::getSequenceIndexExclusive(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int localDe,                      // in  - local DE
   int const *index,                 // in  - DE-local index tuple in exclusive
                                     //       region basis 0
   SeqIndex<IT> *seqIndex,           // out - sequence index
   bool recursive,                   // in  - recursive mode or not
   bool canonical                    // in  - return canonical seqIndex even if
                                     //       arbitrary seqIndices available
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get sequential index - assuming index input to be basis 0 in excl. region,
      but allowing the incoming index to be outside of the exclusive region
      under special conditions. See the used DistGrid method for details.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::getSequenceIndexTile] {ESMCI::Array::getSequenceIndexTile}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename IT> SeqIndex<IT> Array::getSequenceIndexTile(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      SeqIndex sequence index\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int tile,                        // in - tile = {1,..., tileCount}
   const int *index,                 // in - index tuple within tile
                                     //    - basis 0
   int *rc                           // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get sequential index - assuming index input to be basis 0 in tile region
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::getTensorSequenceIndex] {ESMCI::Array::getTensorSequenceIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::getTensorSequenceIndex(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Tensor sequence index\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   const int *index,                 // in - index tuple basis 0
   int *rc                           // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get tensor sequential index - assuming index input to be basis 0
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::getArbSequenceIndexOffset] {ESMCI::Array::getArbSequenceIndexOffset}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::getArbSequenceIndexOffset(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Arbitrary sequence index offset\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   const int *index,                 // in - index tuple basis 0
   int *rc                           // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get offset into arb sequential index list - assuming index input to be
   basis 0
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::setComputationalLWidth] {ESMCI::Array::setComputationalLWidth}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::setComputationalLWidth(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<int> *computationalLWidthArg        // (in)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set computationalLWidth for all local DEs.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::setComputationalUWidth] {ESMCI::Array::setComputationalUWidth}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::setComputationalUWidth(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<int> *computationalUWidthArg        // (in)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set computationalUWidth for all local DEs.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::setRimMembers] {ESMCI::Array::setRimMembers}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void Array::setRimMembers(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set setRimMembers
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::setRimSeqIndex] {ESMCI::Array::setRimSeqIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<>
   int Array::setRimSeqIndex<ESMC_I4>(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int localDe,                          // (in)
   InterArray<ESMC_I4> *rimSeqIndexArg   // (in)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set rimSeqIndex for localDe.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::setRimSeqIndex] {ESMCI::Array::setRimSeqIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<>
   int Array::setRimSeqIndex<ESMC_I8>(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int localDe,                          // (in)
   InterArray<ESMC_I8> *rimSeqIndexArg   // (in)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set rimSeqIndex for localDe.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::getRimSeqIndex] {ESMCI::Array::getRimSeqIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<>
   int Array::getRimSeqIndex<ESMC_I4>(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const std::vector<std::vector<SeqIndex<ESMC_I4> > > **rimSeqIndex_  // out -
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get rimSeqIndex
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::getRimSeqIndex] {ESMCI::Array::getRimSeqIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<>
   int Array::getRimSeqIndex<ESMC_I8>(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const std::vector<std::vector<SeqIndex<ESMC_I8> > > **rimSeqIndex_  // out -
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get rimSeqIndex
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::isRHCompatible] {ESMCI::Array::isRHCompatible}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool Array::isRHCompatible(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool according to whether RHCompatible or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array const *array,     // in - Array to compare to
   int *rc                 // (out) return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Determine whether a RouteHandle computed for this Array could also be
      applied to the {\tt array} argument.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::matchBool] {ESMCI::Array::matchBool}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool Array::matchBool(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool according to match\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array const *array1,                    // in
   Array const *array2,                    // in
   int *rc                                 // (out) return code
   ){
  TODO: Remove or rename according to below. See where it is used and how!
  TODO: 1) rename this method to compatible()
  TODO: 2) consider compatible: distributed dims match,
  TODO:    and strictly compatible: distributed and undistributed dims match.\end{verbatim}
{\sf DESCRIPTION:\\ }


      Determine if array1 and array2 match.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::read] {ESMCI::Array::read}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::read(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   const std::string &file,        // in    - name of file being read
   const std::string &variableName,// in    - optional variable name
   int   *timeslice,               // in    - timeslice option
   ESMC_IOFmt_Flag *iofmt          // in    - I/O format flag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Read Array data from file and put it into an ESMF_Array object.
     For this API to be functional, the environment variable ESMF_PIO
     should be set to "internal" when the ESMF library is built.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::write] {ESMCI::Array::write}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::write(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   const std::string &file,        // in    - name of file being written
   const std::string &variableName,// in    - optional variable name
   const std::string &convention,  // in    - optional Attribute package
   const std::string &purpose,     // in    - optional Attribute package
   bool  *overwrite,               // in    - OK to overwrite file data
   ESMC_FileStatus_Flag *status,   // in    - file status flag
   int   *timeslice,               // in    - timeslice option
   ESMC_IOFmt_Flag *iofmt          // in    - I/O format flag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Write Array data into a file. For this API to be functional, the
     environment variable {\tt ESMF\_PIO} should be set to "internal" when
     the ESMF library is built.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::print] {ESMCI::Array::print}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::print()const{\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Print details of Array object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::sync] {ESMCI::Array::sync}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::sync(){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Sync DEs arcoss the Array object in case of sharing.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::validate] {ESMCI::Array::validate}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::validate()const{\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Validate details of Array object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::constructFileMap] {ESMCI::Array::constructFileMap}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::constructFileMap(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int64_t *fileMapList,         // (in)  - Array of map elements to fill
   int mapListSize,              // (in)  - Number of elements in fileMapList
   int localDe,                  // (in)  - local DE = {0, ..., localDeCount-1}
   int64_t unmap_val             // (in)  - value to give to unmapped elements
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Construct the map between each local array element and its location
      in a disk file for the total Array region on localDe.
      Unmapped elements (those outside of exclusive region) are given a value
      of of unmap_val (defaults to zero which is the PIO convention).
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::serialize] {ESMCI::Array::serialize - Turn Array into a byte stream}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::serialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char *buffer,          // inout - byte stream to fill
   int *length,           // inout - buf length
   int *offset,           // inout - original offset
   const ESMC_AttReconcileFlag &attreconflag,     // in - attreconcile flag
   const ESMC_InquireFlag &inquireflag) const {   // in - inquiry flag\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn info in array class into a stream of bytes.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::deserialize] {ESMCI::Array::deserialize - Turn a byte stream into an Array}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::deserialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char *buffer,          // in - byte stream to read
   int *offset,           // inout - original offset
   const ESMC_AttReconcileFlag &attreconflag) {  // in - attreconcile flag\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn a stream of bytes into an object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::gather] {ESMCI::Array::gather}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::gather(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *arrayArg,                       // out -
   ESMC_TypeKind_Flag typekindArg,       // in -
   int rankArg,                          // in -
   int *counts,                          // in -
   int *tileArg,                         // in -
   int rootPet,                          // in -
   VM *vm                                // in -
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Gather Array object into native array.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::scatter] {ESMCI::Array::scatter}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::scatter(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *arrayArg,                       // in -
   ESMC_TypeKind_Flag typekindArg,       // in -
   int rankArg,                          // in -
   int *counts,                          // in -
   int *tileArg,                         // in -
   int rootPet,                          // in -
   VM *vm                                // in -
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Scatter native array across Array object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::haloStore] {ESMCI::Array::haloStore}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::haloStore(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *array,                       // in    - Array
   RouteHandle **routehandle,          // inout - handle to precomputed comm
   ESMC_HaloStartRegionFlag halostartregionflag, // in - start of halo region
   InterArray<int> *haloLDepth,        // in    - lower corner halo depth
   InterArray<int> *haloUDepth,        // in    - upper corner halo depth
   int *pipelineDepthArg               // in (optional)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Precompute and store communication pattern for halo
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::tHaloStore] {ESMCI::Array::tHaloStore}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename IT>
   int Array::tHaloStore(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *array,                       // in    - Array
   RouteHandle **routehandle,          // inout - handle to precomputed comm
   ESMC_HaloStartRegionFlag halostartregionflag, // in - start of halo region
   InterArray<int> *haloLDepth,        // in    - lower corner halo depth
   InterArray<int> *haloUDepth,        // in    - upper corner halo depth
   int *pipelineDepthArg               // in (optional)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Precompute and store communication pattern for halo
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::halo] {ESMCI::Array::halo}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::halo(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *array,                         // in    - Array
   RouteHandle **routehandle,            // inout - handle to precomputed comm
   ESMC_CommFlag commflag,               // in    - communication options
   bool *finishedflag,                   // out   - TEST ops finished or not
   bool *cancelledflag,                  // out   - any cancelled operations
   bool checkflag                        // in    - false: (def.) basic checks
                                         //         true:  full input check
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Execute an Array halo
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::haloRelease] {ESMCI::Array::haloRelease}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::haloRelease(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   RouteHandle *routehandle        // inout -
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Release information for an Array halo
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::redistStore] {ESMCI::Array::redistStore}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::redistStore(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *srcArray,                        // in    - source Array
   Array *dstArray,                        // in    - destination Array
   RouteHandle **routehandle,              // inout - handle to precomputed comm
   InterArray<int> *srcToDstTransposeMap,  // in    - mapping src -> dst dims
   ESMC_TypeKind_Flag typekindFactor,      // in    - typekind of factor
   void *factor,                           // in    - redist factor
   bool ignoreUnmatched,                   // in    - support unmatched indices
   int *pipelineDepthArg                   // in (optional)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Precompute and store communication pattern for redistribution
    from srcArray to dstArray.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::tRedistStore] {ESMCI::Array::tRedistStore}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename SIT, typename DIT>
   int Array::tRedistStore(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *srcArray,                        // in    - source Array
   Array *dstArray,                        // in    - destination Array
   RouteHandle **routehandle,              // inout - handle to precomputed comm
   InterArray<int> *srcToDstTransposeMap,  // in    - mapping src -> dst dims
   ESMC_TypeKind_Flag typekindFactor,      // in    - typekind of factor
   void *factor,                           // in    - redist factor
   bool ignoreUnmatched,                   // in    - support unmatched indices
   int *pipelineDepthArg                   // in (optional)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Precompute and store communication pattern for redistribution
    from srcArray to dstArray.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::redist] {ESMCI::Array::redist}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::redist(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *srcArray,                      // in    - source Array
   Array *dstArray,                      // inout - destination Array
   RouteHandle **routehandle,            // inout - handle to precomputed comm
   ESMC_CommFlag commflag,               // in    - communication options
   bool *finishedflag,                   // out   - TEST ops finished or not
   bool *cancelledflag,                  // out   - any cancelled operations
   ESMC_Region_Flag zeroflag,            // in    - ESMC_REGION_TOTAL:
                                         //          -> zero out total region
                                         //         ESMC_REGION_SELECT:
                                         //          -> zero out target points
                                         //         ESMC_REGION_EMPTY:
                                         //          -> don't zero out any points
   bool checkflag                        // in    - false: (def.) basic checks
                                         //         true:  full input check
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Execute an Array redistribution
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::redistRelease] {ESMCI::Array::redistRelease}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::redistRelease(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   RouteHandle *routehandle        // inout -
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Release information for an Array redistribution
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::sparseMatMulStore] {ESMCI::Array::sparseMatMulStore}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename SIT, typename DIT>
   int Array::sparseMatMulStore(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *srcArray,                          // in    - source Array
   Array *dstArray,                          // in    - destination Array
   RouteHandle **routehandle,                // inout - handle to precomp. comm
   vector<SparseMatrix<SIT,DIT> > const &sparseMatrix,// in- sparse matrix vector
   bool haloFlag,                            // in    - support halo conditions
   bool ignoreUnmatched,                     // in    - support unmatched indices
   int *srcTermProcessingArg,                // inout - src term proc (optional)
                                 // if (NULL) -> auto-tune, no pass back
                                 // if (!NULL && -1) -> auto-tune, pass back
                                 // if (!NULL && >=0) -> no auto-tune, use input
   int *pipelineDepthArg                     // inout - pipeline depth (optional)
                                 // if (NULL) -> auto-tune, no pass back
                                 // if (!NULL && -1) -> auto-tune, pass back
                                 // if (!NULL && >=0) -> no auto-tune, use input
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Precompute and store communication pattern for sparse matrix multiplication
    from srcArray to dstArray.
  
    The implementation consists of four main phases:
  
    - Phase I:    Check input for consistency. The sparse matrix is provided in
                  "input" distribution
    - Phase II:   Construct two distributed directories of sparse matrix
                  elements, one indexed by srcSeqIndex, one indexed by
                  dstSeqIndex. This takes the matrix from "input" to "work"
                  distribution.
    - Phase III:  Use the information in "work" distribution and take it into
                  "run" distribution, i.e. src and dst DEs have access to all
                  the local data they may operate on.
    - Phase IV:   Use the information in "run" distribution to encode an
                  optimized XXE stream, balancing src/dst work-loads and
                  pipelining overlapping communications and computation.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::tSparseMatMulStore] {ESMCI::Array::tSparseMatMulStore}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename SIT, typename DIT>
   int Array::tSparseMatMulStore(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *srcArray,                          // in    - source Array
   Array *dstArray,                          // in    - destination Array
   RouteHandle **routehandle,                // inout - handle to precomp. comm
   vector<SparseMatrix<SIT,DIT> >const &sparseMatrix,// in - sparse matrix vector
   bool haloFlag,                            // in    - support halo conditions
   bool ignoreUnmatched,                     // in    - support unmatched indices
   int *srcTermProcessingArg,                // inout - src term proc (optional)
                                 // if (NULL) -> auto-tune, no pass back
                                 // if (!NULL && -1) -> auto-tune, pass back
                                 // if (!NULL && >=0) -> no auto-tune, use input
   int *pipelineDepthArg                     // inout - pipeline depth (optional)
                                 // if (NULL) -> auto-tune, no pass back
                                 // if (!NULL && -1) -> auto-tune, pass back
                                 // if (!NULL && >=0) -> no auto-tune, use input
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Precompute and store communication pattern for sparse matrix multiplication
    from srcArray to dstArray.
  
    The implementation consists of four main phases:
  
    - Phase I:    Check input for consistency. The sparse matrix is provided in
                  "input" distribution
    - Phase II:   Construct two distributed directories of sparse matrix
                  elements, one indexed by srcSeqIndex, one indexed by
                  dstSeqIndex. This takes the matrix from "input" to "work"
                  distribution.
    - Phase III:  Use the information in "work" distribution and take it into
                  "run" distribution, i.e. src and dst DEs have access to all
                  the local data they may operate on.
    - Phase IV:   Use the information in "run" distribution to encode an
                  optimized XXE stream, balancing src/dst work-loads and
                  pipelining overlapping communications and computation.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::sparseMatMulStoreNbVectors] {ESMCI::sparseMatMulStoreNbVectors}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename SIT, typename DIT> int sparseMatMulStoreNbVectors(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VM *vm,                                 // in
   DELayout *srcDelayout,                  // in
   DELayout *dstDelayout,                  // in
 #if (SMMSLSQV_OPTION==2)
   bool haloFlag,                          // in //TODO: remove when no longer needed
 #endif
   bool tensorMixFlag,                     // in
   int srcTensorContigLength,              // in
   int dstTensorContigLength,              // in
   ESMC_TypeKind_Flag typekindFactors,     // in
   ESMC_TypeKind_Flag typekindSrc,         // in
   ESMC_TypeKind_Flag typekindDst,         // in
   const int *srcLocalDeElementCount,      // in
   const int *dstLocalDeElementCount,      // in
   vector<vector<AssociationElement<SeqIndex<SIT>,SeqIndex<DIT> > > >&srcLinSeqVect, // in - sparse mat "run dist."
   vector<vector<AssociationElement<SeqIndex<DIT>,SeqIndex<SIT> > > >&dstLinSeqVect, // in - sparse mat "run dist."
   RouteHandle **routehandle,              // inout
 #ifdef ASMM_STORE_TIMING_on
   double *t8, double *t9, double *t10, double *t11,
 #endif
   vector<ArrayHelper::SendnbElement<SeqIndex<SIT>,SeqIndex<DIT> > > &sendnbVector, // inout
   vector<ArrayHelper::RecvnbElement<SeqIndex<DIT>,SeqIndex<SIT> > > &recvnbVector, // inout
   bool srcTermProcessingExplicitZero,     // in
   bool srcTermProcessingExplicitPositive  // in
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Take the incoming sparse matrix information from "run distribution" and
      transform it into (srcDe, dstDe) pair specific SendnbElement and
      RecvnbElement objects:
  
        srcLinSeqVect -> sendnbVector
        dstLinSeqVect -> recvnbVector
  
      These two vectors contain as many objects as there are srcDe, dstDe on
      the localPet, respectively.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::sparseMatMulStoreEncodeXXE] {ESMCI::sparseMatMulStoreEncodeXXE}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename SIT, typename DIT> int sparseMatMulStoreEncodeXXE(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VM *vm,                                 // in
   DELayout *srcDelayout,                  // in
   DELayout *dstDelayout,                  // in
   bool tensorMixFlag,                     // in
   int srcTensorContigLength,              // in
   int dstTensorContigLength,              // in
   ESMC_TypeKind_Flag typekindFactors,     // in
   ESMC_TypeKind_Flag typekindSrc,         // in
   ESMC_TypeKind_Flag typekindDst,         // in
   vector<ArrayHelper::SendnbElement<SIT,DIT> > &sendnbVector, // in
   vector<ArrayHelper::RecvnbElement<DIT,SIT> > &recvnbVector, // in
   const int *dstLocalDeTotalElementCount, // in
   char **rraList,                         // in
   int rraCount,                           // in
   RouteHandle **routehandle,              // inout - handle to precomputed comm
   bool undistributedElementsPresent,      // in
 #ifdef ASMM_STORE_TIMING_on
   double *t12pre, double *t12, double *t13, double *t14,
 #endif
   int *srcTermProcessingArg,    // inout (optional)
                                 // if (NULL) -> auto-tune, no pass back
                                 // if (!NULL && -1) -> auto-tune, pass back
                                 // if (!NULL && >=0) -> no auto-tune, use input
   int *pipelineDepthArg         // inout (optional)
                                 // if (NULL) -> auto-tune, no pass back
                                 // if (!NULL && -1) -> auto-tune, pass back
                                 // if (!NULL && >=0) -> no auto-tune, use input
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      The incoming sparse matrix information is provided in (srcDe, dstDe) pair
      specific SendnbElement and RecvnbElement objects. These elements are
      stored in the two incoming vectors:
  
        sendnbVector
        recvnbVector
  
      These two vectors contain as many objects as there are srcDe, dstDe on
      the localPet, respectively.
  
      In this method, sendnbVector and recvnbVector are used to encode the
      actual XXE stream by calling sparseMatMulStoreEncodeXXEStream(). This
      stream encode routine allows two stream parameters to be specified:
      srcTermProcessing and pipelineDepth. sparseMatMulStoreEncodeXXE() calls
      sparseMatMulStoreEncodeXXEStream() multiple times with different settings
      for srcTermProcessing and pipelineDepth, scanning the parameter space to
      find an optimum parameter setting for the current machine characteristic
      and the communication pattern provided in sendnbVector and recvnbVector.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::sparseMatMulStoreEncodeXXEStream] {ESMCI::sparseMatMulStoreEncodeXXEStream}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename SIT, typename DIT> int sparseMatMulStoreEncodeXXEStream(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VM *vm,                                 // in
   vector<ArrayHelper::SendnbElement<SIT,DIT> > &sendnbVector, // in - exchange pattern
   vector<ArrayHelper::RecvnbElement<DIT,SIT> > &recvnbVector, // in - exchange pattern
   int srcTermProcessing,                  // in
   int pipelineDepth,                      // in
   XXE::TKId elementTK,                    // in
   XXE::TKId valueTK,                      // in
   XXE::TKId factorTK,                     // in
   int dataSizeSrc,                        // in
   int dataSizeDst,                        // in
   int dataSizeFactors,                    // in
   int srcLocalDeCount,                    // in
   int dstLocalDeCount,                    // in
   const int *dstLocalDeTotalElementCount, // in
   char **rraList,                         // in
   int rraCount,                           // in
   int vectorLength,                       // in
   XXE *xxe                                // inout - XXE stream
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Encode a pipelined XXE stream with the specified degree of
      srcTermProcessing for the sparseMatMul exchange pattern defined by
      recvnbVector and sendnbVector.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::sparseMatMul] {ESMCI::Array::sparseMatMul}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::sparseMatMul(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *srcArray,                      // in    - source Array
   Array *dstArray,                      // inout - destination Array
   RouteHandle **routehandle,            // inout - handle to precomputed comm
   ESMC_CommFlag commflag,               // in    - communication options
   bool *finishedflag,                   // out   - TEST ops finished or not
   bool *cancelledflag,                  // out   - any cancelled operations
   ESMC_Region_Flag zeroflag,            // in    - ESMC_REGION_TOTAL:
                                         //          -> zero out total region
                                         //         ESMC_REGION_SELECT:
                                         //          -> zero out target points
                                         //         ESMC_REGION_EMPTY:
                                         //          -> don't zero out any points
   ESMC_TermOrder_Flag termorderflag,    // in    - ESMC_TERMORDER_SRCSEQ:
                                         //          -> strict srcSeqInd order
                                         //         ESMC_TERMORDER_SRCPET:
                                         //          -> order by src PET & seqInd
                                         //         ESMC_TERMORDER_FREE:
                                         //          -> free order
   bool checkflag,                       // in    - false: (def.) basic checks
                                         //         true:  full input check
   bool haloFlag                         // in    - support halo conditions
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Execute an Array sparse matrix multiplication operation
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::sparseMatMulRelease] {ESMCI::Array::sparseMatMulRelease}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Array::sparseMatMulRelease(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   RouteHandle *routehandle        // inout -
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Release information for an Array sparse matrix multiplication operation
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Array::superVecParam] {ESMCI::Array::superVecParam}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void Array::superVecParam(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim} \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Array *array,             // in
       int localDeCount,         // in
       bool superVectorOkay,     // in
       int superVecSizeUnd[3],   // out
       int *superVecSizeDis[2],  // out
       int &vectorLength         // out
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Determine super-vectorization parameter.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::ArrayElement::ArrayElement] {ESMCI::ArrayElement::ArrayElement}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} ArrayElement::ArrayElement(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ArrayElement*\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array const *arrayArg,      // in - the Array in which ArrayElement iterates
   int localDeArg,             // in - localDe index, starting with 0
   bool seqIndexEnabled,       // in - enable seqIndex lookup during iteration
   bool seqIndexRecursive,     // in - recursive or not seqIndex lookup
   bool seqIndexCanonical      // in - canonical or not seqIndex lookup
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Constructor of ArrayElement iterator through Array elements in exclusive
      region.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::ArrayElement::ArrayElement] {ESMCI::ArrayElement::ArrayElement}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} ArrayElement::ArrayElement(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ArrayElement*\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array const *arrayArg,      // in - the Array in which ArrayElement iterates
   int localDeArg,             // in - localDe index, starting with 0
   bool blockExclusiveFlag,    // in - block the exclusive region if set to true
   bool seqIndexEnabled,       // in - enable seqIndex lookup during iteration
   bool seqIndexRecursive,     // in - recursive or not seqIndex lookup
   bool seqIndexCanonical      // in - canonical or not seqIndex lookup
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Constructor of ArrayElement iterator through Array elements in total
      region, with the option to block the elements of the exclusive region.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::ArrayElement::hasValidSeqIndex] {ESMCI::ArrayElement::hasValidSeqIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool ArrayElement::hasValidSeqIndex(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      true or false\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Indicate whether the ArrayElement is valid. Invalid elements are
      those that are outside the exclusive region for discontiguous dimensions,
      or arbitrarily decomposed dimensions.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::ArrayElement::getTensorSequenceIndex] {ESMCI::ArrayElement::getTensorSequenceIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ArrayElement::getTensorSequenceIndex(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      linear index\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Obtain linear index for ArrayElement
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::ArrayElement::getArbSequenceIndexOffset] {ESMCI::ArrayElement::getArbSequenceIndexOffset}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ArrayElement::getArbSequenceIndexOffset(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      linear index\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Obtain linear index for ArrayElement
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::ArrayElement::log] {ESMCI::ArrayElement::log}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void ArrayElement::log(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Print internal information..
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::SparseMatrix::SparseMatrix] {ESMCI::SparseMatrix::SparseMatrix}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 template<typename SIT, typename DIT> SparseMatrix<SIT,DIT>::SparseMatrix(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      SparseMatrix*\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ESMC_TypeKind_Flag const typekind_,
   void const *factorList_,
   int const factorListCount_,
   int const srcN_,
   int const dstN_,
   void const *factorIndexList_
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Constructor
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayConstruct] {ESMC\_newArrayConstruct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayConstruct(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ESMC_LocalArray *larray,  // pointer to ESMC_LocalArray object
   int *haloWidth,           // halo width
   ESMCI::DELayout *delayout,// DELayout
   int rootPET,              // root
   ESMCI::VM *vm){           // optional VM argument to speed up things\end{verbatim}
{\sf DESCRIPTION:\\ }


      Construct the internal information structure in a new ESMC\_newArray
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayDestruct] {ESMC\_newArrayDestruct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayDestruct(void){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Destruct the internal information structure in a new ESMC\_newArray
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayScatter] {ESMC\_newArrayScatter}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayScatter(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ESMC_LocalArray *larray,  // pointer to ESMC_LocalArray object
   int rootPET,              // root
   ESMCI::VM *vm){             // optional VM argument to speed up things\end{verbatim}
{\sf DESCRIPTION:\\ }


      Scatter the contents of an {\tt ESMC\_LocalArray} across the
      {\tt ESMC\_newArray}. PET-based blocking paradigm.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayScatter] {ESMC\_newArrayScatter}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayScatter(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ESMC_LocalArray *larray,  // pointer to ESMC_LocalArray object
   int rootPET,              // root
   ESMC_newArrayCommHandle *commh, // commu handle for non-blocking mode
   ESMCI::VM *vm){             // optional VM argument to speed up things\end{verbatim}
{\sf DESCRIPTION:\\ }


      Scatter the contents of an {\tt ESMC\_LocalArray} across the
      {\tt ESMC\_newArray}. DE-based non-blocking paradigm.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayScatter] {ESMC\_newArrayScatter}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayScatter(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ESMC_LocalArray *larray,  // pointer to ESMC_LocalArray object
   int rootPET,              // root
   int de,                   // DE for DE-based non-blocking scatter
   ESMCI::VM *vm){             // optional VM argument to speed up things\end{verbatim}
{\sf DESCRIPTION:\\ }


      Scatter the contents of an {\tt ESMC\_LocalArray} across the
      {\tt ESMC\_newArray}. DE-based non-blocking paradigm.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayScalarReduce] {ESMC\_newArrayScalarReduce}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayScalarReduce(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *result,             // result value (scalar)
   ESMC_TypeKind_Flag dtk,   // data type kind
   ESMC_Operation op,        // reduce operation
   int rootPET,              // root
   ESMCI::VM *vm){           // optional VM argument to speed up things\end{verbatim}
{\sf DESCRIPTION:\\ }


      Reduce the data of an {\tt ESMC\_newArray} into a single scalar value.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayScalarReduce] {ESMC\_newArrayScalarReduce}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayScalarReduce(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *result,             // result value (scalar)
   ESMC_TypeKind_Flag dtk,   // data type kind
   ESMC_Operation op,        // reduce operation
   int rootPET,              // root
   ESMC_newArrayCommHandle *commh, // commu handle for non-blocking mode
   ESMCI::VM *vm){           // optional VM argument to speed up things\end{verbatim}
{\sf DESCRIPTION:\\ }


      Reduce the data of an {\tt ESMC\_newArray} into a single scalar value.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayScalarReduce] {ESMC\_newArrayScalarReduce}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayScalarReduce(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *result,             // result value (scalar)
   ESMC_TypeKind_Flag dtk,   // data type kind
   ESMC_Operation op,        // reduce operation
   int rootPET,              // root
   int de,                   // DE for DE-based non-blocking reduce
   ESMCI::VM *vm){           // optional VM argument to speed up things\end{verbatim}
{\sf DESCRIPTION:\\ }


      Reduce the data of an {\tt ESMC\_newArray} into a single scalar value.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayWait] {ESMC\_newArrayWait}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayWait(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int rootPET,              // root
   ESMC_newArrayCommHandle *commh, // commu handle specif. non-blocking op.
   ESMCI::VM *vm){             // optional VM argument to speed up things\end{verbatim}
{\sf DESCRIPTION:\\ }


      Wait for a non-blocking newArray communication to be done with data
      object on rootPET.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayWait] {ESMC\_newArrayWait}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayWait(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int de,                   // DE for which to wait
   ESMCI::VM *vm){             // optional VM argument to speed up things\end{verbatim}
{\sf DESCRIPTION:\\ }


      Wait for a non-blocking newArray communication to finish for de.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayGet] {ESMC\_newArrayGet}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayGet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *rank_out,                      // out - rank of newArray
   ESMCI::DELayout **delayout,         // out - associated DELayout
   ESMC_LocalArray **localArrays,      // out - local arrays
   int len_localArrays,                // in  - length of localArrays array
   int *globalFullLBound,              // out - 2d array of bounds
   int *len_globalFullLBound,          // in  - lengths of the above array
   int *globalFullUBound,              // out - 2d array of bounds
   int *len_globalFullUBound,          // in  - lengths of the above array
   int *globalDataLBound,              // out - 2d array of bounds
   int *len_globalDataLBound,          // in  - lengths of the above array
   int *globalDataUBound,              // out - 2d array of bounds
   int *len_globalDataUBound,          // in  - lengths of the above array
   int *localDataLBound,               // out - 2d array of bounds
   int *len_localDataLBound,           // in  - lengths of the above array
   int *localDataUBound,               // out - 2d array of bounds
   int *len_localDataUBound            // in  - lengths of the above array
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get access to internals
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayPrint] {ESMC\_newArrayPrint}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArray::ESMC_newArrayPrint(void){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Print ESMC\_newArray
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayCreate] {ESMC\_newArrayCreate}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} ESMC_newArray *ESMC_newArrayCreate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ESMC_newArray * to newly allocated ESMC_newArray\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ESMC_LocalArray *larray,  // pointer to ESMC_LocalArray object
   int *haloWidth,           // halo width
   int deCount,              // number of DEs
   int rootPET,              // root
   int *rc){                 // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      This Create method generates a DELayout following a very simple
      algorithm that assumes:
        1. that the DE vertex weight is proportional to the number of logical
           grid points of the associated array domain - thus it is best to
           chunk up the entire domain into equal pieces 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayDestroy] {ESMC\_newArrayDestroy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_newArrayDestroy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ESMC_newArray **array){      // in - ESMC_newArray to destroy\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayScatterThread] {ESMC\_newArrayScatterThread}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void *ESMC_newArrayScatterThread(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      return value required by pthread standard\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       void *arg){               // pointer to information structure\end{verbatim}
{\sf DESCRIPTION:\\ }


      Scatter the contents of an {\tt ESMC\_LocalArray} across the
      {\tt ESMC\_newArray}. DE-based non-blocking paradigm.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_newArrayScalarReduceThread] {ESMC\_newArrayScalarReduceThread}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void *ESMC_newArrayScalarReduceThread(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      return value required by pthread standard\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       void *arg){               // pointer to information structure\end{verbatim}
{\sf DESCRIPTION:\\ }


      Reduce the contents of an {\tt ESMC\_newArray}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
