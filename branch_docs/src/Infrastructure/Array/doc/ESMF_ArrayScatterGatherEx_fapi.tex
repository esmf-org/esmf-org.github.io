%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_ArrayScatterGatherEx.F90,  Date: Tue May  5 20:59:43 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

  
   \subsubsection{Communication -- Scatter and Gather}
   \label{Array:ScatterGather}
   
   It is a common situation, particularly in legacy code, that an ESMF Array
   object must be filled with data originating from a large Fortran array stored
   on a single PET. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  if (localPet == 0) then
    allocate(farray(10,20,30))
    do k=1, 30
      do j=1, 20
        do i=1, 10
          farray(i, j, k) = k*1000 + j*100 +  i
        enddo
      enddo
    enddo
  else
    allocate(farray(0,0,0))
  endif
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1,1/), maxIndex=(/10,20,30/), &
    rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=3, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The {\tt ESMF\_ArrayScatter()} method provides a convenient way of scattering
   array data from a single root PET across the DEs of an ESMF Array object. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayScatter(array, farray=farray, rootPet=0, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  deallocate(farray)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The destination of the ArrayScatter() operation are all the DEs of a single
   tile. For multi-tile Arrays the destination tile can be specified. The 
   shape of the scattered Fortran array must match the shape of the destination
   tile in the ESMF Array.
  
   Gathering data decomposed and distributed across the DEs of an ESMF Array
   object into a single Fortran array on root PET is accomplished by calling
   {\tt ESMF\_ArrayGather()}. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  if (localPet == 3) then
    allocate(farray(10,20,30))
  else
    allocate(farray(0,0,0))
  endif
  
  call ESMF_ArrayGather(array, farray=farray, rootPet=3, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  deallocate(farray)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The source of the ArrayGather() operation are all the DEs of a single
   tile. For multi-tile Arrays the source tile can be specified. The 
   shape of the gathered Fortran array must match the shape of the source
   tile in the ESMF Array. 
%/////////////////////////////////////////////////////////////

   The {\tt ESMF\_ArrayScatter()} operation allows to fill entire replicated
   Array objects with data coming from a single root PET. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &
    regDecomp=(/2,3/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &
    distgridToArrayMap=(/0,0/), undistLBound=(/11,21/), &
    undistUBound=(/14,22/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The shape of the Fortran source array used in the Scatter() call must be
   that of the contracted Array, i.e. contracted DistGrid dimensions do not
   count. For the {\tt array} just created this means that the source array
   on {\tt rootPet} must be of shape 4 x 2. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  if (localPet == 0) then
    allocate(myFarray2D(4,2))
    do j=1,2
      do i=1,4
        myFarray2D(i,j) = i * 100.d0 + j * 1.2345d0 ! initialize
      enddo
    enddo
  else
    allocate(myFarray2D(0,0))
  endif
  
  call ESMF_ArrayScatter(array, farray=myFarray2D, rootPet=0, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  deallocate(myFarray2D)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   This will have filled each local 4 x 2 Array piece with the replicated
   data of {\tt myFarray2D}. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayDestroy(array, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_DistGridDestroy(distgrid, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   As a second example for the use of Scatter() and Gather() consider the
   following replicated Array created from existing local Fortran arrays. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(myFarray2D(3,10))
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(farray=myFarray2D, distgrid=distgrid, &
    indexflag=ESMF_INDEX_DELOCAL, distgridToArrayMap=(/0,2/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The {\tt array} object associates the 2nd DistGrid dimension with the 2nd
   Array dimension. The first DistGrid dimension is not associated with any
   Array dimension and will lead to replication of the Array along the DEs of
   this direction. Still, the local arrays that comprise the {\tt array} 
   object refer to independent pieces of memory and can be initialized 
   independently. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  myFarray2D = localPet ! initialize
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   However, the notion of replication becomes visible when an array of shape
   3 x 10 on root PET 0 is scattered across the Array object. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  if (localPet == 0) then
    allocate(myFarray2D2(5:7,11:20))
  
    do j=11,20
      do i=5,7
        myFarray2D2(i,j) = i * 100.d0 + j * 1.2345d0 ! initialize
      enddo
    enddo
  else
    allocate(myFarray2D2(0,0))
  endif
  
  call ESMF_ArrayScatter(array, farray=myFarray2D2, rootPet=0, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  deallocate(myFarray2D2)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The Array pieces on every DE will receive the same source data, resulting
   in a replication of data along DistGrid dimension 1. 
%/////////////////////////////////////////////////////////////

   When the inverse operation, i.e. {\tt ESMF\_ArrayGather()}, is applied to
   a replicated Array an intrinsic ambiguity needs to be considered. ESMF 
   defines the gathering of data of a replicated Array as the collection of data
   originating from the numerically higher DEs. This means that data in
   replicated elements associated with numerically lower DEs will be ignored
   during {\tt ESMF\_ArrayGather()}. For the current example this means that
   changing the Array contents on PET 1, which here corresponds to DE 1, 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  if (localPet == 1) then
    myFarray2D = real(1.2345, ESMF_KIND_R8)
  endif
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   will {\em not} affect the result of 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(myFarray2D2(3,10))
  myFarray2D2 = 0.d0    ! initialize to a known value
  call ESMF_ArrayGather(array, farray=myFarray2D2, rootPet=0, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The result remains completely defined by the unmodified values of Array in 
   DE 3, the numerically highest DE. However, overriding the DE-local Array
   piece on DE 3 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  if (localPet==3) then
    myFarray2D = real(5.4321, ESMF_KIND_R8)
  endif
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   will change the outcome of 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayGather(array, farray=myFarray2D2, rootPet=0, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   as expected. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  deallocate(myFarray2D2)

  call ESMF_ArrayDestroy(array, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_DistGridDestroy(distgrid, rc=rc)
 
\end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
