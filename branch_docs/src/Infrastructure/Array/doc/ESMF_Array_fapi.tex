%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_Array.F90,  Date: Tue May  5 20:59:42 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_ArraySet] {ESMF\_ArraySet - Set object-wide Array information}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArraySet()
   subroutine ESMF_ArraySetDefault(array, computationalLWidth, &
     computationalUWidth, name, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Array),   intent(inout)         :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: computationalLWidth(:,:)
     integer,            intent(in),  optional :: computationalUWidth(:,:)
     character(len = *), intent(in),  optional :: name
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Sets adjustable settings in an {\tt ESMF\_Array} object. Arrays with
       tensor dimensions will set values for {\em all} tensor components.
  
       The arguments are:
       \begin{description}
       \item [array]
         {\tt ESMF\_Array} object for which to set properties.
       \item [{[name]}]
         The Array name.
       \item[{[computationalLWidth]}] 
         \begin{sloppypar}
         This argument must have of size {\tt (dimCount, localDeCount)}.
         {\tt computationalLWidth} specifies the lower corner of the
         computational region with respect to the lower corner of the exclusive
         region for all local DEs.
         \end{sloppypar}
       \item[{[computationalUWidth]}] 
         \begin{sloppypar}
         This argument must have of size {\tt (dimCount, localDeCount)}.
         {\tt computationalUWidth} specifies the upper corner of the
         computational region with respect to the upper corner of the exclusive
         region for all local DEs.
         \end{sloppypar}
       \item [{[rc]}]
         Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySet] {ESMF\_ArraySet - Set DE-local Array information}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArraySet()
   subroutine ESMF_ArraySetPLocalDe(array, localDe, rimSeqIndex, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Array),   intent(inout)         :: array
     integer,            intent(in)            :: localDe
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: rimSeqIndex(:)
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Sets adjustable settings in an {\tt ESMF\_Array} object for a specific
       localDe.
  
       The arguments are:
       \begin{description}
       \item [array]
         {\tt ESMF\_Array} object for which to set properties.
       \item [localDe]
         Local DE for which to set values.
       \item[{[rimSeqIndex]}] 
         Sequence indices in the halo rim of localDe.
       \item [{[rc]}]
         Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySMM] {ESMF\_ArraySMM - Execute an Array sparse matrix multiplication}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_ArraySMM(srcArray, dstArray, routehandle, &
     routesyncflag, finishedflag, cancelledflag, zeroregion, termorderflag, &
     checkflag, dynamicMask, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Array),               intent(in),    optional :: srcArray
     type(ESMF_Array),               intent(inout), optional :: dstArray
     type(ESMF_RouteHandle),         intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_RouteSync_Flag),      intent(in),    optional :: routesyncflag
     logical,                        intent(out),   optional :: finishedflag
     logical,                        intent(out),   optional :: cancelledflag
     type(ESMF_Region_Flag),         intent(in),    optional :: zeroregion
     type(ESMF_TermOrder_Flag),      intent(in),    optional :: termorderflag
     logical,                        intent(in),    optional :: checkflag
     type(ESMF_DynamicMask), target, intent(in),    optional :: dynamicMask
     integer,                        intent(out),   optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[6.1.0] Added argument {\tt termorderflag}.
                The new argument gives the user control over the order in which
                the src terms are summed up.
   \item[7.1.0r] Added argument {\tt dynamicMask}.
                The new argument supports the dynamic masking feature.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     \begin{sloppypar}
     Execute a precomputed Array sparse matrix multiplication from {\tt srcArray}
     to {\tt dstArray}.
     Both {\tt srcArray} and {\tt dstArray} must match the respective Arrays
     used during {\tt ESMF\_ArraySMMStore()} in {\em type}, {\em kind}, and 
     memory layout of the {\em distributed} dimensions. However, the size, 
     number, and index order of {\em undistributed} dimensions may be different. See section
     \ref{RH:Reusability} for a more detailed discussion of RouteHandle 
     reusability.
     \end{sloppypar}
  
     The {\tt srcArray} and {\tt dstArray} arguments are optional in support of
     the situation where {\tt srcArray} and/or {\tt dstArray} are not defined on
     all PETs. The {\tt srcArray} and {\tt dstArray} must be specified on those
     PETs that hold source or destination DEs, respectively, but may be omitted
     on all other PETs. PETs that hold neither source nor destination DEs may
     omit both arguments.
  
     It is erroneous to specify the identical Array object for {\tt srcArray} and
     {\tt dstArray} arguments.
  
     See {\tt ESMF\_ArraySMMStore()} on how to precompute 
     {\tt routehandle}. See section \ref{Array:SparseMatMul} for details on the
     operation {\tt ESMF\_ArraySMM()} performs.
  
     This call is {\em collective} across the current VM.
  
     \begin{description}
     \item [{[srcArray]}]
       {\tt ESMF\_Array} with source data.
     \item [{[dstArray]}]
       {\tt ESMF\_Array} with destination data.
     \item [routehandle]
       Handle to the precomputed Route.
     \item [{[routesyncflag]}]
       Indicate communication option. Default is {\tt ESMF\_ROUTESYNC\_BLOCKING},
       resulting in a blocking operation.
       See section \ref{const:routesync} for a complete list of valid settings.
     \item [{[finishedflag]}]
       \begin{sloppypar}
       Used in combination with {\tt routesyncflag = ESMF\_ROUTESYNC\_NBTESTFINISH}.
       Returned {\tt finishedflag} equal to {\tt .true.} indicates that all
       operations have finished. A value of {\tt .false.} indicates that there
       are still unfinished operations that require additional calls with
       {\tt routesyncflag = ESMF\_ROUTESYNC\_NBTESTFINISH}, or a final call with
       {\tt routesyncflag = ESMF\_ROUTESYNC\_NBWAITFINISH}. For all other {\tt routesyncflag}
       settings the returned value in {\tt finishedflag} is always {\tt .true.}.
       \end{sloppypar}
     \item [{[cancelledflag]}]
       A value of {\tt .true.} indicates that were cancelled communication
       operations. In this case the data in the {\tt dstArray} must be considered
       invalid. It may have been partially modified by the call. A value of
       {\tt .false.} indicates that none of the communication operations was
       cancelled. The data in {\tt dstArray} is valid if {\tt finishedflag} 
       returns equal {\tt .true.}.
     \item [{[zeroregion]}]
       \begin{sloppypar}
       If set to {\tt ESMF\_REGION\_TOTAL} {\em (default)} the total regions of
       all DEs in {\tt dstArray} will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       {\tt ESMF\_REGION\_EMPTY} the elements in {\tt dstArray} will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting {\tt zeroregion} to 
       {\tt ESMF\_REGION\_SELECT} will only zero out those elements in the 
       destination Array that will be updated by the sparse matrix
       multiplication. See section \ref{const:region} for a complete list of
       valid settings.
       \end{sloppypar}
     \item [{[termorderflag]}]
       Specifies the order of the source side terms in all of the destination
       sums. The {\tt termorderflag} only affects the order of terms during 
       the execution of the RouteHandle. See the \ref{RH:bfb} section for an
       in-depth discussion of {\em all} bit-for-bit reproducibility
       aspects related to route-based communication methods.
       See \ref{const:termorderflag} for a full list of options.
       The default setting depends on whether the {\tt dynamicMask} argument
       is present or not. With {\tt dynamicMask} argument present, the default
       of {\tt termorderflag} is {\tt ESMF\_TERMORDER\_SRCSEQ}. This ensures
       that {\tt all} source terms are present on the destination side, and 
       the interpolation can be calculated as a single sum. When 
       {\tt dynamicMask} is absent, the default of {\tt termorderflag} is
       {\tt ESMF\_TERMORDER\_FREE}, allowing maximum flexibility and partial 
       sums for optimum performance.
     \item [{[checkflag]}]
       If set to {\tt .TRUE.} the input Array pair will be checked for
       consistency with the precomputed operation provided by {\tt routehandle}.
       If set to {\tt .FALSE.} {\em (default)} only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       {\tt checkflag} to {\tt .FALSE.} to achieve highest performance.
     \item [{[dynamicMask]}]
       Object holding dynamic masking information.
       See section \ref{RH:DynMask} for a discussion of dynamic masking.
     \item [{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySMMRelease] {ESMF\_ArraySMMRelease - Release resources associated with Array sparse matrix multiplication}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_ArraySMMRelease(routehandle, noGarbage, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: noGarbage
     integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[8.0.0] Added argument {\tt noGarbage}.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Release resources associated with an Array sparse matrix multiplication. 
     After this call {\tt routehandle} becomes invalid.
  
     \begin{description}
     \item [routehandle]
       Handle to the precomputed Route.
     \item[{[noGarbage]}]
       If set to {\tt .TRUE.} the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases -- a situation which may lead to hard to debug 
       application crashes.
   
       It is generally recommended to leave the {\tt noGarbage} argument
       set to {\tt .FALSE.} (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully 
       removing the entire temporary object from memory.
     \item [{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySMMStore] {ESMF\_ArraySMMStore - Precompute Array sparse matrix multiplication with local factors}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStore<type><kind>(srcArray, dstArray, &
     routehandle, factorList, factorIndexList, &
     ignoreUnmatchedIndices, srcTermProcessing, pipelineDepth, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Array),          intent(in)              :: srcArray
     type(ESMF_Array),          intent(inout)           :: dstArray
     type(ESMF_RouteHandle),    intent(inout)           :: routehandle
     <type>(ESMF_KIND_<kind>), target, intent(in)       :: factorList(:)
     integer(ESMF_KIND_<kind>), intent(in)              :: factorIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                   intent(in),    optional :: ignoreUnmatchedIndices
     integer,                   intent(inout), optional :: srcTermProcessing
     integer,                   intent(inout), optional :: pipelineDepth
     integer,                   intent(out),   optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[6.1.0] Added argument {\tt srcTermProcessing}.
                Added argument {\tt pipelineDepth}.
                The new arguments provide access to the tuning parameters
                affecting the sparse matrix execution.
   \item[7.0.0] Added argument {\tt transposeRoutehandle} to allow a handle to
                the transposed matrix operation to be returned.\newline
                Added argument {\tt ignoreUnmatchedIndices} to support sparse 
                matrices that contain elements with indices that do not have a
                match within the source or destination Array.
   \item[7.1.0r] Removed argument {\tt transposeRoutehandle} and provide it
                via interface overloading instead. This allows argument 
                {\tt srcArray} to stay strictly intent(in) for this entry point.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   \label{ArraySMMStoreTK}
   {\tt ESMF\_ArraySMMStore()} is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   -- in principle -- each PET to call into {\tt ESMF\_ArraySMMStore()}
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the {\tt ESMF\_ArraySMMStore()} method, as provided
   through the separate entry points shown in \ref{ArraySMMStoreTK} and
   \ref{ArraySMMStoreNF}, is described in the following paragraphs as a whole.
  
     \begin{sloppypar}
     Store an Array sparse matrix multiplication operation from {\tt srcArray}
     to {\tt dstArray}. PETs that specify non-zero matrix coefficients must use
     the <type><kind> overloaded interface and provide the {\tt factorList} and
     {\tt factorIndexList} arguments. Providing {\tt factorList} and
     {\tt factorIndexList} arguments with {\tt size(factorList) = (/0/)} and
     {\tt size(factorIndexList) = (/2,0/)} or {\tt (/4,0/)} indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     {\em without} {\tt factorList} and {\tt factorIndexList} arguments.
     \end{sloppypar}
  
     Both {\tt srcArray} and {\tt dstArray} are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of tiles within the DistGrid or by user-supplied arbitrary
     sequence indices. See section \ref{Array:SparseMatMul} for details on the
     definition of {\em sequence indices}.
  
     Source and destination Arrays, as well as the supplied {\tt factorList}
     argument, may be of different <type><kind>. Further source and
     destination Arrays may differ in shape and number of elements.
  
     It is erroneous to specify the identical Array object for {\tt srcArray} and
     {\tt dstArray} arguments.
  
     The routine returns an {\tt ESMF\_RouteHandle} that can be used to call 
     {\tt ESMF\_ArraySMM()} on any pair of Arrays that matches 
     {\tt srcArray} and {\tt dstArray} in {\em type}, {\em kind}, and 
     memory layout of the {\em distributed} dimensions. However, the size,
     number, and index order of {\em undistributed} dimensions may be different.
     See section \ref{RH:Reusability} for a more detailed discussion of 
     RouteHandle reusability.
  
     This method is overloaded for:\newline
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},\newline 
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
  
     This call is {\em collective} across the current VM.
  
     \begin{description}
  
     \item [srcArray]
       {\tt ESMF\_Array} with source data.
  
     \item [dstArray]
       {\tt ESMF\_Array} with destination data. The data in this Array may be
       destroyed by this call.
  
     \item [routehandle]
       Handle to the precomputed Route.
  
     \item [factorList]
       List of non-zero coefficients.
  
     \item [factorIndexList]
       Pairs of sequence indices for the factors stored in {\tt factorList}.
  
       \begin{sloppypar}
       The second dimension of {\tt factorIndexList} steps through the list of
       pairs, i.e. {\tt size(factorIndexList,2) == size(factorList)}. The first
       dimension of {\tt factorIndexList} is either of size 2 or size 4.
       \end{sloppypar}
  
       In the {\em size 2 format} {\tt factorIndexList(1,:)} specifies the
       sequence index of the source element in the {\tt srcArray} while
       {\tt factorIndexList(2,:)} specifies the sequence index of the
       destination element in {\tt dstArray}. For this format to be a valid
       option source and destination Arrays must have matching number of
       tensor elements (the product of the sizes of all Array tensor dimensions).
       Under this condition an identity matrix can be applied within the space of
       tensor elements for each sparse matrix factor.
  
       \begin{sloppypar}
       The {\em size 4 format} is more general and does not require a matching
       tensor element count. Here the {\tt factorIndexList(1,:)} specifies the
       sequence index while {\tt factorIndexList(2,:)} specifies the tensor
       sequence index of the source element in the {\tt srcArray}. Further
       {\tt factorIndexList(3,:)} specifies the sequence index and
       {\tt factorIndexList(4,:)} specifies the tensor sequence index of the 
       destination element in the {\tt dstArray}.
       \end{sloppypar}
  
       See section \ref{Array:SparseMatMul} for details on the definition of 
       Array {\em sequence indices} and {\em tensor sequence indices}.
  
     \item [{[ignoreUnmatchedIndices]}]
       A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       {\tt srcArray} or {\tt dstArray} side. The default setting is 
       {\tt .false.}, indicating that it is an error when such a situation is 
       encountered. Setting {\tt ignoreUnmatchedIndices} to {\tt .true.} ignores
       entries with unmatched indices.
  
     \item [{[srcTermProcessing]}]
       The {\tt srcTermProcessing} parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied 
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of {\tt srcTermProcessing} indicate the maximum number
       of terms in the partial sums on the source side.
  
       Note that partial sums may lead to bit-for-bit differences in the results.
       See section \ref{RH:bfb} for an in-depth discussion of {\em all}
       bit-for-bit reproducibility aspects related to route-based communication
       methods.
  
       \begin{sloppypar}
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt srcTermProcessing} parameter. The intent on the 
       {\tt srcTermProcessing} argument is "{\tt inout}" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the 
       {\tt srcTermProcessing} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt srcTermProcessing} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt srcTermProcessing}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt srcTermProcessing} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       {\tt srcTermProcessing} argument is omitted.
       \end{sloppypar}
       
     \item [{[pipelineDepth]}]
       The {\tt pipelineDepth} parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of {\tt pipelineDepth} typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.
  
       Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.
  
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt pipelineDepth} parameter. The intent on the 
       {\tt pipelineDepth} argument is "{\tt inout}" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the 
       {\tt pipelineDepth} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt pipelineDepth} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt pipelineDepth}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt pipelineDepth} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       {\tt pipelineDepth} argument is omitted.
       
     \item [{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySMMStore] {ESMF\_ArraySMMStore - Precompute Array sparse matrix multiplication and transpose with local factors}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStore<type><kind>TP(srcArray, dstArray, &
     routehandle, transposeRoutehandle, factorList, factorIndexList, &
     ignoreUnmatchedIndices, srcTermProcessing, pipelineDepth, &
     rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Array),          intent(inout)           :: srcArray
     type(ESMF_Array),          intent(inout)           :: dstArray
     type(ESMF_RouteHandle),    intent(inout)           :: routehandle
     type(ESMF_RouteHandle),    intent(inout)           :: transposeRoutehandle
     <type>(ESMF_KIND_<kind>), target, intent(in)       :: factorList(:)
     integer(ESMF_KIND_<kind>), intent(in)              :: factorIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                   intent(in),    optional :: ignoreUnmatchedIndices
     integer,                   intent(inout), optional :: srcTermProcessing
     integer,                   intent(inout), optional :: pipelineDepth
     integer,                   intent(out),   optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   \label{ArraySMMStoreTK}
   {\tt ESMF\_ArraySMMStore()} is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   -- in principle -- each PET to call into {\tt ESMF\_ArraySMMStore()}
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the {\tt ESMF\_ArraySMMStore()} method, as provided
   through the separate entry points shown in \ref{ArraySMMStoreTK} and
   \ref{ArraySMMStoreNF}, is described in the following paragraphs as a whole.
  
     \begin{sloppypar}
     Store an Array sparse matrix multiplication operation from {\tt srcArray}
     to {\tt dstArray}. PETs that specify non-zero matrix coefficients must use
     the <type><kind> overloaded interface and provide the {\tt factorList} and
     {\tt factorIndexList} arguments. Providing {\tt factorList} and
     {\tt factorIndexList} arguments with {\tt size(factorList) = (/0/)} and
     {\tt size(factorIndexList) = (/2,0/)} or {\tt (/4,0/)} indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     {\em without} {\tt factorList} and {\tt factorIndexList} arguments.
     \end{sloppypar}
  
     Both {\tt srcArray} and {\tt dstArray} are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of tiles within the DistGrid or by user-supplied arbitrary
     sequence indices. See section \ref{Array:SparseMatMul} for details on the
     definition of {\em sequence indices}.
  
     Source and destination Arrays, as well as the supplied {\tt factorList}
     argument, may be of different <type><kind>. Further source and
     destination Arrays may differ in shape and number of elements.
  
     It is erroneous to specify the identical Array object for {\tt srcArray} and
     {\tt dstArray} arguments.
  
     The routine returns an {\tt ESMF\_RouteHandle} that can be used to call 
     {\tt ESMF\_ArraySMM()} on any pair of Arrays that matches 
     {\tt srcArray} and {\tt dstArray} in {\em type}, {\em kind}, and 
     memory layout of the {\em distributed} dimensions. However, the size,
     number, and index order of {\em undistributed} dimensions may be different.
     See section \ref{RH:Reusability} for a more detailed discussion of
     RouteHandle reusability.
  
     This method is overloaded for:\newline
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},\newline 
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
  
     This call is {\em collective} across the current VM.
  
     \begin{description}
  
     \item [srcArray]
       {\tt ESMF\_Array} with source data. The data in this Array may be
       destroyed by this call.
  
     \item [dstArray]
       {\tt ESMF\_Array} with destination data. The data in this Array may be
       destroyed by this call.
  
     \item [routehandle]
       Handle to the precomputed Route.
  
     \item [{[transposeRoutehandle]}]
       Handle to the transposed matrix operation. The transposed operation goes
       from {\tt dstArray} to {\tt srcArray}.
  
     \item [factorList]
       List of non-zero coefficients.
  
     \item [factorIndexList]
       Pairs of sequence indices for the factors stored in {\tt factorList}.
  
       \begin{sloppypar}
       The second dimension of {\tt factorIndexList} steps through the list of
       pairs, i.e. {\tt size(factorIndexList,2) == size(factorList)}. The first
       dimension of {\tt factorIndexList} is either of size 2 or size 4.
       \end{sloppypar}
  
       In the {\em size 2 format} {\tt factorIndexList(1,:)} specifies the
       sequence index of the source element in the {\tt srcArray} while
       {\tt factorIndexList(2,:)} specifies the sequence index of the
       destination element in {\tt dstArray}. For this format to be a valid
       option source and destination Arrays must have matching number of
       tensor elements (the product of the sizes of all Array tensor dimensions).
       Under this condition an identity matrix can be applied within the space of
       tensor elements for each sparse matrix factor.
  
       \begin{sloppypar}
       The {\em size 4 format} is more general and does not require a matching
       tensor element count. Here the {\tt factorIndexList(1,:)} specifies the
       sequence index while {\tt factorIndexList(2,:)} specifies the tensor
       sequence index of the source element in the {\tt srcArray}. Further
       {\tt factorIndexList(3,:)} specifies the sequence index and
       {\tt factorIndexList(4,:)} specifies the tensor sequence index of the 
       destination element in the {\tt dstArray}.
       \end{sloppypar}
  
       See section \ref{Array:SparseMatMul} for details on the definition of 
       Array {\em sequence indices} and {\em tensor sequence indices}.
  
     \item [{[ignoreUnmatchedIndices]}]
       A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       {\tt srcArray} or {\tt dstArray} side. The default setting is 
       {\tt .false.}, indicating that it is an error when such a situation is 
       encountered. Setting {\tt ignoreUnmatchedIndices} to {\tt .true.} ignores
       entries with unmatched indices.
  
     \item [{[srcTermProcessing]}]
       The {\tt srcTermProcessing} parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied 
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of {\tt srcTermProcessing} indicate the maximum number
       of terms in the partial sums on the source side.
  
       Note that partial sums may lead to bit-for-bit differences in the results.
       See section \ref{RH:bfb} for an in-depth discussion of {\em all}
       bit-for-bit reproducibility aspects related to route-based communication
       methods.
  
       \begin{sloppypar}
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt srcTermProcessing} parameter. The intent on the 
       {\tt srcTermProcessing} argument is "{\tt inout}" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the 
       {\tt srcTermProcessing} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt srcTermProcessing} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt srcTermProcessing}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt srcTermProcessing} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       {\tt srcTermProcessing} argument is omitted.
       \end{sloppypar}
       
     \item [{[pipelineDepth]}]
       The {\tt pipelineDepth} parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of {\tt pipelineDepth} typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.
  
       Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.
  
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt pipelineDepth} parameter. The intent on the 
       {\tt pipelineDepth} argument is "{\tt inout}" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the 
       {\tt pipelineDepth} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt pipelineDepth} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt pipelineDepth}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt pipelineDepth} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       {\tt pipelineDepth} argument is omitted.
       
     \item [{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySMMStore] {ESMF\_ArraySMMStore - Precompute Array sparse matrix multiplication without local factors}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStoreNF(srcArray, dstArray, routehandle, &
     ignoreUnmatchedIndices, srcTermProcessing, pipelineDepth, &
     rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Array),       intent(in)              :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: srcTermProcessing
     integer,                intent(inout), optional :: pipelineDepth
     integer,                intent(out),   optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[6.1.0] Added argument {\tt srcTermProcessing}.
                Added argument {\tt pipelineDepth}.
                The new arguments provide access to the tuning parameters
                affecting the sparse matrix execution.
   \item[7.0.0] Added argument {\tt transposeRoutehandle} to allow a handle to
                the transposed matrix operation to be returned.\newline
                Added argument {\tt ignoreUnmatchedIndices} to support sparse 
                matrices that contain elements with indices that do not have a
                match within the source or destination Array.
   \item[7.1.0r] Removed argument {\tt transposeRoutehandle} and provide it
                via interface overloading instead. This allows argument 
                {\tt srcArray} to stay strictly intent(in) for this entry point.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   \label{ArraySMMStoreNF}
   {\tt ESMF\_ArraySMMStore()} is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   -- in principle -- each PET to call into {\tt ESMF\_ArraySMMStore()}
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the {\tt ESMF\_ArraySMMStore()} method, as provided
   through the separate entry points shown in \ref{ArraySMMStoreTK} and
   \ref{ArraySMMStoreNF}, is described in the following paragraphs as a whole.
  
     \begin{sloppypar}
     Store an Array sparse matrix multiplication operation from {\tt srcArray}
     to {\tt dstArray}. PETs that specify non-zero matrix coefficients must use
     the <type><kind> overloaded interface and provide the {\tt factorList} and
     {\tt factorIndexList} arguments. Providing {\tt factorList} and
     {\tt factorIndexList} arguments with {\tt size(factorList) = (/0/)} and
     {\tt size(factorIndexList) = (/2,0/)} or {\tt (/4,0/)} indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     {\em without} {\tt factorList} and {\tt factorIndexList} arguments.
     \end{sloppypar}
  
     Both {\tt srcArray} and {\tt dstArray} are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of tiles within the DistGrid or by user-supplied arbitrary
     sequence indices. See section \ref{Array:SparseMatMul} for details on the
     definition of {\em sequence indices}.
  
     Source and destination Arrays, as well as the supplied {\tt factorList}
     argument, may be of different <type><kind>. Further source and
     destination Arrays may differ in shape and number of elements.
  
     It is erroneous to specify the identical Array object for {\tt srcArray} and
     {\tt dstArray} arguments.
  
     The routine returns an {\tt ESMF\_RouteHandle} that can be used to call 
     {\tt ESMF\_ArraySMM()} on any pair of Arrays that matches 
     {\tt srcArray} and {\tt dstArray} in {\em type}, {\em kind}, and 
     memory layout of the {\em distributed} dimensions. However, the size,
     number, and index order of {\em undistributed} dimensions may be different.
     See section \ref{RH:Reusability} for a more detailed discussion of
     RouteHandle reusability.
  
     This call is {\em collective} across the current VM.
  
     \begin{description}
  
     \item [srcArray]
       {\tt ESMF\_Array} with source data.
  
     \item [dstArray]
       {\tt ESMF\_Array} with destination data. The data in this Array may be
       destroyed by this call.
  
     \item [routehandle]
       Handle to the precomputed Route.
  
     \item [{[ignoreUnmatchedIndices]}]
       A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       {\tt srcArray} or {\tt dstArray} side. The default setting is 
       {\tt .false.}, indicating that it is an error when such a situation is 
       encountered. Setting {\tt ignoreUnmatchedIndices} to {\tt .true.} ignores
       entries with unmatched indices.
  
     \item [{[srcTermProcessing]}]
       The {\tt srcTermProcessing} parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied 
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of {\tt srcTermProcessing} indicate the maximum number
       of terms in the partial sums on the source side.
  
       Note that partial sums may lead to bit-for-bit differences in the results.
       See section \ref{RH:bfb} for an in-depth discussion of {\em all}
       bit-for-bit reproducibility aspects related to route-based communication
       methods.
  
       \begin{sloppypar}
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt srcTermProcessing} parameter. The intent on the 
       {\tt srcTermProcessing} argument is "{\tt inout}" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the 
       {\tt srcTermProcessing} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt srcTermProcessing} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt srcTermProcessing}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt srcTermProcessing} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       {\tt srcTermProcessing} argument is omitted.
       \end{sloppypar}
       
     \item [{[pipelineDepth]}]
       The {\tt pipelineDepth} parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of {\tt pipelineDepth} typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.
  
       Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.
  
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt pipelineDepth} parameter. The intent on the 
       {\tt pipelineDepth} argument is "{\tt inout}" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the 
       {\tt pipelineDepth} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt pipelineDepth} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt pipelineDepth}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt pipelineDepth} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       {\tt pipelineDepth} argument is omitted.
       
     \item [{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySMMStore] {ESMF\_ArraySMMStore - Precompute Array sparse matrix multiplication and transpose without local factors}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStoreNFTP(srcArray, dstArray, routehandle, &
     transposeRoutehandle, ignoreUnmatchedIndices, &
     srcTermProcessing, pipelineDepth, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Array),       intent(inout)           :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     type(ESMF_RouteHandle), intent(inout)           :: transposeRoutehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: srcTermProcessing
     integer,                intent(inout), optional :: pipelineDepth
     integer,                intent(out),   optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   \label{ArraySMMStoreNF}
   {\tt ESMF\_ArraySMMStore()} is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   -- in principle -- each PET to call into {\tt ESMF\_ArraySMMStore()}
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the {\tt ESMF\_ArraySMMStore()} method, as provided
   through the separate entry points shown in \ref{ArraySMMStoreTK} and
   \ref{ArraySMMStoreNF}, is described in the following paragraphs as a whole.
  
     \begin{sloppypar}
     Store an Array sparse matrix multiplication operation from {\tt srcArray}
     to {\tt dstArray}. PETs that specify non-zero matrix coefficients must use
     the <type><kind> overloaded interface and provide the {\tt factorList} and
     {\tt factorIndexList} arguments. Providing {\tt factorList} and
     {\tt factorIndexList} arguments with {\tt size(factorList) = (/0/)} and
     {\tt size(factorIndexList) = (/2,0/)} or {\tt (/4,0/)} indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     {\em without} {\tt factorList} and {\tt factorIndexList} arguments.
     \end{sloppypar}
  
     Both {\tt srcArray} and {\tt dstArray} are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of tiles within the DistGrid or by user-supplied arbitrary
     sequence indices. See section \ref{Array:SparseMatMul} for details on the
     definition of {\em sequence indices}.
  
     Source and destination Arrays, as well as the supplied {\tt factorList}
     argument, may be of different <type><kind>. Further source and
     destination Arrays may differ in shape and number of elements.
  
     It is erroneous to specify the identical Array object for {\tt srcArray} and
     {\tt dstArray} arguments.
  
     The routine returns an {\tt ESMF\_RouteHandle} that can be used to call 
     {\tt ESMF\_ArraySMM()} on any pair of Arrays that matches 
     {\tt srcArray} and {\tt dstArray} in {\em type}, {\em kind}, and 
     memory layout of the {\em distributed} dimensions. However, the size,
     number, and index order of {\em undistributed} dimensions may be different.
     See section \ref{RH:Reusability} for a more detailed discussion of
     RouteHandle reusability.
  
     This call is {\em collective} across the current VM.
  
     \begin{description}
  
     \item [srcArray]
       {\tt ESMF\_Array} with source data. The data in this Array may be
       destroyed by this call.
  
     \item [dstArray]
       {\tt ESMF\_Array} with destination data. The data in this Array may be
       destroyed by this call.
  
     \item [routehandle]
       Handle to the precomputed Route.
  
     \item [{[transposeRoutehandle]}]
       Handle to the transposed matrix operation. The transposed operation goes
       from {\tt dstArray} to {\tt srcArray}.
       
     \item [{[ignoreUnmatchedIndices]}]
       A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       {\tt srcArray} or {\tt dstArray} side. The default setting is 
       {\tt .false.}, indicating that it is an error when such a situation is 
       encountered. Setting {\tt ignoreUnmatchedIndices} to {\tt .true.} ignores
       entries with unmatched indices.
  
     \item [{[srcTermProcessing]}]
       The {\tt srcTermProcessing} parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied 
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of {\tt srcTermProcessing} indicate the maximum number
       of terms in the partial sums on the source side.
  
       Note that partial sums may lead to bit-for-bit differences in the results.
       See section \ref{RH:bfb} for an in-depth discussion of {\em all}
       bit-for-bit reproducibility aspects related to route-based communication
       methods.
  
       \begin{sloppypar}
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt srcTermProcessing} parameter. The intent on the 
       {\tt srcTermProcessing} argument is "{\tt inout}" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the 
       {\tt srcTermProcessing} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt srcTermProcessing} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt srcTermProcessing}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt srcTermProcessing} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       {\tt srcTermProcessing} argument is omitted.
       \end{sloppypar}
       
     \item [{[pipelineDepth]}]
       The {\tt pipelineDepth} parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of {\tt pipelineDepth} typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.
  
       Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.
  
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt pipelineDepth} parameter. The intent on the 
       {\tt pipelineDepth} argument is "{\tt inout}" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the 
       {\tt pipelineDepth} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt pipelineDepth} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt pipelineDepth}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt pipelineDepth} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       {\tt pipelineDepth} argument is omitted.
       
     \item [{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySMMStore] {ESMF\_ArraySMMStore - Precompute sparse matrix multiplication using factors read from file.}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStoreFromFile(srcArray, dstArray, filename, &
     routehandle, ignoreUnmatchedIndices, &
     srcTermProcessing, pipelineDepth, rc)
 
   ! ARGUMENTS:
     type(ESMF_Array),       intent(in)              :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     character(len=*),       intent(in)              :: filename
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: srcTermProcessing
     integer,                intent(inout), optional :: pipeLineDepth
     integer,                intent(out),   optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   Compute an {\tt ESMF\_RouteHandle} using factors read from file.
  
   The arguments are:
  
   \begin{description}
  
   \item [srcArray]
       {\tt ESMF\_Array} with source data.
  
   \item [dstArray]
         {\tt ESMF\_Array} with destination data. The data in this Array may be
         destroyed by this call.
  
   \item [filename]
         Path to the file containing weights for creating an {\tt ESMF\_RouteHandle}.
         See ~(\ref{sec:weightfileformat}) for a description of the SCRIP weight
         file format. Only "row", "col", and "S" variables are required. They
         must be one-dimensionsal with dimension "n\_s".
  
   \item [routehandle]
         Handle to the {\tt ESMF\_RouteHandle}.
  
     \item [{[ignoreUnmatchedIndices]}]
       A logical flag that affects the behavior for when sequence indices
       in the sparse matrix are encountered that do not have a match on the
       {\tt srcArray} or {\tt dstArray} side. The default setting is
       {\tt .false.}, indicating that it is an error when such a situation is
       encountered. Setting {\tt ignoreUnmatchedIndices} to {\tt .true.} ignores
       entries with unmatched indices.
  
     \item [{[srcTermProcessing]}]
       The {\tt srcTermProcessing} parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of {\tt srcTermProcessing} indicate the maximum number
       of terms in the partial sums on the source side.
  
       Note that partial sums may lead to bit-for-bit differences in the results.
       See section \ref{RH:bfb} for an in-depth discussion of {\em all}
       bit-for-bit reproducibility aspects related to route-based communication
       methods.
  
       \begin{sloppypar}
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt srcTermProcessing} parameter. The intent on the
       {\tt srcTermProcessing} argument is "{\tt inout}" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the
       {\tt srcTermProcessing} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt srcTermProcessing} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt srcTermProcessing}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt srcTermProcessing} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       {\tt srcTermProcessing} argument is omitted.
       \end{sloppypar}
  
     \item [{[pipelineDepth]}]
       The {\tt pipelineDepth} parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of {\tt pipelineDepth} typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.
  
       Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt pipelineDepth} parameter. The intent on the
       {\tt pipelineDepth} argument is "{\tt inout}" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the
       {\tt pipelineDepth} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt pipelineDepth} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt pipelineDepth}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt pipelineDepth} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       {\tt pipelineDepth} argument is omitted.
  
     \item [{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySMMStore] {ESMF\_ArraySMMStore - Precompute sparse matrix multiplication and transpose using factors read from file.}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStoreFromFileTP(srcArray, dstArray, filename, &
     routehandle, transposeRoutehandle, ignoreUnmatchedIndices,&
     srcTermProcessing, pipelineDepth, rc)
 
   ! ARGUMENTS:
     type(ESMF_Array),       intent(inout)           :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     character(len=*),       intent(in)              :: filename
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     type(ESMF_RouteHandle), intent(inout)           :: transposeRoutehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: srcTermProcessing
     integer,                intent(inout), optional :: pipeLineDepth
     integer,                intent(out),   optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   Compute an {\tt ESMF\_RouteHandle} using factors read from file.
  
   The arguments are:
  
   \begin{description}
  
   \item [srcArray]
       {\tt ESMF\_Array} with source data. The data in this Array may be
       destroyed by this call.
  
   \item [dstArray]
         {\tt ESMF\_Array} with destination data. The data in this Array may be
         destroyed by this call.
  
   \item [filename]
         Path to the file containing weights for creating an {\tt ESMF\_RouteHandle}.
         See ~(\ref{sec:weightfileformat}) for a description of the SCRIP weight
         file format. Only "row", "col", and "S" variables are required. They
         must be one-dimensionsal with dimension "n\_s".
  
   \item [routehandle]
         Handle to the {\tt ESMF\_RouteHandle}.
  
     \item [{[transposeRoutehandle]}]
       Handle to the transposed matrix operation. The transposed operation goes
       from {\tt dstArray} to {\tt srcArray}.
  
     \item [{[ignoreUnmatchedIndices]}]
       A logical flag that affects the behavior for when sequence indices
       in the sparse matrix are encountered that do not have a match on the
       {\tt srcArray} or {\tt dstArray} side. The default setting is
       {\tt .false.}, indicating that it is an error when such a situation is
       encountered. Setting {\tt ignoreUnmatchedIndices} to {\tt .true.} ignores
       entries with unmatched indices.
  
     \item [{[srcTermProcessing]}]
       The {\tt srcTermProcessing} parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of {\tt srcTermProcessing} indicate the maximum number
       of terms in the partial sums on the source side.
  
       Note that partial sums may lead to bit-for-bit differences in the results.
       See section \ref{RH:bfb} for an in-depth discussion of {\em all}
       bit-for-bit reproducibility aspects related to route-based communication
       methods.
  
       \begin{sloppypar}
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt srcTermProcessing} parameter. The intent on the
       {\tt srcTermProcessing} argument is "{\tt inout}" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the
       {\tt srcTermProcessing} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt srcTermProcessing} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt srcTermProcessing}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt srcTermProcessing} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       {\tt srcTermProcessing} argument is omitted.
       \end{sloppypar}
  
     \item [{[pipelineDepth]}]
       The {\tt pipelineDepth} parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of {\tt pipelineDepth} typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.
  
       Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.
       The {\tt ESMF\_ArraySMMStore()} method implements an auto-tuning scheme
       for the {\tt pipelineDepth} parameter. The intent on the
       {\tt pipelineDepth} argument is "{\tt inout}" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the
       {\tt pipelineDepth} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt pipelineDepth} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt pipelineDepth}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt pipelineDepth} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       {\tt pipelineDepth} argument is omitted.
  
     \item [{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArraySync] {ESMF\_ArraySync - Synchronize DEs across the Array in case of sharing}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_ArraySync(array, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Array), intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc  \end{verbatim}
{\sf DESCRIPTION:\\ }


       Synchronizes access to DEs across {\tt array} to make sure PETs correctly
       access the data for read and write when DEs are shared. 
  
       The arguments are:
       \begin{description}
       \item[array] 
            Specified {\tt ESMF\_Array} object.
       \item[{[rc]}] 
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayValidate] {ESMF\_ArrayValidate - Validate object-wide Array information}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_ArrayValidate(array, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Array), intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc  \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


        Validates that the {\tt Array} is internally consistent.
        The method returns an error code if problems are found.  
  
       The arguments are:
       \begin{description}
       \item[array] 
            Specified {\tt ESMF\_Array} object.
       \item[{[rc]}] 
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_ArrayWrite] {ESMF\_ArrayWrite - Write Array data into a file}


   \label{api:ArrayWrite}
  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_ArrayWrite(array, fileName, &
       variableName, convention, purpose,  &
       overwrite, status, timeslice, iofmt, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Array),           intent(in)            :: array
     character(*),               intent(in)            :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*),               intent(in),  optional :: variableName
     character(*),               intent(in),  optional :: convention
     character(*),               intent(in),  optional :: purpose
     logical,                    intent(in),  optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional :: status
     integer,                    intent(in),  optional :: timeslice
     type(ESMF_IOFmt_Flag),      intent(in),  optional :: iofmt
     integer,                    intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Write Array data into a file. For this API to be functional, the 
     environment variable {\tt ESMF\_PIO} should be set to "internal" when 
     the ESMF library is built.  Please see the section on 
     Data I/O,~\ref{io:dataio}. 
  
     When {\tt convention} and {\tt purpose} arguments are specified,
     a NetCDF variable can be created with user-specified dimension labels and
     attributes.  Dimension labels may be defined for both gridded and
     ungridded dimensions.  Dimension labels for gridded dimensions are specified
     at the DistGrid level by attaching an ESMF Attribute package to it.  The Attribute
     package must contain an attribute named by the pre-defined ESMF parameter
     {\tt ESMF\_ATT\_GRIDDED\_DIM\_LABELS}.  The corresponding value is an array of
     character strings specifying the desired names of the dimensions.  Likewise,
     for ungridded dimensions, an Attribute package is attached at the Array level.
     The name of the name must be {\tt ESMF\_ATT\_UNGRIDDED\_DIM\_LABELS}.
  
     NetCDF attributes for the variable can also be specified.  As with dimension labels,
     an Attribute package is added to the Array with the desired names and values.
     A value may be either a scalar character string, or a scalar or array of type
     integer, real, or double precision.  Dimension label attributes can co-exist with
     variable attributes within a common Attribute package.
  
     Limitations:
     \begin{itemize}
       \item Only single tile Arrays are supported.
       \item Not supported in {\tt ESMF\_COMM=mpiuni} mode.
     \end{itemize}
  
    The arguments are:
    \begin{description}
     \item[array]
      The {\tt ESMF\_Array} object that contains data to be written.
     \item[fileName]
      The name of the output file to which Array data is written.
     \item[{[variableName]}]
      Variable name in the output file; default is the "name" of Array.
      Use this argument only in the I/O format (such as NetCDF) that
      supports variable name. If the I/O format does not support this
      (such as binary format), ESMF will return an error code.
     \item[{[convention]}]
       Specifies an Attribute package associated with the Array, used to create NetCDF
       dimension labels and attributes for the variable in the file.  When this argument is present,
       the {\tt purpose} argument must also be present.  Use this argument only with a NetCDF
       I/O format. If binary format is used, ESMF will return an error code.
     \item[{[purpose]}]
       Specifies an Attribute package associated with the Array, used to create NetCDF
       dimension labels and attributes for the variable in the file.  When this argument is present,
       the {\tt convention} argument must also be present.  Use this argument only with a NetCDF
       I/O format. If binary format is used, ESMF will return an error code.
     \item[{[overwrite]}]
      \begin{sloppypar}
        A logical flag, the default is .false., i.e., existing Array data may
        {\em not} be overwritten. If .true., the overwrite behavior depends
        on the value of {\tt iofmt} as shown below:
      \begin{description}
      \item[{\tt iofmt} = {\tt ESMF\_IOFMT\_BIN}:]\ All data in the file will
        be overwritten with each Array's data.
      \item[{\tt iofmt} = {\tt ESMF\_IOFMT\_NETCDF, ESMF\_IOFMT\_NETCDF\_64BIT\_OFFSET}:]\ Only the
        data corresponding to each Array's name will be
        be overwritten. If the {\tt timeslice} option is given, only data for
        the given timeslice may be overwritten.
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.
      \end{description}
      \end{sloppypar}
     \item[{[status]}]
      \begin{sloppypar}
      The file status. Please see Section~\ref{const:filestatusflag} for
      the list of options. If not present, defaults to
      {\tt ESMF\_FILESTATUS\_UNKNOWN}.
      \end{sloppypar}
     \item[{[timeslice]}]
      \begin{sloppypar}
      Some I/O formats (e.g. NetCDF) support the output of data in form of
      time slices.  An unlimited dimension called {\tt time} is defined in the
      file variable for this capability.
      The {\tt timeslice} argument provides access to the {\tt time} dimension,
      and must have a positive value. The behavior of this
      option may depend on the setting of the {\tt overwrite} flag:
      \begin{description}
      \item[{\tt overwrite = .false.}:]\ If the timeslice value is
      less than the maximum time already in the file, the write will fail.
      \item[{\tt overwrite = .true.}:]\ Any positive timeslice value is valid.
      \end{description}
      By default, i.e. by omitting the {\tt timeslice} argument, no
      provisions for time slicing are made in the output file,
      however, if the file already contains a time axis for the variable,
      a timeslice one greater than the maximum will be written.
      \end{sloppypar}
     \item[{[iofmt]}]
      \begin{sloppypar}
      The I/O format.  Please see Section~\ref{opt:iofmtflag} for the list
      of options. If not present, file names with a {\tt .bin} extension will
      use {\tt ESMF\_IOFMT\_BIN}, and file names with a {\tt .nc} extension
      will use {\tt ESMF\_IOFMT\_NETCDF}.  Other files default to
      {\tt ESMF\_IOFMT\_NETCDF}.
      \end{sloppypar}
     \item[{[rc]}]
      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
    \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
