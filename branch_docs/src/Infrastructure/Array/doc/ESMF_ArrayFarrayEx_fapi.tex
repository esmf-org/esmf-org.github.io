%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_ArrayFarrayEx.F90,  Date: Tue May  5 20:59:43 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

   \subsubsection{Array from native Fortran array with 1 DE per PET}
   \label{Array_from_native_1_to_1}
   
   The create call of the {\tt ESMF\_Array} class has been overloaded
   extensively to facilitate the need for generality while keeping simple
   cases simple. The following program demonstrates one of the simpler
   cases, where existing local Fortran arrays are to be used to provide
   the PET-local memory allocations for the Array object.
   
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
program ESMF_ArrayFarrayEx
#include "ESMF.h"

  use ESMF
  use ESMF_TestMod
  
  implicit none
  
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The Fortran language provides a variety of ways to define and allocate
   an array. Actual Fortran array objects must either be explicit-shape or
   deferred-shape. In the first case the memory allocation and deallocation is 
   automatic from the user's perspective and the details of the allocation 
   (static or dynamic, heap or stack) are left to the compiler. (Compiler flags
   may be used to control some of the details). In the second case, i.e. for 
   deferred-shape actual objects, the array definition must include the {\tt pointer} 
   or {\tt allocatable} attribute and it is the user's responsibility to allocate 
   memory. While it is also the user's responsibility to deallocate memory for
   arrays with the {\tt pointer} attribute the compiler will automatically deallocate
   allocatable arrays under certain circumstances defined by the Fortran
   standard.
  
   The {\tt ESMF\_ArrayCreate()} interface has been written to accept native
   Fortran arrays of any flavor as a means to allow user-controlled memory
   management. The Array create call will check on each PET if sufficient 
   memory has been provided by the specified Fortran arrays and will indicate 
   an error if a problem is detected. However, the Array create call cannot
   validate the lifetime of the provided memory allocations. If, for instance,
   an Array object was created in a subroutine from an automatic explicit-shape
   array or an allocatable array, the memory allocations referenced by the Array 
   object will be automatically deallocated on return from the subroutine unless
   provisions are made by the application writer to prevent such behavior. The
   Array object cannot control when memory that has been provided by the user
   during Array creation becomes deallocated, however, the Array will indicate
   an error if its memory references have been invalidated. 
 
   The easiest, portable way to provide safe native Fortran memory allocations
   to Array create is to use arrays with the {\tt pointer} attribute. Memory allocated
   for an array pointer will not be deallocated automatically. However, in this
   case the possibility of memory leaks becomes an issue of concern. The 
   deallocation of memory provided to an Array in form of a native Fortran
   allocation will remain the users responsibility.
   
   None of the concerns discussed above are an issue in this example where the
   native Fortran array {\tt farray} is defined in the main program. All
   different types of array memory allocation are demonstrated in this example.
   First {\tt farrayE} is defined as a 2D explicit-shape array on each PET which 
   will automatically provide memory for $10\times 10$ elements. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  ! local variables
  real(ESMF_KIND_R8)       :: farrayE(10,10)  ! explicit shape Fortran array
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Then an allocatable array {\tt farrayA} is declared which will be used
   to show user-controlled dynamic memory allocation. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  real(ESMF_KIND_R8), allocatable :: farrayA(:,:) ! allocatable Fortran array
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Finally an array with pointer attribute {\tt farrayP} is declared, also used
   for user-controlled dynamic memory allocation. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  real(ESMF_KIND_R8), pointer :: farrayP(:,:)   ! Fortran array pointer 
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   A matching array pointer must also be available to gain access to the arrays
   held by an Array object. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  real(ESMF_KIND_R8), pointer :: farrayPtr(:,:) ! matching Fortran array ptr 
  type(ESMF_DistGrid)         :: distgrid       ! DistGrid object
  type(ESMF_Array)            :: array          ! Array object
  integer                     :: rc
  
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_Initialize(defaultlogfilename="ArrayFarrayEx.Log", &
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   On each PET {\tt farrayE} can be accessed directly to initialize the entire
   PET-local array. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  farrayE = 12.45d0 ! initialize to some value
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   In order to create an Array object a DistGrid must first be created that 
   describes the total index space and how it is decomposed and distributed.
   In the simplest case only the {\tt minIndex} and {\tt maxIndex} of the 
   total space must be provided. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   This example is assumed to run on 4 PETs. The default 2D decomposition will 
   then be into 4 x 1 DEs as to ensure 1 DE per PET. 
   
   Now the Array object can be created using the {\tt farrayE} and the DistGrid
   just created. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(farray=farrayE, distgrid=distgrid, &
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The 40 x 10 index space defined by the {\tt minIndex} and {\tt maxIndex} 
   arguments paired with the default decomposition will result in the following
   distributed Array.
  
   \begin{verbatim}
  
         +---------------------------> 2nd dimension
         |   (1,1)-------+
         |     |         |
         |     |   DE 0  |   <--- farray on PET 0
         |     |         |
         |     +------(10,10)
         |  (11,1)-------+
         |     |         |
         |     |   DE 1  |   <--- farray on PET 1
         |     |         |
         |     +------(20,10)
         |  (21,1)-------+
         |     |         |
         |     |   DE 2  |   <--- farray on PET 2
         |     |         |
         |     +------(30,10)
         |  (31,1)-------+
         |     |         |
         |     |   DE 3  |   <--- farray on PET 3
         |     |         |
         |     +------(40,10)
         v
       1st dimension
  
   \end{verbatim}
  
   Providing {\tt farrayE} during Array creation does not change anything about
   the actual {\tt farrayE} object. This means that each PET can use its
   local {\tt farrayE} directly to access the memory referenced by the Array 
   object. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  print *, farrayE
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

  
   Another way of accessing the memory associated with an Array object is to 
   use {\tt ArrayGet()} to obtain an Fortran pointer that references the
   PET-local array. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  print *, farrayPtr
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Finally the Array object must be destroyed. The PET-local memory of the
   {\tt farrayE}s will remain in user control and will not be altered by 
   {\tt ArrayDestroy()}. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayDestroy(array, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Since the memory allocation for each {\tt farrayE} is automatic there is
   nothing more to do.
  
   The interaction between {\tt farrayE} and the Array class is representative
   also for the two other cases {\tt farrayA} and {\tt farrayP}. The only
   difference is in the handling of memory allocations. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(farrayA(10,10))    ! user controlled allocation
  farrayA = 23.67d0           ! initialize to some value
  array = ESMF_ArrayCreate(farray=farrayA, distgrid=distgrid, &
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  print *, farrayA            ! print PET-local farrayA directly
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)! obtain array pointer
  print *, farrayPtr          ! print PET-local piece of Array through pointer
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the Array
  deallocate(farrayA)         ! user controlled de-allocation
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The {\tt farrayP} case is identical. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(farrayP(10,10))    ! user controlled allocation
  farrayP = 56.81d0           ! initialize to some value
  array = ESMF_ArrayCreate(farray=farrayP, distgrid=distgrid, &
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  print *, farrayP            ! print PET-local farrayA directly
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)! obtain array pointer
  print *, farrayPtr          ! print PET-local piece of Array through pointer
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the Array
  deallocate(farrayP)         ! user controlled de-allocation
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   To wrap things up the DistGrid object is destroyed and ESMF can be finalized. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}

  call ESMF_DistGridDestroy(distgrid, rc=rc) ! destroy the DistGrid
  
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_Finalize(rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
end program
 
\end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
