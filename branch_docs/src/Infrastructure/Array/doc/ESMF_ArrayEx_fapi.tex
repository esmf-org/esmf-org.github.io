%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_ArrayEx.F90,  Date: Tue May  5 20:59:43 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

   \subsubsection{Create Array with automatic memory allocation}
  
   In the examples of the previous sections the user provided memory allocations
   for each of the DE-local regions for an Array object. The user was able to 
   use any of the Fortran methods to allocate memory, or go through
   the {\tt ESMF\_LocalArray} interfaces to obtain memory allocations before
   passing them into ArrayCreate(). Alternatively ESMF offers methods that 
   handle Array memory allocations inside the library.
   
   As before, to create an {\tt ESMF\_Array} object an {\tt ESMF\_DistGrid}
   must be created. The DistGrid object holds information about the entire 
   index space and how it is decomposed into DE-local exclusive regions. The 
   following line of code creates a DistGrid for a 5x5 global index space that 
   is decomposed into 2 x 3 = 6 DEs. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &
    regDecomp=(/2,3/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The following is a representation of the index space and its decomposition into
   DEs. Each asterisk (*) represents a single element.
  
   \begin{verbatim}
   
    +---------------------------------------> 2nd dimension
    |  (1,1)
    |    +-----------+-----------+------+
    |    | DE 0      | DE 2      | DE 4 |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    +-----------+-----------+------+
    |    |           |           |      |
    |    | DE 1      | DE 3      | DE 5 |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    +-----------+-----------+------+
    |                                 (5,5)
    v 
   1st dimension
  
   \end{verbatim}
  
   Besides the DistGrid it is the {\em type, kind} and {\em rank} information,
   "tkr" for short, that is required to create an Array object. It turns out that
   the rank of the Array object is fully determined by the DistGrid and other 
   (optional) arguments passed into ArrayCreate(), so that explicit 
   specification of the Array rank is redundant.
  
   The simplest way to supply the type and kind information of the Array is
   directly through the {\tt typekind} argument. Here a double precision Array
   is created on the previously created DistGrid. Since no other arguments are
   specified that could alter the rank of the Array it becomes equal to the 
   dimCount of the DistGrid, i.e a 2D Array is created on top of the DistGrid. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(typekind=ESMF_TYPEKIND_R8, distgrid=distgrid, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The different methods on how an Array object is created have no effect on
   the use of {\tt ESMF\_ArrayDestroy()}. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayDestroy(array, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Alternatively the same Array can be created specifying the "tkr" information
   in form of an ArraySpec variable. The ArraySpec explicitly contains the 
   Array rank and thus results in an over specification on the ArrayCreate()
   interface. ESMF checks all input information for consistency and returns 
   appropriate error codes in case any inconsistencies are found. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The Array object created by the above call is an ESMF distributed 
   object. As such it must follow the ESMF convention that requires that 
   the call to {\tt ESMF\_ArrayCreate()} must be issued in unison by all 
   PETs of the current context.
  
 
   \subsubsection{Native language memory access}
   \label{Array_native_language_localde}
  
   There are two different methods by which the user can access the data held 
   inside an ESMF Array object. The first method provides direct access to a
   native language array object. Specifically, the {\tt farrayPtr} argument
   returned by {\tt ESMF\_ArrayGet()} is a Fortran array pointer that can be
   used to access the PET-local data inside the Array object.
  
   Many applications work in the 1 DE per PET mode, with exactly one DE on 
   every PET. Accessing the Array memory on each PET for this situation is 
   especially simple as is shown in section \ref{Array_from_native_1_to_1}.
   However, the Array class is not restricted to the special 1 DE per PET case,
   but supports multiple separate memory allocations on each PET.
   The number of such PET-local allocations is given by the {\tt localDeCount},
   i.e. there is one memory allocation for every DE that is associated with the
   local PET.
  
   Access to a specific local memory allocation of an Array object is still
   accomplished by returning the {\tt farrayPtr} argument. However, for
   $ localDeCount > 1 $ the formally optional {\tt localDe} argument to
   {\tt ESMF\_ArrayGet()} turns into a practically required argument. While
   in general the {\tt localDe} in ESMF is simply a local index variable that 
   enumerates the DEs that are associated with the local PET (e.g. see section
   \ref{DELayout_general_mapping}), the bounds of this index variable are 
   strictly defined as {\tt [0,...,localDeCount-1]} when it is used as an 
   input argument. The following code demonstrates this.
  
   First query the Array for {\tt localDeCount}. This number may be different
   on each PET and indicates how many DEs are mapped against the local PET. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Looping the {\tt localDe} index variable from 0 to {\tt localDeCount-1} allows
   access to each of the local memory allocations of the Array object: 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  do localDe=0, localDeCount-1
    call ESMF_ArrayGet(array, farrayPtr=myFarray, localDe=localDe, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    ! use myFarray to access local DE data
  enddo
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The second method to access the memory allocations in an Array object is to
   go through the ESMF LocalArray object. To this end the Array is queried
   for a list of PET-local LocalArray objects. The LocalArray objects in the list
   correspond to the DEs on the local PET. Here the {\tt localDe} argument is
   solely a user level index variable, and in principle the lower bound can be 
   chosen freely. However, for better alignment with the previous case (where 
   {\tt localDe} served as an input argument to an ESMF method) the following
   example again fixes the lower bound at zero. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(larrayList(0:localDeCount-1))
  call ESMF_ArrayGet(array, localarrayList=larrayList, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray, &
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    ! use myFarray to access local DE data
  enddo
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   See section \ref{Array:LocalArray} for more on LocalArray usage in Array. 
   In most cases memory access through a LocalArray list is less convenient than
   the direct {\tt farrayPtr} method because it adds an extra object level 
   between the ESMF Array and the native language array. 
  
  
   \subsubsection{Regions and default bounds}
   \label{Array_regions_and_default_bounds}
  
   Each {\tt ESMF\_Array} object is decomposed into DEs as specified by the
   associated {\tt ESMF\_DistGrid} object. Each piece of this decomposition, i.e.
   each DE, holds a chunk of the Array data in its own local piece of memory.
   The details of the Array decomposition are described in the following 
   paragraphs.
  
   At the center of the Array decomposition is the {\tt ESMF\_DistGrid} class.
   The DistGrid object specified during Array creation contains three essential
   pieces of information:
   \begin{itemize}
   \item The extent and topology of the global domain covered by the Array object
         in terms of indexed elements. The total extent may be a composition of
         smaller logically rectangular (LR) domain pieces called tiles.
   \item The decomposition of the entire domain into "element exclusive" DE-local
         LR chunks. {\em Element exclusive} means that there is no element overlap
         between DE-local chunks. This, however, does not exclude degeneracies 
         on edge boundaries for certain topologies (e.g. bipolar).
   \item The layout of DEs over the available PETs and thus the distribution of
         the Array data.
   \end{itemize}
  
   Each element of an Array is associated with a {\em single} DE. The union of
   elements associated with a DE, as defined by the DistGrid above, corresponds
   to a LR chunk of index space, called the {\em exclusive region} of the DE.
  
   There is a hierarchy of four regions that can be identified for each DE in an
   Array object. Their definition and relationship to each other is as follows:
   \begin{itemize}
   \item {\em Interior Region}: Region that only contains local elements that are
         {\em not} mapped into the halo of any other DE. The shape and size of 
         this region for a particular DE depends non-locally on the halos defined
         by other DEs and may change during computation as halo operations are
         precomputed and released. Knowledge of the interior elements may be used
         to improve performance by overlapping communications with ongoing 
         computation for a DE.
   \item {\em Exclusive Region}: Elements for which a DE claims exclusive
         ownership. Practically this means that the DE will be the sole source
         for these elements in halo and reduce operations. There are exceptions
         to this in some topologies. The exclusive region includes all elements
         of the interior region.
   \item {\em Computational Region}: Region that can be set arbitrarily within
         the bounds of the total region (defined next). The typical use of the
         computation region is to define bounds that only include elements that
         are updated by a DE-local computation kernel. The computational region
         does not need to include all exclusive elements and it may also contain
         elements that lie outside the exclusive region.
   \item {\em Total (Memory) Region}: Total of all DE-locally allocated elements.
         The size and shape of the total memory region must accommodate the
         union of exclusive and computational region but may contain 
         additional elements. Elements outside the exclusive region may overlap
         with the exclusive region of another DE which makes them potential 
         receivers for Array halo operations. Elements outside the exclusive
         region that do not overlap with the exclusive region of another DE
         can be used to set boundary conditions and/or serve as extra memory 
         padding.
   \end{itemize}
  
   \begin{verbatim}
  
     +-totalLBound(:)----------------------------------+
     |\                                                |
     | \ <--- totalLWidth(:)                           |
     |  \                                              |
     |   +-computationalLBound(:)------------------+   |
     |   |\                                        |   |
     |   | \ <--- computationalLWidth(:)           |   |
     |   |  \                                      |   |
     |   |   +-exclusiveLBound(:)-------------+    |   |
     |   |   |                                |    |   |
     |   |   |     +------+      +-----+      |    |   |
     |   |   |     |      |      |     |      |    |   |
     |   |   |     |      +------+     |      |    |   |
     |   |   |     | "Interior Region" |      |    |   |
     |   |   |     +-----+             |      |    |   |
     |   |   |           |             |      |    |   |
     |   |   |           +-------------+      |    |   |
     |   |   |                                |    |   |
     |   |   | "Exclusive Region"             |    |   |
     |   |   +-------------exclusiveUBound(:)-+    |   |
     |   |                                     \   |   |
     |   |           computationalUWidth(:) --> \  |   |
     |   |                                       \ |   |
     |   | "Computational Region"                 \|   |
     |   +------------------computationalUBound(:)-+   |
     |                                              \  | 
     |                             totalUWidth(:) -> \ | 
     | "Total Region"                                 \| 
     +--------------------------------- totalUBound(:)-+
   \end{verbatim}
  
  
   With the following definitions:
   \begin{verbatim}
  
   computationalLWidth(:) = exclusiveLBound(:) - computationalLBound(:)
   computationalUWidth(:) = computationalUBound(:) - exclusiveUBound(:)
  
   \end{verbatim}
   and
   \begin{verbatim}
  
   totalLWidth(:) = exclusiveLBound(:) - totalLBound(:)
   totalUWidth(:) = totalUBound(:) - exclusiveUBound(:)
  
   \end{verbatim}
  
  
   The {\em exclusive region} is determined during Array creation by the 
   DistGrid argument. Optional arguments may be used to specify the 
   {\em computational region} when the Array is created, by default it will be
   set equal to the exclusive region. The {\em total region}, i.e. the actual
   memory allocation for each DE, is also determined during Array creation. When
   creating the Array object from existing Fortran arrays the total region is
   set equal to the memory provided by the Fortran arrays. Otherwise the 
   default is to allocate as much memory as is needed to accommodate the union
   of the DE-local exclusive and computational region. Finally it is also
   possible to use optional arguments to the ArrayCreate() call to specify the
   total region of the object explicitly.
  
   The {\tt ESMF\_ArrayCreate()} call checks that the input parameters are
   consistent and will result in an Array that fulfills all of the above 
   mentioned requirements for its DE-local regions.
  
   Once an Array object has been created the exclusive and total regions are
   fixed. The computational region, however, may be adjusted within the limits
   of the total region using the {\tt ArraySet()} call.
  
   The {\em interior region} is very different from the other regions in that
   it cannot be specified. The {\em interior region} for each DE is a {\em
   consequence} of the choices made for the other regions collectively across
   all DEs into which an Array object is decomposed. An Array object can be
   queried for its DE-local {\em interior regions} as to offer additional
   information to the user necessary to write more efficient code.
   %See section 
   %\ref{ArrayEx_interiorRegion}(not yet implemented) for more details.
  
   By default the bounds of each DE-local {\em total region} are defined as
   to put the start of the DE-local {\em exclusive region} at the "origin" of 
   the local index space, i.e. at {\tt (1, 1, ..., 1)}. With that definition the
   following loop will access each element of the DE-local memory segment for
   each PET-local DE of the Array object used in the previous sections and
   print its content. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray, &
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    do i=1, size(myFarray, 1)
      do j=1, size(myFarray, 2)
        print *, "localPET=", localPet, " localDE=", &
            localDe, ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo
  enddo
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 
   \subsubsection{Array bounds}
  
   The loop over Array elements at the end of the last section only works
   correctly because of the default definition of the {\em computational} and
   {\em total regions} used in the example. In general, without such specific
   knowledge about an Array object, it is necessary to use a more formal approach
   to access its regions with DE-local indices.
  
   The DE-local {\em exclusive region} takes a central role in the definition
   of Array bounds. Even as the {\em computational region} may adjust during 
   the course of execution the {\em exclusive region} remains unchanged.
   The {\em exclusive region} provides a unique reference frame
   for the index space of all Arrays associated with the same DistGrid.
  
   There is a choice between two indexing options that needs to be made during 
   Array creation. By default each DE-local exclusive region starts at 
   {\tt (1, 1, ..., 1)}. However, for some computational kernels it may be more
   convenient to choose the index bounds of the DE-local exclusive regions to 
   match the index space coordinates as they are defined in the corresponding
   DistGrid object. The second option is only available if the DistGrid object 
   does not contain any non-contiguous decompositions (such as cyclically
   decomposed dimensions).
  
   The following example code demonstrates the safe way of dereferencing the
   DE-local exclusive regions of the previously created {\tt array} object.
  
   
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(exclusiveUBound(2, 0:localDeCount-1))  ! dimCount=2
  allocate(exclusiveLBound(2, 0:localDeCount-1))  ! dimCount=2
  call ESMF_ArrayGet(array, indexflag=indexflag, &
    exclusiveLBound=exclusiveLBound, exclusiveUBound=exclusiveUBound, rc=rc)
  if (indexflag == ESMF_INDEX_DELOCAL) then
    ! this is the default
!    print *, "DE-local exclusive regions start at (1,1)"
    do localDe=0, localDeCount-1
      call ESMF_LocalArrayGet(larrayList(localDe), myFarray, &
          datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
      do i=1, exclusiveUBound(1, localDe)
        do j=1, exclusiveUBound(2, localDe)
!          print *, "DE-local exclusive region for localDE=", localDe, &
!            ": array(",i,",",j,")=", myFarray(i,j)
        enddo
      enddo
    enddo
  else if (indexflag == ESMF_INDEX_GLOBAL) then
    ! only if set during ESMF_ArrayCreate()
!    print *, "DE-local exclusive regions of this Array have global bounds"
    do localDe=0, localDeCount-1
      call ESMF_LocalArrayGet(larrayList(localDe), myFarray, &
         datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
      do i=exclusiveLBound(1, localDe), exclusiveUBound(1, localDe)
        do j=exclusiveLBound(2, localDe), exclusiveUBound(2, localDe)
!          print *, "DE-local exclusive region for localDE=", localDe, &
!            ": array(",i,",",j,")=", myFarray(i,j)
        enddo
      enddo
    enddo
  endif
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the array object
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Obviously the second branch of this simple code will work for either case, 
   however, if a complex computational kernel was written assuming 
   {\tt ESMF\_INDEX\_DELOCAL} type bounds the second branch would simply be 
   used to indicate the problem and bail out.
  
   The advantage of the {\tt ESMF\_INDEX\_GLOBAL} index option is that
   the Array bounds directly contain information on where the DE-local
   Array piece is located in a global index space sense. When the
   {\tt ESMF\_INDEX\_DELOCAL} option is used the correspondence between local
   and global index space must be made by querying the associated DistGrid for
   the DE-local {\tt indexList} arguments.
 
 
   \subsubsection{Computational region and extra elements for halo or padding}
   \label{Array:padding}
  
   In the previous examples the computational region of {\tt array} was chosen 
   by default to be identical to the exclusive region defined by the DistGrid
   argument during Array creation. In the following the same {\tt arrayspec} and
   {\tt distgrid} objects as before will be used to create an Array but now a 
   larger computational region shall be defined around each DE-local exclusive 
   region. Furthermore, extra space will be defined around the computational
   region of each DE to accommodate a halo and/or serve as memory padding.
  
   In this example the {\tt indexflag} argument is set to 
   {\tt ESMF\_INDEX\_GLOBAL} indicating that the bounds of the exclusive region
   correspond to the index space coordinates as they are defined by the DistGrid
   object.
  
   The same {\tt arrayspec} and {\tt distgrid} objects as before are used
   which also allows the reuse of the already allocated {\tt larrayList}
   variable. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &
    computationalLWidth=(/0,3/), computationalUWidth=(/1,1/), &
    totalLWidth=(/1,4/), totalUWidth=(/3,1/), &
    indexflag=ESMF_INDEX_GLOBAL, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Obtain the {\tt larrayList} on every PET. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(localDeToDeMap(0:localDeCount-1))
  call ESMF_ArrayGet(array, localarrayList=larrayList, &
    localDeToDeMap=localDeToDeMap, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The bounds of DE 1 for {\tt array} are shown in the following 
   diagram to illustrate the situation. Notice that the {\tt totalLWidth} and
   {\tt totalUWidth} arguments in the ArrayCreate() call define the total region 
   with respect to the exclusive region given for each DE by the {\tt distgrid} 
   argument.
   
   \begin{verbatim}
        +-(3,-3)---------------------------------+ 
        |\                                       | 
        | +-(4,-2)-+-(4,1)--------------------+--+ 
        | |        |                          |  | 
        | |        |                          |  | 
        | |        |          DE 1            |  | 
        | |        |                          |  | 
        | |        |                          |  | 
        | |        | Exclusive Region         |  | 
        | |        +--------------------(5,2)-+  | 
        | | Computational Region                 | 
        | +-------------------------------(6,3)--+ 
        |                                        | 
        | Total Region                           | 
        +---------------------------------(8,3)--+ 
   \end{verbatim}
  
   When working with this {\tt array} it is possible for the computational
   kernel to overstep the exclusive region for both read/write access 
   (computational region) and potentially read-only access into the total region
   outside of the computational region, if a halo operation provides valid 
   entries for these elements. 
  
   The Array object can be queried for absolute {\em bounds} 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(computationalLBound(2, 0:localDeCount-1))  ! dimCount=2
  allocate(computationalUBound(2, 0:localDeCount-1))  ! dimCount=2
  allocate(totalLBound(2, 0:localDeCount-1))          ! dimCount=2
  allocate(totalUBound(2, 0:localDeCount-1))          ! dimCount=2
  call ESMF_ArrayGet(array, exclusiveLBound=exclusiveLBound, &
    exclusiveUBound=exclusiveUBound, &
    computationalLBound=computationalLBound, &
    computationalUBound=computationalUBound, &
    totalLBound=totalLBound, &
    totalUBound=totalUBound, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   or for the relative {\em widths}. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(computationalLWidth(2, 0:localDeCount-1))  ! dimCount=2
  allocate(computationalUWidth(2, 0:localDeCount-1))  ! dimCount=2
  allocate(totalLWidth(2, 0:localDeCount-1))          ! dimCount=2
  allocate(totalUWidth(2, 0:localDeCount-1))          ! dimCount=2
  call ESMF_ArrayGet(array, computationalLWidth=computationalLWidth, &
    computationalUWidth=computationalUWidth, totalLWidth=totalLWidth, &
    totalUWidth=totalUWidth, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Either way the dereferencing of Array data is centered around the DE-local
   exclusive region: 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray, &
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    ! initialize the DE-local array
    myFarray = 0.1d0 * localDeToDeMap(localDe)
    ! first time through the total region of array    
!    print *, "myFarray bounds for DE=", localDeToDeMap(localDe), &
!      lbound(myFarray),  ubound(myFarray)
    do j=exclusiveLBound(2, localDe), exclusiveUBound(2, localDe)
      do i=exclusiveLBound(1, localDe), exclusiveUBound(1, localDe)
!        print *, "Excl region DE=", localDeToDeMap(localDe), &
!        ": array(",i,",",j,")=",  myFarray(i,j)
      enddo
    enddo
    do j=computationalLBound(2, localDe), computationalUBound(2, localDe)
      do i=computationalLBound(1, localDe), computationalUBound(1, localDe)
!        print *, "Excl region DE=", localDeToDeMap(localDe), &
!        ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo
    do j=totalLBound(2, localDe), totalUBound(2, localDe)
      do i=totalLBound(1, localDe), totalUBound(1, localDe)
!        print *, "Total region DE=", localDeToDeMap(localDe), &
!        ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo

    ! second time through the total region of array    
    do j=exclusiveLBound(2, localDe)-totalLWidth(2, localDe), &
      exclusiveUBound(2, localDe)+totalUWidth(2, localDe)
      do i=exclusiveLBound(1, localDe)-totalLWidth(1, localDe), &
        exclusiveUBound(1, localDe)+totalUWidth(1, localDe)
!        print *, "Excl region DE=", localDeToDeMap(localDe), &
!        ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo
  enddo
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \subsubsection{Create 1D and 3D Arrays}
  
   All previous examples were written for the 2D case. There is, however, no
   restriction within the Array or DistGrid class that limits the dimensionality
   of Array objects beyond the language-specific limitations (7D for Fortran).
  
   In order to create an {\tt n}-dimensional Array the rank indicated by both
   the {\tt arrayspec} and the {\tt distgrid} arguments specified during Array
   create must be equal to {\tt n}. A 1D Array of double precision real data
   hence requires the following {\tt arrayspec}. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=1, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The index space covered by the Array and the decomposition description is
   provided to the Array create method by the {\tt distgrid} argument. The index
   space in this example has 16 elements and covers the interval $[-10, 5]$. It is 
   decomposed into as many DEs as there are PETs in the current context. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  distgrid1D = ESMF_DistGridCreate(minIndex=(/-10/), maxIndex=(/5/), &
    regDecomp=(/petCount/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   A 1D Array object with default regions can now be created. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array1D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid1D, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   
   The creation of a 3D Array proceeds analogous to the 1D case. The rank of the
   {\tt arrayspec} must be changed to 3 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   and an appropriate 3D DistGrid object must be created 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  distgrid3D = ESMF_DistGridCreate(minIndex=(/1,1,1/), &
    maxIndex=(/16,16,16/), regDecomp=(/4,4,4/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   before an Array object can be created. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array3D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid3D, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The {\tt distgrid3D} object decomposes the 3-dimensional index space into
   $4\times 4\times 4 = 64$ DEs. These DEs are laid out across the computational
   resources (PETs) of the current component according to a default DELayout that
   is created during the DistGrid create call. Notice that in the index space 
   proposal a DELayout does not have a sense of dimensionality. The DELayout
   function is simply to map DEs to PETs. The DistGrid maps chunks of index space
   against DEs and thus its rank is equal to the number of index space 
   dimensions.
  
   The previously defined DistGrid and the derived Array object decompose 
   the index space along all three dimension. It is, however, not a requirement
   that the decomposition be along all dimensions. An Array with the same 3D
   index space could as well be decomposed along just one or along two of the
   dimensions. The following example shows how for the same index space only the
   last two dimensions are decomposed while the first Array dimension has full
   extent on all DEs. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayDestroy(array3D, rc=rc)
  call ESMF_DistGridDestroy(distgrid3D, rc=rc)
  distgrid3D = ESMF_DistGridCreate(minIndex=(/1,1,1/), &
    maxIndex=(/16,16,16/), regDecomp=(/1,4,4/), rc=rc)
  array3D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid3D, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 
   \subsubsection{Working with Arrays of different rank}
   Assume a computational kernel that involves the {\tt array3D} object as it was
   created at the end of the previous section. Assume further that the kernel 
   also involves a 2D Array on a 16x16 index space where each point (j,k) was
   interacting with each (i,j,k) column of the 3D Array. An efficient formulation
   would require that the decomposition of the 2D Array must match that of the 3D
   Array and further the DELayout be identical. The following code shows how this
   can be accomplished. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_DistGridGet(distgrid3D, delayout=delayout, rc=rc) ! get DELayout
  distgrid2D = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/16,16/), &
    regDecomp=(/4,4/), delayout=delayout, rc=rc)
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
  array2D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid2D, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Now the following kernel is sure to work with {\tt array3D} and {\tt array2D}. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_DELayoutGet(delayout, localDeCount=localDeCount, rc=rc)
  allocate(larrayList1(0:localDeCount-1))
  call ESMF_ArrayGet(array3D, localarrayList=larrayList1, rc=rc)
  allocate(larrayList2(0:localDeCount-1))
  call ESMF_ArrayGet(array2D, localarrayList=larrayList2, rc=rc)
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList1(localDe), myFarray3D, &
      datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray3D = 0.1d0 * localDe ! initialize
    call ESMF_LocalArrayGet(larrayList2(localDe), myFarray2D, &
      datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray2D = 0.5d0 * localDe ! initialize
    do k=1, 4
      do j=1, 4
        dummySum = 0.d0
        do i=1, 16
          dummySum = dummySum + myFarray3D(i,j,k) ! sum up the (j,k) column
        enddo
        dummySum = dummySum * myFarray2D(j,k) ! multiply with local 2D element
!        print *, "dummySum(",j,k,")=",dummySum
      enddo
    enddo
  enddo
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

  
   \subsubsection{Array and DistGrid rank -- 2D+1 Arrays}
  
   Except for the special Array create interface that implements a copy from
   an existing Array object all other Array create interfaces require the 
   specification of at least two arguments: {\tt farray} and {\tt distgrid},
   {\tt larrayList} and {\tt distgrid}, or {\tt arrayspec} and {\tt distgrid}.
   In all these cases both required arguments contain a sense of dimensionality.
   The relationship between these two arguments deserves extra attention.
  
   The first argument, {\tt farray}, {\tt larrayList} or {\tt arrayspec}, 
   determines the rank of the created Array object, i.e. the dimensionality
   of the actual data storage. The rank of a native language array, extracted 
   from an Array object, is equal to the rank specified by either of these
   arguments. So is the {\tt rank} that is returned by the {\tt ESMF\_ArrayGet()}
   call.
  
   The rank specification contained in the {\tt distgrid} argument, which is of 
   type {\tt ESMF\_DistGrid}, on the other hand has no effect on the
   rank of the Array. The {\tt dimCount} specified by the DistGrid object,
   which may be equal, greater or less than the Array rank, determines the 
   dimensionality of the {\em decomposition}.
  
   While there is no constraint between DistGrid {\tt dimCount} and Array
   {\tt rank}, there is an important relationship between the two, resulting in
   the concept of index space dimensionality. Array dimensions can be
   arbitrarily mapped against DistGrid dimension, rendering them {\em decomposed}
   dimensions. The index space dimensionality is equal to the number of 
   decomposed Array dimensions.
  
   \begin{sloppypar}
   Array dimensions that are not mapped to DistGrid dimensions are the 
   {\em undistributed} dimensions of the Array. They are not part
   of the index space. The mapping is specified during {\tt ESMF\_ArrayCreate()}
   via the {\tt distgridToArrayMap} argument. DistGrid dimensions that have
   not been associated with Array dimensions are {\em replicating} dimensions.
   The Array will be replicated across the DEs that lie along replication
   DistGrid dimensions.
   \end{sloppypar}
  
   Undistributed Array dimensions can be used to store multi-dimensional data for
   each Array index space element. One application of this is to store the 
   components of a vector quantity in a single Array. The same 2D {\tt distgrid}
   object as before will be used. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &
    regDecomp=(/2,3/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The rank in the {\tt arrayspec} argument, however, must change from 2 to 3 in
   order to provide for the extra Array dimension. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   During Array creation with extra dimension(s) it is necessary to specify the
   bounds of these undistributed dimension(s). This requires two additional
   arguments, {\tt undistLBound} and {\tt undistUBound}, which are vectors in 
   order to accommodate multiple undistributed dimensions. The other arguments
   remain unchanged and apply across all undistributed components. 
   
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &
    totalLWidth=(/0,1/), totalUWidth=(/0,1/), &
    undistLBound=(/1/), undistUBound=(/2/), rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   This will create {\tt array} with 2+1 dimensions. The 2D DistGrid is used
   to describe decomposition into DEs with 2 Array dimensions mapped to the 
   DistGrid dimensions resulting in a 2D index space. The extra Array dimension
   provides storage for multi component user data within the Array object.
  
   By default the {\tt distgrid} dimensions are associated
   with the first Array dimensions in sequence. For the example above this means
   that the first 2 Array dimensions are decomposed according to the provided 2D
   DistGrid. The 3rd Array dimension does not have an associated DistGrid
   dimension, rendering it an undistributed Array dimension.
  
   Native language access to an Array with undistributed dimensions is in
   principle the same as without extra dimensions. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
  allocate(larrayList(0:localDeCount-1))
  call ESMF_ArrayGet(array, localarrayList=larrayList, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The following loop shows how a Fortran pointer to the DE-local data chunks
   can be obtained and used to set data values in the exclusive regions. The
   {\tt myFarray3D} variable must be of rank 3 to match the Array rank of
   {\tt array}. However, variables such as {\tt exclusiveUBound} that store the
   information about the decomposition, remain to be allocated for the 2D 
   index space. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayGet(array, exclusiveLBound=exclusiveLBound, &
    exclusiveUBound=exclusiveUBound, rc=rc)
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray3D, &
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray3D = 0.0 ! initialize
    myFarray3D(exclusiveLBound(1,localDe):exclusiveUBound(1,localDe), &
      exclusiveLBound(2,localDe):exclusiveUBound(2,localDe), &
      1) = 5.1 ! dummy assignment
    myFarray3D(exclusiveLBound(1,localDe):exclusiveUBound(1,localDe), &
      exclusiveLBound(2,localDe):exclusiveUBound(2,localDe), &
      2) = 2.5 ! dummy assignment
  enddo
  deallocate(larrayList)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   For some applications the default association rules between DistGrid and Array
   dimensions may not satisfy the user's needs. The optional {\tt distgridToArrayMap} 
   argument can be used during Array creation to explicitly specify the mapping 
   between DistGrid and Array dimensions. To demonstrate this the following lines
   of code reproduce the above example but with rearranged dimensions. Here the
   {\tt distgridToArrayMap} argument is a list with two elements corresponding to
   the DistGrid {\tt dimCount} of 2. The first element indicates which Array
   dimension the first DistGrid dimension is mapped against. Here the
   1st DistGrid dimension maps against the 3rd Array dimension and the 2nd 
   DistGrid dimension maps against the 1st Array dimension. This leaves the 2nd
   Array dimension to be the extra and undistributed dimension in the resulting
   Array object. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayDestroy(array, rc=rc)
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &
    distgridToArrayMap=(/3, 1/), totalLWidth=(/0,1/), totalUWidth=(/0,1/), &
    undistLBound=(/1/), undistUBound=(/2/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Operations on the Array object as a whole are unchanged by the different
   mapping of dimensions.
  
   When working with Arrays that contain explicitly mapped Array and DistGrid 
   dimensions it is critical to know the order in which the entries of
   {\em width} and {\em bound} arguments that are associated with distributed
   Array dimensions are specified. The size of these arguments is equal to the
   DistGrid {\tt dimCount}, because the maximum number of distributed Array
   dimensions is given by the dimensionality of the index space.
  
   The order of dimensions in these arguments, however, is {\em not} that of
   the associated DistGrid. Instead each entry corresponds to the distributed
   Array dimensions in sequence. In the example above the entries in 
   {\tt totalLWidth} and {\tt totalUWidth} correspond to Array dimensions 1 and
   3 in this sequence. 
  
   The {\tt distgridToArrrayMap} argument optionally provided during Array create
   indicates how the DistGrid dimensions map to Array dimensions. The inverse
   mapping, i.e. Array to DistGrid dimensions, is just as important. The 
   {\tt ESMF\_ArrayGet()} call offers both mappings as {\tt distgridToArrrayMap}
   and {\tt arrayToDistGridMap}, respectively. The number of elements in 
   {\tt arrayToDistGridMap} is equal to the rank of the Array. Each element
   corresponds to an Array dimension and indicates the associated DistGrid
   dimension by an integer number. An entry of "0" in {\tt arrayToDistGridMap}
   indicates that the corresponding Array dimension is undistributed.
  
   Correct understanding about the association between Array and DistGrid
   dimensions becomes critical for correct data access into the Array. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(arrayToDistGridMap(3))  ! arrayRank = 3
  call ESMF_ArrayGet(array, arrayToDistGridMap=arrayToDistGridMap, &
    exclusiveLBound=exclusiveLBound, exclusiveUBound=exclusiveUBound, &
    localDeCount=localDeCount, rc=rc)  
  if (arrayToDistGridMap(2) /= 0) then   ! check if extra dimension at 
    ! expected index indicate problem and bail out
  endif
  ! obtain larrayList for local DEs
  allocate(larrayList(0:localDeCount-1))
  call ESMF_ArrayGet(array, localarrayList=larrayList, rc=rc)
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray3D, &
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray3D(exclusiveLBound(1,localDe):exclusiveUBound(1,localDe), &
      1, exclusiveLBound(2,localDe):exclusiveUBound(2, &
      localDe)) = 10.5 !dummy assignment
    myFarray3D(exclusiveLBound(1,localDe):exclusiveUBound(1,localDe), &
      2, exclusiveLBound(2,localDe):exclusiveUBound(2, &
      localDe)) = 23.3 !dummy assignment
  enddo
  deallocate(exclusiveLBound, exclusiveUBound)
  deallocate(arrayToDistGridMap)
  deallocate(larrayList)
  call ESMF_ArrayDestroy(array, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

  
   \subsubsection{Arrays with replicated dimensions}
  
   Thus far most examples demonstrated cases where the DistGrid {\tt dimCount}
   was equal to the Array {\tt rank}. The previous section introduced the
   concept of Array {\em tensor} dimensions when {\tt dimCount < rank}. In this
   section {\tt dimCount} and {\tt rank} are assumed completely unconstrained and
   the relationship to {\tt distgridToArrayMap} and {\tt arrayToDistGridMap} will
   be discussed.
  
   The Array class allows completely arbitrary mapping between Array and
   DistGrid dimensions. Most cases considered in the previous sections used
   the default mapping which assigns the DistGrid dimensions in sequence to the
   lower Array dimensions. Extra Array dimensions, if present, are considered
   non-distributed tensor dimensions for which the optional {\tt undistLBound}
   and {\tt undistUBound} arguments must be specified.
  
   The optional {\tt distgridToArrayMap} argument provides the option to override
   the default DistGrid to Array dimension mapping. The entries of the
   {\tt distgridToArrayMap} array correspond to the DistGrid dimensions in
   sequence and assign a unique Array dimension to each DistGrid dimension.
   DistGrid and Array dimensions are indexed starting at {\tt 1} for the lowest
   dimension. A value of {\tt "0"} in the {\tt distgridToArrayMap} array 
   indicates that the respective DistGrid dimension is {\em not} mapped against
   any Array dimension. What this means is that the Array will be replicated 
   along this DistGrid dimension.
   
   As a first example consider the case where a 1D Array 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=1, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   is created on the 2D DistGrid used during the previous section. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Here the default DistGrid to Array dimension mapping is used which assigns
   the Array dimensions in sequence to the DistGrid dimensions starting with
   dimension "1". Extra DistGrid dimensions are considered replicator dimensions
   because the Array will be replicated along those dimensions. In the above
   example the 2nd DistGrid dimension will cause 1D Array pieces to be
   replicated along the DEs of the 2nd DistGrid dimension. Replication in the
   context of {\tt ESMF\_ArrayCreate()} does not mean that data values are
   communicated and replicated between different DEs, but it means that different
   DEs provide memory allocations for {\em identical} exclusive elements.
  
   Access to the data storage of an Array that has been replicated along 
   DistGrid dimensions is the same as for Arrays without replication. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(larrayList(0:localDeCount-1))
  allocate(localDeToDeMap(0:localDeCount-1))
  call ESMF_ArrayGet(array, localarrayList=larrayList, &
    localDeToDeMap=localDeToDeMap, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The {\tt array} object was created without additional padding which means
   that the bounds of the Fortran array pointer correspond to the bounds of
   the exclusive region. The following loop will cycle through all local DEs, 
   print the DE number as well as the Fortran array pointer bounds. The bounds
   should be:
   \begin{verbatim}
            lbound       ubound
  
   DE 0:      1            3         --+
   DE 2:      1            3         --|  1st replication set
   DE 4:      1            3         --+
  
   DE 1:      1            2         --+
   DE 3:      1            2         --|  2nd replication set
   DE 5:      1            2         --+
   \end{verbatim} 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray1D, &
      datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    print *, "localPet: ", localPet, "DE ",localDeToDeMap(localDe)," [", &
      lbound(myFarray1D), ubound(myFarray1D),"]"
  enddo
  deallocate(larrayList)
  deallocate(localDeToDeMap)
  call ESMF_ArrayDestroy(array, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The Fortran array pointer in the above loop was of rank 1 because the
   Array object was of rank 1. However, the {\tt distgrid} object associated
   with {\tt array} is 2-dimensional! Consequently DistGrid based information
   queried from {\tt array} will be 2D. The {\tt distgridToArrayMap} and
   {\tt arrayToDistGridMap}
   arrays provide the necessary mapping to correctly associate DistGrid based 
   information with Array dimensions.
  
   The next example creates a 2D Array 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   on the previously used 2D DistGrid. By default, i.e. without the
   {\tt distgridToArrayMap}
   argument, both DistGrid dimensions would be associated with the two Array
   dimensions. However, the {\tt distgridToArrayMap} specified in the following
   call will only associate the second DistGrid dimension with the first Array 
   dimension. This will render the first DistGrid dimension a replicator
   dimension and the second Array dimension a tensor dimension for which 1D
   {\tt undistLBound} and {\tt undistUBound} arguments must be supplied. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &
    distgridToArrayMap=(/0,1/), undistLBound=(/11/), &
    undistUBound=(/14/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayDestroy(array, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Finally, the same {\tt arrayspec} and {\tt distgrid} arguments are used to
   create a 2D Array that is fully replicated in both dimensions of the DistGrid.
   Both Array dimensions are now tensor dimensions and both DistGrid dimensions
   are replicator dimensions. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &
    distgridToArrayMap=(/0,0/), undistLBound=(/11,21/), &
    undistUBound=(/14,22/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The result will be an Array with local lower bound (/11,21/) and upper bound
   (/14,22/) on all 6 DEs of the DistGrid. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayDestroy(array, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_DistGridDestroy(distgrid, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Replicated Arrays can also be created from existing local Fortran arrays.
   The following Fortran array allocation will provide a 3 x 10 array on each
   PET.  
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(myFarray2D(3,10))
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Assuming a petCount of 4 the following DistGrid defines a 2D index space
   that is distributed across the PETs along the first dimension. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The following call creates an Array object on the above distgrid using
   the locally existing {\tt myFarray2D} Fortran arrays. The difference 
   compared to the case with automatic memory allocation is that instead of
   {\tt arrayspec} the Fortran array is provided as argument. Furthermore,
   the {\tt undistLBound} and {\tt undistUBound} arguments can be omitted,
   defaulting into Array tensor dimension lower bound of 1 and an upper
   bound equal to the size of the respective Fortran array dimension. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  array = ESMF_ArrayCreate(farray=myFarray2D, distgrid=distgrid, &
    indexflag=ESMF_INDEX_DELOCAL, distgridToArrayMap=(/0,2/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The {\tt array} object associates the 2nd DistGrid dimension with the 2nd
   Array dimension. The first DistGrid dimension is not associated with any
   Array dimension and will lead to replication of the Array along the DEs of
   this direction. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayDestroy(array, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_DistGridDestroy(distgrid, rc=rc)
 
\end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
