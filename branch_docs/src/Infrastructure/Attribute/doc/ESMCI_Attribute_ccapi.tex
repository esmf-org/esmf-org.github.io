%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_Attribute.C,  Date: Tue May  5 21:00:05 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Attribute] {Attribute - empty private copy constructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute::Attribute(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Attribute&) {
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt Attribute} object.
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Empty private copy constructor.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackAddAttribute()] {AttPackAddAttribute() - add an {\tt Attribute} to an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackAddAttribute(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,                    // in - Attribute name
       const string &convention,              // in - Attribute convention
       const string &purpose,                 // in - Attribute purpose
       const string &object) {                // in - Attribute object type 
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Add an {\tt Attribute} with a specified name but no value.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackAddAttribute()] {AttPackAddAttribute() - add an {\tt Attribute} to this attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackAddAttribute(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name) {                    // in - Attribute name
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Add an {\tt Attribute} with a specified name but no value.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackCreateCustom()] {AttPackCreateCustom() - create an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute *Attribute::AttPackCreateCustom(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &convention,              // in - Attribute convention
       const string &purpose,                 // in - Attribute purpose
       const string &object) {                // in - Attribute object type\end{verbatim}
{\sf DESCRIPTION:\\ }


       Setup the name, convention and purpose of an attpack.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackCreateStandard()] {AttPackCreateStandard() - create an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackCreateStandard(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &convention,              // in - Attribute convention
       const string &purpose,                 // in - Attribute purpose
       const string &object) {                // in - Attribute object type
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Setup the name, convention and purpose of an attpack.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackCreateStandard(instance] {AttPackCreateStandard(instance list) - nest a instance list of attpacks (full multi-child tree)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackCreateStandard(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &convention,              // in - Attribute convention
       const string &purpose,                 // in - Attribute purpose
       const string &object,                  // in - Attribute object type
       const vector<string> &nestConvention,  // in - Attribute nestConventions
       const vector<string> &nestPurpose,     // in - Attribute nestPurposes
       const vector<int> &nestAttPackInstanceCountList, // in - # of attPack instances of each (conv,purp) type
       int   nestCount,                       // in - # of attpacks (child nodes)
       vector<string> &nestAttPackInstanceNameList, // inout - Attribute package instance names
       int   &nestAttPackInstanceNameCount) { // inout - # of attPack instance names
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Top-down approach:  Create a new standard parent attpack of type
       (conv,purp), and create within it nested standard children attpacks of 
       type (nestConv,nestPurp).  For each (nestConv,nestPurp) child type, 
       create multiple nested attpacks as specified in 
       nestAttPackInstanceCountList, and return the unique instance names in
       nestAttPackInstanceNameList.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackNest(single)] {AttPackNest(single) - nest a single attpack (single-child tree)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackNest(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &convention,              // in - Attribute convention
       const string &purpose,                 // in - Attribute purpose
       const string &object,                  // in - Attribute object type
       const string &nestConvention,          // in - Attribute nestConvention
       const string &nestPurpose) {           // in - Attribute nestPurpose
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Setup the name, convention and purpose of a single nested attpack.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackNest(list)] {AttPackNest(list) - nest a list of attpacks (full multi-child tree)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackNest(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &convention,              // in - Attribute convention
       const string &purpose,                 // in - Attribute purpose
       const string &object,                  // in - Attribute object type
       int   nestCount,                       // in - # of attpacks (child nodes)
       const vector<string> &nestConvention,  // in - Attribute nestConventions
       const vector<string> &nestPurpose) {   // in - Attribute nestPurposes
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Bottom up approach:  Given a set of already created attpacks, nest them
       within a new parent attpack.  Assumes one attpack instance for each
       (nestConv, nestPurp) attpack type.
       TODO:  Create a different overloaded method that takes a list of 
              attpack instance names instead of (nestConv,nestPurp) pairs.
              This will handle the bottom-up case of already-created multiple
              instances of (nestConv, nestPurp) attpack types.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackGet] {AttPackGet - get an attpack on an {\tt Attribute}}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute *Attribute::AttPackGet(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt Attribute} pointer to requested object or NULL on early exit.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &convention,          // in - Attribute convention to retrieve
       const string &purpose,             // in - Attribute purpose to retrieve
       const string &object,              // in - Attribute object type to retrieve
       const string &attPackInstanceName, // in - attPack name
     ESMC_AttNest_Flag anflag) const {
 \end{verbatim}
{\sf DESCRIPTION:\\ }


      Get an attpack on an {\tt Attribute} given it's convention, 
      purpose, object type, and optional attPackInstanceName
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackGet] {AttPackGet - get an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute *Attribute::AttPackGet(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt Attribute} pointer to requested object or NULL on early exit.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &convention,      // in - attpack convention,
       const string &purpose,         //      purpose, and
       const string &object,          //      object to match
       const string &name,            // in - Attribute name to match)
       const string &value) const {   // in - Attribute value to match
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Get an attpack of given convention, purpose and object type, and which
       contains an attribute of given name and value.  Recursively search
       through the ESMF object/attribute tree from the point of invocation.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackGet] {AttPackGet - get attpack instance names associated with the given}


                            convention, purpose, and object
  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackGet(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &convention,        // in - Attribute convention to retrieve
       const string &purpose,           // in - Attribute purpose to retrieve
       const string &object,            // in - Attribute object type to retrieve
       vector<string> &attPackInstanceNameList, // out - Attribute package instance names
       int &attPackInstanceNameCount,            // out - # of attPack instance names
     ESMC_AttNest_Flag anflag) const {        // in - attnestflag\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the attpack instance names given its convention, 
      purpose, and object type.  Looks for all the instance names to be 
      at one level in the tree.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackGetAttribute] {AttPackGetAttribute - get an {\tt Attribute} from an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute *Attribute::AttPackGetAttribute(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt Attribute} pointer to requested object or NULL on early exit.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name) const {         // in - Attribute name to retrieve)
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Get an {\tt Attribute} from an attpack given its name, convention, 
       purpose, and object type.  This routine is assumed to be called on the 
       Attribute package that holds the Attribute in question.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackGetAttribute] {AttPackGetAttribute - get an {\tt Attribute} from an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute *Attribute::AttPackGetAttribute(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt Attribute} pointer to requested object or NULL on early exit.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const int &num) const {         // in - Attribute name to retrieve)\end{verbatim}
{\sf DESCRIPTION:\\ }


       Get an {\tt Attribute} from an attpack given its index.
       This routine is assumed to be called on the
       Attribute package that holds the Attribute in question.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackGetAttribute] {AttPackGetAttribute - get an {\tt Attribute} from an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute *Attribute::AttPackGetAttribute(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt Attribute} pointer to requested object or NULL on early exit.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,         // in - Attribute name to retrieve)
     ESMC_AttNest_Flag anflag    // in - attnestflag
     ) const {\end{verbatim}
{\sf DESCRIPTION:\\ }


       Get an {\tt Attribute} from an attpack given its name, convention,
       purpose, and object type.  This routine is assumed to be called on the
       Attribute package that holds the Attribute in question.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackGetAttribute] {AttPackGetAttribute - get an {\tt Attribute} from an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute *Attribute::AttPackGetAttribute(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt Attribute} pointer to requested object or NULL on early exit.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const int &num,              // in - Attribute index
     ESMC_AttNest_Flag anflag    // in - attnestflag
     ) const {\end{verbatim}
{\sf DESCRIPTION:\\ }


       Get an {\tt Attribute} from an attpack given its index.
       This routine is assumed to be called on the
       Attribute package that holds the Attribute in question.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackIsPresent] {AttPackIsPresent - query an {\tt Attpack} about existence}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackIsPresent(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Value of the present flag.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Attribute *attpack,          // in - Attribute package
       ESMC_Logical *present) {     // in/out - the present flag
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Query an Attribute package for an {\tt Attribute} given its name.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackIsPresent] {AttPackIsPresent - query an {\tt Attribute} for an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackIsPresent(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Value of the present flag.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,                // in - Attribute name
       const Attribute *attpack,          // in - Attribute package
       ESMC_AttNest_Flag anflag,          // in - attgetcount flag
       ESMC_Logical *present) const {     // in/out - the present flag\end{verbatim}
{\sf DESCRIPTION:\\ }


       Query an Attribute package for an {\tt Attribute} given its name.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackIsPresent] {AttPackIsPresent - query an {\tt Attribute} for an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackIsPresent(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Value of the present flag.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const int &num,                    // in - Attribute name
       const Attribute *attpack,          // in - Attribute package
       ESMC_AttNest_Flag anflag,          // in - attgetcount flag
       ESMC_Logical *present) const {     // in/out - the present flag\end{verbatim}
{\sf DESCRIPTION:\\ }


       Query an Attribute package for an {\tt Attribute} given its name.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackIsSet] {AttPackIsSet - check if any {\tt Attribute} is set in an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Attribute::AttPackIsSet(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      true if attribute set, false otherwise.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &convention,          // in - Attribute convention
       const string &purpose,             // in - Attribute purpose
       const string &object,              // in - Attribute object type
       const bool   &inObjectTree,        // in - search ESMF object tree?
       const bool   &inThisCompTreeOnly,  // in - only search within this component tree?
       const bool   &inNestedAttPacks) const {// in -search within nested attpacks?
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Search for set Attribute packages of the given type, within the
       attribute hierarchy of the given ESMF object, and optionally within the
       attribute hierarchies of other ESMF objects, within the tree of this ESMF
       object, to see if any {\tt Attribute} of the attpack has been set.
       Returns true as soon as a set attribute is found.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackIsSet] {AttPackIsSet - check if any {\tt Attribute} is set in an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Attribute::AttPackIsSet(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      true if attribute set, false otherwise.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const bool &inNestedAttPacks) const {  // search within nested attpacks?
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Query Attribute package to see if any {\tt Attribute} has been set,
       within the given package or optionally any of its nested packages.
       Returns true as soon as a set attribute is found.
  
       TODO: Ability to specify which level in the nest (and optionally below
             or not) to search for set attributes (via pathing mechanism?) 
             E.g., only interested in attributes set within CF/Extended or
             CF/General within a CIM/Inputs package, as used in
             AttributeWriteCIMmodelComp(). 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackRemove] {AttPackRemove - Remove an {\tt Attribute} package}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackRemove(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         ESMCI::Attribute *attpack) {   // in - attPack
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Remove an {\tt Attribute} package
  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackRemoveAttribute] {AttPackRemoveAttribute - Remove an {\tt Attribute} from}


                                              an {\tt Attribute} package
  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackRemoveAttribute(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,         // in - name
       ESMCI::Attribute *attpack,  // in - attPack name
     ESMC_AttNest_Flag anflag) { // in - attnestflag
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Remove an {\tt Attribute} from an {\tt Attribute} package
  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackSet()] {AttPackSet() - set an {\tt Attribute} in an attpack}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackSet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,             // in - Attribute name
       const ESMC_TypeKind_Flag &tk,       // in - typekind
       int count,              // in - item count
       void *value,            // in - Attribute value
       const string &convention,       // in - attpack convention
       const string &purpose,          // in - attpack purpose
       const string &object,           // in - attpack object type
       const string &attPackInstanceName) {   // in - attPack name
                                        // specifying which one of multiple packs
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Set the value for an {\tt Attribute} belonging to an attpack with  
       convention, purpose, and object type.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttPackSet] {AttPackSet - set {\tt Attribute} on an ESMF type}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttPackSet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Attribute *attr) {   // in - Attribute name, type, value
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Associate a (name,value) pair with any type in the system.
       This version of set is used when the caller has already allocated
       an {\tt Attribute} object and filled it, and the {\tt Attribute} 
       is simply added to the list belonging to this object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeCopy] {AttributeCopy - copy all {\tt Attribute} data }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeCopy(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         const Attribute &source) {   // in - source
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       All of the {\tt Attribute} data associated with the source object is 
       copied.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeCopyHybrid] {AttributeCopyHybrid - copy {\tt Attributes} between ESMF objects}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeCopyHybrid(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         const Attribute &source) {   // in - source\end{verbatim}
{\sf DESCRIPTION:\\ }


     Copy all {\tt Attribute} data, copy by value all {\tt Attributes} in this
     base level, and copy by reference all {\tt Attributes} in lower base levels.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeCopyIgnore] {AttributeCopyIgnore - copy {\tt Attributes} between ESMF objects}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeCopyIgnore(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         const Attribute &source) {   // in - source\end{verbatim}
{\sf DESCRIPTION:\\ }


     Copy all {\tt Attribute} data and copy by value all {\tt Attributes} in
     this base level.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeCopyReplace] {AttributeCopyReplace - copy {\tt Attributes} between ESMF objects}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeCopyReplace(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         const Attribute &source) {   // in - source\end{verbatim}
{\sf DESCRIPTION:\\ }


     Copy all {\tt Attribute} data and copy by value all {\tt Attributes} in 
     this base level, replacing those that already exist.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeMove] {AttributeMove - Move {\tt Attributes} between ESMF objects}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeMove(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         Attribute *source) {   // in - source\end{verbatim}
{\sf DESCRIPTION:\\ }


     Copy all {\tt Attribute} data and copy by reference all {\tt Attributes} in 
     this base level and remove everything copied from source.  
  
     Note:  this routine is written with the assumption of being called from a Base
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeCountTree] {AttributeCountTree - count objects in {\tt Attribute} hierarchy }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeCountTree(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &convention,                 // in - convention
       const string &purpose,                    // in - purpose
       const string &object,                     // in - object type to look for
       int &objcount,             // inout - object count
       int &numattrs ) const{     // inout - count of attrs on objects in tree
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Count the number of objects in the {\tt Attribute} hierarchy 
  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeCountTreeAttpack] {AttributeCountTreeAttpack - count objects in {\tt Attribute} hierarchy }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeCountTreeAttpack(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int &objcount,             // inout - count of objects to write
       int &numattrs ) const{     // inout - count of attrs on objects in tree
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Count the number of objects in the {\tt Attribute} hierarchy 
  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeCountTreeLens] {AttributeCountTreeLens - get lengths of {\tt Attribute} values}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeCountTreeLens(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &convention,           // in - convention
       const string &purpose,              // in - purpose
       const string &object,               // in - object type to look for
       int *attrLens,                      // inout - lengths of column names
       vector<string> &attrNames ) const{  // inout - names of columns
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Count the number of objects in the Attribute hierarchy
  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeCountTreeLensAttpack] {AttributeCountTreeLensAttpack - get lengths and names of columns}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeCountTreeLensAttpack(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int &index,               // in - index counter
       int *attrLens,                      // inout - lengths of column names
       vector<string> &attrNames ) const{  // inout - names of columns
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Get the lengths and names of the columns in the table
  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [get(int] {get(int *)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::get(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int *count,                      // out - number of values in list
       vector<ESMC_I4> *value) const {  // out - Attribute value
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the {\tt ESMC\_I4} valueList of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [get(ESMC\_I8] {get(ESMC\_I8 *)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::get(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int *count,                      // out - number of values in list
       vector<ESMC_I8> *value) const {  // out - Attribute value
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the {\tt ESMC\_I8} valueList of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [get(ESMC\_R4] {get(ESMC\_R4 *)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::get(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int *count,                      // out - number of values in list
       vector<ESMC_R4> *value) const {  // out - Attribute value
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the {\tt ESMC\_R4} valueList of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [get(ESMC\_R8] {get(ESMC\_R8 *)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::get(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} 
       int *count,                      // out - number of values in list
       vector<ESMC_R8> *value) const {  // out - Attribute value
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the {\tt ESMC\_R8} valueList of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [get(ESMC\_Logical] {get(ESMC\_Logical *)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::get(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int *count,                           // out - number of values in list
       vector<ESMC_Logical> *value) const {  // out - Attribute value
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the {\tt ESMC\_Logical} valueList of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [get(charlist)] {get(charlist)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::get(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       vector<string> *value) const {  // out - Attribute values
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the charlist value of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [get] {get - get lengths of strings in an {\tt Attribute}}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::get(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt Attribute} pointer or NULL on error exit.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int *lens,          // out - Atttribute char* lengths to retrieve
       int count) const {  // in/out - number of Attribute lengths to retrieve\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the lengths of the strings in an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getCount] {getCount - get an the number of {\tt Attributes}}


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::getCount(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      number of {\tt Attributes} in this attrList
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       ESMC_AttGetCountFlag gcflag,  // in - attgetcount flag
     int *count                     // out - the count to return
     ) const {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Returns number of {\tt Attributes} present
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getCount] {getCount - get an the number of {\tt Attributes}}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::getCount(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      number of {\tt Attributes} in this attrList\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       ESMC_AttGetCountFlag gcflag,   // in - attgetcount flag
       ESMC_AttNest_Flag anflag,      // in - attnestflag
     int *count                     // out - the count to return
     ) const {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Returns number of {\tt Attributes} present
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeGet] {AttributeGet - get {\tt Attribute} from an ESMF type}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute *Attribute::AttributeGet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt Attribute} pointer or NULL on error exit.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name) const {        // in - Attribute name to retrieve\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the {\tt Attribute} name.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeGet] {AttributeGet - get an {\tt Attribute} by number}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute *Attribute::AttributeGet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int number) const {             // in - Attribute number\end{verbatim}
{\sf DESCRIPTION:\\ }


       Allows the caller to get {\tt Attributes} by number instead of by name.
       This can be useful in iterating through all {\tt Attributes} in a loop.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeIsPresent] {AttributeIsPresent - query for an {\tt Attribute}}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeIsPresent(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Value of the present flag.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,                             // in - Attribute name
       ESMC_Logical *present) const {         // in/out - the present flag
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Query for an {\tt Attribute} given its name
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeIsPresent] {AttributeIsPresent - query for an {\tt Attribute}}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeIsPresent(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Value of the present flag.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const int &num,                 // in - Attribute index
       ESMC_Logical *present) const {  // in/out - the present flag\end{verbatim}
{\sf DESCRIPTION:\\ }


       Query for an {\tt Attribute} given its index
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [isSet] {isSet - query if an {\tt Attribute} has been set}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Attribute::isSet(const Attribute *attribute) {
 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Whether the value has been set
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   
      None\end{verbatim}
{\sf DESCRIPTION:\\ }


       Query for whether an {\tt Attribute} has been set
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeLink] {AttributeLink - Link an {\tt Attribute} hierarchy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeLink(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Attribute *destination,         // in/out destination Attribute to be linked
       ESMC_Logical *linkChangeIn) {   // in - link Changes?\end{verbatim}
{\sf DESCRIPTION:\\ }


       Link an {\tt Attribute} hierarchy.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeLinkRemove] {AttributeLinkRemove - Remove a link in an {\tt Attribute} hierarchy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeLinkRemove(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Attribute *destination,         // in/out destination Attribute to be linked
       ESMC_Logical *linkChangeIn) {   // in - link Changes?\end{verbatim}
{\sf DESCRIPTION:\\ }


       Set a link in an {\tt Attribute} hierarchy.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeRemove] {AttributeRemove - Remove the {\tt Attribute}}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeRemove(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name) {                // in - name
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Remove the {\tt Attribute} 
  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeSet] {AttributeSet - set {\tt Attribute} on an ESMF type}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeSet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Attribute *attr) {   // in - Attribute name, type, value
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Associate a (name,value) pair with any type in the system.
       This version of set is used when the caller has already allocated
       an {\tt Attribute} object and filled it, and the {\tt Attribute} 
       is simply added to the list belonging to this object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeSet(int] {AttributeSet(int *) - set {\tt Attribute} on an ESMF type}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeSet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,              // in - Attribute name
       int count,               // in - number of ints in list
       vector<ESMC_I4> *value) {        // in - Attribute values
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the {\tt ESMC\_I4} valueList of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeSet(ESMC\_I8] {AttributeSet(ESMC\_I8 *) - set {\tt Attribute} on an ESMF type}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeSet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,              // in - Attribute name
       int count,               // in - number of ints in list
       vector<ESMC_I8> *value) {        // in - Attribute values
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the {\tt ESMC\_I8} valueList of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeSet(ESMC\_R4] {AttributeSet(ESMC\_R4 *) - set {\tt Attribute} on an ESMF type}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeSet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,              // in - Attribute name
       int count,               // in - number of ESMC_R4s in list
       vector<ESMC_R4> *value) {        // in - Attribute values
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the {\tt ESMC\_R4} valueList of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeSet(ESMC\_R8] {AttributeSet(ESMC\_R8 *) - set {\tt Attribute} on an ESMF type}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeSet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,              // in - Attribute name
       int count,               // in - number of ESMC_R8s in list
       vector<ESMC_R8> *value) {        // in - Attribute values
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the {\tt ESMC\_R8} valueList of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeSet(ESMC\_Logical] {AttributeSet(ESMC\_Logical *) - set {\tt Attribute} on an ESMF type}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeSet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,              // in - Attribute name
       int count,               // in - number of logicals in list
       vector<ESMC_Logical> *value) {   // in - Attribute values
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the {\tt ESMC\_Logical} valueList of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeSet(charlist)] {AttributeSet(charlist) - set {\tt Attribute} on an ESMF type}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeSet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,       // in - Attribute name
       int count,               // in - number of strings in vector
       vector<string> *value) {    // in - Attribute value
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the value of an {\tt Attribute}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttributeSetObjsInTree] {AttributeSetObjsInTree - set all objects in {\tt Attribute} hierarchy }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttributeSetObjsInTree(
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const string &name,                    // in - name
       const string &object,                  // in - object
       const ESMC_TypeKind_Flag &tk,              // in - typekind
       const int &count,                     // in - count
       void *value) {                 // in - value
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Set the objects in the {\tt Attribute} hierarchy 
  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Attribute::ESMC\_Print] {Attribute::ESMC\_Print - Print the {\tt Attribute} contents}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::ESMC_Print(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       bool tofile,            // stream to stdout or file
       const char *filename,   // filename
       bool append) const {    // append or start new
   \end{verbatim}
{\sf DESCRIPTION:\\ }


       Print the contents of an {\tt Attribute} object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Attribute::print\_to\_file] {Attribute::print\_to\_file - Print the {\tt Attribute} contents}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::print_to_file(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       bool tofile,                  // stream to stdout or file
       ofstream &fp,                 // file handle
       unsigned int level) const {   // indentation according to attpack\end{verbatim}
{\sf DESCRIPTION:\\ }


       Print the contents of an {\tt Attribute} object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Attribute::ESMC\_Print] {Attribute::ESMC\_Print - Print the {\tt Attribute} contents}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::ESMC_Print(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       ) const {                    // could add options at some point\end{verbatim}
{\sf DESCRIPTION:\\ }


       Print the contents of an {\tt Attribute} object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Attribute] {Attribute - native C++ constructor for Attribute class}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute::Attribute(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      new {\tt Attribute} object\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         const string &conv,                  // convention
         const string &purp,                  // purpose
         const string &obj) {                 // object\end{verbatim}
{\sf DESCRIPTION:\\ }


     Initialize an {\tt Attribute} and set the name, convention, and purpose.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Attribute] {Attribute - native C++ constructor for Attribute class}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute::Attribute(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      new {\tt Attribute} object\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         const string &name,                  // Attribute name
         const string &conv,                  // convention
         const string &purp,                  // purpose
         const string &obj) {                 // object\end{verbatim}
{\sf DESCRIPTION:\\ }


     Initialize an {\tt Attribute} and set the name, convention, and purpose.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Attribute] {Attribute - native C++ constructor for Attribute class}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute::Attribute(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


       Create an empty {\tt Attribute} structure.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Attribute] {Attribute - native C++ constructor for Attribute class}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute::Attribute(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      new {\tt Attribute} object\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         const ESMC_Logical &attributeRoot) {                 // root value\end{verbatim}
{\sf DESCRIPTION:\\ }


     Initialize an {\tt Attribute} and set the name, convention, and purpose.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Attribute] {Attribute - native C++ constructor for Attribute class}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute::Attribute(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt Attribute} object\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         const string &name,                // Attribute name
         const ESMC_TypeKind_Flag &typekind,    // typekind
         int numitems,              // single or list
         void *datap) {             // generic pointer to values\end{verbatim}
{\sf DESCRIPTION:\\ }


     Initialize an {\tt Attribute}, and make a copy of the data - multi item case
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [AttrModifyValue] {AttrModifyValue - native C++ modifier for Attribute class}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::AttrModifyValue(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         const ESMC_TypeKind_Flag &typekind,    // typekind
         int numitems,              // single or list
         void *datap) {             // generic pointer to values\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set a value on an existing {\tt Attribute} object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Attribute] {Attribute - generic operator=}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute& Attribute::operator=(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Attribute& source) {
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt Attribute} object.
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Generic operator= call AttributeCopyValue.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [clean] {clean - remove all Attributes, packages and links}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       void Attribute::clean() {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


      Delete an {\tt Attribute} hierarchy.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [~Attribute] {~Attribute - native C++ destructor for Attribute class}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Attribute::~Attribute(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


      Delete an {\tt Attribute} hierarchy.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Deserialize] {ESMC\_Deserialize - Turn a byte stream into an object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::ESMC_Deserialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       char *buffer,          // in - byte stream to read
       int *offset) {         // inout - original offset, updated to point 
                              //       to first free byte after current obj\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn a stream of bytes into an {\tt Attribute} hierarchy.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Serialize] {ESMC\_Serialize - Turn the object information into a byte stream}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Attribute::ESMC_Serialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       char *buffer,          // inout - byte stream to fill
       int *length,           // inout - buf length; realloc'd here if needed
       int *offset,           // inout - original offset, updated to point 
                              //  to first free byte after current obj info
       ESMC_InquireFlag inquireflag) const { // in - inquire flag
   \end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn an {\tt Attribute} into a stream of bytes.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_SerializeCC] {ESMC\_SerializeCC - Turn the object information into a byte stream}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     int Attribute::ESMC_SerializeCC(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     char *buffer,          // inout - byte stream to fill
     int *length,           // inout - buf length; realloc'd here if needed
     int &offset,           // inout - original offset, updated throughout
     bool cc,               // in - to tell whether in count or copy mode
     ESMC_InquireFlag inquireflag) const { // in - inquire flag\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn an {\tt Attribute} into a stream of bytes.
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
