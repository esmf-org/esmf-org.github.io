%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_LogErr.C,  Date: Tue May  5 20:59:27 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

 
 extern "C" {
   void FTN_X(esmf_breakpoint)(void);
 }
 
 namespace ESMCI{
 
  ----------------------------------------------------------------------------
 #define ESMC_METHOD "LogErr::AllocError" 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [AllocError] {AllocError}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 
 void LogErr::AllocError(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int LINE,
     const std::string &FILE,
     const std::string &method,
     int *rcToReturn
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Allocation error without message. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [MsgAllocError] {MsgAllocError}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 
 void LogErr::MsgAllocError(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const string& msg,
     int LINE,
     const std::string &FILE,
     const std::string &method,
     int *rcToReturn
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Allocation error with message. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [DeallocError] {DeallocError}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 
 void LogErr::DeallocError(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int LINE,
     const std::string &FILE,
     const std::string &method,
     int *rcToReturn
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Deallocation error without message. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [MsgDeallocError] {MsgDeallocError}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 
 void LogErr::MsgDeallocError(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const std::string &msg,
     int LINE,
     const std::string &FILE,
     const std::string &method,
     int *rcToReturn
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


      Deallocation error with message. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Open] {Open - opens a Log object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 void LogErr::Open(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} 
      const std::string &filename     //string to form name of log file (input)
 
    )\end{verbatim}
{\sf DESCRIPTION:\\ }


   {\tt ESMC\_LogOpen} opens a new log file and sets the default filename
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMC\_LogSetFilename] {ESMC\_LogSetFilename - sets filename of a log that is open}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_LogSetFilename(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    int\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} 
      const std::string &filename     //string to form name of log file (input)
 
    )\end{verbatim}
{\sf DESCRIPTION:\\ }


   {\tt ESMC\_LogSetFilename} sets the filename to the opened log.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMC\_LogFinalize] {ESMC\_LogFinalize - Finalizes an open log}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int ESMC_LogFinalize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} 
    )\end{verbatim}
{\sf DESCRIPTION:\\ }


   {\tt ESMC\_LogFinalize} finalizes an open log. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Close] {Close - closes log file.}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 void LogErr::Close(
   ! RETURN VALUE:
      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none
 
    )
   ! DESCRIPTION:
   This routine simply closes the log file(s).\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Write] {Write - write to log file}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int LogErr::Write(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    bool\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        const string& msg,   // Log Entry
        int msgtype   // Msg Type
       )\end{verbatim}
{\sf DESCRIPTION:\\ }


   Prints log message and returns ESMF_SUCCESS if successful.  It takes two
   arguments -
   msg which is a user message and log type.  This method does not use cpp
   macros 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Write] {Write - write to log file}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 int LogErr::Write(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    bool\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const std::string &msg,     // Log Entry
     int msgtype,        // Msg Type
     int LINE,
     const std::string &FILE,
     const std::string &method
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


   Prints log message and returns ESMF_SUCCESS if successful.  It takes two
   arguments -
   msg which is a user message and log type.  This method uses cpp macros 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Set] {Set - set Log parameters}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 int LogErr::Set(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    integer return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int flush
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


   Sets log parameters 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [SetTrace] {SetTrace - set trace flag}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 int LogErr::SetTrace(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    integer return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     bool traceflag
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


   Sets log parameters 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [FoundError] {FoundError - LogFoundError}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 
 bool LogErr::FoundError(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    bool\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int rcToCheck,
     int LINE,
     const char FILE[],
     const char method[],
     int *rcToReturn
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


   Returns true if rcToCheck does not equal ESMF\_SUCCESS and writes the error
   to the log.  This method uses cpp macros. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [FoundError] {FoundError - LogFoundError}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 
 bool LogErr::FoundError(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    bool\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int rcToCheck,
     int LINE,
     const std::string &FILE,
     const std::string &method,
     int *rcToReturn
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


   Returns true if rcToCheck does not equal ESMF\_SUCCESS and writes the error
   to the log.  This method uses cpp macros. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [MsgFoundError] {MsgFoundError - LogMsgFoundError}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 bool LogErr::MsgFoundError(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    bool\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int rcToCheck,
     const char msg[],
     int LINE,
     const char FILE[],
     const char method[],
     int *rcToReturn
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


   Returns true if rcToCheck does not equal ESMF\_SUCCESS and writes the error
   to the log with a user supplied message.  This method uses cpp macros. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [MsgFoundError] {MsgFoundError - LogMsgFoundError}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 bool LogErr::MsgFoundError(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    bool\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int rcToCheck,
     const std::string &msg,
     int LINE,
     const std::string &FILE,
     const std::string &method,
     int *rcToReturn
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


   Returns true if rcToCheck does not equal ESMF\_SUCCESS and writes the error
   to the log with a user supplied message.  This method uses cpp macros. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMC\_TimeStamp] {ESMC\_TimeStamp - ESMC\_TimeStamp}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 void ESMC_TimeStamp(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int *y,
     int *mn,
     int *d,
     int *h,
     int *m,
     int *s,
     int *ms
 
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


   Returns time stamp values so that microsecond precision can be used. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMC\_LogGetErrMsg] {ESMC\_LogGetErrMsg - LogGetErrMsg}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 const char *ESMC_LogGetErrMsg(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    char\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int rc
     )\end{verbatim}
{\sf DESCRIPTION:\\ }


   Returns error message corresponding to rc
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
