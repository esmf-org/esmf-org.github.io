%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_LogErr.h,  Date: Tue May  5 20:59:27 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsection{C++:  Class Interface ESMCI\_Log - C++ interface to Log (Source File: ESMCI\_LogErr.h)}


  
{\sf DESCRIPTION:\\ }


  
   The code in this file defines the C++ Log members and declares all class
   data and methods.  All methods, except for the Set and Get methods, which
   are inlined, are defined in the companion file ESMCI\_LogErr.C
  
\bigskip{\em USES:}
\begin{verbatim} 
 #include "ESMF_LogMacros.inc"
 
 #include "ESMC_LogErr.h"
 #include "ESMC_Util.h"
 #include "ESMCI_Util.h"
 
 #include <cstdio>
 #include <string>
 #include <sstream>
 
   use this macro to test for NULL pointer in the interface layer
   -> here assume rcvar is not a pointer, and must be returned directly
 #define ESMCI_NULL_CHECK_RC(ptr, rcvar) \
   if (ptr == NULL){ \
     ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL, \
     "Not a valid object pointer", ESMC_CONTEXT, &rcvar); \
     return rcvar;  \
   }
 
   use this macro to test for NULL pointer in the interface layer
   -> here assume rcvar is a pointer, and will be returned through argument list
 #define ESMCI_NULL_CHECK_PRC(ptr, rcvar) \
   if (ptr == NULL){ \
     ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL, \
     "Not a valid object pointer", ESMC_CONTEXT, rcvar); \
     return;  \
   }
 
   use this macro to test for NULL pointer in the interface layer
   -> here assume rcvar is a pointer, and will be returned through argument list
 #define ESMCI_NULL_CHECK_PRC_RETURN_NULL(ptr, rcvar) \
   if (ptr == NULL){ \
     ESMC_LogDefault.MsgFoundError(ESMC_RC_PTR_NULL, \
     "Not a valid object pointer", ESMC_CONTEXT, rcvar); \
     return NULL;  \
   }
 
 namespace ESMCI{
 
 class LogErr {
 private:\end{verbatim}{\sf PRIVATE TYPES:}
\begin{verbatim} 
     int numFilePtr;             // index into global array of File pointers
                                 // for C++ I/O
     ESMC_Logical FileIsOpen;
 
     ESMC_Logical verbose;       // If set to ESMC_TF_TRUE, log messages written
                                 // out.
 
     ESMC_Logical flush;         // If true, all output is flushed
 
     bool trace;                 // If true, some methods issue trace messages upon entry
 
     ESMC_Logical rootOnly;
 
     int halt;
 
     int filetype;
 
     int stream;
 
     int max_elements;
 
     int *pet_number;
                 
     ESMC_Logical fileI0;        // If true, output written to files
 
     int stdOutUnitNumber;       // Unit number corresponding to standard
                                 // out
 
   public:
 \end{verbatim}{\sf PUBLIC MEMBER FUNCTIONS:}
\begin{verbatim}     void AllocError(
         int LINE, const std::string &FILE, const std::string &method,
         int *rcToReturn);
     void DeallocError(
         int LINE, const std::string &FILE, const std::string &method,
         int *rcToReturn);
     void Close();
     bool FoundError(int rcToCheck,
         int LINE, const char FILE[], const char method[],
         int *rcToReturn);
     bool FoundError(int rcToCheck,
         int LINE, const std::string &FILE, const std::string &method,
         int *rcToReturn);
     void MsgAllocError(const std::string& msg,
         int LINE, const std::string &FILE, const std::string &method,
         int *rcToReturn);
     void MsgDeallocError(const std::string& msg,
         int LINE, const std::string &FILE, const std::string &method,
         int *rcToReturn);
     bool MsgFoundError(int rcToCheck, const char msg[],
         int LINE, const char FILE[], const char method[],
         int *rcToReturn);
     bool MsgFoundError(int rcToCheck, const std::string &msg,
         int LINE, const std::string &FILE, const std::string &method,
         int *rcToReturn);
     bool MsgFoundError(int rcToCheck, const std::stringstream& msg,
         int LINE, const std::string &FILE, const std::string &method,
         int *rcToReturn) {
       return MsgFoundError(rcToCheck, msg.str(), LINE, FILE, method, rcToReturn);
     }
     void Open(const std::string &filename);
     int Set(int flush);
     int SetTrace(bool traceflag);
     int Write(const std::string& msg, int msgtype);
     int Write(const std::stringstream& msg, int msgtype) {
       return Write(msg.str(), msgtype);
     }
     int Write(const std::string& msg, int msgtype,
         int LINE, const std::string &FILE, const std::string &method);
     int Write(const std::stringstream& msg, int msgtype,
         int LINE, const std::string &FILE, const std::string &method) {
       return Write(msg.str(), msgtype, LINE, FILE, method);
     }
 
   !PUBLIC Variables:
     std::FILE *ESMC_LogFile;
     std::string nameLogErrFile;
     int *pet_num;
     ESMC_LogKind_Flag logtype;
     int *errorMask;
     int errorMaskCount;
 
 
   private:
   !PRIVATE MEMBER FUNCIONS:
 
 };
 
 } //namespace ESMCI
 
   the default global log object
 extern ESMCI::LogErr ESMC_LogDefault;
 extern "C" {
  void FTN_X(f_esmf_logset)(ESMC_Logical *flush, int *rc);
  void FTN_X(f_esmf_logwrite0)(const char *msg, int *msgtype, int *rc, ESMCI_FortranStrLenArg mlen);
  void FTN_X(f_esmf_logwrite1)(const char *msg, int *msgtype,
                             int *line, const char *file, const char *method, int *rc,
                             ESMCI_FortranStrLenArg mlen, ESMCI_FortranStrLenArg flen,
                             ESMCI_FortranStrLenArg mdlen);
 }
 \end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
