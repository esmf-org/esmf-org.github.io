%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_TimeInterval.F90,  Date: Tue May  5 20:59:34 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_TimeIntervalAssignment(=)] {ESMF\_TimeIntervalAssignment(=) - Assign a TimeInterval to another TimeInterval}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface assignment(=)
       timeinterval1 = timeinterval2\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval) :: timeinterval1
       type(ESMF_TimeInterval) :: timeinterval2
   \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       \begin{sloppypar}
       Set {\tt timeinterval1} equal to {\tt timeinterval2}.  This is the default
       Fortran assignment, which creates a complete, independent copy of
       {\tt timeinterval2} as {\tt timeinterval1}.  If {\tt timeinterval2} is an
       invalid {\tt ESMF\_TimeInterval} object then {\tt timeinterval1} will be
       equally invalid after the assignment.
       \end{sloppypar}
  
       The arguments are:
       \begin{description} 
       \item[timeinterval1] 
            The {\tt ESMF\_TimeInterval} to be set.
       \item[timeinterval2] 
            The {\tt ESMF\_TimeInterval} to be copied.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(+)] {ESMF\_TimeIntervalOperator(+) - Add two TimeIntervals}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(+)
       sum = timeinterval1 + timeinterval2\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_TimeInterval) :: sum\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Overloads the (+) operator for the {\tt ESMF\_TimeInterval} class to
       add {\tt timeinterval1} to {\tt timeinterval2} and return the
       sum as an {\tt ESMF\_TimeInterval}.
  
       The arguments are:
       \begin{description}
       \item[timeinterval1]
            The augend.
       \item[timeinterval2]
            The addend.
       \end{description}
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(-)] {ESMF\_TimeIntervalOperator(-) - Subtract one TimeInterval from another}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(-)
       difference = timeinterval1 - timeinterval2\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_TimeInterval) :: difference\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       \begin{sloppypar}
       Overloads the (-) operator for the {\tt ESMF\_TimeInterval} class to
       subtract {\tt timeinterval2} from {\tt timeinterval1} and return
       the difference as an {\tt ESMF\_TimeInterval}.
       \end{sloppypar}
  
       The arguments are:
       \begin{description}
       \item[timeinterval1]
            The minuend.
       \item[timeinterval2]
            The subtrahend.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(-)] {ESMF\_TimeIntervalOperator(-) - Perform unary negation on a TimeInterval}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(-)
       timeinterval = -timeinterval\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_TimeInterval) :: -timeInterval\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Overloads the (-) operator for the {\tt ESMF\_TimeInterval} class to
       perform unary negation on {\tt timeinterval} and return the result.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            The time interval to be negated.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(/)] {ESMF\_TimeIntervalOperator(/) - Divide two TimeIntervals, return double precision quotient}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(/)
       quotient = timeinterval1 / timeinterval2\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       real(ESMF_KIND_R8) :: quotient\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       \begin{sloppypar}
       Overloads the (/) operator for the {\tt ESMF\_TimeInterval} class to
       return {\tt timeinterval1} divided by {\tt timeinterval2} as a
       double precision quotient.
       \end{sloppypar}
  
       The arguments are:
       \begin{description}
       \item[timeinterval1]
            The dividend.
       \item[timeinterval2]
            The divisor.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(/)] {ESMF\_TimeIntervalOperator(/) - Divide a TimeInterval by an integer, return TimeInterval quotient }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(/)
       quotient = timeinterval / divisor\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_TimeInterval) :: quotient\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval
       integer(ESMF_KIND_I4),   intent(in) :: divisor\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Overloads the (/) operator for the {\tt ESMF\_TimeInterval} class to
       divide a {\tt timeinterval} by an integer {\tt divisor}, and
       return the quotient as an {\tt ESMF\_TimeInterval}.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            The dividend.
       \item[divisor]
            Integer divisor.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalFunction(MOD)] {ESMF\_TimeIntervalFunction(MOD) - Divide two TimeIntervals, return TimeInterval remainder}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface MOD
       function MOD(timeinterval1, timeinterval2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_TimeInterval) :: MOD\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Overloads the Fortran intrinsic MOD() function for the
       {\tt ESMF\_TimeInterval} class to return the remainder of 
       {\tt timeinterval1} divided by {\tt timeinterval2} as an 
       {\tt ESMF\_TimeInterval}.
  
       The arguments are:
       \begin{description}
       \item[timeinterval1]
            The dividend.
       \item[timeinterval2]
            The divisor.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(*)] {ESMF\_TimeIntervalOperator(*) - Multiply a TimeInterval by an integer}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(*)
       product = timeinterval * multiplier
                     OR
       product = multiplier * timeinterval\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_TimeInterval) :: product\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval
       integer(ESMF_KIND_I4),   intent(in) :: multiplier\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Overloads the (*) operator for the {\tt ESMF\_TimeInterval} class to
       multiply a {\tt timeinterval} by an integer {\tt multiplier},
       and return the product as an {\tt ESMF\_TimeInterval}.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]        
            The multiplicand.
       \item[multiplier]
            The integer multiplier.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(==)] {ESMF\_TimeIntervalOperator(==) - Test if TimeInterval 1 is equal to TimeInterval 2}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(==)
       if (timeinterval1 == timeinterval2) then ... endif
                    OR
       result = (timeinterval1 == timeinterval2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Overloads the (==) operator for the {\tt ESMF\_TimeInterval} class to
       return {\tt .true.} if {\tt timeinterval1} and {\tt timeinterval2} 
       represent an equal duration of time, and {\tt .false.} otherwise.
  
       The arguments are:
       \begin{description}
       \item[timeinterval1]
            First {\tt ESMF\_TimeInterval} in comparison.
       \item[timeinterval2]
            Second {\tt ESMF\_TimeInterval} in comparison.
       \end{description}
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(/=)] {ESMF\_TimeIntervalOperator(/=) - Test if TimeInterval 1 is not equal to TimeInterval 2}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(/=)
       if (timeinterval1 /= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 /= timeinterval2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Overloads the (/=) operator for the {\tt ESMF\_TimeInterval} class to
       return {\tt .true.} if {\tt timeinterval1} and {\tt timeinterval2} do not 
       represent an equal duration of time, and {\tt .false.} otherwise.
  
       The arguments are:
       \begin{description}
       \item[timeinterval1]
            First {\tt ESMF\_TimeInterval} in comparison.
       \item[timeinterval2]
            Second {\tt ESMF\_TimeInterval} in comparison.
       \end{description}
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(<)] {ESMF\_TimeIntervalOperator(<) - Test if TimeInterval 1 is less than TimeInterval 2}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(<)
       if (timeinterval1 < timeinterval2) then ... endif
                    OR
       result = (timeinterval1 < timeinterval2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Overloads the (<) operator for the {\tt ESMF\_TimeInterval} class to
       return {\tt .true.} if {\tt timeinterval1} is a lesser duration of time 
       than {\tt timeinterval2}, and {\tt .false.} otherwise.
 
       The arguments are:
       \begin{description}
       \item[timeinterval1]
            First {\tt ESMF\_TimeInterval} in comparison.
       \item[timeinterval2]
            Second {\tt ESMF\_TimeInterval} in comparison.
       \end{description}
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(<=)] {ESMF\_TimeIntervalOperator(<=) - Test if TimeInterval 1 is less than or equal to TimeInterval 2}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(<=)
       if (timeinterval1 <= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 <= timeinterval2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Overloads the (<=) operator for the {\tt ESMF\_TimeInterval} class to
       return {\tt .true.} if {\tt timeinterval1} is a lesser or equal duration 
       of time than {\tt timeinterval2}, and {\tt .false.} otherwise.
  
       The arguments are:
       \begin{description}
       \item[timeinterval1]
            First {\tt ESMF\_TimeInterval} in comparison.
       \item[timeinterval2]
            Second {\tt ESMF\_TimeInterval} in comparison.
       \end{description}
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(>)] {ESMF\_TimeIntervalOperator(>) - Test if TimeInterval 1 is greater than TimeInterval 2}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(>)
       if (timeinterval1 > timeinterval2) then ... endif
                    OR
       result = (timeinterval1 > timeinterval2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Overloads the (>) operator for the {\tt ESMF\_TimeInterval} class to
       return {\tt .true.} if {\tt timeinterval1} is a greater duration of time 
       than {\tt timeinterval2}, and {\tt .false.} otherwise.
  
       The arguments are:
       \begin{description}
       \item[timeinterval1]
            First {\tt ESMF\_TimeInterval} in comparison.
       \item[timeinterval2]
            Second {\tt ESMF\_TimeInterval} in comparison.
       \end{description}
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalOperator(>=)] {ESMF\_TimeIntervalOperator(>=) - Test if TimeInterval 1 is greater than or equal to TimeInterval 2}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       interface operator(>=)
       if (timeinterval1 >= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 >= timeinterval2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Overloads the (>=) operator for the {\tt ESMF\_TimeInterval} class to
       return {\tt .true.} if {\tt timeinterval1} is a greater or equal 
       duration of time than {\tt timeinterval2}, and {\tt .false.} otherwise.
  
       The arguments are:
       \begin{description}
       \item[timeinterval1]
            First {\tt ESMF\_TimeInterval} in comparison.
       \item[timeinterval2]
            Second {\tt ESMF\_TimeInterval} in comparison.
       \end{description}
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalAbsValue] {ESMF\_TimeIntervalAbsValue - Get the absolute value of a TimeInterval}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       function ESMF_TimeIntervalAbsValue(timeinterval)
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_TimeInterval) :: ESMF_TimeIntervalAbsValue
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Returns the absolute value of {\tt timeinterval}.
  
       The argument is:
       \begin{description}
       \item[timeinterval]
            The object instance to take the absolute value of.
            Absolute value is returned as the value of the function.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalGet] {ESMF\_TimeIntervalGet - Get a TimeInterval value }


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDur(timeinterval, &
         yy, yy_i8, &
         mm, mm_i8, &
         d, d_i8, &
         h, m, &
         s, s_i8, &
         ms, us, ns, &
         d_r8, h_r8, m_r8, s_r8, &
         ms_r8, us_r8, ns_r8, &
         sN, sN_i8, sD, sD_i8, &
         startTime, calendar, calkindflag, &
         timeString, timeStringISOFrac, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in)            :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Gets the value of {\tt timeinterval} in units specified by the
       user via Fortran optional arguments.
  
       The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.
  
       Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       {\tt ESMF\_TimeIntervalGet(d = days, s = seconds)} would return
         {\tt days = 1}, {\tt seconds = 0},
       whereas {\tt ESMF\_TimeIntervalGet(s = seconds)} would return
         {\tt seconds = 86400}.
  
       For timeString, converts {\tt ESMF\_TimeInterval}'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See ~\cite{ISO} and
       ~\cite{ISOnotes}.  See also method {\tt ESMF\_TimeIntervalPrint()}.
  
       For timeStringISOFrac, converts {\tt ESMF\_TimeInterval}'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See ~\cite{ISO} and
       ~\cite{ISOnotes}.  See also method {\tt ESMF\_TimeIntervalPrint()}.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            The object instance to query.
       \item[{[yy]}]
            Integer year (32-bit).
       \item[{[yy\_i8]}]
            Integer year (large, 64-bit).
       \item[{[mm]}]
            Integer month (32-bit).
       \item[{[mm\_i8]}]
            Integer month (large, 64-bit).
       \item[{[d]}]
            Integer Julian day, or Modified Julian day (32-bit).
       \item[{[d\_i8]}]
            Integer Julian day, or Modified Julian day (large, 64-bit).
       \item[{[h]}]
            Integer hour.
       \item[{[m]}]
            Integer minute.
       \item[{[s]}]
            Integer second (32-bit).
       \item[{[s\_i8]}]
            Integer second (large, 64-bit).
       \item[{[ms]}]
            Integer millisecond.
       \item[{[us]}]
            Integer microsecond.
       \item[{[ns]}]
            Integer nanosecond.
       \item[{[d\_r8]}]
            Double precision day.
       \item[{[h\_r8]}]
            Double precision hour.
       \item[{[m\_r8]}]
            Double precision minute.
       \item[{[s\_r8]}]
            Double precision second.
       \item[{[ms\_r8]}]
            Double precision millisecond.
       \item[{[us\_r8]}]
            Double precision microsecond.
       \item[{[ns\_r8]}]
            Double precision nanosecond.
       \item[{[sN]}]
            Integer numerator of fractional second (sN/sD).
       \item[{[sN\_i8]}]
            Integer numerator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit).
       \item[{[sD]}]
            Integer denominator of fractional second (sN/sD).
       \item[{[sD\_i8]}]
            Integer denominator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit).
       \item[{[startTime]}]
            Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       \item[{[calendar]}]
            Associated {\tt Calendar}, if any.
       \item[{[calkindflag]}]
            Associated {\tt CalKind\_Flag}, if any.
       \item[{[timeString]}]
            \begin{sloppypar}
            Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See ~\cite{ISO} and
            ~\cite{ISOnotes}.  See also method {\tt ESMF\_TimeIntervalPrint()}.
            \end{sloppypar}
       \item[{[timeStringISOFrac]}]
            Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See ~\cite{ISO} and ~\cite{ISOnotes}.  See also method
            {\tt ESMF\_TimeIntervalPrint()}.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalGet] {ESMF\_TimeIntervalGet - Get a TimeInterval value }


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurStart(timeinterval, startTimeIn, &
         &
         yy, yy_i8, &
         mm, mm_i8, &
         d, d_i8, &
         h, m, &
         s, s_i8, &
         ms, us, ns, &
         d_r8, h_r8, m_r8, s_r8, &
         ms_r8, us_r8, ns_r8, &
         sN, sN_i8, sD, sD_i8, &
         startTime, &
         calendar, calkindflag, &
         timeString, timeStringISOFrac, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_Time),         intent(in)            :: startTimeIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Gets the value of {\tt timeinterval} in units specified by the
       user via Fortran optional arguments.
  
       The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.
  
       Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       {\tt ESMF\_TimeIntervalGet(d = days, s = seconds)} would return
         {\tt days = 1}, {\tt seconds = 0},
       whereas {\tt ESMF\_TimeIntervalGet(s = seconds)} would return
         {\tt seconds = 86400}.
  
       For timeString, converts {\tt ESMF\_TimeInterval}'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See ~\cite{ISO} and
       ~\cite{ISOnotes}.  See also method {\tt ESMF\_TimeIntervalPrint()}.
  
       For timeStringISOFrac, converts {\tt ESMF\_TimeInterval}'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See ~\cite{ISO} and
       ~\cite{ISOnotes}.  See also method {\tt ESMF\_TimeIntervalPrint()}.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            The object instance to query.
       \item[startTimeIn]
            INPUT argument:  pins a calendar interval to a specific point
            in time to allow conversion between relative units (yy, mm, d) and
            absolute units (d, h, m, s).  Overrides any startTime and/or endTime
            previously set.  Mutually exclusive with endTimeIn and calendarIn.
       \item[{[yy]}]
            Integer year (32-bit).
       \item[{[yy\_i8]}]
            Integer year (large, 64-bit).
       \item[{[mm]}]
            Integer month (32-bit).
       \item[{[mm\_i8]}]
            Integer month (large, 64-bit).
       \item[{[d]}]
            Integer Julian day, or Modified Julian day (32-bit).
       \item[{[d\_i8]}]
            Integer Julian day, or Modified Julian day (large, 64-bit).
       \item[{[h]}]
            Integer hour.
       \item[{[m]}]
            Integer minute.
       \item[{[s]}]
            Integer second (32-bit).
       \item[{[s\_i8]}]
            Integer second (large, 64-bit).
       \item[{[ms]}]
            Integer millisecond.
       \item[{[us]}]
            Integer microsecond.
       \item[{[ns]}]
            Integer nanosecond.
       \item[{[d\_r8]}]
            Double precision day.
       \item[{[h\_r8]}]
            Double precision hour.
       \item[{[m\_r8]}]
            Double precision minute.
       \item[{[s\_r8]}]
            Double precision second.
       \item[{[ms\_r8]}]
            Double precision millisecond.
       \item[{[us\_r8]}]
            Double precision microsecond.
       \item[{[ns\_r8]}]
            Double precision nanosecond.
       \item[{[sN]}]
            Integer numerator of fractional second (sN/sD).
       \item[{[sN\_i8]}]
            Integer numerator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit).
       \item[{[sD]}]
            Integer denominator of fractional second (sN/sD).
       \item[{[sD\_i8]}]
            Integer denominator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit).
       \item[{[startTime]}]
            Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       \item[{[calendar]}]
            Associated {\tt Calendar}, if any.
       \item[{[calkindflag]}]
            Associated {\tt CalKind\_Flag}, if any.
       \item[{[timeString]}]
            \begin{sloppypar}
            Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See ~\cite{ISO} and
            ~\cite{ISOnotes}.  See also method {\tt ESMF\_TimeIntervalPrint()}.
            \end{sloppypar}
       \item[{[timeStringISOFrac]}]
            Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See ~\cite{ISO} and ~\cite{ISOnotes}. See also method
            {\tt ESMF\_TimeIntervalPrint()}.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalGet] {ESMF\_TimeIntervalGet - Get a TimeInterval value }


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurCal(timeinterval, calendarIn, &
         &
         yy, yy_i8, &
         mm, mm_i8, &
         d, d_i8, &
         h, m, &
         s, s_i8, &
         ms, us, ns, &
         d_r8, h_r8, m_r8, s_r8, &
         ms_r8, us_r8, ns_r8, &
         sN, sN_i8, sD, sD_i8, &
         startTime, &
         calendar, calkindflag, &
         timeString, timeStringISOFrac, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_Calendar),     intent(in)            :: calendarIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Gets the value of {\tt timeinterval} in units specified by the
       user via Fortran optional arguments.
  
       The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.
  
       Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       {\tt ESMF\_TimeIntervalGet(d = days, s = seconds)} would return
         {\tt days = 1}, {\tt seconds = 0},
       whereas {\tt ESMF\_TimeIntervalGet(s = seconds)} would return
         {\tt seconds = 86400}.
  
       For timeString, converts {\tt ESMF\_TimeInterval}'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See ~\cite{ISO} and
       ~\cite{ISOnotes}.  See also method {\tt ESMF\_TimeIntervalPrint()}.
  
       For timeStringISOFrac, converts {\tt ESMF\_TimeInterval}'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See ~\cite{ISO} and
       ~\cite{ISOnotes}.  See also method {\tt ESMF\_TimeIntervalPrint()}.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            The object instance to query.
       \item[calendarIn]
            INPUT argument:  pins a calendar interval to a specific calendar
            to allow conversion between relative units (yy, mm, d) and
            absolute units (d, h, m, s).  Mutually exclusive with startTimeIn
            and endTimeIn since they contain a calendar.  Alternate to, and
            mutually exclusive with, calkindflagIn below.  Primarily for
            specifying a custom calendar kind.
       \item[{[yy]}]
            Integer year (32-bit).
       \item[{[yy\_i8]}]
            Integer year (large, 64-bit).
       \item[{[mm]}]
            Integer month (32-bit).
       \item[{[mm\_i8]}]
            Integer month (large, 64-bit).
       \item[{[d]}]
            Integer Julian day, or Modified Julian day (32-bit).
       \item[{[d\_i8]}]
            Integer Julian day, or Modified Julian day (large, 64-bit).
       \item[{[h]}]
            Integer hour.
       \item[{[m]}]
            Integer minute.
       \item[{[s]}]
            Integer second (32-bit).
       \item[{[s\_i8]}]
            Integer second (large, 64-bit).
       \item[{[ms]}]
            Integer millisecond.
       \item[{[us]}]
            Integer microsecond.
       \item[{[ns]}]
            Integer nanosecond.
       \item[{[d\_r8]}]
            Double precision day.
       \item[{[h\_r8]}]
            Double precision hour.
       \item[{[m\_r8]}]
            Double precision minute.
       \item[{[s\_r8]}]
            Double precision second.
       \item[{[ms\_r8]}]
            Double precision millisecond.
       \item[{[us\_r8]}]
            Double precision microsecond.
       \item[{[ns\_r8]}]
            Double precision nanosecond.
       \item[{[sN]}]
            Integer numerator of fractional second (sN/sD).
       \item[{[sN\_i8]}]
            Integer numerator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit). 
       \item[{[sD]}]
            Integer denominator of fractional second (sN/sD).
       \item[{[sD\_i8]}]
            Integer denominator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit). 
       \item[{[startTime]}]
            Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       \item[{[calendar]}]
            Associated {\tt Calendar}, if any.
       \item[{[calkindflag]}]
            Associated {\tt CalKind\_Flag}, if any.
       \item[[{timeString]}]
            \begin{sloppypar}
            Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See ~\cite{ISO} and
            ~\cite{ISOnotes}.  See also method {\tt ESMF\_TimeIntervalPrint()}.
            \end{sloppypar}
       \item[{[timeStringISOFrac]}]
            Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See ~\cite{ISO} and ~\cite{ISOnotes}. See also method
            {\tt ESMF\_TimeIntervalPrint()}.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalGet] {ESMF\_TimeIntervalGet - Get a TimeInterval value }


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurCalTyp(timeinterval, calkindflagIn, &
         &
         yy, yy_i8, &
         mm, mm_i8, &
         d, d_i8, &
         h, m, &
         s, s_i8, &
         ms, us, ns, &
         d_r8, h_r8, m_r8, s_r8, &
         ms_r8, us_r8, ns_r8, &
         sN, sN_i8, sD, sD_i8, &
         startTime, &
         calendar, calkindflag, &
         timeString, &
         timeStringISOFrac, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflagIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Gets the value of {\tt timeinterval} in units specified by the
       user via Fortran optional arguments.
  
       The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.
  
       Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       {\tt ESMF\_TimeIntervalGet(d = days, s = seconds)} would return
         {\tt days = 1}, {\tt seconds = 0},
       whereas {\tt ESMF\_TimeIntervalGet(s = seconds)} would return
         {\tt seconds = 86400}.
  
       For timeString, converts {\tt ESMF\_TimeInterval}'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See ~\cite{ISO} and
       ~\cite{ISOnotes}.  See also method {\tt ESMF\_TimeIntervalPrint()}.
  
       For timeStringISOFrac, converts {\tt ESMF\_TimeInterval}'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See ~\cite{ISO} and
       ~\cite{ISOnotes}.  See also method {\tt ESMF\_TimeIntervalPrint()}.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            The object instance to query.
       \item[calkindflagIn]
            INPUT argument:  Alternate to, and mutually exclusive with,
            calendarIn above.  More convenient way of specifying a built-in
            calendar kind.
       \item[{[yy]}]
            Integer year (32-bit).
       \item[{[yy\_i8]}]
            Integer year (large, 64-bit).
       \item[{[mm]}]
            Integer month (32-bit).
       \item[{[mm\_i8]}]
            Integer month (large, 64-bit).
       \item[{[d]}]
            Integer Julian day, or Modified Julian day (32-bit).
       \item[{[d\_i8]}]
            Integer Julian day, or Modified Julian day (large, 64-bit).
       \item[{[h]}]
            Integer hour.
       \item[{[m]}]
            Integer minute.
       \item[{[s]}]
            Integer second (32-bit).
       \item[{[s\_i8]}]
            Integer second (large, 64-bit).
       \item[{[ms]}]
            Integer millisecond.
       \item[{[us]}]
            Integer microsecond.
       \item[{[ns]}]
            Integer nanosecond.
       \item[{[d\_r8]}]
            Double precision day.
       \item[{[h\_r8]}]
            Double precision hour.
       \item[{[m\_r8]}]
            Double precision minute.
       \item[{[s\_r8]}]
            Double precision second.
       \item[{[ms\_r8]}]
            Double precision millisecond.
       \item[{[us\_r8]}]
            Double precision microsecond.
       \item[{[ns\_r8]}]
            Double precision nanosecond.
       \item[{[sN]}]
            Integer numerator of fractional second (sN/sD).
       \item[{[sN\_i8]}]
            Integer numerator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit).
       \item[{[sD]}]
            Integer denominator of fractional second (sN/sD).
       \item[{[sD\_i8]}]
            Integer denominator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit).
       \item[{[startTime]}]
            Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       \item[{[calendar]}]
            Associated {\tt Calendar}, if any.
       \item[{[calkindflag]}]
            Associated {\tt CalKind\_Flag}, if any.
       \item[[{timeString]}]
            \begin{sloppypar}
            Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See ~\cite{ISO} and
            ~\cite{ISOnotes}.  See also method
            {\tt ESMF\_TimeIntervalPrint()}.
            \end{sloppypar}
       \item[{[timeStringISOFrac]}]
            Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See ~\cite{ISO} and ~\cite{ISOnotes}. See also method
            {\tt ESMF\_TimeIntervalPrint()}.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalNegAbsValue] {ESMF\_TimeIntervalNegAbsValue - Return the negative absolute value of a TimeInterval}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       function ESMF_TimeIntervalNegAbsValue(timeinterval)
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_TimeInterval) :: ESMF_TimeIntervalNegAbsValue
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in) :: timeinterval
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Returns the negative absolute value of {\tt timeinterval}.
  
       The argument is:
       \begin{description}
       \item[timeinterval]
            The object instance to take the negative absolute value of.
            Negative absolute value is returned as the value of the function.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalPrint] {ESMF\_TimeIntervalPrint - Print TimeInterval information}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_TimeIntervalPrint(timeinterval, options, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       character (len=*),       intent(in),  optional :: options
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


       Prints out the contents of an {\tt ESMF\_TimeInterval} to {\tt stdout},
       in support of testing and debugging.  The options control the type of
       information and level of detail. \\
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            Time interval to be printed out.
       \item[{[options]}]
            Print options.  If none specified, prints all {\tt timeinterval}
            property values. \\
            "string" - prints {\tt timeinterval}'s value in ISO 8601 format
                       for all units through seconds.  For any non-zero
                       fractional seconds, prints in integer rational
                       fraction form n/d.  Format is PyYmMdDThHmMs[:n/d]S,
                       where [:n/d] is the integer numerator and denominator
                       of the fractional seconds value, if present.
                       See ~\cite{ISO} and ~\cite{ISOnotes}.  See also method
                       {\tt ESMF\_TimeIntervalGet(..., timeString= , ...)} \\
            "string isofrac" - prints {\tt timeinterval}'s value in strict
                       ISO 8601 format for all units, including any fractional
                       seconds part.  Format is PyYmMdDThHmMs[.f]S, where [.f]
                       represents fractional seconds in decimal form,
                       if present.  See ~\cite{ISO} and ~\cite{ISOnotes}.
                       See also method {\tt ESMF\_TimeIntervalGet(..., timeStringISOFrac= , ...)} \\
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalSet] {ESMF\_TimeIntervalSet - Initialize or set a TimeInterval}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDur(timeinterval, &
         yy, yy_i8, &
         mm, mm_i8, &
         d, d_i8, &
         h, m, &
         s, s_i8, &
         ms, us, ns, &
         d_r8, h_r8, m_r8, s_r8, &
         ms_r8, us_r8, ns_r8, &
         sN, sN_i8, sD, sD_i8, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Sets the value of the {\tt ESMF\_TimeInterval} in units specified by
       the user via Fortran optional arguments.
  
       The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.
  
       Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            The object instance to initialize.
       \item[{[yy]}]
            Integer year (32-bit).  Default = 0.
       \item[{[yy\_i8]}]
            Integer year (large, 64-bit).  Default = 0.
       \item[{[mm]}]
            Integer month (32-bit).  Default = 0.
       \item[{[mm\_i8]}]
            Integer month (large, 64-bit).  Default = 0.
       \item[{[d]}]
            Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       \item[{[d\_i8]}]
            Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       \item[{[h]}]
            Integer hour.  Default = 0.
       \item[{[m]}]
            Integer minute.  Default = 0.
       \item[{[s]}]
            Integer second (32-bit).  Default = 0.
       \item[{[s\_i8]}]
            Integer second (large, 64-bit).  Default = 0.
       \item[{[ms]}]
            Integer millisecond.  Default = 0.
       \item[{[us]}]
            Integer microsecond.  Default = 0.
       \item[{[ns]}]
            Integer nanosecond.  Default = 0.
       \item[{[d\_r8]}]
            Double precision day.  Default = 0.0.
       \item[{[h\_r8]}]
            Double precision hour.  Default = 0.0.
       \item[{[m\_r8]}]
            Double precision minute.  Default = 0.0.
       \item[{[s\_r8]}]
            Double precision second.  Default = 0.0.
       \item[{[ms\_r8]}]
            Double precision millisecond.  Default = 0.0.
       \item[{[us\_r8]}]
            Double precision microsecond.  Default = 0.0.
       \item[{[ns\_r8]}]
            Double precision nanosecond.  Default = 0.0.
       \item[{[sN]}]
            Integer numerator of fractional second (sN/sD).
            Default = 0.
       \item[{[sN\_i8]}]
            Integer numerator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit).
            Default = 0.
       \item[{[sD]}]
            Integer denominator of fractional second (sN/sD).
            Default = 1.
       \item[{[sD\_i8]}]
            Integer denominator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit).
            Default = 1.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalSet] {ESMF\_TimeIntervalSet - Initialize or set a TimeInterval}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurStart(timeinterval, startTime, &
         &
         yy, yy_i8, &
         mm, mm_i8, &
         d, d_i8, &
         h, m, &
         s, s_i8, &
         ms, us, ns, &
         d_r8, h_r8, m_r8, s_r8, &
         ms_r8, us_r8, ns_r8, &
         sN, sN_i8, sD, sD_i8, &
         rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_Time),         intent(in)            :: startTime
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Sets the value of the {\tt ESMF\_TimeInterval} in units specified by
       the user via Fortran optional arguments.
  
       The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.
  
       Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            The object instance to initialize.
       \item[startTime]
            Starting time of an absolute calendar interval 
            (yy, mm, and/or d); pins a calendar interval to a specific point 
            in time.  If not set, and calendar also not set, calendar interval 
            "floats" across all calendars and times.
       \item[{[yy]}]
            Integer year (32-bit).  Default = 0.
       \item[{[yy\_i8]}]
            Integer year (large, 64-bit).  Default = 0.
       \item[{[mm]}]
            Integer month (32-bit).  Default = 0.
       \item[{[mm\_i8]}]
            Integer month (large, 64-bit).  Default = 0.
       \item[{[d]}]
            Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       \item[{[d\_i8]}]
            Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       \item[{[h]}]
            Integer hour.  Default = 0.
       \item[{[m]}]
            Integer minute.  Default = 0.
       \item[{[s]}]
            Integer second (32-bit).  Default = 0.
       \item[{[s\_i8]}]
            Integer second (large, 64-bit).  Default = 0.
       \item[{[ms]}]
            Integer millisecond.  Default = 0.
       \item[{[us]}]
            Integer microsecond.  Default = 0.
       \item[{[ns]}]
            Integer nanosecond.  Default = 0.
       \item[{[d\_r8]}]
            Double precision day.  Default = 0.0.
       \item[{[h\_r8]}]
            Double precision hour.  Default = 0.0.
       \item[{[m\_r8]}]
            Double precision minute.  Default = 0.0.
       \item[{[s\_r8]}]
            Double precision second.  Default = 0.0.
       \item[{[ms\_r8]}]
            Double precision millisecond.  Default = 0.0.
       \item[{[us\_r8]}]
            Double precision microsecond.  Default = 0.0.
       \item[{[ns\_r8]}]
            Double precision nanosecond.  Default = 0.0.
       \item[{[sN]}]
            Integer numerator of fractional second (sN/sD).
            Default = 0.
       \item[{[sN\_i8]}]
            Integer numerator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit).
            Default = 0.
       \item[{[sD]}]
            Integer denominator of fractional second (sN/sD).
            Default = 1.
       \item[{[sD\_i8]}]
            Integer denominator of fractional second (sN\_i8/sD\_i8).
                                                             (large, 64-bit).
            Default = 1.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalSet] {ESMF\_TimeIntervalSet - Initialize or set a TimeInterval}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurCal(timeinterval, calendar, &
         &
         yy, yy_i8, &
         mm, mm_i8, &
         d, d_i8, &
         h, m, &
         s, s_i8, &
         ms, us, ns, &
         d_r8, h_r8, m_r8, s_r8, &
         ms_r8, us_r8, ns_r8, &
         sN, sN_i8, sD, sD_i8, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_Calendar),     intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Sets the value of the {\tt ESMF\_TimeInterval} in units specified by
       the user via Fortran optional arguments.
  
       The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.
  
       Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            The object instance to initialize.
       \item[calendar]
            {\tt Calendar} used to give better definition to 
            calendar interval (yy, mm, and/or d) for arithmetic, comparison, 
            and conversion operations.  Allows calendar interval to "float" 
            across all times on a specific calendar.  Default = NULL; 
            if startTime also not specified, calendar interval "floats" across 
            all calendars and times.  Mutually exclusive with startTime since 
            it contains a calendar.  Alternate to, and mutually exclusive with, 
            calkindflag below.  Primarily for specifying a custom calendar kind.
       \item[{[yy]}]
            Integer year (32-bit).  Default = 0.
       \item[{[yy\_i8]}]
            Integer year (large, 64-bit).  Default = 0.
       \item[{[mm]}]
            Integer month (32-bit).  Default = 0.
       \item[{[mm\_i8]}]
            Integer month (large, 64-bit).  Default = 0.
       \item[{[d]}]
            Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       \item[{[d\_i8]}]
            Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       \item[{[h]}]
            Integer hour.  Default = 0.
       \item[{[m]}]
            Integer minute.  Default = 0.
       \item[{[s]}]
            Integer second (32-bit).  Default = 0.
       \item[{[s\_i8]}]
            Integer second (large, 64-bit).  Default = 0.
       \item[{[ms]}]
            Integer millisecond.  Default = 0.
       \item[{[us]}]
            Integer microsecond.  Default = 0.
       \item[{[ns]}]
            Integer nanosecond.  Default = 0.
       \item[{[d\_r8]}]
            Double precision day.  Default = 0.0.
       \item[{[h\_r8]}]
            Double precision hour.  Default = 0.0.
       \item[{[m\_r8]}]
            Double precision minute.  Default = 0.0.
       \item[{[s\_r8]}]
            Double precision second.  Default = 0.0.
       \item[{[ms\_r8]}]
            Double precision millisecond.  Default = 0.0.
       \item[{[us\_r8]}]
            Double precision microsecond.  Default = 0.0.
       \item[{[ns\_r8]}]
            Double precision nanosecond.  Default = 0.0.
       \item[{[sN]}]
            Integer numerator of fractional second (sN/sD).
            Default = 0.
       \item[{[sN\_i8]}]
            Integer numerator of fractional second (sN\_i8/sD\_i8).
                                                             (large, 64-bit).
            Default = 0.
       \item[{[sD]}]
            Integer denominator of fractional second (sN/sD).
            Default = 1.
       \item[{[sD\_i8]}]
            Integer denominator of fractional second (sN\_i8/sD\_i8).
                                                             (large, 64-bit).
            Default = 1.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalSet] {ESMF\_TimeIntervalSet - Initialize or set a TimeInterval}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurCalTyp(timeinterval, calkindflag, &
         &
         yy, yy_i8, &
         mm, mm_i8, &
         d, d_i8, &
         h, m, &
         s, s_i8, &
         ms, us, ns, &
         d_r8, h_r8, m_r8, s_r8, &
         ms_r8, us_r8, ns_r8, &
         sN, sN_i8, sD, sD_i8, &
         rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Sets the value of the {\tt ESMF\_TimeInterval} in units specified by
       the user via Fortran optional arguments.
  
       The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.
  
       Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            The object instance to initialize.
       \item[calkindflag]
            Alternate to, and mutually exclusive with, 
            calendar above.  More convenient way of specifying a built-in 
            calendar kind.
       \item[{[yy]}]
            Integer year (32-bit).  Default = 0.
       \item[{[yy\_i8]}]
            Integer year (large, 64-bit).  Default = 0.
       \item[{[mm]}]
            Integer month (32-bit).  Default = 0.
       \item[{[mm\_i8]}]
            Integer month (large, 64-bit).  Default = 0.
       \item[{[d]}]
            Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       \item[{[d\_i8]}]
            Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       \item[{[h]}]
            Integer hour.  Default = 0.
       \item[{[m]}]
            Integer minute.  Default = 0.
       \item[{[s]}]
            Integer second (32-bit).  Default = 0.
       \item[{[s\_i8]}]
            Integer second (large, 64-bit).  Default = 0.
       \item[{[ms]}]
            Integer millisecond.  Default = 0.
       \item[{[us]}]
            Integer microsecond.  Default = 0.
       \item[{[ns]}]
            Integer nanosecond.  Default = 0.
       \item[{[d\_r8]}]
            Double precision day.  Default = 0.0.
       \item[{[h\_r8]}]
            Double precision hour.  Default = 0.0.
       \item[{[m\_r8]}]
            Double precision minute.  Default = 0.0.
       \item[{[s\_r8]}]
            Double precision second.  Default = 0.0.
       \item[{[ms\_r8]}]
            Double precision millisecond.  Default = 0.0.
       \item[{[us\_r8]}]
            Double precision microsecond.  Default = 0.0.
       \item[{[ns\_r8]}]
            Double precision nanoseconds.  Default = 0.0.
       \item[{[sN]}]
            Integer numerator of fractional second (sN/sD).
            Default = 0.
       \item[{[sN\_i8]}]
            Integer numerator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit).
            Default = 0.
       \item[{[sD]}]
            Integer denominator of fractional second (sN/sD).
            Default = 1.
       \item[{[sD\_i8]}]
            Integer denominator of fractional second (sN\_i8/sD\_i8)
                                                             (large, 64-bit).
            Default = 1.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_TimeIntervalValidate] {ESMF\_TimeIntervalValidate - Validate a TimeInterval}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_TimeIntervalValidate(timeinterval, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_TimeInterval), intent(in)            :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                 intent(out), optional :: rc
 \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Checks whether a {\tt timeinterval} is valid.
       If fractional value, denominator must be non-zero.
  
       The arguments are:
       \begin{description}
       \item[timeinterval]
            {\tt ESMF\_TimeInterval} to be validated.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
