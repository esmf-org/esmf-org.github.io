%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_Alarm.C,  Date: Tue May  5 20:59:33 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMCI\_alarmCreate] {ESMCI\_alarmCreate - allocates and initializes an Alarm object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Alarm *ESMCI_alarmCreate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      pointer to newly allocated Alarm\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int                nameLen,           // in
       const char        *name,              // in
       Clock        *clock,             // in
       Time         *ringTime,          // in
       TimeInterval *ringInterval,      // in
       Time         *stopTime,          // in
       TimeInterval *ringDuration,      // in
       int               *ringTimeStepCount, // in
       Time         *refTime,           // in
       bool              *enabled,           // in
       bool              *sticky,            // in
       int               *rc ) {             // out - return code\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which allocates and initializes {\tt ESMC\_Alarm} values.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_alarmCreate-] {ESMCI\_alarmCreate- Creates a copy of an alarm}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Alarm *ESMCI_alarmCreate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       pointer to newly allocated Alarm\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Alarm *alarm,  // in  - alarm to copy
       int        *rc) {   // out - return code 
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Creates a new copy of the given alarm.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_alarmDestroy] {ESMCI\_alarmDestroy - free an Alarm created with Create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMCI_alarmDestroy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Alarm **alarm) {  // in - Alarm to destroy\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which destroys a Alarm object previously allocated
        via an {\tt ESMCI_alarmCreate} routine.  Define for deep classes only.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::set] {Alarm::set - Sets an Alarm's properties}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::set(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int                nameLen,           // in
       const char        *name,              // in
       Clock       **clock,             // in
       Time         *ringTime,          // in
       TimeInterval *ringInterval,      // in
       Time         *stopTime,          // in
       TimeInterval *ringDuration,      // in
       int               *ringTimeStepCount, // in
       Time         *refTime,           // in
       bool              *ringing,           // in
       bool              *enabled,           // in
       bool              *sticky) {          // in\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which only initializes {\tt ESMC\_Alarm} values;
        it does not allocate any resources.  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::get] {Alarm::get - Gets an alarm's properties}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::get(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int                nameLen,                // in
       int               *tempNameLen,            // out
       char              *tempName,               // out
       Clock       **clock,                  // out
       Time         *ringTime,               // out
       Time         *prevRingTime,           // out
       TimeInterval *ringInterval,           // out
       Time         *stopTime,               // out
       TimeInterval *ringDuration,           // out
       int               *ringTimeStepCount,      // out
       int               *timeStepRingingCount,   // out
       Time         *ringBegin,              // out
       Time         *ringEnd,                // out
       Time         *refTime,                // out
       bool              *ringing,                // out
       bool              *ringingOnPrevTimeStep,  // out
       bool              *enabled,                // out
       bool              *sticky) {               // out\end{verbatim}
{\sf DESCRIPTION:\\ }


        Gets {\tt ESMC\_Alarm} property values;
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::enable] {Alarm::enable - enables an Alarm object to function}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::enable(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which enables an {\tt ESMC\_Alarm} object to function
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::disable] {Alarm::disable - disables an Alarm object from functioning}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::disable(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which disables an {\tt ESMC\_Alarm} object from functioning
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::isEnabled] {Alarm::isEnabled - check if Alarm is enabled}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Alarm::isEnabled(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool is enabled or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int  *rc) const {        // out - error return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      checks if {\tt ESMC\_Alarm}'s enabled state is set.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::ringerOn] {Alarm::ringerOn - sets an Alarm to the ringing state}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::ringerOn(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which sets an {\tt ESMC\_Alarm} object to the
        ringing state.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::ringerOff] {Alarm::ringerOff - turns off an Alarm's ringing state}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::ringerOff(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which turns off an {\tt ESMC\_Alarm}'s ringing state.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::isRinging] {Alarm::isRinging - check if Alarm is ringing}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Alarm::isRinging(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool is ringing or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int  *rc) const {        // out - error return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Checks if {\tt ESMC\_Alarm}'s ringing state is set.
  
      See also method ESMC\_ClockGetAlarmList(areRinging, ...) to get
      a list of all ringing alarms belonging to a {\tt ESMC\_Clock}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::willRingNext] {Alarm::willRingNext - check if Alarm will ring upon the next clock timestep}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Alarm::willRingNext(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool will ring or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       TimeInterval *timeStep,   // in - optional timestep to use instead
                                      //      of the clock's
       int  *rc) const {              // out - error return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Checks if {\tt ESMC\_Alarm}'s ringing state will be set on the next
      clock timestep, using either the clock's current timestep,
      or a passed-in one.
  
      See also method ESMC\_ClockGetAlarmList(willRingNext, ...) to get
      a list of all alarms belonging to a {\tt ESMC\_Clock} that will ring on
      the next time step.
 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::wasPrevRinging] {Alarm::wasPrevRinging - check if Alarm was ringing on the previous clock timestep}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Alarm::wasPrevRinging(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool was previously ringing or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int  *rc) const {        // out - error return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Checks if {\tt ESMC\_Alarm}'s ringing state was set on the previous
      clock timestep.
  
      See also method ESMC\_ClockGetAlarmList(werePrevRinging, ...) to
      get a list of all alarms belonging to a {\tt ESMC\_Clock} that were
      ringing on the previous time step.
 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::setToSticky] {Alarm::setToSticky - sets an Alarm's sticky state }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::setToSticky(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which sets an {\tt ESMC\_Alarm}'s sticky flag.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::notSticky] {Alarm::notSticky - unsets an Alarm's sticky state }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::notSticky(TimeInterval *ringDuration,
                                           int *ringTimeStepCount) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which unsets an {\tt ESMC\_Alarm}'s sticky flag,
        and optionally sets a ring duration either in terms of an
        {\tt ESMC\_TimeInterval} or a integer number of clock timesteps.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::isSticky] {Alarm::isSticky - check if Alarm is sticky}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Alarm::isSticky(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool is sticky or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int  *rc) const {        // out - error return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      checks if {\tt ESMC\_Alarm}'s sticky state is set.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::checkRingTime] {Alarm::checkRingTime - check if time to ring}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Alarm::checkRingTime(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool is ringing or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int *rc) {         // out - error return code
 \end{verbatim}
{\sf DESCRIPTION:\\ }


      Checks if its time to ring based on current clock time crossing the ring
      time in either the positive or negative direction. If already ringing,
      checks if its time to turn off.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm(==)] {Alarm(==) - Alarm equality comparison }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Alarm::operator==(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Alarm &alarm) const {   // in - Alarm to compare\end{verbatim}
{\sf DESCRIPTION:\\ }


        Compare for equality the current object's (this) {\tt ESMC\_Alarm} with
        given {\tt ESMC\_Alarm}, return result.  Comparison is based on IDs.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm(!=)] {Alarm(!=) - Alarm inequality comparison }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Alarm::operator!=(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Alarm &alarm) const {   // in - Alarm to compare\end{verbatim}
{\sf DESCRIPTION:\\ }


        Compare for inequality the current object's (this)
        {\tt ESMC\_Alarm} with given {\tt ESMC\_Alarm}, return result.
        Comparison is based on IDs.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_alarmReadRestart] {ESMCI\_alarmReadRestart - restore contents of an Alarm}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Alarm *ESMCI_alarmReadRestart(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      pointer to newly allocated and restored Alarm\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int          nameLen,  // in
       const char  *name,     // in
       int         *rc ) {    // out - return code
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Restore information about an {\tt ESMC\_Alarm}.
        For persistence/checkpointing.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::writeRestart] {Alarm::writeRestart - save contents of an Alarm}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::writeRestart(void) const {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        Save information about an {\tt ESMC\_Alarm}.
        For persistence/checkpointing
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::validate] {Alarm::validate - internal consistency check for an Alarm}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::validate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *options) const {    // in - validate options\end{verbatim}
{\sf DESCRIPTION:\\ }


        Validates that a {\tt ESMC\_Alarm} is internally consistent.
        Returns error code if problems are found.  {\tt ESMC\_Base}
        class method.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm::print] {Alarm::print - print contents of an Alarm}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::print(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *options) const {    // in - print options\end{verbatim}
{\sf DESCRIPTION:\\ }


        Print information about an {\tt ESMC\_Alarm}.  For testing/debugging.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm] {Alarm - native C++ constructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Alarm::Alarm(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        Initializes a {\tt ESMC\_Alarm} with defaults for either
        C++ or F90, since {\tt ESMC\_Alarm} is a deep, dynamically
        allocated class.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Alarm] {Alarm - native C++ copy constructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Alarm::Alarm(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Alarm &alarm) {  // in - alarm to copy\end{verbatim}
{\sf DESCRIPTION:\\ }


        Copies members of given alarm.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [~Alarm] {~Alarm - native C++ destructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Alarm::~Alarm(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        Calls standard ESMF deep or shallow methods for destruction.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Alarm::checkTurnOn] {Alarm::checkTurnOn - check if time to turn on alarm}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Alarm::checkTurnOn(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool whether to turn on alarm\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       bool timeStepPositive) {  // in - sign of clock's timeStep,
                                //        true: positive, false: negative\end{verbatim}
{\sf DESCRIPTION:\\ }


      Checks whether alarm should be ringing
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Alarm::resetRingBegin] {Alarm::resetRingBegin - reset ringBegin during ESMF\_DIRECTION\_REVERSE}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Alarm::resetRingBegin(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       bool timeStepPositive) {  // in - sign of clock's timeStep,
                                //        true: positive, false: negative\end{verbatim}
{\sf DESCRIPTION:\\ }


        Reconstructs ringBegin for an alarm event during
        {\tt ESMF\_DIRECTION\_REVERSE}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
