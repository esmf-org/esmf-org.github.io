%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_Calendar.C,  Date: Tue May  5 20:59:33 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMCI\_CalendarInitialize] {ESMCI\_CalendarInitialize - initialize the default Calendar kind}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMCI_CalendarInitialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       ESMC_CalKind_Flag *calkindflag) {  // in - ESMC_CalKind_Flag to be the
                                          //      default\end{verbatim}
{\sf DESCRIPTION:\\ }


        Friend function which initializes the Time Manager default calendar.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI\_CalendarFinalize] {ESMCI\_CalendarFinalize - free all internal Calendars}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMCI_CalendarFinalize(void) { \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        Friend function which de-allocates all internal built-in Calendars.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_CalendarCreate] {ESMCI\_CalendarCreate - Allocates and Initializes a Calendar object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Calendar *ESMCI_CalendarCreate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       pointer to newly allocated Calendar\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int                nameLen,      // in
       const char        *name,         // in
       ESMC_CalKind_Flag  calkindflag,  // in
       int               *rc) {         // out - return code
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Allocates and Initializes a {\tt ESMC\_Calendar} with given type
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_CalendarCreate] {ESMCI\_CalendarCreate - Allocates and Initializes an internal Calendar object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMCI_CalendarCreate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       ESMC_CalKind_Flag calkindflag) { // in
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Allocates and Initializes an internal {\tt ESMC\_Calendar} of given type
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_CalendarCreate] {ESMCI\_CalendarCreate - Allocates and Initializes a Custom Calendar object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Calendar *ESMCI_CalendarCreate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       pointer to newly allocated Calendar\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int           nameLen,       // in
       const char   *name,          // in
       int          *daysPerMonth,  // in
       int           monthsPerYear, // in  
       ESMC_I4 *secondsPerDay, // in
       ESMC_I4 *daysPerYear,   // in
       ESMC_I4 *daysPerYearDn, // in
       ESMC_I4 *daysPerYearDd, // in
       int          *rc) {          // out - return code
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Allocates and Initializes a custom {\tt ESMC\_Calendar}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_CalendarCreate] {ESMCI\_CalendarCreate - Creates a copy of a calendar}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Calendar *ESMCI_CalendarCreate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       pointer to newly allocated Calendar\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Calendar *calendar,  // in  - calendar to copy
       int           *rc) {      // out - return code 
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Creates a new copy of the given calendar.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_CalendarDestroy] {ESMCI\_CalendarDestroy - free a Calendar created with Create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMCI_CalendarDestroy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Calendar **calendar) {  // in - Calendar to destroy\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which destroys a Calendar object previously allocated
        via an {\tt ESMC\_CalendarCreate} routine. Define for deep classes only.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_CalendarSetDefault] {ESMCI\_CalendarSetDefault - set the default Calendar}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMCI_CalendarSetDefault(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Calendar **calendar) {  // in - Calendar to be the default\end{verbatim}
{\sf DESCRIPTION:\\ }


        Friend function which sets the Time Manager default calendar.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_CalendarSetDefault] {ESMCI\_CalendarSetDefault - set the default Calendar kind}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMCI_CalendarSetDefault(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       ESMC_CalKind_Flag *calkindflag) {  // in - ESMC_CalKind_Flag to be the
                                           //      default\end{verbatim}
{\sf DESCRIPTION:\\ }


        Friend function which sets the Time Manager default calendar.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar::set] {Calendar::set - Set a calendar's type}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Calendar::set(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int               nameLen,         // in
       const char       *name,            // in
       ESMC_CalKind_Flag calkindflag) {   // in - set to be Calendar kind\end{verbatim}
{\sf DESCRIPTION:\\ }


        Sets a {\tt EMSC\_Calendar} to be of a specific type
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar::set] {Calendar::set - Set up a custom calendar}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Calendar::set(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int           nameLen,          // in
       const char   *name,             // in
       int          *daysPerMonth,     // in
       int           monthsPerYear,    // in
       ESMC_I4 *secondsPerDay,    // in
       ESMC_I4 *daysPerYear,      // in
       ESMC_I4 *daysPerYeardN,    // in
       ESMC_I4 *daysPerYeardD) {  // in
   \end{verbatim}
{\sf DESCRIPTION:\\ }


        Initialzes a {\tt EMSC\_Calendar} to be a custom, user-defined type
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar::get] {Calendar::get - get calendar properties}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Calendar::get(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int                nameLen,         // in
       int               *tempNameLen,     // out
       char              *tempName,        // out
       ESMC_CalKind_Flag *calkindflag,     // out
       int               *daysPerMonth,    // out
       int                sizeofDaysPerMonth, // in
       int               *monthsPerYear,   // out
       ESMC_I4      *secondsPerDay,   // out
       ESMC_I4      *secondsPerYear,  // out
       ESMC_I4      *daysPerYear,     // out
       ESMC_I4      *daysPerYeardN,   // out
       ESMC_I4      *daysPerYeardD) { // out
   \end{verbatim}
{\sf DESCRIPTION:\\ }


        Gets a {\tt EMSC\_Calendar}'s properties
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar:convertToTime] {Calendar:convertToTime - convert calendar date to ESMC\_BaseTime}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Calendar::convertToTime(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       ESMC_I8 yy, int mm, int dd, ESMC_I8 d, ESMC_R8 d_r8,    // in
       BaseTime *t) const {                                    // out\end{verbatim}
{\sf DESCRIPTION:\\ }


       Converts a calendar-specific date to core {\tt ESMC\_BaseTime}
       representation. Conversions based on UTC: time zone offset done by
       client
  
       The Gregorian <-> Julian day conversion algorithm is from
       Henry F. Fliegel and Thomas C. Van Flandern, in Communications of
       the ACM, CACM, volume 11, number 10, October 1968, p. 657.
       Julian day refers to the number of days since a reference day.
       For the algorithm used, this reference day is November 24, -4713
       in the Proleptic Gregorian calendar, which is equivalent to
       January 1, -4712 in the Proleptic Julian calendar.
   
       When converting from a Julian day to a Gregorian date (implemented
       in {\tt ESMC\_CalendarConvertToDate()}), this algorithm is valid from
       3/1/-4900 Gregorian forward.  When converting from a Gregorian date to
       a Julian day (implemented in this method), the algorithm is valid from
       3/1/-4800 forward.  In both cases, the algorithm correctly takes into
       account leap years, those that are divisible by 4 and not 100, or those
       divisible by 400.
  
       The Fliegel algorithm implements the Gregorian calendar as continuously
       proleptic from October 15, 1582 backward to March 1, -4800/-4900.
       Hence the algorithm does not take into account the Gregorian Reformation
       (when the Gregorian calendar officially began) where 10 days were
       eliminated from the calendar in October 1582.  Thursday, October 4, 1582
       was officially the last day of the Julian calendar; the following day,
       Friday, was decreed to be October 15, 1582, the first day of the
       Gregorian calendar.
  
       The Julian <-> Julian day conversion algorithm is from D.A. Hatcher,
       Q.JlR. astr. Soc. (1984) 25, 53-55.  It is valid from 3/1/-4712 forward.
  
       See also:  http://www.hermetic.ch/cal\_stud/jdn.htm
                  http://www.numerical-recipes.com/julian.html
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar::convertToDate] {Calendar::convertToDate - convert ESMC\_BaseTime to calendar date}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Calendar::convertToDate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       BaseTime *t,                                                // in/out
       ESMC_I4 *yy, ESMC_I8 *yy_i8, int *mm, int *dd,         // out
       ESMC_I4 *d, ESMC_I8 *d_i8, ESMC_R8 *d_r8) const { // out\end{verbatim}
{\sf DESCRIPTION:\\ }


       Converts a core {\tt ESMC\_BaseTime} representation to a
       calendar-specific date. Conversions based on UTC: time zone offset
       done by client
  
       The Gregorian <-> Julian day conversion algorithm is from
       Henry F. Fliegel and Thomas C. Van Flandern, in Communications of
       the ACM, CACM, volume 11, number 10, October 1968, p. 657.
       Julian day refers to the number of days since a reference day.
       For the algorithm used, this reference day is November 24, -4713
       in the Proleptic Gregorian calendar, which is equivalent to
       January 1, -4712 in the Proleptic Julian calendar.
   
       When converting from a Julian day to a Gregorian date (implemented
       in this method), this algorithm is valid from 3/1/-4900 Gregorian
       forward.  When converting from a Gregorian date to a Julian day
       (implemented in method {\tt ESMC\_CalendarConvertToTime()}), the
       algorithm is valid from 3/1/-4800 forward.  In both cases, the
       algorithm correctly takes into account leap years, those that are
       divisible by 4 and not 100, or those divisible by 400.
  
       The Fliegel algorithm implements the Gregorian calendar as continuously
       proleptic from October 15, 1582 backward to March 1, -4800/-4900.
       Hence the algorithm does not take into account the Gregorian Reformation
       (when the Gregorian calendar officially began) where 10 days were
       eliminated from the calendar in October 1582.  Thursday, October 4, 1582
       was officially the last day of the Julian calendar; the following day,
       Friday, was decreed to be October 15, 1582, the first day of the
       Gregorian calendar.
  
       The Julian <-> Julian day conversion algorithm is from D.A. Hatcher,
       Q.JlR. astr. Soc. (1984) 25, 53-55.  It is valid from 3/1/-4712 forward.
  
       See also:  http://www.hermetic.ch/cal\_stud/jdn.htm\#comp
                  http://www.numerical-recipes.com/julian.html
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar::increment] {Calendar::increment - increment a Time by a TimeInterval}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Time Calendar::increment(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Time sum\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Time *time,                            // in
       const TimeInterval &timeinterval) const {    // in
 \end{verbatim}
{\sf DESCRIPTION:\\ }


       Increments a given {\tt ESMC\_Time} by the given
       {\tt ESMC\_TimeInterval}, taking into account calendar intervals of
       years, months, and or days as defined on the given time's calendar.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar::decrement] {Calendar::decrement - decrement a Time by a TimeInterval}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Time Calendar::decrement(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Time diff\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Time *time,                            // in
       const TimeInterval &timeinterval) const {    // in
 \end{verbatim}
{\sf DESCRIPTION:\\ }


       Decrements a given {\tt ESMC\_Time} by the given
       {\tt ESMC\_TimeInterval}, taking into account calendar intervals of
       years, months, and or days as defined on the given time's calendar.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar::isLeapYear] {Calendar::isLeapYear - Determine if given year is a leap year}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Calendar::isLeapYear(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool is leap year or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       ESMC_I8 yy_i8,      // in  - year
       int  *rc) const {        // out - error return code\end{verbatim}
{\sf DESCRIPTION:\\ }


       Determines whether given year is a leap year within *this* calendar.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar(==)] {Calendar(==) - Calendar equality comparison}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Calendar::operator==(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Calendar &calendar) const {   // in - Calendar to compare\end{verbatim}
{\sf DESCRIPTION:\\ }


        Compare for equality the current object's (this) {\tt ESMC\_Calendar}
        with given {\tt ESMC\_Calendar}, return result.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar(==)] {Calendar(==) - Calendar equality comparison}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Calendar::operator==(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const ESMC_CalKind_Flag &calkindflag) const {   // in - ESMC_CalKind_Flag to compare\end{verbatim}
{\sf DESCRIPTION:\\ }


        Compare for equality the current object's (this) {\tt ESMC\_Calendar}
        type with given {\tt ESMC\_CalKind\_Flag}, return result.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar(!=)] {Calendar(!=) - Calendar inequality comparison}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Calendar::operator!=(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Calendar &calendar) const {   // in - Calendar to compare\end{verbatim}
{\sf DESCRIPTION:\\ }


        Compare for inequality the current object's (this) {\tt ESMC\_Calendar}
        with given {\tt ESMC\_Calendar}, return result.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar(!=)] {Calendar(!=) - Calendar inequality comparison}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Calendar::operator!=(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const ESMC_CalKind_Flag &calkindflag) const {   // in - ESMC_CalKind_Flag to compare\end{verbatim}
{\sf DESCRIPTION:\\ }


        Compare for inequality the current object's (this) {\tt ESMC\_Calendar}
        type with given {\tt ESMC\_CalKind\_Flag}, return result.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_CalendarReadRestart] {ESMCI\_CalendarReadRestart - restore contents of a Calendar }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Calendar *ESMCI_CalendarReadRestart(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      pointer to newly allocated and restored Calendar\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int          nameLen,  // in
       const char  *name,     // in
       int         *rc ) {    // out - return code
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Restore information about a {\tt Calendar}. 
        For persistence/checkpointing.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar::writeRestart] {Calendar::writeRestart - save Calendar state}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Calendar::writeRestart(void) const {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        Save {\tt Calendar} state for persistence/checkpointing
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar::validate] {Calendar::validate - validate Calendar state}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Calendar::validate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *options) const {   // in - validate options
      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        validate {\tt EMSC\_Calendar} state
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar::print] {Calendar::print - print Calendar state}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Calendar::print(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *options,            // in - print options
       const Time *time) const {  // in - optional time context in which
                                       //      to print
                                       //      (e.g. Leap Year => Feb. 29 days)\end{verbatim}
{\sf DESCRIPTION:\\ }


        print {\tt EMSC\_Calendar} state for testing/debugging
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar] {Calendar - native default C++ constructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Calendar::Calendar(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        Initializes a {\tt ESMC\_Calendar} with defaults for either
        C++ or F90, since {\tt ESMC\_Calendar} is a deep, dynamically
        allocated class.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar] {Calendar - native C++ constructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Calendar::Calendar(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char       *name,            // in
       ESMC_CalKind_Flag calkindflag) {  // in\end{verbatim}
{\sf DESCRIPTION:\\ }


        Initializes a {\tt ESMC\_TimeInstant} to be of a specific type via
        {\tt ESMC\_CalendarSet}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar] {Calendar - native C++ constructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Calendar::Calendar(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char   *name,              // in
       int          *daysPerMonth,      // in
       int           monthsPerYear,     // in
       ESMC_I4 *secondsPerDay,     // in
       ESMC_I4 *daysPerYear,       // in
       ESMC_I4 *daysPerYeardN,     // in
       ESMC_I4 *daysPerYeardD) {   // in\end{verbatim}
{\sf DESCRIPTION:\\ }


        Initializes a {\tt ESMC\_Time} to be of a custom user-defined type
        via {\tt ESMC\_CalendarSet}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Calendar] {Calendar - native C++ copy constructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Calendar::Calendar(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Calendar &calendar) {  // in - calendar to copy\end{verbatim}
{\sf DESCRIPTION:\\ }


        Copies members of given calendar.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [~Calendar] {~Calendar - native default C++ destructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Calendar::~Calendar(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        Default {\tt ESMC\_Calendar} destructor
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
