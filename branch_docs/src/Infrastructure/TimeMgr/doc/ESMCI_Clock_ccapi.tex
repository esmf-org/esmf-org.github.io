%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_Clock.C,  Date: Tue May  5 20:59:33 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMCI\_ClockCreate] {ESMCI\_ClockCreate - Allocates and Initializes a Clock object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Clock *ESMCI_ClockCreate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       pointer to newly allocated Clock\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int                nameLen,          // in
       const char        *name,             // in
       TimeInterval *timeStep,         // in
       Time         *startTime,        // in
       Time         *stopTime,         // in
       TimeInterval *runDuration,      // in
       int               *runTimeStepCount, // in
       Time         *refTime,          // in
       int               *rc) {             // out - return code
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Allocates and Initializes a {\tt ESMC\_Clock} with given values
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_ClockCreate] {ESMCI\_ClockCreate - Creates a copy of a clock}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Clock *ESMCI_ClockCreate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       pointer to newly allocated Clock\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Clock *clock,  // in  - clock to copy
       int        *rc) {   // out - return code
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Creates a new copy of the given clock.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_ClockDestroy] {ESMCI\_ClockDestroy - free a Clock created with Create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMCI_ClockDestroy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Clock **clock) {  // in - Clock to destroy\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which destroys a Clock object previously allocated
        via an {\tt ESMCI\_ClockCreate} routine.  Define for deep classes only.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::set] {Clock::set - Sets a Clock object's properties}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::set(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int                nameLen,          // in
       const char        *name,             // in
       TimeInterval *timeStep,         // in
       Time         *startTime,        // in
       Time         *stopTime,         // in
       TimeInterval *runDuration,      // in
       int               *runTimeStepCount, // in
       Time         *refTime,          // in
       Time         *currTime,         // in
       ESMC_I8      *advanceCount,     // in
       ESMC_Direction    *direction) {      // in
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Sets a {\tt ESMC\_Clock}'s properties
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::get] {Clock::get - gets a Clock object's properties}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::get(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int             nameLen,          // in
       int            *tempNameLen,      // out
       char           *tempName,         // out
       TimeInterval   *timeStep,         // out
       Time           *startTime,        // out
       Time           *stopTime,         // out
       TimeInterval   *runDuration,      // out
       ESMC_R8        *runTimeStepCount, // out
       Time           *refTime,          // out
       Time           *currTime,         // out
       Time           *prevTime,         // out
       TimeInterval   *currSimTime,      // out
       TimeInterval   *prevSimTime,      // out
       Calendar      **calendar,         // out
       ESMC_CalKind_Flag *calkindflag,   // out
       int            *timeZone,         // out
       ESMC_I8        *advanceCount,     // out
       int            *alarmCount,       // out
       ESMC_Direction *direction) {      // out
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Gets a {\tt ESMC\_Clock}'s property values
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::advance] {Clock::advance - increment a clock's time}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::advance(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       TimeInterval *timeStep,               // in  - optional new timestep
       char              *ringingAlarmList1stElementPtr, // out - optional array
                                                  //        of ringing alarms
       char              *ringingAlarmList2ndElementPtr, // in - address of 2nd
                                                  //        element to calculate
                                                  //        F90 array element
                                                  //        size
       int                sizeofRingingAlarmList, // in  - size of given array
                                                  //       of ringing alarms
       int               *ringingAlarmCount) {    // out - number of ringing
                                                  //       alarms\end{verbatim}
{\sf DESCRIPTION:\\ }


       Advances a clock's current time by timestep, then checks
       each of its alarms to see if its time to ring.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::isStopTime] {Clock::isStopTime - check if Clock's stop time has been reached}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Clock::isStopTime(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool is stop time or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int  *rc) const {        // out - error return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      checks if {\tt Clock}'s stop time has been reached.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::stopTimeEnable] {Clock::stopTimeEnable - enables a Clock's stopTime to function}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::stopTimeEnable(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Time *stopTime) {              // in  - optional new stop time\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which enables a {\tt ESMC\_Clock}'s stopTime to function.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::stopTimeDisable] {Clock::stopTimeDisable - disables a Clock's stopTime from functioning}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::stopTimeDisable(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which disables a {\tt ESMC\_Clock}'s stopTime from
        functioning.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::isStopTimeEnabled] {Clock::isStopTimeEnabled - check if Clock's stop time is enabled}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Clock::isStopTimeEnabled(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool is stop time enabled or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int  *rc) const {        // out - error return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      checks if {\tt ESMCI\_Clock}'s stop time is enabled.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::isDone] {Clock::isDone - check if Clock's stop time or start time has been reached, depending on direction}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Clock::isDone(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool is done or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int  *rc) const {        // out - error return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Checks if {\tt ESMC\_Clock}'s stop time has been reached if in
      {\tt ESMF\_DIRECTION\_FORWARD} or if it has reached start time if in
      {\tt ESMF\_DIRECTION\_REVERSE}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::isReverse] {Clock::isReverse - test if clock is in reverse mode}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Clock::isReverse(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool is reverse mode or not\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int  *rc) const {        // out - error return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Checks if {\tt ESMC\_Clock}'s direction is {\tt ESMF\_DIRECTION\_REVERSE}.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::getNextTime] {Clock::getNextTime - calculates a Clock's next time }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::getNextTime(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Time         *nextTime,       // out
       TimeInterval *timeStep) {     // in
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Calculates what the next time of the {\tt ESMF\_Clock} will be, based
        on the clock's current timestep or an optionally passed-in timestep.
 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::getAlarm] {Clock::getAlarm - get alarm from clock's alarm list}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::getAlarm(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int          alarmnameLen,   // in  - the length of the alarm name
       char        *alarmname,      // in  - the alarm "name" to get
       Alarm **alarm) {   // out - the alarm named "name"\end{verbatim}
{\sf DESCRIPTION:\\ }


       Retrieves the clock's alarm named "alarmname" from the alarm list
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::getAlarmList] {Clock::getAlarmList - Get a list of alarms from a clock}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::getAlarmList(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       ESMC_AlarmList_Flag alarmlistflag,         // in - list flag to get
       char              *alarmList1stElementPtr, // out - array of alarms
       char              *alarmList2ndElementPtr, // in  - address of 2nd
                                                  //        element to calculate
                                                  //        F90 array element
                                                  //        size
       int                sizeofAlarmList,        // in  - size of given array
                                                  //       of alarms
       int               *alarmCount,             // out - number of alarms
       TimeInterval *timeStep) {                  // in  - optional time step to
                                                  //         use instead of the
                                                  //         clock's (only use
                                                  //         with alarm list flag
                                                  // ESMF_ALARMLIST_NEXTRINGING)\end{verbatim}
{\sf DESCRIPTION:\\ }


      Gets an {\tt ESMF\_Clock}'s list of alarms.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::getAlarmList] {Clock::getAlarmList - get a clock's alarm list}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::getAlarmList(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Alarm ***alarmList,            // out - alarm list
       int          *alarmCount) const {   // out - number of alarms in list\end{verbatim}
{\sf DESCRIPTION:\\ }


       Get a clock's alarm list and number of alarms
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::getRingingAlarm] {Clock::getRingingAlarm - get ringing alarm from clock's alarm list}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::getRingingAlarm(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int          i,         // in  - the i'th alarm to get
       Alarm **alarm) {   // out - the i'th alarm\end{verbatim}
{\sf DESCRIPTION:\\ }


       Retrieves the clock's i'th ringing alarm from the alarm list
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::getAlarmList] {Clock::getAlarmList - get a clock's alarm list}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::getAlarmList(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Alarm **alarmList,            // out - alarm list
       int         *alarmCount) const {   // out - number of alarms in list\end{verbatim}
{\sf DESCRIPTION:\\ }


       Get a clock's alarm list and number of alarms
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::syncToRealTime] {Clock::syncToRealTime - synchronize a clock to the wall clock time}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::syncToRealTime(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


      Synchronize a clock to the wall clock time
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock(=)] {Clock(=) - assignment operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Clock& Clock::operator=(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Clock& result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Clock &clock) {   // in - Clock to copy\end{verbatim}
{\sf DESCRIPTION:\\ }


        Assign current object's (this) {\tt ESMC\_Clock} with given
        {\tt ESMC\_Clock}.   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock(==)] {Clock(==) - Clock equality comparison}


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Clock::operator==(
     \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Clock &clock) const {   // in - Clock to compare\end{verbatim}
{\sf DESCRIPTION:\\ }


        Compare for equality the current object's (this) {\tt ESMC\_Clock} with
        given {\tt ESMC\_Clock}, return result.  Comparison is based on IDs.
      
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock(!=)] {Clock(!=) - Clock inequality comparison}


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}       bool Clock::operator!=(
     \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Clock &clock) const {   // in - Clock to compare\end{verbatim}
{\sf DESCRIPTION:\\ }


        Compare for inequality the current object's (this)
        {\tt ESMC\_Clock} with given {\tt ESMC\_Clock}, return result.
        Comparison is based on IDs.
      
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI\_ClockReadRestart] {ESMCI\_ClockReadRestart - restore contents of a Clock}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Clock *ESMCI_ClockReadRestart(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      pointer to newly allocated and restored Clock\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int          nameLen,  // in
       const char  *name,     // in
       int         *rc ) {    // out - return code
 \end{verbatim}
{\sf DESCRIPTION:\\ }


        Restore information about an {\tt ESMC\_Clock}.
        For persistence/checkpointing.
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::writeRestart] {Clock::writeRestart - save contents of a Clock}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::writeRestart(void) const {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        Save information about an {\tt ESMC\_Clock}.
        For persistence/checkpointing
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::validate] {Clock::validate - internal consistency check for a Clock}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::validate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *options) const {    // in - validate options\end{verbatim}
{\sf DESCRIPTION:\\ }


        Validates that a {\tt ESMC\_Clock} is internally consistent.
        Returns error code if problems are found.  {\tt ESMC\_Base}
        class method.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::print] {Clock::print - print contents of a Clock}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::print(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *options) const {    // in - print options\end{verbatim}
{\sf DESCRIPTION:\\ }


        Prints a {\tt ESMC\_Clock}'s contents for testing/debugging
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock] {Clock - native C++ constructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Clock::Clock(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        Initializes for either C++ or F90, since {\tt ESMC\_Clock} is a deep,
        dynamically allocated class.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock] {Clock - native C++ copy constructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Clock::Clock(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const Clock &clock) {  // in - clock to copy\end{verbatim}
{\sf DESCRIPTION:\\ }


        Copies members of given clock.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [~Clock] {~Clock - native C++ destructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Clock::~Clock(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


        Calls standard ESMF deep or shallow methods for destruction
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::addAlarm] {Clock::addAlarm - add alarm to clock's alarm list}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::addAlarm(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Alarm *alarm) {   // in - alarm to add\end{verbatim}
{\sf DESCRIPTION:\\ }


       Adds given alarm to a clock's alarm list. 
       Used by {\tt ESMC\_AlarmCreate().}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [Clock::removeAlarm] {Clock::removeAlarm - remove alarm from clock's alarm list}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Clock::removeAlarm(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       Alarm *alarm) {   // in - alarm to remove\end{verbatim}
{\sf DESCRIPTION:\\ }


       Adds given alarm to a clock's alarm list. 
       Used by {\tt ESMC\_AlarmCreate().}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
