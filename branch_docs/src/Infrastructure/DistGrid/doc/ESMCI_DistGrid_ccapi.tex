%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_DistGrid.C,  Date: Tue May  5 20:59:40 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMCI::DistGrid::create] {ESMCI::DistGrid::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DistGrid *DistGrid::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ESMCI::DistGrid * to newly allocated DistGrid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   DistGrid *dg,                         // (in)
   InterArray<int> *firstExtra,          // (in)
   InterArray<int> *lastExtra,           // (in)
   ESMC_IndexFlag *indexflag,            // (in)
   InterArray<int> *connectionList,      // (in)
   bool balanceflag,                     // (in)
   DELayout *delayout,                   // (in)
   VM *vm,                               // (in)
   bool actualFlag,                      // (in)
   int *rc                               // (out) return code
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Create a new DistGrid from an existing DistGrid, potentially on a
      different VM, keeping the decomposition unchanged. The firstExtra 
      and lastExtra arguments allow extra elements to be added at the 
      first/last edge DE in each dimension. The method also allows the 
      indexflag to be set different from the passed in DistGrid. Further, 
      if the connectionList argument is passed in it will be used to set
      connections in the newly created DistGrid, otherwise the connections
      of the existing DistGrid will be used.
      If neither firstExtra, lastExtra, indexflag, connectionList, nor vm
      arguments are specified, the method reduces to a deep copy of the
      incoming DistGrid object.
      The actualFlag argument identifies PETs that are part of vm. If
      on a PET actualFlag is true, and vm is not NULL, this PET is part of a
      vm that is of smaller size than the currentVM. If on a PET actualFlag is
      false then there exists such a smaller vm (even if vm is NULL), but the
      PET is not part of that VM.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::create] {ESMCI::DistGrid::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DistGrid *DistGrid::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ESMCI::DistGrid * to newly allocated DistGrid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<int> *minIndex,            // (in)
   InterArray<int> *maxIndex,            // (in)
   InterArray<int> *regDecomp,           // (in)
   Decomp_Flag *decompflag,              // (in)
   int decompflagCount,                  // (in)
   InterArray<int> *regDecompFirstExtra, // (in)
   InterArray<int> *regDecompLastExtra,  // (in)
   InterArray<int> *deLabelList,         // (in)
   ESMC_IndexFlag *indexflag,            // (in)
   InterArray<int> *connectionList,      // (in)
   DELayout *delayout,                   // (in)
   VM *vm,                               // (in)
   int *rc,                              // (out) return code
   ESMC_TypeKind_Flag indexTK            // (in) - default auto selection
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::create] {ESMCI::DistGrid::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DistGrid *DistGrid::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      DistGrid * to newly allocated DistGrid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<int> *minIndex,            // (in)
   InterArray<int> *maxIndex,            // (in)
   InterArray<int> *deBlockList,         // (in)
   InterArray<int> *deLabelList,         // (in)
   ESMC_IndexFlag *indexflag,            // (in)
   InterArray<int> *connectionList,      // (in)
   DELayout *delayout,                   // (in)
   VM *vm,                               // (in)
   int *rc,                              // (out) return code
   ESMC_TypeKind_Flag indexTK            // (in) - default auto selection
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::create] {ESMCI::DistGrid::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DistGrid *DistGrid::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      DistGrid * to newly allocated DistGrid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<int> *minIndex,            // (in)
   InterArray<int> *maxIndex,            // (in)
   InterArray<int> *deBlockList,         // (in)
   InterArray<int> *deToTileMap,         // (in)
   InterArray<int> *deLabelList,         // (in)
   ESMC_IndexFlag *indexflag,            // (in)
   InterArray<int> *connectionList,      // (in)
   DELayout *delayout,                   // (in)
   VM *vm,                               // (in)
   int *rc,                              // (out) return code
   ESMC_TypeKind_Flag indexTK            // (in) - default auto selection
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::create] {ESMCI::DistGrid::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DistGrid *DistGrid::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      DistGrid * to newly allocated DistGrid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<int> *minIndex,            // (in)
   InterArray<int> *maxIndex,            // (in)
   InterArray<int> *regDecomp,           // (in)
   Decomp_Flag *decompflag,              // (in)
   int decompflagCount,                  // (in)
   InterArray<int> *regDecompFirstExtra, // (in)
   InterArray<int> *regDecompLastExtra,  // (in)
   InterArray<int> *deLabelList,         // (in)
   ESMC_IndexFlag *indexflag,            // (in)
   InterArray<int> *connectionList,      // (in)
   int fastAxis,                         // (in)
   VM *vm,                               // (in)
   int *rc,                              // (out) return code
   ESMC_TypeKind_Flag indexTK            // (in) - default auto selection
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::create] {ESMCI::DistGrid::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DistGrid *DistGrid::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      DistGrid * to newly allocated DistGrid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<int> *minIndex,            // (in)
   InterArray<int> *maxIndex,            // (in)
   InterArray<int> *regDecomp,           // (in)
   Decomp_Flag *decompflag,              // (in)
   int decompflagCount1,                 // (in)
   int decompflagCount2,                 // (in)
   InterArray<int> *regDecompFirstExtra, // (in)
   InterArray<int> *regDecompLastExtra,  // (in)
   InterArray<int> *deLabelList,         // (in)
   ESMC_IndexFlag *indexflag,            // (in)
   InterArray<int> *connectionList,      // (in)
   DELayout *delayout,                   // (in)
   VM *vm,                               // (in)
   int *rc,                              // (out) return code
   ESMC_TypeKind_Flag indexTK            // (in) - default auto selection
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI:DistGrid::destroy] {ESMCI:DistGrid::destroy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::destroy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   DistGrid **distgrid,          // in - DistGrid to destroy
   bool noGarbage){              // in - remove from garbage collection\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::construct] {ESMCI::DistGrid::construct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::construct(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int dimCountArg,                      // (in)
   int tileCountArg,                     // (in)
   int *tileListPDeArg,                  // (in)
   int *minIndexArg,                     // (in)
   int *maxIndexArg,                     // (in)
   int *minIndexPDimPDeArg,              // (in)
   int *maxIndexPDimPDeArg,              // (in)
   int *contigFlagPDimPDeArg,            // (in)
   int *indexCountPDimPDeArg,            // (in)
   int **indexListPDimPLocalDeArg,       // (in)
   int *regDecompArg,                    // (in)
   InterArray<int> *connectionListArg,   // (in)
   Decomp_Flag const *decompflagArg,     // (in)
   ESMC_IndexFlag *indexflagArg,         // (in)
   DELayout *delayoutArg,                // (in) DELayout
   bool delayoutCreatorArg,              // (in)
   VM *vmArg,                            // (in) VM context
   ESMC_TypeKind_Flag indexTKArg         // (in) indexing typekind
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Construct the internal information structure of an ESMCI::DistGrid object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::destruct] {ESMCI::DistGrid::destruct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::destruct(bool followCreator, bool noGarbage){
   TODO: The followCreator flag is only needed until we have reference counting
   TODO: For now followCreator, which by default is true, will be coming in as
   TODO: false when calling through the native destructor. This prevents
   TODO: sequence problems during automatic garbage collection unitl reference
   TODO: counting comes in to solve this problem in the final manner.\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Destruct the internal information structure of an ESMCI::DistGrid object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::fillSeqIndexList] {ESMCI::DistGrid::fillSeqIndexList}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename T> int DistGrid::fillSeqIndexList(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   vector<T> &seqIndexList,      // in
   int localDe,                  // in  - local DE = {0, ..., localDeCount-1}
   int collocation               // in  -
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Fill the seqIndexList argument. The sequence indices are cast to the
      requested type T. There are checks in place to error out in case an
      overflow condition is detected during the cast. The most efficient way
      to call is with the same typekind (indexTK) of the DistGrid.
      
      If the size of seqIndexList does not match it will automatically
      resized by this method.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::fillSeqIndexList] {ESMCI::DistGrid::fillSeqIndexList}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename T> int DistGrid::fillSeqIndexList(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<T> *seqIndexList,    // in
   int localDe,                    // in  - local DE = {0, ..., localDeCount-1}
   int collocation                 // in  -
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Fill the seqIndexList argument. The sequence indices are cast to the
      requested type T. There are checks in place to error out in case an
      overflow condition is detected during the cast. The most efficient way
      to call is with the same typekind (indexTK) of the DistGrid.
      
      This InterArray based method is required for efficient filling of arrays
      that come through the Fortran API, without having to do an extra copy. 
      It is also leveraged by the overloaded vector<T> based interface.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::fillIndexListPDimPDe] {ESMCI::DistGrid::fillIndexListPDimPDe}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::fillIndexListPDimPDe(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *indexList,                   // out - only on rootPet
   int de,                           // in  - DE   = {0, ..., deCount-1}
   int dim,                          // in  - dim  = {1, ..., dimCount}
   VMK::commhandle **commh,          // inout -
   int rootPet,                      // in  -
   VM *vm                            // [in] - default: currentVM
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Fill indexList with values on rootPet for de and dim.
  
      Only rootPet must supply a sufficiently allocated indexList pointer.
      All PETs are allowed to call into this method once for each DE/dim
      request. Only the rootPet and the PET on which DE is local _must_ issue
      a call to this method. If on input *commh == NULL a new commhandle will
      be allocated internally and *commh will point to this new allocation on
      return. This behavior can be used by the calling code to test if
      the method did issue communications on behalf of the calling PET.
      If on input *commh != NULL the method will reuse the already
      allocated commhandle. In either case it is the caller's responsibility to
      issue the appropriate wait calls and delete the commhandles when finished.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::match] {ESMCI::DistGrid::match}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DistGridMatch_Flag DistGrid::match(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool according to match\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   DistGrid *distgrid1,                    // in
   DistGrid *distgrid2,                    // in
   int *rc                                 // (out) return code
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Determine if distgrid1 and distgrid2 match.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::print] {ESMCI::DistGrid::print}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::print()const{\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Print details of DistGrid object 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::validate] {ESMCI::DistGrid::validate}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::validate()const{\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Validate details of DistGrid object 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::isLocalDeOnEdgeL] {ESMCI::DistGrid::isLocalDeOnEdgeL}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool DistGrid::isLocalDeOnEdgeL(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool, true if local DE is on indicated edge, false otherwise\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int localDe,                      // in  - local DE = {0, ..., localDeCount-1}
   int dim,                          // in  - dim  = {1, ..., dimCount}
   int *rc                           // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Determine if local DE is on lower edge along dimension dim.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::isLocalDeOnEdgeU] {ESMCI::DistGrid::isLocalDeOnEdgeU}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool DistGrid::isLocalDeOnEdgeU(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool, true if local DE is on indicated edge, false otherwise\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int localDe,                      // in  - local DE = {0, ..., localDeCount-1}
   int dim,                          // in  - dim  = {1, ..., dimCount}
   int *rc                           // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Determine if local DE is on upper edge along dimension dim.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getContigFlagPDimPDe] {ESMCI::DistGrid::getContigFlagPDimPDe}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::getContigFlagPDimPDe(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int contigFlag for de and dim\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int de,                           // in  - DE   = {0, ..., deCount-1}
   int dim,                          // in  - dim  = {1, ..., dimCount}
   int *rc                           // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get information about a DistGrid object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getElementCountPDe] {ESMCI::DistGrid::getElementCountPDe}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} ESMC_I8 DistGrid::getElementCountPDe(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int elementCount for DE\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int de,                               // in  - DE   = {0, ..., deCount-1}
   int *rc                               // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get information about a DistGrid object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getSequenceIndexLocalDe] {ESMCI::DistGrid::getSequenceIndexLocalDe}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename T> int DistGrid::getSequenceIndexLocalDe(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int sequence index\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int localDe,                      // in  - local DE = {0, ..., localDeCount-1}
   const int *index,                 // in  - DE-local index tuple in or 
                                     //       relative to exclusive region
                                     //       basis 0
   vector<T> &seqIndex,              // out - sequence index
   bool recursive,                   // in  - recursive mode or not
   bool canonical                    // in  - return canonical seqIndex even if
                                     //       arbitrary seqIndices available
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get sequential index provided the index tuple in terms of the exclusive
      region of a local DE starting at basis 0. DistGrid dimensions that have
      contiguous indices support the specified index to lay outside of the
      localDe exclusive region unless arbitrary sequence indices have been
      specified during DistGrid creation. DistGrids with arbitrary sequence
      indices and/or along dimensions with non-contiguous indices require
      the specified index to be within [0..indexCountPDimPDe[dim,localDe]-1].
  
      A value of -1 is returned by this function if the specified index tuple
      cannot be mapped to a sequence index in DistGrid. If at the same time
      the code returned in rc does not indicate an error a return value of -1
      indicates that the index tuple lies outside of the DistGrid index space.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getSequenceIndexTileRelative] {ESMCI::DistGrid::getSequenceIndexTileRelative}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename T> int DistGrid::getSequenceIndexTileRelative(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int sequence index\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int tile,                         // in  - tile = {1, ..., tileCount}
   const int *index,                 // in  - tile relative index tuple, base 0
   T *seqIndex                       // out - sequence index
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get sequential index provided the tile relative index tuple.
  
      A value of -1 is returned by this function if the specified index tuple
      cannot be mapped to a sequence index in DistGrid. If at the same time
      the code returned in rc does not indicate an error a return value of -1
      indicates that the index tuple lies outside of the DistGrid index space.
  
      Same as getSequenceIndexTile(), but allows index tuple to be passed in
      tile relative, base 0, which is more conveninet in many cases.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getSequenceIndexTile] {ESMCI::DistGrid::getSequenceIndexTile}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename T> int DistGrid::getSequenceIndexTile(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int sequence index\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int tile,                         // in  - tile = {1, ..., tileCount}
   const int *index,                 // in  - tile-specific absolute index tuple
   vector<T> &seqIndex,              // out - sequence index
   bool recursive                    // in  - recursive mode or not
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get sequential index provided the tile relative index tuple.
  
      A value of -1 is returned by this function if the specified index tuple
      cannot be mapped to a sequence index in DistGrid. If at the same time
      the code returned in rc does not indicate an error a return value of -1
      indicates that the index tuple lies outside of the DistGrid index space.
  
      The method requires that the
      provided index tuple be expressed in a "tile-specific absolute" sense.
      It is "absolute" in that the (0,0,...) tuple is not 'defined' to
      equal the origin of the tile. Instead the origin of the tile would
      be indicated by an index tuple that is equal to the "tile-specific"
      vector slice of minIndexPDimPTile[].
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getSequenceIndexTileRecursive] {ESMCI::DistGrid::getSequenceIndexTileRecursive}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename T> int DistGrid::getSequenceIndexTileRecursive(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int sequence index\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int tile,                         // in  - tile = {1, ..., tileCount}
   const int *index,                 // in  - tile-specific absolute index tuple
   int depth,                        // inout - depth of recursive search
   int hops,                         // inout - connection hops taken
   vector<T> &seqIndexV              // out - sequence index
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get sequential index provided the tile relative index tuple.
  
      A value of -1 is returned by this function if the specified index tuple
      cannot be mapped to a sequence index in DistGrid. If at the same time
      the code returned in rc does not indicate an error a return value of -1
      indicates that the index tuple lies outside of the DistGrid index space.
  
      The way this recursive algorithm is written, it requires that the 
      provided index tuple be expressed in a "tile-specific absolute" sense.
      It is "absolute" in that the (0,0,...) tuple is not 'defined' to
      equal the origin of the tile. Instead the origin of the tile would
      be indicated by an index tuple that is equal to the "tile-specific"
      vector slice of minIndexPDimPTile[].
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getIndexTupleFromSeqIndex] {ESMCI::DistGrid::getIndexTupleFromSeqIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::getIndexTupleFromSeqIndex(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int seqIndex,                 // in  - sequence index to be transformed
   vector<int> &indexTuple,      // out - index tuple within tile
   int &tile                     // out - tile index (1-based)
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Transform the seqIndex argument into tile and indexTuple. If the size 
      of indexTuple does not match dimCount, it will automatically be resized 
      by this method.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getMinIndexPDimPTile] {ESMCI::DistGrid::getMinIndexPDimPTile}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} const int *DistGrid::getMinIndexPDimPTile(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int *minIndex for tile\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int tile,                             // in  - tile   = {1, ..., tileCount}
   int *rc                               // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get information about a DistGrid object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getMaxIndexPDimPTile] {ESMCI::DistGrid::getMaxIndexPDimPTile}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} const int *DistGrid::getMaxIndexPDimPTile(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int *maxIndex for tile\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int tile,                             // in  - tile   = {1, ..., tileCount}
   int *rc                               // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get information about a DistGrid object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getMinIndexPDimPDe] {ESMCI::DistGrid::getMinIndexPDimPDe}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} const int *DistGrid::getMinIndexPDimPDe(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int *minIndex for de\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int de,                               // in  - de   = {0, ..., deCount-1}
   int *rc                               // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get information about a DistGrid object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getMaxIndexPDimPDe] {ESMCI::DistGrid::getMaxIndexPDimPDe}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} const int *DistGrid::getMaxIndexPDimPDe(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int *maxIndex for de\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int de,                               // in  - de   = {0, ..., deCount-1}
   int *rc                               // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get information about a DistGrid object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getIndexListPDimPLocalDe] {ESMCI::DistGrid::getIndexListPDimPLocalDe}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} const int *DistGrid::getIndexListPDimPLocalDe(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int *indexListPDimPLocalDe for localDe, dim\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int localDe,                      // in  - local DE = {0, ..., localDeCount-1}
   int dim,                          // in  - dim  = {1, ..., dimCount}
   int *rc                           // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get information about a DistGrid object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::getArbSeqIndexList] {ESMCI::DistGrid::getArbSeqIndexList}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void const *DistGrid::getArbSeqIndexList(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int *arbSeqIndexList for localDe\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int localDe,                      // in  - local DE = {0, ..., localDeCount-1}
   int collocation,                  // in
   int *rc                           // out - return code
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get information about a DistGrid object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC::DistGrid::serialize] {ESMC::DistGrid::serialize - Turn distgrid into a byte stream}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::serialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char *buffer,          // inout - byte stream to fill
   int *length,           // inout - buf length; realloc'd here if needed
   int *offset,           // inout - original offset, updated to point 
                              //  to first free byte after current obj info
   ESMC_InquireFlag inquireflag // in - inquire flag
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn info in distgrid object into a stream of bytes.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::deserialize] {ESMCI::DistGrid::deserialize - Turn a byte stream into an object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DistGrid *DistGrid::deserialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      DistGrid * to deserialized proxy object\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char *buffer,          // in - byte stream to read
   int *offset) {         // inout - original offset, updated to point 
                              //  to first free byte after current obj info\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn a stream of bytes into an object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::connection] {ESMCI::DistGrid::connection}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::connection(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<int> *connection,        // out -
   int tileIndexA,                     // in  -
   int tileIndexB,                     // in  -
   InterArray<int> *positionVector,    // in -
   InterArray<int> *orientationVector  // in -
   ){    \end{verbatim}
{\sf DESCRIPTION:\\ }


      Construct a connection element
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::regDecompSetCubic] {ESMCI::DistGrid::regDecompSetCubic}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::regDecompSetCubic(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<int> *regDecomp,         // out -
   int v                               // in  -
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set a regDecomp to be most cubic
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::setCollocationPDim] {ESMCI::DistGrid::setCollocationPDim}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::setCollocationPDim(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<int> *collocationPDimArg // in
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the collocation list
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::setArbSeqIndex] {ESMCI::DistGrid::setArbSeqIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename T> int DistGrid::setArbSeqIndex(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   vector<T> &arbSeqIndex,       // in
   int localDe,                  // in  - local DE = {0, ..., localDeCount-1}
   int collocation               // in
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the array of arbitrary indices for localDe and collocation. The 
      indexTK of the DistGrid object might be changed. It is set to the 
      typekind of the incoming type T.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::setArbSeqIndex] {ESMCI::DistGrid::setArbSeqIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template<typename T> int DistGrid::setArbSeqIndex(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   InterArray<T> *arbSeqIndex,   // in
   int localDe,                  // in  - local DE = {0, ..., localDeCount-1}
   int collocation               // in
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the array of arbitrary indices for localDe and collocation. The 
      indexTK of the DistGrid object might be changed. It is set to the 
      typekind of the incoming type T.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DistGrid::setArbSeqIndex] {ESMCI::DistGrid::setArbSeqIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DistGrid::setArbSeqIndex(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *ptr,                    // in
   int localDe,                  // in  - local DE = {0, ..., localDeCount-1}
   int collocation               // in
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the array of arbitrary indices to the incoming pointer.
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
