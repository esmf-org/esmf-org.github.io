%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_FieldGet.F90,  Date: Tue May  5 21:00:01 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_FieldGet] {ESMF\_FieldGet - Get object-wide Field information}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldGet()
   subroutine ESMF_FieldGetDefault(field, arrayspec, &
     status, geomtype, grid, mesh, locstream, xgrid, array, &
     typekind, dimCount, rank, staggerloc, meshloc, xgridside, &
     gridindex, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     totalLWidth, totalUWidth, localDeCount, &
     minIndex, maxIndex, elementCount, &
     localMinIndex, localMaxIndex, localElementCount, name, vm, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Field), intent(in) :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_ArraySpec), intent(out), optional :: arrayspec
     type(ESMF_FieldStatus_Flag),intent(out), optional :: status
     type(ESMF_GeomType_Flag), intent(out), optional :: geomtype
     type(ESMF_Grid), intent(out), optional :: grid
     type(ESMF_Mesh), intent(out), optional :: mesh
     type(ESMF_LocStream), intent(out), optional :: locstream
     type(ESMF_XGrid), intent(out), optional :: xgrid
     type(ESMF_Array), intent(out), optional :: array
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer, intent(out), optional :: dimCount
     integer, intent(out), optional :: rank
     type(ESMF_StaggerLoc), intent(out), optional :: staggerloc
     type(ESMF_MeshLoc), intent(out), optional :: meshloc
     type(ESMF_XGridSide_Flag), intent(out), optional :: xgridside
     integer, intent(out), optional :: gridindex
     integer, intent(out), optional :: gridToFieldMap(:)
     integer, intent(out), optional :: ungriddedLBound(:)
     integer, intent(out), optional :: ungriddedUBound(:)
     integer, intent(out), optional :: totalLWidth(:,:)
     integer, intent(out), optional :: totalUWidth(:,:)
     integer, intent(out), optional :: localDeCount
     integer, intent(out), optional :: minIndex(:)
     integer, intent(out), optional :: maxIndex(:)
     integer, intent(out), optional :: elementCount(:)
     integer, intent(out), optional :: localMinIndex(:)
     integer, intent(out), optional :: localMaxIndex(:)
     integer, intent(out), optional :: localElementCount(:)
     character(len=*), intent(out), optional :: name
     type(ESMF_VM), intent(out), optional :: vm
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersionExceptions{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[6.3.0r] Added argument {\tt vm} in order to offer information about the
   VM on which the Field was created.
   \item[8.0.0] Added argument {\tt minIndex}.
   The new argument allows the user to query the global lower bounds of the field data across all PETs.
   \item[8.0.0] Added argument {\tt maxIndex}.
   The new argument allows the user to query the global upper bounds of the field data across all PETs.
   \item[8.0.0] Added argument {\tt elementCount}.
   The new argument allows the user to query the global number of items of the field data across all PETs.
   \item[8.0.0] Added argument {\tt localMinIndex}.
   The new argument allows the user to query the PET local lower bounds globally indexed of the field data.
   \item[8.0.0] Added argument {\tt localMaxIndex}.
   The new argument allows the user to query the PET local upper bounds globally indexed of the field data.
   \item[8.0.0] Added argument {\tt localElementCount}.
   The new argument allows the user to query the PET local number of items of the field data.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Query an {\tt ESMF\_Field} for various things. All arguments after
   the {\tt field} are optional. To select individual items use the
   named\_argument=value syntax. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:field_get_default}.
  
   The arguments are:
   \begin{description}
   \item [field]
   {\tt ESMF\_Field} object to query.
   \item[{[arrayspec]}]
   {\tt ESMF\_ArraySpec} object containing the type/kind/rank information
   of the Field object.
   \item [{[status]}]
   \begin{sloppypar}
   The status of the Field. See section \ref{const:fieldstatus} for a
   complete list of values.
   \end{sloppypar}
   \item [{[geomtype]}]
   The type of geometry on which the Field is built. See
   section~\ref{const:geomtype} for the range of values.
   \item [{[grid]}]
   {\tt ESMF\_Grid}.
   \item [{[mesh]}]
   \apiStatusCompatibleException
   {\tt ESMF\_Mesh}.
   \item [{[locstream]}]
   \apiStatusCompatibleException
   {\tt ESMF\_LocStream}.
   \item [{[xgrid]}]
   \apiStatusCompatibleException
   {\tt ESMF\_XGrid}.
   \item [{[array]}]
   {\tt ESMF\_Array}.
   \item [{[typekind]}]
   TypeKind specifier for Field. See section \ref{const:typekind} for a
   complete list of values.
   \item [{[dimCount]}]
   Number of geometrical dimensions in {\tt field}.
   For an detailed discussion of this parameter, please see
   section \ref{sec:field:usage:createArbGrid} and
   section \ref{sec:field:usage:createArbGridRep}.
   \item [{[rank]}]
   Number of dimensions in the physical memory of the {\tt field} data. It is
   identical to dimCount when the corresponding grid is a non-arbitrary grid.
   It is less than dimCount when the grid is arbitrarily distributed.
   For an detailed discussion of this parameter, please see
   section \ref{sec:field:usage:createArbGrid} and
   section \ref{sec:field:usage:createArbGridRep}.
   \item [{[staggerloc]}]
   Stagger location of data in grid cells. For valid
   predefined values and interpretation of results see
   section \ref{const:staggerloc}.
   \item [{[meshloc]}]
   \begin{sloppypar}
   \apiStatusCompatibleException
   The part of the mesh to build the Field on. Can be either
   {\tt ESMF\_MESHLOC\_NODE} or {\tt ESMF\_MESHLOC\_ELEMENT}. If not set,
   defaults to {\tt ESMF\_MESHLOC\_NODE}.
   \end{sloppypar}
   \item [{[xgridside]}]
   \begin{sloppypar}
   \apiStatusCompatibleException
   The side of the XGrid that the Field was created on. See section
   \ref{const:xgridside} for a complete list of values.
   \end{sloppypar}
   \item [{[gridIndex]}]
   \apiStatusCompatibleException
   If xgridside is {\tt ESMF\_XGRIDSIDE\_A} or {\tt ESMF\_XGRIDSIDE\_B}
   then this index tells which Grid/Mesh on that side the Field was
   created on.
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[totalLWidth]}]
   Lower bound of halo region. The size of the first dimension of this array is the number
   of gridded dimensions in the {\tt field}. However, ordering of the elements
   needs to be the same as they appear in the {\tt field}. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the {\tt field}. That is, for each gridded dimension the
   {\tt field} size should be max( {\tt totalLWidth} + {\tt totalUWidth}
   + {\tt computationalCount}, {\tt exclusiveCount} ).
   The size of the 2nd dimension of this array is localDeCount.
   \item [{[totalUWidth]}]
   Upper bound of halo region. The size of the first dimension of this array is the number
   of gridded dimensions in the {\tt field}. However, ordering of the elements
   needs to be the same as they appear in the {\tt field}. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the {\tt field}. That is, for each gridded dimension the
   {\tt field} size should max( {\tt totalLWidth} + {\tt totalUWidth}
   + {\tt computationalCount}, {\tt exclusiveCount} ).
   The size of the 2nd dimension of this array is localDeCount.
   \item [{[localDeCount]}]
   Upon return this holds the number of PET-local DEs defined in
   the DELayout associated with the Field object.
   \item[{[minIndex]}]
   Upon return this holds the global lower bounds of the field data across all PETs.
   This information will be identical across all PETs.
   {\tt minIndex} must be allocated to be of size equal to the field rank.
   \item[{[maxIndex]}]
   Upon return this holds the global upper bounds of the field data across all PETs.
   This information will be identical across all PETs.
   {\tt maxIndex} must be allocated to be of size equal to the field rank.
   \item[{[elementCount]}]
   Upon return this holds the global number of items of the field data across all PETs.
   This information will be identical across all PETs.
   {\tt elementCount} must be allocated to be of size equal to the field rank.
   \item[{[localMinIndex]}]
   Upon return this holds the PET local lower bounds globally indexed of the field data.
   {\tt localMinIndex} must be allocated to be of size equal to the field rank.
   \item[{[localMaxIndex]}]
   Upon return this holds the PET local upper bounds globally indexed of the field data.
   {\tt localMaxIndex} must be allocated to be of size equal to the field rank.
   \item[{[localElementCount]}]
   Upon return this holds the PET local number of items of the field data.
   {\tt localElementCount} must be allocated to be of size equal to the field rank.
   \item [{[name]}]
   Name of queried item.
   \item [{[vm]}]
   The VM on which the Field object was created.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldGet] {ESMF\_FieldGet - Get a DE-local Fortran array pointer from a Field }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldGet() 
   subroutine ESMF_FieldGetDataPtr<rank><type><kind>(field, localDe, & 
   farrayPtr, exclusiveLBound, exclusiveUBound, exclusiveCount, & 
   computationalLBound, computationalUBound, computationalCount, & 
   totalLBound, totalUBound, totalCount, rc) 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Field), intent(in) :: field 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: localDe 
   <type> (ESMF_KIND_<kind>), pointer :: farrayPtr(<rank>) 
   integer, intent(out), optional :: exclusiveLBound(:) 
   integer, intent(out), optional :: exclusiveUBound(:) 
   integer, intent(out), optional :: exclusiveCount(:) 
   integer, intent(out), optional :: computationalLBound(:) 
   integer, intent(out), optional :: computationalUBound(:) 
   integer, intent(out), optional :: computationalCount(:) 
   integer, intent(out), optional :: totalLBound(:) 
   integer, intent(out), optional :: totalUBound(:) 
   integer, intent(out), optional :: totalCount(:) 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf STATUS:}
   \begin{itemize} 
   \item\apiStatusCompatibleVersion{5.2.0r} 
   \end{itemize} 
   
{\sf DESCRIPTION:\\ }

 
   Get a Fortran pointer to DE-local memory allocation within {\tt field}. 
   For convenience DE-local bounds can be queried at the same time. 
   For an example and 
   associated documentation using this method see section 
   \ref{sec:field:usage:field_get_dataptr}. 
   
   The arguments are: 
   \begin{description} 
   \item [field] 
   {\tt ESMF\_Field} object. 
   \item[{[localDe]}] 
   Local DE for which information is requested. {\tt [0,..,localDeCount-1]}. 
   For {\tt localDeCount==1} the {\tt localDe} argument may be omitted, 
   in which case it will default to {\tt localDe=0}. 
   \item [farrayPtr] 
   Fortran array pointer which will be pointed at DE-local memory allocation. 
   It depends on the specific entry point 
   of {\tt ESMF\_FieldCreate()} used during {\tt field} creation, which 
   Fortran operations are supported on the returned {\tt farrayPtr}. See 
   \ref{Field:rest} for more details. 
   \item[{[exclusiveLBound]}] 
   Upon return this holds the lower bounds of the exclusive region. 
   {\tt exclusiveLBound} must be allocated to be of size equal to {\tt field}'s {\tt dimCount}. 
   See section \ref{Array_regions_and_default_bounds} for a description 
   of the regions and their associated bounds and counts. 
   \item[{[exclusiveUBound]}] 
   Upon return this holds the upper bounds of the exclusive region. 
   {\tt exclusiveUBound} must be allocated to be of size equal to {\tt field}'s {\tt dimCount}. 
   See section \ref{Array_regions_and_default_bounds} for a description 
   of the regions and their associated bounds and counts. 
   \item[{[exclusiveCount]}] 
   Upon return this holds the number of items, {\tt exclusiveUBound-exclusiveLBound+1}, 
   in the exclusive region per dimension. 
   {\tt exclusiveCount} must 
   be allocated to be of size equal to {\tt field}'s {\tt dimCount}. 
   See section \ref{Array_regions_and_default_bounds} for a description 
   of the regions and their associated bounds and counts. 
   \item[{[computationalLBound]}] 
   \begin{sloppypar} 
   Upon return this holds the lower bounds of the computational region. 
   {\tt computationalLBound} must be allocated to be of size equal to {\tt field}'s {\tt dimCount}. 
   See section \ref{Array_regions_and_default_bounds} for a description 
   of the regions and their associated bounds and counts. 
   \end{sloppypar} 
   \item[{[computationalUBound]}] 
   \begin{sloppypar} 
   Upon return this holds the lower bounds of the computational region. 
   {\tt computationalUBound} must be allocated to be of size equal to {\tt field}'s {\tt dimCount}. 
   See section \ref{Array_regions_and_default_bounds} for a description 
   of the regions and their associated bounds and counts. 
   \end{sloppypar} 
   \item[{[computationalCount]}] 
   Upon return this holds the number of items in the computational region per dimension 
   (i.e. {\tt computationalUBound-computationalLBound+1}). {\tt computationalCount} must 
   be allocated to be of size equal to {\tt field}'s {\tt dimCount}. 
   See section \ref{Array_regions_and_default_bounds} for a description 
   of the regions and their associated bounds and counts. 
   \item[{[totalLBound]}] 
   Upon return this holds the lower bounds of the total region. 
   {\tt totalLBound} must be allocated to be of size equal to {\tt field}'s {\tt dimCount}. 
   See section \ref{Array_regions_and_default_bounds} for a description 
   of the regions and their associated bounds and counts. 
   \item[{[totalUBound]}] 
   Upon return this holds the lower bounds of the total region. 
   {\tt totalUBound} must be allocated to be of size equal to {\tt field}'s {\tt dimCount}. 
   See section \ref{Array_regions_and_default_bounds} for a description 
   of the regions and their associated bounds and counts. 
   \item[{[totalCount]}] 
   \begin{sloppypar} 
   Upon return this holds the number of items in the total region per dimension 
   (i.e. {\tt totalUBound-totalLBound+1}). {\tt computationalCount} must 
   be allocated to be of size equal to {\tt field}'s {\tt dimCount}. 
   See section \ref{Array_regions_and_default_bounds} for a description 
   of the regions and their associated bounds and counts. 
   \end{sloppypar} 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldGetBounds] {ESMF\_FieldGetBounds - Get DE-local Field data bounds}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldGetBounds()
   subroutine ESMF_FieldGetBounds(field, localDe, &
     exclusiveLBound, exclusiveUBound, exclusiveCount, computationalLBound, &
     computationalUBound, computationalCount, totalLBound, &
     totalUBound, totalCount, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Field), intent(in) :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: localDe
     integer, intent(out), optional :: exclusiveLBound(:)
     integer, intent(out), optional :: exclusiveUBound(:)
     integer, intent(out), optional :: exclusiveCount(:)
     integer, intent(out), optional :: computationalLBound(:)
     integer, intent(out), optional :: computationalUBound(:)
     integer, intent(out), optional :: computationalCount(:)
     integer, intent(out), optional :: totalLBound(:)
     integer, intent(out), optional :: totalUBound(:)
     integer, intent(out), optional :: totalCount(:)
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   This method returns the bounds information of a field that consists of a
   internal grid and a internal array. The exclusive and computational bounds
   are shared between the grid and the array but the total bounds are the array
   bounds plus the halo width. The count is the number of elements between each
   bound pair.
  
   The arguments are:
   \begin{description}
   \item[field]
   Field to get the information from.
   \item[{[localDe]}]
   Local DE for which information is requested. {\tt [0,..,localDeCount-1]}.
   For {\tt localDeCount==1} the {\tt localDe} argument may be omitted,
   in which case it will default to {\tt localDe=0}.
   \item[{[exclusiveLBound]}]
   Upon return this holds the lower bounds of the exclusive region.
   {\tt exclusiveLBound} must be allocated to be of size equal to the field rank.
   Please see section~\ref{sec:grid:usage:bounds} for a description
   of the regions and their associated bounds and counts.
   \item[{[exclusiveUBound]}]
   Upon return this holds the upper bounds of the exclusive region.
   {\tt exclusiveUBound} must be allocated to be of size equal to the field rank.
   Please see section~\ref{sec:grid:usage:bounds} for a description
   of the regions and their associated bounds and counts.
   \item[{[exclusiveCount]}]
   Upon return this holds the number of items, {\tt exclusiveUBound-exclusiveLBound+1},
   in the exclusive region per dimension.
   {\tt exclusiveCount} must
   be allocated to be of size equal to the field rank.
   Please see section~\ref{sec:grid:usage:bounds} for a description
   of the regions and their associated bounds and counts.
   \item[{[computationalLBound]}]
   Upon return this holds the lower bounds of the stagger region.
   {\tt computationalLBound} must be allocated to be of size equal to the field rank.
   Please see section~\ref{sec:grid:usage:bounds} for a description
   of the regions and their associated bounds and counts.
   \item[{[computationalUBound]}]
   Upon return this holds the upper bounds of the stagger region.
   {\tt computationalUBound} must be allocated to be of size equal to the field rank.
   Please see section~\ref{sec:grid:usage:bounds} for a description
   of the regions and their associated bounds and counts.
   \item[{[computationalCount]}]
   Upon return this holds the number of items in the computational region per dimension
   (i.e. {\tt computationalUBound-computationalLBound+1}). {\tt computationalCount}
   must be allocated to be of size equal to the field rank.
   Please see section~\ref{sec:grid:usage:bounds} for a description
   of the regions and their associated bounds and counts.
   \item[{[totalLBound]}]
   Upon return this holds the lower bounds of the total region.
   {\tt totalLBound} must be allocated to be of size equal to the field rank.
   \item[{[totalUBound]}]
   Upon return this holds the upper bounds of the total region.
   {\tt totalUBound} must be allocated to be of size equal to the field rank.
   \item[{[totalCount]}]
   \begin{sloppypar}
   Upon return this holds the number of items in the total region per dimension
   (i.e. {\tt totalUBound-totalLBound+1}). {\tt totalCount} must
   be allocated to be of size equal to the field rank.
   \end{sloppypar}
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
