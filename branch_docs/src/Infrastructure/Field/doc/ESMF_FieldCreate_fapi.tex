%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_FieldCreate.F90,  Date: Tue May  5 21:00:00 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_FieldAssignment(=)] {ESMF\_FieldAssignment(=) - Field assignment}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface assignment(=)
   field1 = field2\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Field) :: field1
   type(ESMF_Field) :: field2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Assign field1 as an alias to the same ESMF Field object in memory
   as field2. If field2 is invalid, then field1 will be equally invalid after
   the assignment.
  
   The arguments are:
   \begin{description}
   \item[field1]
   The {\tt ESMF\_Field} object on the left hand side of the assignment.
   \item[field2]
   The {\tt ESMF\_Field} object on the right hand side of the assignment.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldOperator(==)] {ESMF\_FieldOperator(==) - Field equality operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(==)
   if (field1 == field2) then ... endif
   OR
   result = (field1 == field2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Field), intent(in) :: field1
   type(ESMF_Field), intent(in) :: field2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Test whether field1 and field2 are valid aliases to the same ESMF
   Field object in memory. For a more general comparison of two ESMF Fields,
   going beyond the simple alias test, the ESMF\_FieldMatch() function (not yet
   implemented) must be used.
  
   The arguments are:
   \begin{description}
   \item[field1]
   The {\tt ESMF\_Field} object on the left hand side of the equality
   operation.
   \item[field2]
   The {\tt ESMF\_Field} object on the right hand side of the equality
   operation.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldOperator(/=)] {ESMF\_FieldOperator(/=) - Field not equal operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(/=)
   if (field1 /= field2) then ... endif
   OR
   result = (field1 /= field2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Field), intent(in) :: field1
   type(ESMF_Field), intent(in) :: field2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Test whether field1 and field2 are {\it not} valid aliases to the
   same ESMF Field object in memory. For a more general comparison of two ESMF
   Fields, going beyond the simple alias test, the ESMF\_FieldMatch() function
   (not yet implemented) must be used.
  
   The arguments are:
   \begin{description}
   \item[field1]
   The {\tt ESMF\_Field} object on the left hand side of the non-equality
   operation.
   \item[field2]
   The {\tt ESMF\_Field} object on the right hand side of the non-equality
   operation.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCopy] {ESMF\_FieldCopy - Copy data from one Field object to another}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldCopy(fieldOut, fieldIn, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type(ESMF_Field), intent(inout) :: fieldOut
        type(ESMF_Field), intent(in) :: fieldIn
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Copy data from one {\tt ESMF\_Field} object to another.
  
   The arguments are:
   \begin{description}
   \item[fieldOut]
   {\tt ESMF\_Field} object into which to copy the data. The incoming
   {\tt fieldOut} must already references a matching memory allocation.
   \item[fieldIn]
   {\tt ESMF\_Field} object that holds the data to be copied.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from Grid and typekind}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGridTKR(grid, typekind, &
     indexflag, staggerloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     totalLWidth, totalUWidth, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateGridTKR\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Grid), intent(in) :: grid
     type(ESMF_TypeKind_Flag),intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag), intent(in), optional :: indexflag
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: totalLWidth(:)
     integer, intent(in), optional :: totalUWidth(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field} and allocate space internally for an
   {\tt ESMF\_Array}. Return a new {\tt ESMF\_Field}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_grid_tkr}.
  
   The arguments are:
   \begin{description}
   \item [grid]
   {\tt ESMF\_Grid} object.
   \item[typekind]
   The typekind of the Field. See section \ref{const:typekind}
   for a list of valid typekind options.
   \item[{[indexflag]}]
   Indicate how DE-local indices are defined. By default each DE's
   exclusive region is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated Grid. See section \ref{const:indexflag}
   for a list of valid indexflag options. The default indexflag value is the
   one stored in then {\tt ESMF\_Grid} object. Currently it is
   erroneous to specify an indexflag
   different from the one stored in the {\tt ESMF\_Grid} object. The default
   value is {\tt ESMF\_INDEX\_DELOCAL}
   \item [{[staggerloc]}]
   Stagger location of data in grid cells. For valid
   predefined values see section \ref{const:staggerloc}.
   To create a custom stagger location see section
   \ref{sec:usage:staggerloc:adv}. The default
   value is {\tt ESMF\_STAGGERLOC\_CENTER}.
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[totalLWidth]}]
   Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the {\tt field}. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the {\tt field}. That is, for each gridded dimension the
   {\tt field} size should be max( {\tt totalLWidth} + {\tt totalUWidth}
   + {\tt computationalCount}, {\tt exclusiveCount} ).
   \item [{[totalUWidth]}]
   Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the {\tt field}. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the {\tt field}. That is, for each gridded dimension the
   {\tt field} size should max( {\tt totalLWidth} + {\tt totalUWidth}
   + {\tt computationalCount}, {\tt exclusiveCount} ).
   \item [{[name]}]
   Field name.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from Grid and ArraySpec}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGridArraySpec(grid, arrayspec, &
     indexflag, staggerloc, gridToFieldMap, ungriddedLBound, &
     ungriddedUBound, totalLWidth, totalUWidth, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateGridArraySpec\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Grid), intent(in) :: grid
     type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag), intent(in), optional :: indexflag
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: totalLWidth(:)
     integer, intent(in), optional :: totalUWidth(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field} and allocate space internally for an
   {\tt ESMF\_Array}. Return a new {\tt ESMF\_Field}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_grid_arrayspec}.
  
   The arguments are:
   \begin{description}
   \item [grid]
   {\tt ESMF\_Grid} object.
   \item [arrayspec]
   Data type and kind specification.
   \item[{[indexflag]}]
   Indicate how DE-local indices are defined. By default each DE's
   exclusive region is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated Grid. See section \ref{const:indexflag}
   for a list of valid indexflag options. The default indexflag value is the
   one stored in then {\tt ESMF\_Grid} object. Currently it is
   erroneous to specify an indexflag
   different from the one stored in the {\tt ESMF\_Grid} object.The default
   value is {\tt ESMF\_INDEX\_DELOCAL}
   \item [{[staggerloc]}]
   Stagger location of data in grid cells. For valid
   predefined values see section \ref{const:staggerloc}.
   To create a custom stagger location see section
   \ref{sec:usage:staggerloc:adv}. The default
   value is {\tt ESMF\_STAGGERLOC\_CENTER}.
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[totalLWidth]}]
   Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the {\tt field}. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the {\tt field}. That is, for each gridded dimension the
   {\tt field} size should be max( {\tt totalLWidth} + {\tt totalUWidth}
   + {\tt computationalCount}, {\tt exclusiveCount} ).
   \item [{[totalUWidth]}]
   Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the {\tt field}. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the {\tt field}. That is, for each gridded dimension the
   {\tt field} size should max( {\tt totalLWidth} + {\tt totalUWidth}
   + {\tt computationalCount}, {\tt exclusiveCount} ).
   \item [{[name]}]
   Field name.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from Grid and Array}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGridArray(grid, array, datacopyflag, &
     staggerloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     totalLWidth, totalUWidth, name, vm, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateGridArray\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Grid), intent(in) :: grid
     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: totalLWidth(:)
     integer, intent(in), optional :: totalUWidth(:)
     character (len = *), intent(in), optional :: name
     type(ESMF_VM), intent(in), optional :: vm
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[8.0.0] Added argument {\tt vm} to support object creation on a
   different VM than that of the current context.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field}. This version of creation
   assumes the data exists already and is being
   passed in through an {\tt ESMF\_Array}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_grid_array}.
  
   The arguments are:
   \begin{description}
   \item [grid]
   {\tt ESMF\_Grid} object.
   \item [array]
   {\tt ESMF\_Array} object.
   \item [{[datacopyflag]}]
   Indicates whether to copy the contents of the {\tt array} or reference it directly.
   For valid values see \ref{const:datacopyflag}. The default is
   {\tt ESMF\_DATACOPY\_REFERENCE}.
   \item [{[staggerloc]}]
   Stagger location of data in grid cells. For valid
   predefined values see section \ref{const:staggerloc}.
   To create a custom stagger location see section
   \ref{sec:usage:staggerloc:adv}. The default
   value is {\tt ESMF\_STAGGERLOC\_CENTER}.
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[totalLWidth]}]
   Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the {\tt field}. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the {\tt field}. That is, for each gridded dimension the
   {\tt field} size should be max( {\tt totalLWidth} + {\tt totalUWidth}
   + {\tt computationalCount}, {\tt exclusiveCount} ).
   \item [{[totalUWidth]}]
   Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the {\tt field}. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the {\tt field}. That is, for each gridded dimension the
   {\tt field} size should max( {\tt totalLWidth} + {\tt totalUWidth}
   + {\tt computationalCount}, {\tt exclusiveCount} ).
   \item [{[name]}]
   Field name.
   \item[{[vm]}]
   If present, the Field object is constructed on the specified
   {\tt ESMF\_VM} object. The default is to construct on the VM of the
   current component context.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from Grid and Fortran array }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateGridData<rank><type><kind>(grid, & 
   farray, indexflag, datacopyflag, staggerloc, & 
   gridToFieldMap, ungriddedLBound, ungriddedUBound, & 
   totalLWidth, totalUWidth, name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Field) :: ESMF_FieldCreateGridData<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Grid), intent(in) :: grid 
   <type> (ESMF_KIND_<kind>),intent(in), target :: farray(<rank>) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_StaggerLoc), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf STATUS:}
   \begin{itemize} 
   \item\apiStatusCompatibleVersion{5.2.0r} 
   \end{itemize} 
   
{\sf DESCRIPTION:\\ }

 
   Create an {\tt ESMF\_Field} from a Fortran data array and {\tt ESMF\_Grid}. 
   The Fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating 
   the retrieved data pointer is not allowed. 
   For examples and 
   associated documentation regarding this method see section 
   \ref{sec:field:usage:create_2darray}, 
   \ref{sec:field:usage:create_2dgrid_3dptr}, 
   \ref{sec:field:usage:create_2dgrid_3dptr_map}, 
   \ref{sec:field:usage:create_2dgrid_3dptr_map_halo}, and 
   \ref{sec:field:usage:create_5dgrid_7dptr_2dungridded}. 
   
   The arguments are: 
   \begin{description} 
   \item [grid] 
   {\tt ESMF\_Grid} object. 
   \item [farray] 
   Native Fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the {\tt farray}. 
   \item[indexflag] 
   Indicate how DE-local indices are defined. See section 
   \ref{const:indexflag} for a list of valid indexflag options. 
   Currently it is erroneous to specify an indexflag 
   different from the one stored in the {\tt ESMF\_Grid} object. 
   \item [{[datacopyflag]}] 
   Whether to copy the contents of the {\tt farray} or reference it directly. 
   For valid values see \ref{const:datacopyflag}. The default is 
   {\tt ESMF\_DATACOPY\_REFERENCE}. 
   \item [{[staggerloc]}] 
   Stagger location of data in grid cells. For valid 
   predefined values see section \ref{const:staggerloc}. 
   To create a custom stagger location see section 
   \ref{sec:usage:staggerloc:adv}. The default 
   value is {\tt ESMF\_STAGGERLOC\_CENTER}. 
   \item [{[gridToFieldMap]}] 
   List with number of elements equal to the 
   {\tt grid}'s dimCount. The list elements map each dimension 
   of the {\tt grid} to a dimension in the {\tt farray} by 
   specifying the appropriate {\tt farray} dimension index. The default is to 
   map all of the {\tt grid}'s dimensions against the lowest dimensions of 
   the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
   The values of all {\tt gridToFieldMap} entries must be greater than or equal 
   to one and smaller than or equal to the {\tt farray} rank. 
   It is erroneous to specify the same {\tt gridToFieldMap} entry 
   multiple times. The total ungridded dimensions in the {\tt field} 
   are the total {\tt farray} dimensions less 
   the total (distributed + undistributed) dimensions in 
   the {\tt grid}. Ungridded dimensions must be in the same order they are 
   stored in the {\t farray}. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the {\tt ESMF\_ArrayRedist()} operation. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the {\tt gridToFieldMap} indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   \item [{[ungriddedLBound]}] 
   Lower bounds of the ungridded dimensions of the {\tt field}. 
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded 
   dimensions in the {\tt field}. All ungridded dimensions of the 
   {\tt field} are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the {\tt farray}. 
   \item [{[ungriddedUBound]}] 
   Upper bounds of the ungridded dimensions of the {\tt field}. 
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded 
   dimensions in the {\tt field}. All ungridded dimensions of the 
   {\tt field} are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the {\tt farray}. 
   \item [{[totalLWidth]}] 
   Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the {\tt farray}. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the {\tt farray}. That is, for each gridded dimension the 
   {\tt farray} size should be max( {\tt totalLWidth} + {\tt totalUWidth} 
   + {\tt computationalCount}, {\tt exclusiveCount} ). 
   \item [{[totalUWidth]}] 
   Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the {\tt farray}. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the {\tt farray}. That is, for each gridded dimension the 
   {\tt farray} size should max( {\tt totalLWidth} + {\tt totalUWidth} 
   + {\tt computationalCount}, {\tt exclusiveCount} ). 
   \item [{[name]}] 
   Field name. 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from Grid and Fortran array pointer }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateGridDataPtr<rank><type><kind>(grid, & 
   farrayPtr, datacopyflag, staggerloc, gridToFieldMap, & 
   totalLWidth, totalUWidth, name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Field) :: ESMF_FieldCreateGridDataPtr<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Grid), intent(in) :: grid 
   <type> (ESMF_KIND_<kind>), pointer :: farrayPtr(<rank>) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_StaggerLoc), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf STATUS:}
   \begin{itemize} 
   \item\apiStatusCompatibleVersion{5.2.0r} 
   \end{itemize} 
   
{\sf DESCRIPTION:\\ }

 
   Create an {\tt ESMF\_Field} from a Fortran data pointer and {\tt ESMF\_Grid}. 
   The Fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when 
   datacopyflag is {\tt ESMF\_DATACOPY\_REFERENCE}. Note that the {\tt ESMF\_FieldDestroy} call does not 
   deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. 
   
   For examples and 
   associated documentation regarding this method see section 
   \ref{sec:field:usage:create_2dptr}, 
   \ref{sec:field:usage:create_2dgrid_3dptr}, 
   \ref{sec:field:usage:create_2dgrid_3dptr_map}, 
   \ref{sec:field:usage:create_2dgrid_3dptr_map_halo}, and 
   \ref{sec:field:usage:create_5dgrid_7dptr_2dungridded}. 
   
   The arguments are: 
   \begin{description} 
   \item [grid] 
   {\tt ESMF\_Grid} object. 
   \item [farrayPtr] 
   Native Fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the {\tt farrayPtr}. 
   \item [{[datacopyflag]}] 
   Whether to copy the contents of the {\tt farrayPtr} or reference it directly. 
   For valid values see \ref{const:datacopyflag}. The default is 
   {\tt ESMF\_DATACOPY\_REFERENCE}. 
   \item [{[staggerloc]}] 
   Stagger location of data in grid cells. For valid 
   predefined values see section \ref{const:staggerloc}. 
   To create a custom stagger location see section 
   \ref{sec:usage:staggerloc:adv}. The default 
   value is {\tt ESMF\_STAGGERLOC\_CENTER}. 
   \item [{[gridToFieldMap]}] 
   List with number of elements equal to the 
   {\tt grid}'s dimCount. The list elements map each dimension 
   of the {\tt grid} to a dimension in the {\tt farrayPtr} by 
   specifying the appropriate {\tt farrayPtr} dimension index. The default is to 
   map all of the {\tt grid}'s dimensions against the lowest dimensions of 
   the {\tt farrayPtr} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
   The values of all {\tt gridToFieldMap} entries must be greater than or equal 
   to one and smaller than or equal to the {\tt farrayPtr} rank. 
   It is erroneous to specify the same {\tt gridToFieldMap} entry 
   multiple times. The total ungridded dimensions in the {\tt field} 
   are the total {\tt farrayPtr} dimensions less 
   the total (distributed + undistributed) dimensions in 
   the {\tt grid}. Ungridded dimensions must be in the same order they are 
   stored in the {\t farrayPtr}. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the {\tt ESMF\_ArrayRedist()} operation. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the {\tt gridToFieldMap} indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   \item [{[totalLWidth]}] 
   Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the {\tt farrayPtr}. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the {\tt farrayPtr}. That is, for each gridded dimension the 
   {\tt farrayPtr} size should be max( {\tt totalLWidth} + {\tt totalUWidth} 
   + {\tt computationalCount}, {\tt exclusiveCount} ). 
   \item [{[totalUWidth]}] 
   Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the {\tt farrayPtr}. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the {\tt farrayPtr}. That is, for each gridded dimension the 
   {\tt farrayPtr} size should max( {\tt totalLWidth} + {\tt totalUWidth} 
   + {\tt computationalCount}, {\tt exclusiveCount} ). 
   \item [{[name]}] 
   Field name. 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from LocStream and typekind}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateLSTKR(locstream, typekind, &
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateLSTKR\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_LocStream), intent(in) :: locstream
     type(ESMF_TypeKind_Flag),intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field} and allocate space internally for an
   {\tt ESMF\_Array}. Return a new {\tt ESMF\_Field}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_locs_tkr}.
  
   The arguments are:
   \begin{description}
   \item [locstream]
   {\tt ESMF\_LocStream} object.
   \item[typekind]
   The typekind of the Field. See section \ref{const:typekind}
   for a list of valid typekind options.
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the LocStream dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   LocStream dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[name]}]
   Field name.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from LocStream and ArraySpec}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateLSArraySpec(locstream, arrayspec, &
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateLSArraySpec\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_LocStream), intent(in) :: locstream
     type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field} and allocate space internally for an
   {\tt ESMF\_Array}. Return a new {\tt ESMF\_Field}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_locs_arrayspec}.
  
   The arguments are:
   \begin{description}
   \item [locstream]
   {\tt ESMF\_LocStream} object.
   \item [arrayspec]
   Data type and kind specification.
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the LocStream dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   LocStream dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[name]}]
   Field name.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from LocStream and Array}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateLSArray(locstream, array, &
     datacopyflag, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateLSArray\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_LocStream), intent(in) :: locstream
     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len = *), intent(in), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field}. This version of creation
   assumes the data exists already and is being
   passed in through an {\tt ESMF\_Array}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_grid_array}.
  
   The arguments are:
   \begin{description}
   \item [locstream]
   {\tt ESMF\_LocStream} object.
   \item [array]
   {\tt ESMF\_Array} object.
   \item [{[datacopyflag]}]
   Indicates whether to copy the contents of the {\tt array} or reference it directly.
   For valid values see \ref{const:datacopyflag}. The default is
   {\tt ESMF\_DATACOPY\_REFERENCE}.
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the LocStream dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   LocStream dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[name]}]
   Field name.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from LocStream and Fortran array }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateLSData<rank><type><kind>(locstream, farray, & 
   indexflag, datacopyflag, gridToFieldMap, ungriddedLBound, & 
   ungriddedUBound, name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Field) :: ESMF_FieldCreateLSData<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_LocStream), intent(in) :: locstream 
   <type> (ESMF_KIND_<kind>),intent(in), target :: farray(<rank>) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   \begin{sloppypar} 
   Create an {\tt ESMF\_Field} from a Fortran data array and {\tt ESMF\_LocStream}. 
   The Fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating 
   the retrieved data pointer is not allowed. 
   \end{sloppypar} 
   
   The arguments are: 
   \begin{description} 
   \item [locstream] 
   {\tt ESMF\_LocStream} object. 
   \item [farray] 
   Native Fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the {\tt farray}. 
   \item[indexflag] 
   Indicate how DE-local indices are defined. See section 
   \ref{const:indexflag} for a list of valid indexflag options. 
   \item [{[datacopyflag]}] 
   Whether to copy the contents of the {\tt farray} or reference directly. 
   For valid values see \ref{const:datacopyflag}. The default is 
   {\tt ESMF\_DATACOPY\_REFERENCE}. 
   \item [{[gridToFieldMap]}] 
   List with number of elements equal to the 
   {\tt locstream}'s dimCount. The list elements map each dimension 
   of the {\tt locstream} to a dimension in the {\tt farray} by 
   specifying the appropriate {\tt farray} dimension index. The default is to 
   map all of the {\tt locstream}'s dimensions against the lowest dimensions of 
   the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
   The values of all {\tt gridToFieldMap} entries must be greater than or equal 
   to one and smaller than or equal to the {\tt farray} rank. 
   It is erroneous to specify the same {\tt gridToFieldMap} entry 
   multiple times. The total ungridded dimensions in the {\tt field} 
   are the total {\tt farray} dimensions less 
   the total (distributed + undistributed) dimensions in 
   the {\tt locstream}. Unlocstreamded dimensions must be in the same order they are 
   stored in the {\t farray}. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the {\tt ESMF\_ArrayRedist()} operation. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the {\tt gridToFieldMap} indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   \item [{[ungriddedLBound]}] 
   Lower bounds of the ungridded dimensions of the {\tt field}. 
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded 
   dimensions in the {\tt field}. All ungridded dimensions of the 
   {\tt field} are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the {\tt farray}. 
   \item [{[ungriddedUBound]}] 
   Upper bounds of the ungridded dimensions of the {\tt field}. 
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded 
   dimensions in the {\tt field}. All ungridded dimensions of the 
   {\tt field} are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the {\tt farray}. 
   \item [{[name]}] 
   Field name. 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from LocStream and Fortran array pointer }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateLSDataPtr<rank><type><kind>(locstream, & 
   farrayPtr, datacopyflag, gridToFieldMap, & 
   name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Field) :: ESMF_FieldCreateLSDataPtr<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_LocStream), intent(in) :: locstream 
   <type> (ESMF_KIND_<kind>),pointer :: farrayPtr(<rank>) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   \begin{sloppypar} 
   Create an {\tt ESMF\_Field} from a Fortran data pointer and {\tt ESMF\_LocStream}. 
   The Fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when 
   datacopyflag is {\tt ESMF\_DATACOPY\_REFERENCE}. Note that the {\tt ESMF\_FieldDestroy} call does not 
   deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. 
   \end{sloppypar} 
   
   The arguments are: 
   \begin{description} 
   \item [locstream] 
   {\tt ESMF\_LocStream} object. 
   \item [farrayPtr] 
   Native Fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the {\tt farrayPtr}. 
   \item [{[datacopyflag]}] 
   Whether to copy the contents of the {\tt farrayPtr} or reference it directly. 
   For valid values see \ref{const:datacopyflag}. The default is 
   {\tt ESMF\_DATACOPY\_REFERENCE}. 
   \item [{[gridToFieldMap]}] 
   List with number of elements equal to the 
   {\tt locstream}'s dimCount. The list elements map each dimension 
   of the {\tt locstream} to a dimension in the {\tt farrayPtr} by 
   specifying the appropriate {\tt farrayPtr} dimension index. The default is to 
   map all of the {\tt locstream}'s dimensions against the lowest dimensions of 
   the {\tt farrayPtr} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
   The values of all {\tt gridToFieldMap} entries must be greater than or equal 
   to one and smaller than or equal to the {\tt farrayPtr} rank. 
   It is erroneous to specify the same {\tt gridToFieldMap} entry 
   multiple times. The total ungridded dimensions in the {\tt field} 
   are the total {\tt farrayPtr} dimensions less 
   the total (distributed + undistributed) dimensions in 
   the {\tt locstream}. Unlocstreamded dimensions must be in the same order they are 
   stored in the {\t farrayPtr}. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the {\tt ESMF\_ArrayRedist()} operation. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the {\tt gridToFieldMap} indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   \item [{[name]}] 
   Field name. 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from Mesh and typekind}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateMeshTKR(mesh, typekind, &
     indexflag, meshloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateMeshTKR\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Mesh), intent(in) :: mesh
     type(ESMF_TypeKind_Flag), intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag), intent(in), optional :: indexflag
     type(ESMF_MeshLoc), intent(in), optional :: meshloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field} and allocate space internally for an
   {\tt ESMF\_Array}. Return a new {\tt ESMF\_Field}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_mesh_tkr}.
  
   The arguments are:
   \begin{description}
   \item [mesh]
   {\tt ESMF\_Mesh} object.
   \item [typekind]
   The typekind of the Field. See section \ref{const:typekind}
   for a list of valid typekind options.
   \item [{[indexflag]}]
   Indicate how DE-local indices are defined. See section
   \ref{const:indexflag} for a list of valid indexflag options.
   \item [{[meshloc]}]
   \begin{sloppypar}
   The part of the Mesh on which to build the Field. For valid
   predefined values see Section~\ref{const:meshloc}.
   If not set, defaults to {\tt ESMF\_MESHLOC\_NODE}.
   \end{sloppypar}
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the Mesh dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   Mesh dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[name]}]
   Field name.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from Mesh and ArraySpec}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateMeshArraySpec(mesh, arrayspec, &
     indexflag, meshloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateMeshArraySpec\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Mesh), intent(in) :: mesh
     type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag),intent(in), optional :: indexflag
     type(ESMF_MeshLoc), intent(in), optional :: meshloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field} and allocate space internally for an
   {\tt ESMF\_Array}. Return a new {\tt ESMF\_Field}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_mesh_arrayspec} and
   \ref{sec:field:usage:createMeshArrayspecOpt}.
  
   The arguments are:
   \begin{description}
   \item [mesh]
   {\tt ESMF\_Mesh} object.
   \item [arrayspec]
   Data type and kind specification.
   \item [{[indexflag]}]
   Indicate how DE-local indices are defined. See section
   \ref{const:indexflag} for a list of valid indexflag options.
   \item [{[meshloc]}]
   \begin{sloppypar}
   The part of the Mesh on which to build the Field. For valid
   predefined values see Section~\ref{const:meshloc}.
   If not set, defaults to {\tt ESMF\_MESHLOC\_NODE}.
   \end{sloppypar}
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the Mesh dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   Mesh dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[name]}]
   Field name.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from Mesh and Array}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateMeshArray(mesh, array, &
     datacopyflag, meshloc, &
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     name, vm, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateMeshArray\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Mesh), intent(in) :: mesh
     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     type(ESMF_MeshLoc), intent(in), optional :: meshloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len = *), intent(in), optional :: name
     type(ESMF_VM), intent(in), optional :: vm
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field}. This version of creation
   assumes the data exists already and is being
   passed in through an {\tt ESMF\_Array}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_mesh_array}.
  
   The arguments are:
   \begin{description}
   \item [mesh]
   {\tt ESMF\_Mesh} object.
   \item [array]
   {\tt ESMF\_Array} object.
   \item [{[datacopyflag]}]
   Indicates whether to copy the contents of the {\tt array} or reference it directly.
   For valid values see \ref{const:datacopyflag}. The default is
   {\tt ESMF\_DATACOPY\_REFERENCE}.
   \item [{[meshloc]}]
   \begin{sloppypar}
   The part of the Mesh on which to build the Field. For valid
   predefined values see Section~\ref{const:meshloc}.
   If not set, defaults to {\tt ESMF\_MESHLOC\_NODE}.
   \end{sloppypar}
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the Mesh dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   Mesh dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[name]}]
   Field name.
   \item[{[vm]}]
   If present, the Field object is constructed on the specified
   {\tt ESMF\_VM} object. The default is to construct on the VM of the
   current component context.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from Mesh and Fortran array }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateMeshData<rank><type><kind>(mesh, & 
   farray, indexflag, datacopyflag, meshloc, & 
   gridToFieldMap, ungriddedLBound, ungriddedUBound, name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Field) :: ESMF_FieldCreateMeshData<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Mesh), intent(in) :: mesh 
   <type> (ESMF_KIND_<kind>),intent(in), target :: farray(<rank>) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_MeshLoc), intent(in), optional :: meshloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Create an {\tt ESMF\_Field} from a Fortran data array and {\tt ESMF\_Mesh}. 
   The Fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating 
   the retrieved data pointer is not allowed. 
   
   The arguments are: 
   \begin{description} 
   \item [mesh] 
   {\tt ESMF\_Mesh} object. 
   \item [farray] 
   Native Fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the {\tt farray}. 
   \item[indexflag] 
   Indicate how DE-local indices are defined. See section 
   \ref{const:indexflag} for a list of valid indexflag options. 
   \item [{[datacopyflag]}] 
   Whether to copy the contents of the {\tt farray} or reference it directly. 
   For valid values see \ref{const:datacopyflag}. The default is 
   {\tt ESMF\_DATACOPY\_REFERENCE}. 
   \item [{[meshloc]}] 
   \begin{sloppypar} 
   The part of the Mesh on which to build the Field. For valid 
   predefined values see Section~\ref{const:meshloc}. 
   If not set, defaults to {\tt ESMF\_MESHLOC\_NODE}. 
   \end{sloppypar} 
   \item [{[gridToFieldMap]}] 
   List with number of elements equal to the 
   {\tt mesh}'s dimCount. The list elements map each dimension 
   of the {\tt mesh} to a dimension in the {\tt farray} by 
   specifying the appropriate {\tt farray} dimension index. The default is to 
   map all of the {\tt mesh}'s dimensions against the lowest dimensions of 
   the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
   The values of all {\tt gridToFieldMap} entries must be greater than or equal 
   to one and smaller than or equal to the {\tt farray} rank. 
   It is erroneous to specify the same {\tt gridToFieldMap} entry 
   multiple times. The total ungridded dimensions in the {\tt field} 
   are the total {\tt farray} dimensions less 
   the total (distributed + undistributed) dimensions in 
   the {\tt mesh}. Unmeshded dimensions must be in the same order they are 
   stored in the {\t farray}. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the {\tt ESMF\_ArrayRedist()} operation. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the {\tt gridToFieldMap} indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   \item [{[ungriddedLBound]}] 
   Lower bounds of the ungridded dimensions of the {\tt field}. 
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded 
   dimensions in the {\tt field}. All ungridded dimensions of the 
   {\tt field} are also undistributed. When field dimension count is 
   greater than mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the {\tt farray}. 
   \item [{[ungriddedUBound]}] 
   Upper bounds of the ungridded dimensions of the {\tt field}. 
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded 
   dimensions in the {\tt field}. All ungridded dimensions of the 
   {\tt field} are also undistributed. When field dimension count is 
   greater than mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the {\tt farray}. 
   \item [{[name]}] 
   Field name. 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from Mesh and Fortran array pointer }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateMeshDataPtr<rank><type><kind>(mesh, & 
   farrayPtr, datacopyflag, meshloc, gridToFieldMap, & 
   name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Field) :: ESMF_FieldCreateMeshDataPtr<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_Mesh), intent(in) :: mesh 
   <type> (ESMF_KIND_<kind>),pointer :: farrayPtr(<rank>) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_MeshLoc), intent(in), optional :: meshloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Create an {\tt ESMF\_Field} from a Fortran data pointer and {\tt ESMF\_Mesh}. 
   The Fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when 
   datacopyflag is {\tt ESMF\_DATACOPY\_REFERENCE}. Note that the {\tt ESMF\_FieldDestroy} call does not 
   deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. 
   
   The arguments are: 
   \begin{description} 
   \item [mesh] 
   {\tt ESMF\_Mesh} object. 
   \item [farrayPtr] 
   Native Fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the {\tt farrayPtr}. 
   \item [{[datacopyflag]}] 
   Whether to copy the contents of the {\tt farrayPtr} or reference it directly. 
   For valid values see \ref{const:datacopyflag}. The default is 
   {\tt ESMF\_DATACOPY\_REFERENCE}. 
   \item [{[meshloc]}] 
   \begin{sloppypar} 
   The part of the Mesh on which to build the Field. For valid 
   predefined values see Section~\ref{const:meshloc}. 
   If not set, defaults to {\tt ESMF\_MESHLOC\_NODE}. 
   \end{sloppypar} 
   \item [{[gridToFieldMap]}] 
   List with number of elements equal to the 
   {\tt mesh}'s dimCount. The list elements map each dimension 
   of the {\tt mesh} to a dimension in the {\tt farrayPtr} by 
   specifying the appropriate {\tt farrayPtr} dimension index. The default is to 
   map all of the {\tt mesh}'s dimensions against the lowest dimensions of 
   the {\tt farrayPtr} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
   The values of all {\tt gridToFieldMap} entries must be greater than or equal 
   to one and smaller than or equal to the {\tt farrayPtr} rank. 
   It is erroneous to specify the same {\tt gridToFieldMap} entry 
   multiple times. The total ungridded dimensions in the {\tt field} 
   are the total {\tt farrayPtr} dimensions less 
   the total (distributed + undistributed) dimensions in 
   the {\tt mesh}. Unmeshded dimensions must be in the same order they are 
   stored in the {\t farrayPtr}. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the {\tt ESMF\_ArrayRedist()} operation. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the {\tt gridToFieldMap} indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   \item [{[name]}] 
   Field name. 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from XGrid and typekind}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateXGTKR(xgrid, typekind, &
     xgridside, gridindex, &
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateXGTKR\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_XGrid), intent(in) :: xgrid
     type(ESMF_TypeKind_Flag), intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside
     integer, intent(in), optional :: gridindex
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field} and allocate space internally for an
   {\tt ESMF\_Array}. Return a new {\tt ESMF\_Field}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_locs_tkr}.
  
   The arguments are:
   \begin{description}
   \item [xgrid]
   {\tt ESMF\_XGrid} object.
   \item[typekind]
   The typekind of the Field. See section \ref{const:typekind}
   for a list of valid typekind options.
   \item [{[xgridside]}]
   Which side of the XGrid to create the Field on (either ESMF\_XGRIDSIDE\_A,
   ESMF\_XGRIDSIDE\_B, or ESMF\_XGRIDSIDE\_BALANCED). If not passed in then
   defaults to ESMF\_XGRIDSIDE\_BALANCED.
   \item [{[gridindex]}]
   If xgridSide is ESMF\_XGRIDSIDE\_A or ESMF\_XGRIDSIDE\_B then this index tells which Grid on
   that side to create the Field on. If not provided, defaults to 1.
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the XGrid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   XGrid dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[name]}]
   Field name.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from XGrid and ArraySpec}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateXGArraySpec(xgrid, arrayspec, &
     xgridside, gridindex, &
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateXGArraySpec\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_XGrid), intent(in) :: xgrid
     type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_XGridSide_Flag), intent(in), optional :: xgridSide
     integer, intent(in), optional :: gridIndex
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field} and allocate space internally for an
   {\tt ESMF\_Array}. Return a new {\tt ESMF\_Field}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_locs_arrayspec}.
  
   The arguments are:
   \begin{description}
   \item [xgrid]
   {\tt ESMF\_XGrid} object.
   \item [arrayspec]
   Data type and kind specification.
   \item [{[xgridside]}]
   Which side of the XGrid to create the Field on (either ESMF\_XGRIDSIDE\_A,
   ESMF\_XGRIDSIDE\_B, or ESMF\_XGRIDSIDE\_BALANCED). If not passed in then
   defaults to ESMF\_XGRIDSIDE\_BALANCED.
   \item [{[gridindex]}]
   If xgridside is ESMF\_XGRIDSIDE\_A or ESMF\_XGRIDSIDE\_B then this index tells which Grid on
   that side to create the Field on. If not provided, defaults to 1.
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the XGrid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   XGrid dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[name]}]
   Field name.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from XGrid and Array}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateXGArray(xgrid, array, &
     datacopyflag, xgridside, gridindex, &
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &
     name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Field) :: ESMF_FieldCreateXGArray\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_XGrid), intent(in) :: xgrid
     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside
     integer, intent(in), optional :: gridindex
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len = *), intent(in), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_Field}. This version of creation
   assumes the data exists already and is being
   passed in through an {\tt ESMF\_Array}. For an example and
   associated documentation using this method see section
   \ref{sec:field:usage:create_grid_array}.
  
   The arguments are:
   \begin{description}
   \item [xgrid]
   {\tt ESMF\_XGrid} object.
   \item [array]
   {\tt ESMF\_Array} object.
   \item [{[datacopyflag]}]
   Indicates whether to copy the contents of the {\tt array} or reference it directly.
   For valid values see \ref{const:datacopyflag}. The default is
   {\tt ESMF\_DATACOPY\_REFERENCE}.
   \item [{[xgridside]}]
   Which side of the XGrid to create the Field on (either ESMF\_XGRIDSIDE\_A,
   ESMF\_XGRIDSIDE\_B, or ESMF\_XGRIDSIDE\_BALANCED). If not passed in then
   defaults to ESMF\_XGRIDSIDE\_BALANCED.
   \item [{[gridindex]}]
   If xgridSide is ESMF\_XGRIDSIDE\_A or ESMF\_XGRIDSIDE\_B then this index tells which Grid on
   that side to create the Field on. If not provided, defaults to 1.
   \item [{[gridToFieldMap]}]
   List with number of elements equal to the
   {\tt grid}'s dimCount. The list elements map each dimension
   of the {\tt grid} to a dimension in the {\tt field} by
   specifying the appropriate {\tt field} dimension index. The default is to
   map all of the {\tt grid}'s dimensions against the lowest dimensions of
   the {\tt field} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../).
   The values of all {\tt gridToFieldMap} entries must be greater than or equal
   to one and smaller than or equal to the {\tt field} rank.
   It is erroneous to specify the same {\tt gridToFieldMap} entry
   multiple times. The total ungridded dimensions in the {\tt field}
   are the total {\tt field} dimensions less
   the dimensions in
   the {\tt grid}. Ungridded dimensions must be in the same order they are
   stored in the {\t field}.
   If the Field dimCount is less than the XGrid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the {\tt gridToFieldMap} indicates that the particular
   XGrid dimension will be replicating the Field across the DEs along
   this direction.
   \item [{[ungriddedLBound]}]
   Lower bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[ungriddedUBound]}]
   Upper bounds of the ungridded dimensions of the {\tt field}.
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded
   dimensions in the {\tt field}. All ungridded dimensions of the
   {\tt field} are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the {\tt field}.
   \item [{[name]}]
   Field name.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from XGrid and Fortran array }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateXGData<rank><type><kind>(xgrid, & 
   farray, indexflag, datacopyflag, xgridside, gridindex, & 
   gridToFieldMap, ungriddedLBound, ungriddedUBound, name,& 
   rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Field) :: ESMF_FieldCreateXGData<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_XGrid), intent(in) :: xgrid 
   <type> (ESMF_KIND_<kind>), intent(in), target :: farray(<rank>) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside 
   integer, intent(in), optional :: gridindex 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Create an {\tt ESMF\_Field} from a Fortran data array and {\tt ESMF\_Xgrid}. 
   The Fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating 
   the retrieved data pointer is not allowed. 
   
   The arguments are: 
   \begin{description} 
   \item [xgrid] 
   {\tt ESMF\_XGrid} object. 
   \item [farray] 
   Native Fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the {\tt farray}. 
   \item[indexflag] 
   Indicate how DE-local indices are defined. See section 
   \ref{const:indexflag} for a list of valid indexflag options. 
   \item [{[datacopyflag]}] 
   Whether to copy the contents of the {\tt farray} or reference directly. 
   For valid values see \ref{const:datacopyflag}. The default is 
   {\tt ESMF\_DATACOPY\_REFERENCE}. 
   \item [{[xgridside]}] 
   Which side of the XGrid to create the Field on (either ESMF\_XGRIDSIDE\_A, 
   ESMF\_XGRIDSIDE\_B, or ESMF\_XGRIDSIDE\_BALANCED). If not passed in then 
   defaults to ESMF\_XGRIDSIDE\_BALANCED. 
   \item [{[gridindex]}] 
   If xgridside is ESMF\_XGRIDSIDE\_A or ESMF\_XGRIDSIDE\_B then this index tells which Grid on 
   that side to create the Field on. If not provided, defaults to 1. 
   \item [{[gridToFieldMap]}] 
   List with number of elements equal to the 
   {\tt xgrid}'s dimCount. The list elements map each dimension 
   of the {\tt xgrid} to a dimension in the {\tt farray} by 
   specifying the appropriate {\tt farray} dimension index. The default is to 
   map all of the {\tt xgrid}'s dimensions against the lowest dimensions of 
   the {\tt farray} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
   The values of all {\tt gridToFieldMap} entries must be greater than or equal 
   to one and smaller than or equal to the {\tt farray} rank. 
   It is erroneous to specify the same {\tt gridToFieldMap} entry 
   multiple times. The total ungridded dimensions in the {\tt field} 
   are the total {\tt farray} dimensions less 
   the total (distributed + undistributed) dimensions in 
   the {\tt xgrid}. Unxgridded dimensions must be in the same order they are 
   stored in the {\t farray}. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the {\tt ESMF\_ArrayRedist()} operation. 
   If the Field dimCount is less than the Xgrid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the {\tt gridToFieldMap} indicates that the particular 
   Xgrid dimension will be replicating the Field across the DEs along 
   this direction. 
   \item [{[ungriddedLBound]}] 
   Lower bounds of the ungridded dimensions of the {\tt field}. 
   The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded 
   dimensions in the {\tt field}. All ungridded dimensions of the 
   {\tt field} are also undistributed. When field dimension count is 
   greater than xgrid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the {\tt farray}. 
   \item [{[ungriddedUBound]}] 
   Upper bounds of the ungridded dimensions of the {\tt field}. 
   The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded 
   dimensions in the {\tt field}. All ungridded dimensions of the 
   {\tt field} are also undistributed. When field dimension count is 
   greater than xgrid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the {\tt farray}. 
   \item [{[name]}] 
   Field name. 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldCreate] {ESMF\_FieldCreate - Create a Field from XGrid and Fortran array pointer }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateXGDataPtr<rank><type><kind>(xgrid, farrayPtr, & 
   datacopyflag, xgridside, & 
   gridindex, gridToFieldMap, name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_Field) :: ESMF_FieldCreateXGDataPtr<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_XGrid), intent(in) :: xgrid 
   <type> (ESMF_KIND_<kind>), pointer :: farrayPtr(<rank>) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside 
   integer, intent(in), optional :: gridindex 
   integer, intent(in), optional :: gridToFieldMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Create an {\tt ESMF\_Field} from a Fortran data pointer and {\tt ESMF\_Xgrid}. 
   The Fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when 
   datacopyflag is {\tt ESMF\_DATACOPY\_REFERENCE}. Note that the {\tt ESMF\_FieldDestroy} call does not 
   deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. 
   
   The arguments are: 
   \begin{description} 
   \item [xgrid] 
   {\tt ESMF\_XGrid} object. 
   \item [farrayPtr] 
   Native Fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the {\tt farrayPtr}. 
   \item [{[datacopyflag]}] 
   Whether to copy the contents of the {\tt farrayPtr} or reference it directly. 
   For valid values see \ref{const:datacopyflag}. The default is 
   {\tt ESMF\_DATACOPY\_REFERENCE}. 
   \item [{[xgridside]}] 
   Which side of the XGrid to create the Field on (either ESMF\_XGRIDSIDE\_A, 
   ESMF\_XGRIDSIDE\_B, or ESMF\_XGRIDSIDE\_BALANCED). If not passed in then 
   defaults to ESMF\_XGRIDSIDE\_BALANCED. 
   \item [{[gridindex]}] 
   If xgridside is ESMF\_XGRIDSIDE\_A or ESMF\_XGRIDSIDE\_B then this index tells which Grid on 
   that side to create the Field on. If not provided, defaults to 1. 
   \item [{[gridToFieldMap]}] 
   List with number of elements equal to the 
   {\tt xgrid}'s dimCount. The list elements map each dimension 
   of the {\tt xgrid} to a dimension in the {\tt farrayPtr} by 
   specifying the appropriate {\tt farrayPtr} dimension index. The default is to 
   map all of the {\tt xgrid}'s dimensions against the lowest dimensions of 
   the {\tt farrayPtr} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
   The values of all {\tt gridToFieldMap} entries must be greater than or equal 
   to one and smaller than or equal to the {\tt farrayPtr} rank. 
   It is erroneous to specify the same {\tt gridToFieldMap} entry 
   multiple times. The total ungridded dimensions in the {\tt field} 
   are the total {\tt farrayPtr} dimensions less 
   the total (distributed + undistributed) dimensions in 
   the {\tt xgrid}. Unxgridded dimensions must be in the same order they are 
   stored in the {\t farrayPtr}. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the {\tt ESMF\_ArrayRedist()} operation. 
   If the Field dimCount is less than the Xgrid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the {\tt gridToFieldMap} indicates that the particular 
   Xgrid dimension will be replicating the Field across the DEs along 
   this direction. 
   \item [{[name]}] 
   Field name. 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldDestroy] {ESMF\_FieldDestroy - Release resources associated with a Field}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldDestroy(field, noGarbage, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Field), intent(inout) :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: noGarbage
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.0.0] Added argument {\tt noGarbage}.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Destroys the {\tt ESMF\_Field}, releasing the resources associated with
   the object.
  
   If an {\tt ESMF\_Grid} is associated with {\tt field}, it will not be
   released.
  
   By default a small remnant of the object is kept in memory in order to
   prevent problems with dangling aliases. The default garbage collection
   mechanism can be overridden with the {\tt noGarbage} argument.
  
   The arguments are:
   \begin{description}
   \item[field]
   {\tt ESMF\_Field} object.
   \item[{[noGarbage]}]
   If set to {\tt .TRUE.} the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases -- a situation which may lead to hard to debug
   application crashes.
  
   It is generally recommended to leave the {\tt noGarbage} argument
   set to {\tt .FALSE.} (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully
   removing the entire temporary object from memory.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
