%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_FieldRegrid.F90,  Date: Tue May  5 21:00:00 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_FieldRegrid] {ESMF\_FieldRegrid - Compute a regridding operation}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldRegrid(srcField, dstField, routehandle, &
     zeroregion, termorderflag, checkflag, dynamicMask, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Field),               intent(in),    optional :: srcField
       type(ESMF_Field),               intent(inout), optional :: dstField
       type(ESMF_RouteHandle),         intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Region_Flag),         intent(in),    optional :: zeroregion
       type(ESMF_TermOrder_Flag),      intent(in),    optional :: termorderflag
       logical,                        intent(in),    optional :: checkflag
       type(ESMF_DynamicMask), target, intent(in),    optional :: dynamicMask
       integer,                        intent(out),   optional :: rc \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[6.1.0] Added argument {\tt termorderflag}.
                The new argument gives the user control over the order in which
                the src terms are summed up.
   \item[7.1.0r] Added argument {\tt dynamicMask}.
                The new argument supports the dynamic masking feature.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Execute the precomputed regrid operation stored in {\tt routehandle} to 
     interpolate from {\tt srcField} to {\tt dstField}.  See {\tt ESMF\_FieldRegridStore()} on how to 
     precompute the {\tt routehandle}. 
    
     \begin{sloppypar}
     Both {\tt srcField} and {\tt dstField} must match the respective Fields
     used during {\tt ESMF\_FieldRegridStore()} in {\em type}, {\em kind}, and 
     memory layout of the {\em gridded} dimensions. However, the size, number, 
     and index order of {\em ungridded} dimensions may be different. See section
     \ref{RH:Reusability} for a more detailed discussion of RouteHandle 
     reusability.
     \end{sloppypar}
  
     The {\tt srcField} and {\tt dstField} arguments are optional in support of
     the situation where {\tt srcField} and/or {\tt dstField} are not defined on
     all PETs. The {\tt srcField} and {\tt dstField} must be specified on those
     PETs that hold source or destination DEs, respectively, but may be omitted
     on all other PETs. PETs that hold neither source nor destination DEs may
     omit both arguments.
  
     It is erroneous to specify the identical Field object for {\tt srcField} and
     {\tt dstField} arguments.
  
     This call is {\em collective} across the current VM.
  
     \begin{description}
     \item [{[srcField]}]
       {\tt ESMF\_Field} with source data.
     \item [{[dstField]}]
       {\tt ESMF\_Field} with destination data.
     \item [routehandle]
       Handle to the precomputed Route.
     \item [{[zeroregion]}]
       \begin{sloppypar}
       If set to {\tt ESMF\_REGION\_TOTAL} {\em (default)} the total regions of
       all DEs in {\tt dstField} will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       {\tt ESMF\_REGION\_EMPTY} the elements in {\tt dstField} will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting {\tt zeroregion} to 
       {\tt ESMF\_REGION\_SELECT} will only zero out those elements in the 
       destination Array that will be updated by the sparse matrix
       multiplication. See section \ref{const:region} for a complete list of
       valid settings.
       \end{sloppypar}
     \item [{[termorderflag]}]
       Specifies the order of the source side terms in all of the destination
       sums. The {\tt termorderflag} only affects the order of terms during 
       the execution of the RouteHandle. See the \ref{RH:bfb} section for an
       in-depth discussion of {\em all} bit-for-bit reproducibility
       aspects related to route-based communication methods.
       See \ref{const:termorderflag} for a full list of options.
       The default setting depends on whether the {\tt dynamicMask} argument
       is present or not. With {\tt dynamicMask} argument present, the default
       of {\tt termorderflag} is {\tt ESMF\_TERMORDER\_SRCSEQ}. This ensures
       that {\tt all} source terms are present on the destination side, and 
       the interpolation can be calculated as a single sum. When 
       {\tt dynamicMask} is absent, the default of {\tt termorderflag} is
       {\tt ESMF\_TERMORDER\_FREE}, allowing maximum flexibility and partial 
       sums for optimum performance.
     \item [{[checkflag]}]
       If set to {\tt .TRUE.} the input Array pair will be checked for
       consistency with the precomputed operation provided by {\tt routehandle}.
       If set to {\tt .FALSE.} {\em (default)} only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       {\tt checkflag} to {\tt .FALSE.} to achieve highest performance.
     \item [{[dynamicMask]}]
       Object holding dynamic masking information.
       See section \ref{RH:DynMask} for a discussion of dynamic masking.
     \item [{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description} 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldRegridRelease] {ESMF\_FieldRegridRelease - Free resources used by a regridding operation}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_FieldRegridRelease(routehandle, &
         noGarbage, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,                intent(in),  optional :: noGarbage
       integer,                intent(out), optional :: rc \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[8.0.0] Added argument {\tt noGarbage}.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Free resources used by regrid objec
  
       The arguments are:
       \begin{description}
       \item [routehandle]
             Handle carrying the sparse matrix
       \item[{[noGarbage]}]
       If set to {\tt .TRUE.} the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases -- a situation which may lead to hard to debug 
       application crashes.
   
       It is generally recommended to leave the {\tt noGarbage} argument
       set to {\tt .FALSE.} (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully 
       removing the entire temporary object from memory.
       \item [{[rc]}]
             Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldRegridStore] {ESMF\_FieldRegridStore - Precompute a Field regridding operation and return a RouteHandle and weights}


   \label{api:esmf_fieldregridstorenx}
\bigskip{\sf INTERFACE:}
\begin{verbatim}   !   Private name; call using ESMF_FieldRegridStore()
       subroutine ESMF_FieldRegridStoreNX(srcField, dstField, &
                     srcMaskValues, dstMaskValues, &
                     regridmethod, &
                     polemethod, regridPoleNPnts, & 
                     lineType, &
                     normType, &
                     extrapMethod, &
                     extrapNumSrcPnts, &
                     extrapDistExponent, &
                     extrapNumLevels, &
                     unmappedaction, ignoreDegenerate, &
                     srcTermProcessing, & 
                     pipeLineDepth, &
                     routehandle, &
                     factorList, factorIndexList, & 
                     weights, indices, &  ! DEPRECATED ARGUMENTS
                     srcFracField, dstFracField, &
                     dstStatusField, &
                     unmappedDstList, &
                     rc)
        \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Field),               intent(in)              :: srcField
       type(ESMF_Field),               intent(inout)           :: dstField
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),          intent(in),    optional :: srcMaskValues(:)
       integer(ESMF_KIND_I4),         intent(in),    optional :: dstMaskValues(:)
       type(ESMF_RegridMethod_Flag),   intent(in),    optional :: regridmethod
       type(ESMF_PoleMethod_Flag),     intent(in),    optional :: polemethod
       integer,                        intent(in),    optional :: regridPoleNPnts
       type(ESMF_LineType_Flag),       intent(in),    optional :: lineType
       type(ESMF_NormType_Flag),       intent(in),    optional :: normType
       type(ESMF_ExtrapMethod_Flag),   intent(in),    optional :: extrapMethod
       integer,                        intent(in),    optional :: extrapNumSrcPnts
       real(ESMF_KIND_R4),             intent(in),    optional :: extrapDistExponent
       integer,                        intent(in),    optional :: extrapNumLevels
       type(ESMF_UnmappedAction_Flag), intent(in),    optional :: unmappedaction
       logical,                        intent(in),    optional :: ignoreDegenerate
       integer,                        intent(inout), optional :: srcTermProcessing
       integer,                        intent(inout), optional :: pipeLineDepth
       type(ESMF_RouteHandle),         intent(inout), optional :: routehandle
       real(ESMF_KIND_R8),             pointer,       optional :: factorList(:)
       integer(ESMF_KIND_I4),          pointer,       optional :: factorIndexList(:,:)
       real(ESMF_KIND_R8),    pointer, optional :: weights(:)   ! DEPRECATED ARG
       integer(ESMF_KIND_I4), pointer, optional :: indices(:,:) ! DEPRECATED ARG
       type(ESMF_Field),               intent(inout), optional :: srcFracField
       type(ESMF_Field),               intent(inout), optional :: dstFracField
       type(ESMF_Field),               intent(inout), optional :: dstStatusField
       integer(ESMF_KIND_I4),          pointer,       optional :: unmappedDstList(:)
       integer,                        intent(out),   optional :: rc \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[5.2.0rp1] Added arguments {\tt factorList} and {\tt factorIndexList}.
                   Started to deprecate arguments {\tt weights} and {\tt indices}.
                   This corrects an inconsistency of this interface with all
                   other ESMF methods that take these same arguments.
   \item[6.1.0] Added arguments {\tt ignoreDegenerate}, {\tt srcTermProcessing},
                {\tt pipelineDepth}, and {\tt unmappedDstList}.
                The argument {\tt ignoreDegenerate} allows the user to skip degenerate
                cells in the regridding instead of stopping with an error.
                The two arguments {\tt srcTermProcessing} and {\tt pipelineDepth}
                provide access to the tuning parameters affecting the sparse matrix
                execution. The argument {\tt unmappedDstList} allows the user to
                get a list of the destination items which the regridding couldn't
                map to a source.
   \item[6.3.0r] Added argument {\tt lineType}. This argument allows the user to
                 control the path of the line between two points on a sphere surface.
                 This allows the user to use their preferred line path for the calculation
                 of distances and the shape of cells during regrid weight calculation on
                 a sphere.
   \item[6.3.0rp1] Added argument {\tt normType}. This argument allows the user to
                 control the type of normalization done during conservative weight generation.
   \item[7.1.0r] Added argument {\tt dstStatusField}. This argument allows the user to
                receive information about what happened to each location in the destination
                Field during regridding.
  
                Added arguments {\tt extrapMethod}, {\tt extrapNumSrcPnts}, and
                {\tt extrapDistExponent}. These three new extrapolation arguments allow the 
                user to extrapolate destination points not mapped by the regrid method. 
                {\tt extrapMethod} allows the user to choose the extrapolation method.
                {\tt extrapNumSrcPnts} and {\tt extrapDistExponent} are parameters that
                allow the user to tune the behavior of the {\tt ESMF\_EXTRAPMETHOD\_NEAREST\_IDAVG} 
                method.
   \item[8.0.0] Added argument {\tt extrapNumLevels}. For level based extrapolation methods
                (e.g. {\tt ESMF\_EXTRAPMETHOD\_CREEP}) this argument allows the user to
                set how many levels to extrapolate. 
                
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


         \begin{sloppypar}
         Creates a sparse matrix operation (stored in {\tt routehandle}) that 
         contains the calculations and communications necessary to interpolate
         from {\tt srcField} to {\tt dstField}. The routehandle can then be 
         used in the call {\tt ESMF\_FieldRegrid()} to interpolate between the
         Fields. The user may also get the interpolation matrix in sparse 
         matrix form via the optional arguments {\tt factorList} and {\tt factorIndexList}. 
         \end{sloppypar}
         
         The routehandle generated by this call is based just on the 
         coordinates in the Grids or Meshes contained in the Fields.  If those
         coordinates don't change the routehandle can
         be used repeatedly to interpolate from the source Field to the 
         destination Field.  This is true even if the data in the Fields 
         changes. The routehandle may also be used to interpolate between any
         source and destination Field which are created on the same location 
         in the same Grid, LocStream, or Mesh as the original Fields.        
  
         When it's no longer needed the routehandle should be destroyed by 
         using {\tt ESMF\_FieldRegridRelease()} to free the memory it's using. 
  
         Note, as a side effect, that this call may change the data in {\tt dstField}. If
         this is undesirable, then an easy work around is to create a second temporary field
         with the same structure as {\tt dstField} and pass that in instead. 
  
       The arguments are:
       \begin{description}
       \item [srcField]
             Source Field.
       \item [dstField]
             Destination Field. The data in this Field may be overwritten by this call. 
       \item [{[srcMaskValues]}]
             Mask information can be set in the Grid (see~\ref{sec:usage:items}) or Mesh (see~\ref{sec:mesh:mask}) 
             upon which the {\tt srcField} is built. The {\tt srcMaskValues} argument specifies the values in that 
             mask information which indicate a source point should be masked out. In other words, a locati on is masked if and only if the
             value for that location in the mask information matches one of the values listed in {\tt srcMaskValues}.  
             If {\tt srcMaskValues} is not specified, no masking will occur. 
       \item [{[dstMaskValues]}]
             Mask information can be set in the Grid (see~\ref{sec:usage:items}) or Mesh (see~\ref{sec:mesh:mask}) 
             upon which the {\tt dstField} is built. The {\tt dstMaskValues} argument specifies the values in that 
             mask information which indicate a destination point should be masked out. In other words, a location is masked if and only if the
             value for that location in the mask information matches one of the values listed in {\tt dstMaskValues}.  
             If {\tt dstMaskValues} is not specified, no masking will occur. 
       \item [{[regridmethod]}]
             The type of interpolation. Please see Section~\ref{opt:regridmethod} 
             for a list of valid options. If not specified, defaults to 
             {\tt ESMF\_REGRIDMETHOD\_BILINEAR}.
       \item [{[polemethod]}]
             Specifies the type of pole
             to construct on the source Grid during regridding. Please see 
             Section~\ref{const:polemethod} for a list of
             valid options. If not specified, defaults to {\tt ESMF\_POLEMETHOD\_ALLAVG} for non-conservative regrid methods, 
             and {\tt ESMF\_POLEMETHOD\_NONE} for conservative methods.
       \item [{[regridPoleNPnts]}]
             If {\tt polemethod} is {\tt ESMF\_POLEMETHOD\_NPNTAVG},
             then this parameter indicates the number of points over which to average.
             If {\tt polemethod} is not {ESMF\_POLEMETHOD\_NPNTAVG} and {\tt regridPoleNPnts} is specified, 
             then it will be ignored.  
             This subroutine will return an error if {\tt polemethod} is {ESMF\_POLEMETHOD\_NPNTAVG} and 
             {\tt regridPoleNPnts} is not specified. 
       \item [{[lineType]}]
             This argument controls the path of the line which connects two points on a sphere surface. This in
             turn controls the path along which distances are calculated and the shape of the edges that make
             up a cell. Both of these quantities can influence how interpolation weights are calculated.
             As would be expected, this argument is only applicable when {\tt srcField} and {\tt dstField} are
             built on grids which lie on the surface of a sphere. Section~\ref{opt:lineType} shows a 
             list of valid options for this argument. If not specified, the default depends on the 
             regrid method. Section~\ref{opt:lineType} has the defaults by line type. Figure~\ref{line_type_support} shows
             which line types are supported for each regrid method as well as showing the default line type by regrid method.  
       \item [{[normType]}] 
             This argument controls the type of normalization used when generating conservative weights. This option
             only applies to weights generated with {\tt regridmethod=ESMF\_REGRIDMETHOD\_CONSERVE} or  {\tt regridmethod=ESMF\_REGRIDMETHOD\_CONSERVE\_2ND}
             Please see  Section~\ref{opt:normType} for a 
             list of valid options. If not specified {\tt normType} defaults to {\tt ESMF\_NORMTYPE\_DSTAREA}. 
       \item [{[extrapMethod]}]
             The type of extrapolation. Please see Section~\ref{opt:extrapmethod} 
             for a list of valid options. If not specified, defaults to 
             {\tt ESMF\_EXTRAPMETHOD\_NONE}.
       \item [{[extrapNumSrcPnts]}] 
             The number of source points to use for the extrapolation methods that use more than one source point 
             (e.g. {\tt ESMF\_EXTRAPMETHOD\_NEAREST\_IDAVG}). If not specified, defaults to 8.
       \item [{[extrapDistExponent]}] 
             The exponent to raise the distance to when calculating weights for 
             the {\tt ESMF\_EXTRAPMETHOD\_NEAREST\_IDAVG} extrapolation method. A higher value reduces the influence 
             of more distant points. If not specified, defaults to 2.0.
       \item [{[extrapNumLevels]}] 
             The number of levels to output for the extrapolation methods that fill levels
             (e.g. {\tt ESMF\_EXTRAPMETHOD\_CREEP}). When a method is used that requires this, then an error will be returned, if it 
             is not specified.
       \item [{[unmappedaction]}]
             Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Please see Section~\ref{const:unmappedaction} for a 
             list of valid options. If not specified, {\tt unmappedaction} defaults to {\tt ESMF\_UNMAPPEDACTION\_ERROR}. 
       \item [{[ignoreDegenerate]}]
             Ignore degenerate cells when checking the input Grids or Meshes for errors. If this is set to true, then the 
             regridding proceeds, but degenerate cells will be skipped. If set to false, a degenerate cell produces an error. 
             If not specified, {\tt ignoreDegenerate} defaults to false.
       \item [{[srcTermProcessing]}]
             The {\tt srcTermProcessing} parameter controls how many source terms,
             located on the same PET and summing into the same destination element,
             are summed into partial sums on the source PET before being transferred
             to the destination PET. A value of 0 indicates that the entire arithmetic
             is done on the destination PET; source elements are neither multiplied 
             by their factors nor added into partial sums before being sent off by the
             source PET. A value of 1 indicates that source elements are multiplied
             by their factors on the source side before being sent to the destination
             PET. Larger values of {\tt srcTermProcessing} indicate the maximum number
             of terms in the partial sums on the source side.
  
       Note that partial sums may lead to bit-for-bit differences in the results.
       See section \ref{RH:bfb} for an in-depth discussion of {\em all}
       bit-for-bit reproducibility aspects related to route-based communication
       methods.
  
       \begin{sloppypar}
       The {\tt ESMF\_FieldRegridStore()} method implements an auto-tuning scheme
       for the {\tt srcTermProcessing} parameter. The intent on the 
       {\tt srcTermProcessing} argument is "{\tt inout}" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the 
       {\tt srcTermProcessing} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt srcTermProcessing} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt srcTermProcessing}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt srcTermProcessing} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       {\tt srcTermProcessing} argument is omitted.
       \end{sloppypar}
       
     \item [{[pipelineDepth]}]
       The {\tt pipelineDepth} parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of {\tt pipelineDepth} typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.
  
       Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.
  
       The {\tt ESMF\_FieldRegridStore()} method implements an auto-tuning scheme
       for the {\tt pipelineDepth} parameter. The intent on the 
       {\tt pipelineDepth} argument is "{\tt inout}" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument $>= 0$ is specified, it is used for the 
       {\tt pipelineDepth} parameter, and the auto-tuning phase is skipped.
       In this case the {\tt pipelineDepth} argument is not modified on
       return. If the provided argument is $< 0$, the {\tt pipelineDepth}
       parameter is determined internally using the auto-tuning scheme. In this
       case the {\tt pipelineDepth} argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       {\tt pipelineDepth} argument is omitted.
       \item [{[routehandle]}]
             The communication handle that implements the regrid operation and that can be used later in 
             the {\tt ESMF\_FieldRegrid()} call. The {\tt routehandle} is optional so that if the 
             user doesn't need it, then they can indicate that by not requesting it. 
             The time to compute the {\tt routehandle} can be a significant fraction of the time 
             taken by this method, so if it's not needed then not requesting it is worthwhile.  
       \item [{[factorList]}] 
             The list of coefficients for a sparse matrix which interpolates from {\tt srcField} to 
             {\tt dstField}. The array coming out of this variable is in the appropriate format to be used
             in other ESMF sparse matrix multiply calls, for example {\tt ESMF\_FieldSMMStore()}. 
             The {\tt factorList} array is allocated by the method and the user is responsible for 
             deallocating it. 
       \item [{[factorIndexList]}] 
             The indices for a sparse matrix which interpolates from {\tt srcField} to 
             {\tt dstField}. This argument is a 2D array containing pairs of source and destination
             sequence indices corresponding to the coefficients in the {\tt factorList} argument. 
             The first dimension of {\tt factorIndexList} is of size 2. {\tt factorIndexList(1,:)} specifies 
             the sequence index of the source element in the {\tt srcField}. {\tt factorIndexList(2,:)} specifies 
             the sequence index of the destination element in the {\tt dstField}. The se cond dimension of 
             {\tt factorIndexList} steps through the list of pairs, i.e. {\tt size(factorIndexList,2)==size(factorList)}.
             The array coming out of this variable is in the appropriate format to be used
             in other ESMF sparse matrix multiply calls, for example {\tt ESMF\_FieldSMMStore()}. 
             The {\tt factorIndexList} array is allocated by the method and the user is responsible for deallocating it. 
       \item [{[weights]}] 
             \apiDeprecatedArgWithReplacement{factorList}
       \item [{[indices]}] 
             \apiDeprecatedArgWithReplacement{factorIndexList}
       \item [{[srcFracField]}] 
             The fraction of each source cell participating in the regridding. Only 
             valid when regridmethod is {\tt ESMF\_REGRIDMETHOD\_CONSERVE} or  {\tt regridmethod=ESMF\_REGRIDMETHOD\_CONSERVE\_2ND}.
             This Field needs to be created on the same location (e.g staggerloc) 
             as the srcField.
       \item [{[dstFracField]}] 
             The fraction of each destination cell participating in the regridding. Only 
             valid when regridmethod is {\tt ESMF\_REGRIDMETHOD\_CONSERVE} or  {\tt regridmethod=ESMF\_REGRIDMETHOD\_CONSERVE\_2ND}.
             This Field needs to be created on the same location (e.g staggerloc) 
             as the dstField. It is important to note that the current implementation
             of conservative regridding doesn't normalize the interpolation weights by the destination fraction. This   means that for a destination
             grid which only partially overlaps the source grid the destination field which is output from the 
             regrid operation should be divided by the corresponding destination fraction to yield the 
             true interpolated values for cells which are only partially covered by the  source grid. 
       \item [{[dstStatusField]}] 
             An ESMF Field which outputs a regrid status value for each destination location.
             Section~\ref{opt:regridstatus} indicates the meaning of each value. The Field needs to 
             be built on the same grid-location (e.g. staggerloc) in the same Grid, Mesh, or LocStream as the {\tt dstField} argument. 
             The Field also needs to be of typekind {\tt ESMF\_TYPEKIND\_I4}.  This option currently doesn't work with 
             the {\tt ESMF\_REGRIDMETHOD\_NEAREST\_DTOS} regrid method.
       \item [{[unmappedDstList]}] 
             The list of the sequence indices for locations in {\tt dstField} which couldn't be mapped the {\tt srcField}. 
             The list on each PET only contains the unmapped locations for the piece of the {\tt dstField} on that PET. 
             If a destination point is masked, it won't be put in this list. This option currently doesn't work with 
             the {\tt ESMF\_REGRIDMETHOD\_NEAREST\_DTOS} regrid method.
       \item [{[rc]}]
             Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldRegridStore] {ESMF\_FieldRegridStore - Precompute a Field regridding operation and return a RouteHandle using XGrid}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   !   Private name; call using ESMF_FieldRegridStore()
       subroutine ESMF_FieldRegridStoreX(xgrid, srcField, dstField, &
                     regridmethod, routehandle, &
                     srcFracField, dstFracField, &
                     srcMergeFracField, dstMergeFracField, rc)
        \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_XGrid),       intent(in)              :: xgrid
       type(ESMF_Field),       intent(in)              :: srcField
       type(ESMF_Field),       intent(inout)           :: dstField
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_RegridMethod_Flag),   intent(in),    optional :: regridmethod
       type(ESMF_RouteHandle), intent(inout), optional :: routehandle
       type(ESMF_Field),       intent(inout), optional :: srcFracField
       type(ESMF_Field),       intent(inout), optional :: dstFracField
       type(ESMF_Field),       intent(inout), optional :: srcMergeFracField
       type(ESMF_Field),       intent(inout), optional :: dstMergeFracField
       integer,                intent(out),   optional :: rc \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[5.3.0] Added arguments {\tt srcFracField}, {\tt dstFracField}, {\tt srcMergeFracField}, and {\tt dstMergeFracField}.
   These fraction Fields allow a user to calculate correct flux regridded through {\tt ESMF\_XGrid}.
   \item[7.1.0r] Added argument {\tt regridmethod}. This new argument allows the user to choose the regrid method
                 to apply when computing the routehandle. 
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


         \begin{sloppypar}
         Creates a sparse matrix operation (stored in {\tt routehandle}) that contains the calculations and 
         communications necessary to interpolate from {\tt srcField} to {\tt dstField}. 
         The routehandle can then be used in the call
         {\tt ESMF\_FieldRegrid()} to interpolate between the {\tt ESMF\_Field}s. Information such as
         index mapping and weights are obtained from the XGrid by matching the Field Grids or Meshes in the XGrid. 
         It's erroneous to have matching Grid or Mesh objects in the {\tt srcField} and {\tt dstField}. 
         They must be different in either topological or geometric characteristics. For {\tt ESMF\_Field}s 
         built on identical {\tt ESMF\_Grid} or {\tt ESMF\_Mesh} on
         different VM, user can use {\tt ESMF\_FieldRedistStore()} and {\tt ESMF\_FieldRedist()} 
         methods to communicate data directly without interpolation.
         \end{sloppypar}
         
         The routehandle generated by this call is subsequently computed based on these information.
         If those information don't change the routehandle can be used repeatedly to interpolate 
         from the source Field to the destination Field. 
         This is true even if the data in the Fields changes. The routehandle may also be used to 
         interpolate between any source and 
         destination Field which are created on the same stagger location and Grid
         or on the same mesh location and Mesh as the original Fields.        
  
         When it's no longer needed the routehandle should be destroyed by using 
         {\tt ESMF\_FieldRegridRelease()} to free the memory it's using. 
         Note {\tt ESMF\_FieldRegridStore()} assumes the coordinates used in the Grids upon which the Fields are built are
     in degrees.  
  
       The arguments are:
       \begin{description}
       \item [xgrid]
             Exchange Grid.
       \item [srcField]
             Source Field.
       \item [dstField]
             Destination Field. The data in this Field may be overwritten by this call. 
       \item [{[regridmethod]}]
             The type of interpolation. For this method only 
             {\tt ESMF\_REGRIDMETHOD\_CONSERVE} and {\tt ESMF\_REGRIDMETHOD\_CONSERVE\_2ND} are
             supported. If not specified, defaults to {\tt ESMF\_REGRIDMETHOD\_CONSERVE}.
       \item [{[routehandle]}]
             The handle that implements the regrid and that can be used in later 
             {\tt ESMF\_FieldRegrid}.
       \item [{[srcFracField]}] 
             The fraction of each source cell participating in the regridding returned from this call. 
             This Field needs to be created on the same Grid and location (e.g staggerloc) 
             as the srcField.
       \item [{[dstFracField]}] 
             The fraction of each destination cell participating in the regridding returned from this call. 
             This Field needs to be created on the same Grid and location (e.g staggerloc) 
             as the dstField.
       \item [{[srcMergeFracField]}] 
             The fraction of each source cell as a result of Grid merge returned from this call.
             This Field needs to be created on the same Grid and location (e.g staggerloc) 
             as the srcField.
       \item [{[dstMergeFracField]}] 
             The fraction of each destination cell as a result of Grid merge returned from this call.
             This Field needs to be created on the same Grid and location (e.g staggerloc) 
             as the dstField.
       \item [{[rc]}]
             Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldRegridGetArea] {ESMF\_FieldRegridGetArea - Get the area of the cells used for conservative interpolation}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_FieldRegridGetArea(areaField, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}        \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Field), intent(inout)                 :: areaField
       integer, intent(out), optional                  :: rc 
 \end{verbatim}
{\sf DESCRIPTION:\\ }


       This subroutine gets the area of the cells used for conservative interpolation for the grid object 
       associated with {\tt areaField} and puts them into {\tt areaField}. If created on a 2D Grid, it must 
       be built on the {\tt ESMF\_STAGGERLOC\_CENTER} stagger location. 
       If created on a 3D Grid, it must be built on the {\tt ESMF\_STAGGERLOC\_CENTER\_VCENTER} stagger 
       location. If created on a Mesh, it must be built on the {\tt ESMF\_MESHLOC\_ELEMENT} mesh location. 
  
       If the user has set the area in the Grid or Mesh under {\tt areaField}, then that's the area that's
       returned in the units that the user set it in. If the user hasn't set the area, then the area is 
       calculated and returned. If the Grid or Mesh is on the surface of a sphere, then the calculated area is in
       units of square radians. If the Grid or Mesh is 
       Cartesian, then the calculated area is in square units of whatever unit the coordinates are in. 
  
       The arguments are:
       \begin{description}
       \item [areaField]
             The Field to put the area values in. 
       \item [{[rc]}]
             Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
