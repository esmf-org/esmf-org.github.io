%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_FieldArbGridEx.F90,  Date: Tue May  5 21:00:02 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

  \subsubsection{Create a Field on an arbitrarily distributed Grid}
  \label{sec:field:usage:createArbGrid}
  
    With the introduction of Field on arbitrarily distributed Grid, Field has two kinds of dimension
    count: one associated geometrical (or physical) dimensionality, the other one associated with its
    memory index space representation. Field and Grid dimCount reflect the physical index 
    space of the objects. A new type of dimCount rank should be added to both of these entities.
    The rank gives the number of dimensions of the memory index space of the objects.
    This would be the dimension of the pointer pulled out of Field and the
    size of the bounds vector, for example. 
  
    For non-arbitrary Grids rank=dimCount, but for grids and fields with
    arbitrary dimensions rank = dimCount - (number of Arb dims) + 1
    (Internally Field can use the Arb info from the grid to create the mapping
    from the Field Array to the DistGrid)
  
    When creating a Field size(GridToFieldMap)=dimCount for both Arb and Non-arb grids
    This array specifies the mapping of Field to Grid identically for both Arb and Nonarb grids 
    If a zero occurs in an entry corresponding to any arbitrary dimension, then
    a zero must occur in every entry corresponding to an arbitrary dimension (i.e.
    all arbitrary dimensions must either be all replicated or all not replicated,
    they can't be broken apart).
  
    In this example an {\tt ESMF\_Field} is created from an arbitrarily distributed {\tt ESMF\_Grid} and 
    an {\tt ESMF\_Arrayspec}. A user can also use other {\tt ESMF\_FieldCreate()} methods to create 
    such a Field, this example illustrates the key concepts and use of Field on arbitrary distributed Grid.
    
    The Grid is 3 dimensional in physics index space but the first two dimension are collapsed into
    a single memory index space. Thus the resulting Field is 3D in physics index space and 2D in memory index
    space. This is made obvious with the 2D arrayspec used to create this Field.
   
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    ! create a 3D grid with the first 2 dimensions collapsed 
    ! and arbitrarily distributed
    grid3d = ESMF_GridCreateNoPeriDim(coordTypeKind=ESMF_TYPEKIND_R8, &
      minIndex=(/1,1,1/), maxIndex=(/xdim, ydim,zdim/), &
      arbIndexList=localArbIndex,arbIndexCount=localArbIndexCount, &
      name="arb3dgrid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create a 2D arrayspec
    call ESMF_ArraySpecSet(arrayspec2D, rank=2, typekind=ESMF_TYPEKIND_R4, &
         rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create a 2D Field using the Grid and the arrayspec
    field = ESMF_FieldCreate(grid3d, arrayspec2D, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
    call ESMF_FieldGet(field, rank=rank, dimCount=dimCount, &
                       rc=rc)
    if (myPet .eq. 0) print *, 'Field rank, dimCount', &
                                rank, dimCount
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
    ! verify that the dimension counts are correct
    if (rank .ne. 2) correct = .false.
    if (dimCount .ne. 3) correct = .false.  
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

  \subsubsection{Create a Field on an arbitrarily distributed Grid with replicated dimensions \& ungridded bounds}
  \label{sec:field:usage:createArbGridRep}
  
    The next example is slightly more complicated in
    that the Field also contains one ungridded dimension and its gridded dimension
    is replicated on the arbitrarily distributed dimension of the Grid.
   
    The same 3D Grid and 2D arrayspec in the previous example
    are used but a gridToFieldMap argument
    is supplied to the {\tt ESMF\_FieldCreate()} call. The first 2 entries of
    the map are 0, the last (3rd) entry is 1. The 3rd dimension of the Grid is
    mapped to the first dimension of the Field, this dimension is then replicated
    on the arbitrarily distributed dimensions of the Grid. In addition, the
    Field also has one ungridded dimension. Thus the final dimension count of the
    Field is 2 in both physics and memory index space.
   
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    field = ESMF_FieldCreate(grid3d, arrayspec2D,gridToFieldMap=(/0,0,1/), &
            ungriddedLBound=(/1/), ungriddedUBound=(/10/),rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
    call ESMF_FieldGet(field, rank=rank, dimCount=dimCount, &
                       rc=rc)
    if (myPet .eq. 0) print *, 'Field rank, dimCount', &
                                rank, dimCount
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
    if (rank .ne. 2) correct = .false.
    if (dimCount .ne. 2) correct = .false.  
 
\end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
