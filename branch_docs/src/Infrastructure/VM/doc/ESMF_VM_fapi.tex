%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_VM.F90,  Date: Tue May  5 20:59:29 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_VMAssignment(=)] {ESMF\_VMAssignment(=) - VM assignment}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     interface assignment(=)
     vm1 = vm2\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM) :: vm1
     type(ESMF_VM) :: vm2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Assign vm1 as an alias to the same ESMF VM object in memory
     as vm2. If vm2 is invalid, then vm1 will be equally invalid after
     the assignment.
  
     The arguments are:
     \begin{description}
     \item[vm1]
       The {\tt ESMF\_VM} object on the left hand side of the assignment.
     \item[vm2]
       The {\tt ESMF\_VM} object on the right hand side of the assignment.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMOperator(==)] {ESMF\_VMOperator(==) - VM equality operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(==)
     if (vm1 == vm2) then ... endif
               OR
     result = (vm1 == vm2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM), intent(in) :: vm1
     type(ESMF_VM), intent(in) :: vm2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Test whether vm1 and vm2 are valid aliases to the same ESMF
     VM object in memory. For a more general comparison of two ESMF VMs,
     going beyond the simple alias test, the ESMF\_VMMatch() function (not yet
     implemented) must be used.
  
     The arguments are:
     \begin{description}
     \item[vm1]
       The {\tt ESMF\_VM} object on the left hand side of the equality
       operation.
     \item[vm2]
       The {\tt ESMF\_VM} object on the right hand side of the equality
       operation.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMOperator(/=)] {ESMF\_VMOperator(/=) - VM not equal operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(/=)
     if (vm1 /= vm2) then ... endif
               OR
     result = (vm1 /= vm2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM), intent(in) :: vm1
     type(ESMF_VM), intent(in) :: vm2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Test whether vm1 and vm2 are {\it not} valid aliases to the
     same ESMF VM object in memory. For a more general comparison of two ESMF
     VMs, going beyond the simple alias test, the ESMF\_VMMatch() function
     (not yet implemented) must be used.
  
     The arguments are:
     \begin{description}
     \item[vm1]
       The {\tt ESMF\_VM} object on the left hand side of the non-equality
       operation.
     \item[vm2]
       The {\tt ESMF\_VM} object on the right hand side of the non-equality
       operation.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMAllFullReduce] {ESMF\_VMAllFullReduce - Fully reduce data across VM, result on all PETs}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMAllFullReduce(vm, sendData, recvData, &
      count, reduceflag, syncflag, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)
      <type>(ESMF_KIND_<kind>),         intent(out)           :: recvData
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that reduces a contiguous data 
     array of <type><kind> across the {\tt ESMF\_VM} object 
     into a single value of the same <type><kind>. The result is
     returned on all PETs. Different reduction operations can be specified.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
  
     {\sc Todo:} The current version of this method does not provide an 
     implementation of the {\em non-blocking} feature. When calling this 
     method with {\tt syncflag = ESMF\_SYNC\_NONBLOCKING}, error code 
     {\tt ESMF\_RC\_NOT\_IMPL} will be returned and an error will be 
     logged.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData]
          Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     \item[recvData] 
          Single data variable to be received. All PETs must specify a
          valid result variable.
     \item[count] 
          Number of elements in sendData. Allowed to be different across the 
          PETs, as long as {\tt count} > 0.
     \item[reduceflag] 
          Reduction operation. See section \ref{const:reduce} for a list of 
          valid reduce operations.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMAllGather] {ESMF\_VMAllGather - Gather data across VM, result on all PETs}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMAllGather(vm, sendData, recvData, count, &
      syncflag, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)
      <type>(ESMF_KIND_<kind>), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that gathers contiguous data 
     from all PETs of an {\tt ESMF\_VM} object into an array on all PETs.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}, 
     {\tt ESMF\_TYPEKIND\_LOGICAL}.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData]
          Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     \item[recvData] 
          Contiguous data array for data to be received. All PETs must specify a
          valid {\tt recvData} argument.
     \item[count] 
          Number of elements to be gathered from each PET. Must be the
          same on all PETs.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMAllGatherV] {ESMF\_VMAllGatherV - GatherV data across VM, result on all PETs}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMAllGatherV(vm, sendData, sendCount, &
      recvData, recvCounts, recvOffsets, syncflag, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      <type>(ESMF_KIND_<kind>), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that gathers contiguous data 
     from all PETs of an {\tt ESMF\_VM} object into an array on all PETs.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
  
     {\sc Todo:} The current version of this method does not provide an 
     implementation of the {\em non-blocking} feature. When calling this 
     method with {\tt syncflag = ESMF\_SYNC\_NONBLOCKING}, error code 
     {\tt ESMF\_RC\_NOT\_IMPL} will be returned and an error will be 
     logged.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData]
          Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     \item[sendCount] 
          Number of {\tt sendData} elements to send from local PET to all other
          PETs.
     \item[recvData] 
          Contiguous data array for data to be received. All PETs must specify a
          valid {\tt recvData} argument.
     \item[recvCounts] 
          Number of {\tt recvData} elements to be received from corresponding
          source PET.
     \item[recvOffsets] 
          Offsets in units of elements in {\tt recvData} marking the start of
          element sequence to be received from source PET.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMAllReduce] {ESMF\_VMAllReduce - Reduce data across VM, result on all PETs}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMAllReduce(vm, sendData, recvData, count, &
      reduceflag, syncflag, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)
      <type>(ESMF_KIND_<kind>), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that reduces a contiguous data 
     array across the {\tt ESMF\_VM} object into a contiguous data array of the
     same <type><kind>. The result array is returned on all PETs. 
     Different reduction operations can be specified.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
  
     {\sc Todo:} The current version of this method does not provide an 
     implementation of the {\em non-blocking} feature. When calling this 
     method with {\tt syncflag = ESMF\_SYNC\_NONBLOCKING}, error code 
     {\tt ESMF\_RC\_NOT\_IMPL} will be returned and an error will be 
     logged.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData]
          Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     \item[recvData] 
          Contiguous data array for data to be received. All PETs must specify a
          valid {\tt recvData} argument.
     \item[count] 
          Number of elements in sendData and recvData. Must be the same on all
          PETs.
     \item[reduceflag] 
          Reduction operation. See section \ref{const:reduce} for a list of 
          valid reduce operations.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMAllToAll] {ESMF\_VMAllToAll - AllToAll communications across VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMAllToAll(vm, sendData, sendCount, &
      recvData, recvCount, syncflag, &
      commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      <type>(ESMF_KIND_<kind>), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCount
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.3.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that performs a total exchange
     operation, sending pieces of the contiguous data buffer {\tt sendData} to
     all other PETs while receiving data into the contiguous data buffer
     {\tt recvData} from all other PETs.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
  
     {\sc Todo:} The current version of this method does not provide an 
     implementation of the {\em non-blocking} feature. When calling this 
     method with {\tt syncflag = ESMF\_SYNC\_NONBLOCKING}, error code 
     {\tt ESMF\_RC\_NOT\_IMPL} will be returned and an error will be 
     logged.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData]
          Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     \item[sendCount] 
          Number of {\tt sendData} elements to send from local PET to
          each destination PET.
     \item[recvData] 
          Contiguous data array for data to be received. All PETs must specify a
          valid {\tt recvData} argument.
     \item[recvCount] 
          Number of {\tt recvData} elements to be received by local PET from
          each source PET.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMAllToAllV] {ESMF\_VMAllToAllV - AllToAllV communications across VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMAllToAllV(vm, sendData, sendCounts, &
      sendOffsets, recvData, recvCounts, recvOffsets, syncflag, &
      commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCounts(:)
      integer,                          intent(in)            :: sendOffsets(:)
      <type>(ESMF_KIND_<kind>), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that performs a total exchange
     operation, sending pieces of the contiguous data buffer {\tt sendData} to
     all other PETs while receiving data into the contiguous data buffer
     {\tt recvData} from all other PETs.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}, 
     {\tt ESMF\_TYPEKIND\_LOGICAL}.
  
     {\sc Todo:} The current version of this method does not provide an 
     implementation of the {\em non-blocking} feature. When calling this 
     method with {\tt syncflag = ESMF\_SYNC\_NONBLOCKING}, error code 
     {\tt ESMF\_RC\_NOT\_IMPL} will be returned and an error will be 
     logged.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData]
          Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     \item[sendCounts] 
          Number of {\tt sendData} elements to send from local PET to
          destination PET.
     \item[sendOffsets] 
          Offsets in units of elements in {\tt sendData} marking to start of
          element sequence to be sent from local PET to destination PET.
     \item[recvData] 
          Contiguous data array for data to be received. All PETs must specify a
          valid {\tt recvData} argument.
     \item[recvCounts] 
          Number of {\tt recvData} elements to be received by local PET from
          source PET.
     \item[recvOffsets] 
          Offsets in units of elements in {\tt recvData} marking to start of
          element sequence to be received by local PET from source PET.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMBarrier] {ESMF\_VMBarrier - VM wide barrier}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_VMBarrier(vm, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM),  intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,        intent(out), optional :: rc           \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that blocks calling PET until
     all PETs of the VM context have issued the call.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMBroadcast] {ESMF\_VMBroadcast - Broadcast data across VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMBroadcast(vm, bcstData, count, rootPet, &
      syncflag, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(inout)         :: bcstData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that broadcasts a contiguous 
     data array from {\tt rootPet} to all other PETs of the {\tt ESMF\_VM}
     object.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}, 
     {\tt ESMF\_TYPEKIND\_LOGICAL}, 
     {\tt ESMF\_TYPEKIND\_CHARACTER}.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[bcstData]
          Contiguous data array. On {\tt rootPet} {\tt bcstData} holds data that
          is to be broadcasted to all other PETs. On all other PETs 
          {\tt bcstData} is used to receive the broadcasted data.
     \item[count] 
          Number of elements in {/bcstData}. Must be the same on all PETs.
     \item[rootPet] 
          PET that holds data that is being broadcast.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMCommWait] {ESMF\_VMCommWait - Wait for non-blocking VM communication to complete}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_VMCommWait(vm, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM),         intent(in)            :: vm
     type(ESMF_CommHandle), intent(in)            :: commhandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,               intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Wait for non-blocking VM communication specified by the {\tt commhandle} to
     complete.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[commhandle] 
          Handle specifying a previously issued non-blocking communication 
          request.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMCommWaitAll] {ESMF\_VMCommWaitAll - Wait for all non-blocking VM comms to complete}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_VMCommWaitAll(vm, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM), intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Wait for {\em all} pending non-blocking VM communication within the 
     specified VM context to complete.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMGather] {ESMF\_VMGather - Gather data from across VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMGather(vm, sendData, recvData, count, rootPet, &
      syncflag, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)
      <type>(ESMF_KIND_<kind>), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that gathers contiguous data 
     from all PETs of an {\tt ESMF\_VM} object (including {\tt rootPet}) into an
     array on {\tt rootPet}.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}, 
     {\tt ESMF\_TYPEKIND\_LOGICAL}.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData]
          Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     \item[recvData] 
          Contiguous data array for data to be received. Only the {\tt recvData}
          array specified by the {\tt rootPet} will be used by this method.
     \item[count] 
          Number of elements to be sent from each PET to {\tt rootPet}. Must be
          the same on all PETs.
     \item[rootPet] 
          PET on which data is gathereds.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMGatherV] {ESMF\_VMGatherV - GatherV data from across VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMGatherV(vm, sendData, sendCount, recvData, &
      recvCounts, recvOffsets, rootPet, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      <type>(ESMF_KIND_<kind>), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that gathers contiguous data 
     from all PETs of an {\tt ESMF\_VM} object into an array on rootPet.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
  
     {\sc Todo:} The current version of this method does not provide an 
     implementation of the {\em non-blocking} feature. When calling this 
     method with {\tt syncflag = ESMF\_SYNC\_NONBLOCKING}, error code 
     {\tt ESMF\_RC\_NOT\_IMPL} will be returned and an error will be 
     logged.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData]
          Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     \item[sendCount] 
          Number of {\tt sendData} elements to send from local PET to all other
          PETs.
     \item[recvData] 
          Contiguous data array for data to be received. Only the {\tt recvData}
          array specified by the {\tt rootPet} will be used by this method.
     \item[recvCounts] 
          An integer array (of length group size, specified in VM object) containing 
          number of {\tt recvData} elements to be received from corresponding
          source PET. This argument is significant only at rootPet.
     \item[recvOffsets] 
          Offsets in units of elements in {\tt recvData} marking the start of
          element sequence to be received from source PET.
     \item[rootPet]
          PET on which data is gathered.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMGet] {ESMF\_VMGet - Get information from a VM}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_VMGet()
   recursive subroutine ESMF_VMGetDefault(vm, localPet, &
     localPe, petCount, peCount, ssiCount, ssiMinPetCount, ssiMaxPetCount, &
     ssiLocalPetCount, mpiCommunicator, pthreadsEnabledFlag, openMPEnabledFlag, &
     ssiSharedMemoryEnabledFlag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM),      intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: localPet
     integer,            intent(out), optional :: localPe
     integer,            intent(out), optional :: petCount
     integer,            intent(out), optional :: peCount
     integer,            intent(out), optional :: ssiCount
     integer,            intent(out), optional :: ssiMinPetCount
     integer,            intent(out), optional :: ssiMaxPetCount
     integer,            intent(out), optional :: ssiLocalPetCount
     integer,            intent(out), optional :: mpiCommunicator
     logical,            intent(out), optional :: pthreadsEnabledFlag
     logical,            intent(out), optional :: openMPEnabledFlag
     logical,            intent(out), optional :: ssiSharedMemoryEnabledFlag
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[8.0.0] Added arguments {\tt ssiCount}, {\tt ssiMinPetCount}, 
     {\tt ssiMaxPetCount}, and {\tt ssiLocalPetCount} to provide access 
     to information about how the VM is mapped across the single system images
     (SSIs) -- typically synonymous to nodes -- of the compute environment. This
     information is useful when constructing custom petLists. \newline
     Added argument {\tt ssiSharedMemoryEnabledFlag} that allows the user to 
     query whether ESMF was compiled with support for shared memory 
     access between PETs on the same SSI.
   \item[8.1.0] Added argument {\tt localPe} for easy access to the PE.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Get internal information about the specified {\tt ESMF\_VM} object.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          Queried {\tt ESMF\_VM} object.
     \item[{[localPet]}]
          Upon return this holds the id of the local PET that issued this call.
          The valid range of {\tt localPet} is $[0..petCount-1]$. A value of $-1$
          is returned on PETs that are not active under the specified {\tt vm}.
     \item[{[localPe]}]
          Upon return this holds the id of the PE on which the local PET is
          executing. The range of the returned value is platform specific and
          refers to the core or cpu id by which the PE is known to the operating
          system.
     \item[{[petCount]}]
          Upon return this holds the number of PETs running under {\tt vm}.
     \item[{[peCount]}]
          Upon return this holds the number of PEs referenced by {\tt vm}.
     \item[{[ssiCount]}]
          Upon return this holds the number of single system images referenced 
          by {\tt vm}.
     \item[{[ssiMinPetCount]}]
          Upon return this holds the smallest number of PETs running in the same
          single system images under {\tt vm}.
     \item[{[ssiMaxPetCount]}]
          Upon return this holds the largest number of PETs running in the same
          single system images under {\tt vm}.
     \item[{[ssiLocalPetCount]}]
          Upon return this holds the number of PETs running in the same
          single system as {\tt localPet}.
     \item[{[mpiCommunicator]}]
          Upon return this holds the MPI intra-communicator used by the 
          specified {\tt ESMF\_VM} object. This communicator may be used for
          user-level MPI communications. It is recommended that the user
          duplicates the communicator via {\tt MPI\_Comm\_Dup()} in order to
          prevent any interference with ESMF communications.
          {\tt MPI\_COMM\_NULL} is returned on PETs that are not active
          under the specified {\tt vm}.
     \item[{[pthreadsEnabledFlag]}]
          \begin{description}
          \item[{\tt .TRUE.}]
               ESMF has been compiled with Pthreads.
          \item[{\tt .FALSE.}]
               ESMF has {\em not} been compiled with Pthreads.
          \end{description}
     \item[{[openMPEnabledFlag]}]
          \begin{description}
          \item[{\tt .TRUE.}]
               ESMF has been compiled with OpenMP.
          \item[{\tt .FALSE.}]
               ESMF has {\em not} been compiled with OpenMP.
          \end{description}
     \item[{[ssiSharedMemoryEnabledFlag]}]
          \begin{description}
          \item[{\tt .TRUE.}]
               ESMF has been compiled to support shared memory access
               between PETs that are on the same single system image (SSI).
          \item[{\tt .FALSE.}]
               ESMF has {\em not} been compiled to support shared memory access
               between PETs that are on the same single system image (SSI).
          \end{description}
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMGet] {ESMF\_VMGet - Get PET specific VM information}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_VMGet()
   subroutine ESMF_VMGetPetSpecific(vm, pet, peCount, &
     accDeviceCount, ssiId, threadCount, threadId, vas, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM), intent(in)            :: vm
     integer,       intent(in)            :: pet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: peCount
     integer,       intent(out), optional :: accDeviceCount
     integer,       intent(out), optional :: ssiId
     integer,       intent(out), optional :: threadCount
     integer,       intent(out), optional :: threadId
     integer,       intent(out), optional :: vas
     integer,       intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.0.0] Added argument {\tt accDeviceCount}.
     The argument provides access to the number of available accelerator devices.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Get internal information about a specific PET within an {\tt ESMF\_VM} 
     object.
  
     The arguments are:
     \begin{description}
     \item[vm] 
           Queried {\tt ESMF\_VM} object.
     \item[pet] 
           Queried PET id within the specified {\tt ESMF\_VM} object.
     \item[{[peCount]}]
          Upon return this holds the number of PEs associated with the specified
          PET in the {\tt ESMF\_VM} object.
     \item[{[accDeviceCount]}]
          Upon return this holds the number of accelerated devices accessible
          from the specified PET in the {\tt ESMF\_VM} object.
     \item[{[ssiId]}]
          Upon return this holds the id of the single-system image (SSI) the
          specified PET is running on.
     \item[{[threadCount]}]
          Upon return this holds the number of PETs in the specified PET"s 
          thread group.
     \item[{[threadId]}]
          Upon return this holds the thread id of the specified PET within the 
          PET"s thread group.
     \item[{[vas]}]
          Virtual address space in which this PET operates.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMGetGlobal] {ESMF\_VMGetGlobal - Get Global VM}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_VMGetGlobal(vm, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM), intent(out)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional  :: rc           \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     \begin{sloppypar}
     Get the global {\tt ESMF\_VM} object. This is the VM object
     that is created during {\tt ESMF\_Initialize()} and is the ultimate
     parent of all VM objects in an ESMF application. It is identical to the VM
     object returned by {\tt ESMF\_Initialize(..., vm=vm, ...)}.
     \end{sloppypar}
  
     The {\tt ESMF\_VMGetGlobal()} call provides access to information about the
     global execution context via the global VM. This call is necessary because
     ESMF does not created a global ESMF Component during
     {\tt ESMF\_Initialize()} that could be queried for information about
     the global execution context of an ESMF application.
  
     Usage of {\tt ESMF\_VMGetGlobal()} from within Component code is
     strongly discouraged. ESMF Components should only access their own VM
     objects through Component methods. Global information, if required by
     the Component user code, should be passed down to the Component from the 
     driver through the Component calling interface.
  
     The arguments are:
     \begin{description}
     \item[vm] 
       Upon return this holds the {\tt ESMF\_VM} object of the global execution 
       context.
     \item[{[rc]}] 
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMGetCurrent] {ESMF\_VMGetCurrent - Get Current VM}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_VMGetCurrent(vm, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM), intent(out)           :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc           \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     \begin{sloppypar}
     Get the {\tt ESMF\_VM} object of the current execution context. Calling
     {\tt ESMF\_VMGetCurrent()} within an ESMF Component, will return the
     same VM object as
     {\tt ESMF\_GridCompGet(..., vm=vm, ...)} or
     {\tt ESMF\_CplCompGet(..., vm=vm, ...)}. 
     \end{sloppypar}
   
     The main purpose of providing {\tt ESMF\_VMGetCurrent()} is to simplify ESMF
     adoption in legacy code. Specifically, code that uses {\tt MPI\_COMM\_WORLD}
     deep within its calling tree can easily be modified to use the correct MPI
     communicator of the current ESMF execution context. The advantage is that
     these modifications are very local, and do not require wide reaching
     interface changes in the legacy code to pass down the ESMF component object,
     or the MPI communicator.
  
     The use of {\tt ESMF\_VMGetCurrent()} is strongly discouraged in newly
     written Component code. Instead, the ESMF Component object should be used as
     the appropriate container of ESMF context information. This object should be
     passed between the subroutines of a Component, and be queried for any
     Component specific information.
  
     Outside of a Component context, i.e. within the driver context, the call
     to {\tt ESMF\_VMGetCurrent()} is identical to {\tt ESMF\_VMGetGlobal()}.
  
     The arguments are:
     \begin{description}
     \item[vm] 
       Upon return this holds the {\tt ESMF\_VM} object of the current execution
       context.
     \item[{[rc]}] 
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMIsCreated] {ESMF\_VMIsCreated - Check whether a VM object has been created}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   function ESMF_VMIsCreated(vm, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: ESMF_VMIsCreated\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM), intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     Return {\tt .true.} if the {\tt vm} has been created. Otherwise return 
     {\tt .false.}. If an error occurs, i.e. {\tt rc /= ESMF\_SUCCESS} is 
     returned, the return value of the function will also be {\tt .false.}.
  
   The arguments are:
     \begin{description}
     \item[vm]
       {\tt ESMF\_VM} queried.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMPrint] {ESMF\_VMPrint - Print VM information}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_VMPrint(vm, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM),  intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,        intent(out), optional :: rc           \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Print internal information about the specified {\tt ESMF\_VM} to
     {\tt stdout}.\\
  
     The arguments are:
     \begin{description}
     \item[vm] 
          Specified {\tt ESMF\_VM} object.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMRecv] {ESMF\_VMRecv - Receive data from srcPet}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMRecv(vm, recvData, count, srcPet, &
      syncflag, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                     intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target,  intent(out)           :: recvData(:)  
      integer,                           intent(in)            :: count
      integer,                           intent(in)            :: srcPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),              intent(in),  optional :: syncflag
      type(ESMF_CommHandle),             intent(out), optional :: commhandle
      integer,                           intent(out), optional :: rc           \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Receive contiguous data from {\tt srcPet} within the same {\tt ESMF\_VM} 
     object.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}, 
     {\tt ESMF\_TYPEKIND\_LOGICAL}, 
     {\tt ESMF\_TYPEKIND\_CHARACTER}.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[recvData] 
          Contiguous data array for data to be received.
     \item[count] 
          Number of elements to be received.
     \item[srcPet] 
          Sending PET.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMReduce] {ESMF\_VMReduce - Reduce data from across VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMReduce(vm, sendData, recvData, count, &
      reduceflag, rootPet, syncflag, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)
      <type>(ESMF_KIND_<kind>), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that reduces a contiguous data 
     array across the {\tt ESMF\_VM} object into a contiguous data array of 
     the same <type><kind>. The result array is returned on {\tt rootPet}. 
     Different reduction operations can be specified.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
  
     {\sc Todo:} The current version of this method does not provide an 
     implementation of the {\em non-blocking} feature. When calling this 
     method with {\tt syncflag = ESMF\_SYNC\_NONBLOCKING}, error code 
     {\tt ESMF\_RC\_NOT\_IMPL} will be returned and an error will be 
     logged.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData]
          Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     \item[recvData] 
          Contiguous data array for data to be received. Only the {\tt recvData}
          array specified by the {\tt rootPet} will be used by this method.
     \item[count] 
          Number of elements in sendData and recvData. Must be the same on all
          PETs.
     \item[reduceflag] 
          Reduction operation. See section \ref{const:reduce} for a list of 
          valid reduce operations.
     \item[rootPet] 
          PET on which reduced data is returned.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMScatter] {ESMF\_VMScatter - Scatter data across VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMScatter(vm, sendData, recvData, count, &
      rootPet, syncflag, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)
      <type>(ESMF_KIND_<kind>), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that scatters contiguous data 
     from the {\tt rootPet} to all PETs across the {\tt ESMF\_VM} object
     (including {\tt rootPet}).
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}, 
     {\tt ESMF\_TYPEKIND\_LOGICAL}.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData]
          Contiguous data array holding data to be sent. Only the {\tt sendData}
          array specified by the {\tt rootPet} will be used by this method.
     \item[recvData] 
          Contiguous data array for data to be received. All PETs must specify a
          valid destination array.
     \item[count] 
          Number of elements to be sent from {\tt rootPet} to each of the PETs.
          Must be the same on all PETs.
     \item[rootPet] 
          PET that holds data that is being scattered.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMScatterV] {ESMF\_VMScatterV - ScatterV across VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMScatterV(vm, sendData, sendCounts, &
      sendOffsets, recvData, recvCount, rootPet, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCounts(:)
      integer,                          intent(in)            :: sendOffsets(:)
      <type>(ESMF_KIND_<kind>), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCount
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,                          intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Collective {\tt ESMF\_VM} communication call that scatters contiguous data 
     from the {\tt rootPet} to all PETs across the {\tt ESMF\_VM} object
     (including {\tt rootPet}).
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData]
          Contiguous data array holding data to be sent. Only the {\tt sendData}
          array specified by the {\tt rootPet} will be used by this method.
     \item[sendCounts] 
          Number of {\tt sendData} elements to be sent to corresponding
          receive PET.
     \item[sendOffsets] 
          Offsets in units of elements in {\tt sendData} marking the start of
          element sequence to be sent to receive PET.
     \item[recvData] 
          Contiguous data array for data to be received. All PETs must specify a
          valid {\tt recvData} argument.
     \item[recvCount] 
          Number of {\tt recvData} elements to receive by local PET from
          {\tt rootPet}.
     \item[rootPet]
          PET that holds data that is being scattered.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMSend] {ESMF\_VMSend - Send data to dstPet}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMSend(vm, sendData, count, dstPet, &
      syncflag, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)  
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: dstPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc           \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Send contiguous data to {\tt dstPet} within the same {\tt ESMF\_VM} object.
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}, 
     {\tt ESMF\_TYPEKIND\_LOGICAL}, 
     {\tt ESMF\_TYPEKIND\_CHARACTER}.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData] 
          Contiguous data array holding data to be sent.
     \item[count] 
          Number of elements to be sent.
     \item[dstPet] 
          Receiving PET.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMSendRecv] {ESMF\_VMSendRecv - Send and Recv data to and from PETs}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}    subroutine ESMF_VMSendRecv(vm, sendData, sendCount, dstPet, &
      recvData, recvCount, srcPet, syncflag, commhandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      type(ESMF_VM),                    intent(in)            :: vm
      <type>(ESMF_KIND_<kind>), target, intent(in)            :: sendData(:)  
      integer,                          intent(in)            :: sendCount
      integer,                          intent(in)            :: dstPet
      <type>(ESMF_KIND_<kind>), target, intent(out)           :: recvData(:)  
      integer,                          intent(in)            :: recvCount
      integer,                          intent(in)            :: srcPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc           \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Send contiguous data to {\tt dstPet} within the same {\tt ESMF\_VM} object
     while receiving contiguous data from {\tt srcPet} within the same 
     {\tt ESMF\_VM} object. The {\tt sendData} and {\tt recvData} arrays must be
     disjoint!
  
     This method is overloaded for:
     {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
     {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8},
     {\tt ESMF\_TYPEKIND\_LOGICAL}, 
     {\tt ESMF\_TYPEKIND\_CHARACTER}.
  
     The arguments are:
     \begin{description}
     \item[vm] 
          {\tt ESMF\_VM} object.
     \item[sendData] 
          Contiguous data array holding data to be sent.
     \item[sendCount] 
          Number of elements to be sent.
     \item[dstPet] 
          PET that holds {\tt recvData}.
     \item[recvData] 
          Contiguous data array for data to be received.
     \item[recvCount] 
          Number of elements to be received.
     \item[srcPet] 
          PET that holds {\tt sendData}.
     \item[{[syncflag]}]
          Flag indicating whether this call behaves blocking or non-blocking.
          The default is {\tt ESMF\_SYNC\_BLOCKING}. See section
          \ref{const:sync} for a complete list of options.
     \item[{[commhandle]}]
          If present, a communication handle will be returned in case of a 
          non-blocking request (see argument {\tt syncflag}). The
          {\tt commhandle} can be used in {\tt ESMF\_VMCommWait()} to block the
          calling PET until the communication call has finished PET-locally. If
          no {\tt commhandle} was supplied to a non-blocking call the VM method
          {\tt ESMF\_VMCommWaitAll()} may be used to block on all currently queued
          communication calls of the VM context.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMValidate] {ESMF\_VMValidate - Validate VM internals}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_VMValidate(vm, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_VM), intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc  \end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


        Validates that the {\tt vm} is internally consistent.
        The method returns an error code if problems are found.  
  
       The arguments are:
       \begin{description}
       \item[vm] 
            Specified {\tt ESMF\_VM} object.
       \item[{[rc]}] 
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMWtime] {ESMF\_VMWtime - Get floating-point number of seconds}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_VMWtime(time, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     real(ESMF_KIND_R8), intent(out)           :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Get floating-point number of seconds of elapsed wall-clock time since the
     beginning of execution of the application.
  
     The arguments are:
     \begin{description}
     \item[time] 
          Time in seconds.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMWtimeDelay] {ESMF\_VMWtimeDelay - Delay execution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   recursive subroutine ESMF_VMWtimeDelay(delay, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     real(ESMF_KIND_R8), intent(in)            :: delay
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Delay execution for amount of seconds.
  
     The arguments are:
     \begin{description}
     \item[delay] 
          Delay time in seconds.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_VMWtimePrec] {ESMF\_VMWtimePrec - Timer precision as floating-point number of seconds}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_VMWtimePrec(prec, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     real(ESMF_KIND_R8), intent(out)           :: prec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Get a run-time estimate of the timer precision as floating-point number 
     of seconds. This is a relatively expensive call since the timer precision
     is measured several times before the maximum is returned as the estimate.
     The returned value is PET-specific and may differ across the VM 
     context.
  
     The arguments are:
     \begin{description}
     \item[prec] 
          Timer precision in seconds.
     \item[{[rc]}] 
          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
