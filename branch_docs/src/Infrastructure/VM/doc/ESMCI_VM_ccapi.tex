%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_VM.C,  Date: Tue May  5 20:59:28 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMCI::VMId::create] {ESMCI::VMId::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VMId::create() {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Allocate space and initialize VMId internals.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMId::destroy] {ESMCI::VMId::destroy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VMId::destroy() {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Deallocate VMId internals.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMId::deserialize] {ESMCI::VMId::deserialize}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VMId::deserialize(const char *buffer, int *offset, bool offsetonly) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Deserialize a buffer into a VMId object.  Assumes vmKey has been
      been pre-allocated.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMId::get] {ESMCI::VMId::get}


  
\bigskip{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\sf INTERFACE:}
\begin{verbatim} int VMId::get(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int  *localID,
   char *key,
   int   key_len
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the elements of a {\tt ESMC\_VMId} object.
  
      This method is primarily intended for use by VM unit tests.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMId::set] {ESMCI::VMId::set}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VMId::set(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int   localID,
   const char *key,
   int   key_len
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the elements of an existing {\tt ESMC\_VMId} object.
  
      This method is primarily intended for use by VM unit tests.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMId::log] {ESMCI::VMId::log}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VMId::log(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   std::string prefix
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


     Log the VMId.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMId::print] {ESMCI::VMId::print}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VMId::print() const{\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Print details of VMId object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMId::serialize] {ESMCI::VMId::serialize}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VMId::serialize(
     const char *buffer,   // in - base address of the serialization buffer
     int *length,          // in - length of the serialization buffer
     int *offset,          // inout - offset for serialization of this object
     const ESMC_InquireFlag &inquireflag) {  // in update offset only flag\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn info in a VMId object into a stream of bytes.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMIdCreate] {ESMCI::VMIdCreate}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} VMId VMIdCreate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Created {\tt ESMC\_VMId} object.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *rc){   // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Allocate memory for a new {\tt ESMC\_VMId} object and reset members.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMIdDestroy] {ESMCI::VMIdDestroy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VMIdDestroy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim} \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMId *vmID,
   int *rc
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Free memory for a previously created {\tt ESMC\_VMId} object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMIdCompare] {ESMCI::VMIdCompare}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool VMIdCompare(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool indicating result of comparison.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMId *vmID1,
   VMId *vmID2
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Compare two {\tt ESMC\_VMId} objects.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMIdCopy] {ESMCI::VMIdCopy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VMIdCopy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMId *vmIDdst,
   VMId *vmIDsrc
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Copy {\tt ESMC\_VMId} object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMIdGet] {ESMCI::VMIdGet}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VMIdGet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim} \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMId *vmID,
   int  *localID,
   char *key,
   int   key_len,
   int  *rc
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the elements of a {\tt ESMC\_VMId} object.
  
      This method is primarily intended for use by VM unit tests.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VMIdSet] {ESMCI::VMIdSet}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VMIdSet(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim} \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMId *vmID,
   int   localID,
   char *key,
   int   key_len,
   int  *rc
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the elements of an existing {\tt ESMC\_VMId} object.
  
      This method is primarily intended for use by VM unit tests.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::startup] {ESMCI::VM::startup}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void *VM::startup(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      void * to info structure\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   class VMPlan *vmp,              // plan for this child VM
   void *(fctp)(void *, void *),   // function pointer to 1st stage callback
   void *cargo,                    // pointer to cargo structure for in/out data
   int *rc){                       // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Startup a new child VM according to plan.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::shutdown] {ESMCI::VM::shutdown}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::shutdown(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   class VMPlan *vmp,              // plan for this child VM
   void *info,                     // info structure
   int *rc){                       // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Shut down a child VM according to plan.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::enter] {ESMCI::VM::enter}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VM::enter(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   class VMPlan *vmp,              // plan for this child VM
   void *info,                     // info structure
   void *cargo                     // pointer to cargo structure for in/out data
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Enter a child VM.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::getPETMatchPET] {ESMCI::VM::getPETMatchPET}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VM::getPETMatchPET(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int pet,                      // in  - id of specified PET
   VM &vmMatch,                  // in  - vm to match against
   int *petMatchCount,           // out - number of matching PETs in vmMatch
   int *petMatchList,            // out - list of matching PETs in vmMatch
   int len_petMatchList          // in  - size of petMatchList
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Match PET in the current VM object against the PETs in the
      provided vmMatch VM. Return number of matched PETs and a list of the
      matching PET id's that operate in the same virtual address space as
      the specified PET.
      Returns ESMC_RC_ARG_SIZE if {\tt petMatchList} was provided
      (i.e. not equal to {\tt ESMC\_NULL\_POINTER) but
      {\tt len_petMatchList} < number of matching PETs found.
      Otherwise returns ESMF_SUCCESS (even if no matching PETs were found!).
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::getVMId] {ESMCI::VM::getVMId - Get ID of VM object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} VMId *VM::getVMId(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ID of VM\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *rc) const{   // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


     Get the ID of the {\tt ESMC\_VM} object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::sendVMId] {ESMCI::VM::sendVMId}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VM::sendVMId(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMId *vmID,                   // in  - VMId to be sent
   int dest                      // in  - destination PET
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Send {\tt ESMCI::VMId} to another PET.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::recvVMId] {ESMCI::VM::recvVMId}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VM::recvVMId(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMId *vmID,                   // out - VMId to be received
   int source                    // in  - source PET
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Receive {\tt ESMCI::VMId} from another PET.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::alltoallvVMId] {ESMCI::VM::alltoallvVMId}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VM::alltoallvVMId(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMId **sendvmID,              // in  - VMIds to send
   int *sendcounts,              // in  - VMId send counts
   int *sendoffsets,             // in  - send offsets
   VMId **recvvmID,              // out - VMIds to receive
   int *recvcounts,              // out - VMId receive counts
   int *recvoffsets              // out - receive offsets
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      All to all communication {\tt ESMCI::VMId}.  Assumes that the receive VMId
   array has been pre-allocated and initialized.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::allgathervVMId] {ESMCI::VM::allgathervVMId}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VM::allgathervVMId(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMId **sendvmid,               // in - VMIds
   int sendcount,                 // in  - VMId count
   VMId **recvvmid,               // out - VMIds
   int *recvcounts,               // in  - VMId count
   int *recvoffsets               // in  - VMId offsets
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      AllGatherV {\tt ESMCI::VMId}.  Assumes that the receive VMId
   array has been pre-allocated and initialized.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::bcastVMId] {ESMCI::VM::bcastVMId}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VM::bcastVMId(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMId **vmID,                  // in/out - VMId
   int count,                    // in  - VMId count
   int root                      // in  - root PET
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Broadcast {\tt ESMCI::VMId}.  Assumes that the receive VMId
   array has been pre-allocated and initialized.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::print] {ESMCI::VM::print}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VM::print() const{\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Print details of VM object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::validate] {ESMCI::VM::validate}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VM::validate()const{\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Validate details of VM object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::getArgs] {ESMCI::VM::getArgs - Get command line arguments}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::getArgs(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Get command line arguments\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *argc,      // count of command line arguments
   char ***argv,   // command line argument strings
   int *rc){       // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


     Get the command line arguments
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::getGlobal] {ESMCI::VM::getGlobal - Get Global VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} VM *VM::getGlobal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Pointer to global VM\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *rc){   // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


     Get the global default {\tt ESMCI::VM} object. This is the {\tt ESMCI::VM}
     object that was created during {\tt ESMC\_Initialize()} and is the ultimate
     parent of all {\tt ESMCI::VM} objects in an ESMF application.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::getCurrent] {ESMCI::VM::getCurrent - Get Current VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} VM *VM::getCurrent(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Pointer to current VM\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *rc){   // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


     Get the {\tt ESMC\_VM} object of the current context.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::getCurrentID] {ESMCI::VM::getCurrentID - Get ID of current VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} VMId *VM::getCurrentID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ID of current VM\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *rc){   // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


     Get the ID of the current {\tt ESMCI::VM} object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::getCurrentGarbageInfo] {ESMCI::VM::getCurrentGarbageInfo - Get garbage info for Current VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::getCurrentGarbageInfo(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *fobjCount,     // number of Fortran objects registered
   int *objCount){     // total number of objects registered (Fortran + C++)\end{verbatim}
{\sf DESCRIPTION:\\ }


     Get the garbage info of the current context.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::logCurrentGarbageInfo] {ESMCI::VM::logCurrentGarbageInfo - Log garbage info of current VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::logCurrentGarbageInfo(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   std::string prefix
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Log the garbage collection information of the current context.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::getMemInfo] {ESMCI::VM::getMemInfo - Get memory info}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::getMemInfo(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *virtMemPet,    // virtual memory used by this PET in KB
   int *physMemPet     // physical memory used by this PET in KB
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Get the memory information of the local PET.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::logMemInfo] {ESMCI::VM::logMemInfo - Log memory info}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::logMemInfo(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   std::string prefix,
   ESMCI::LogErr *log
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Log the memory information of the local PET.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::getBaseIDAndInc] {ESMCI::VM::getBaseIDAndInc - Get BaseID and increment counter}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int VM::getBaseIDAndInc(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      current BaseID count\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMId *vmID){   // identifying vmID\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::addObject] {ESMCI::VM::addObject - Add object to table for garbage collection}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::addObject(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ESMC_Base *object,
   VMId *vmID){   // identifying vmID\end{verbatim}
{\sf DESCRIPTION:\\ }


      Add object to matchTable_Objects list for this VM. Objects in this
      list will be delete during VM shutdown and finalize. This implements
      automatic garbage collection of ESMF objects on the Component scope.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::rmObject] {ESMCI::VM::rmObject - Remove object from table for garbage collection}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::rmObject(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ESMC_Base *object){   // object to be removed\end{verbatim}
{\sf DESCRIPTION:\\ }


      Remove object from matchTable_Objects list for current VM.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::addFObject] {ESMCI::VM::addFObject - Add Fortran object to table for garb col.}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::addFObject(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void **fobject,
   int objectID,
   VMId *vmID){   // identifying vmID\end{verbatim}
{\sf DESCRIPTION:\\ }


      Add Fortran object to matchTable_FObjects list for this VM. Objects in
      list will be delete during VM shutdown and finalize. This implements
      automatic garbage collection of ESMF objects on the Component scope.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::getObject] {ESMCI::VM::getObject - Find and return an ESMF object.}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::getObject(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void **fobject,     // out - alias to object
   int objectID,       // in - identifying ID
   VMId *vmID,         // in - identifying vmID
   const string &name, // in - identifying object name
   ESMC_ProxyFlag proxyflag,  // in - proxy/non-proxy flag
   bool *object_found, // out - true if found, false if not
   int *rc) {\end{verbatim}
{\sf DESCRIPTION:\\ }


      Find and return a object in matchTable_FObjects list for a
      given ID/vmId.
  
      If proxyflag is ESMF_PROXYYES, only match proxies.  Likewise, if
      ESMF_PROXYNO, only match non-proxies.  ESMF_PROXYANY matches any.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::rmFObject] {ESMCI::VM::rmFObject - Remove Fortran object from table for garbage collection}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::rmFObject(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void **fobject){   // object to be removed\end{verbatim}
{\sf DESCRIPTION:\\ }


      Remove Fortran object from matchTable_Objects list for current VM.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::printMatchTable] {ESMCI::VM::printMatchTable - Print the current match table}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::printMatchTable(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Print the current match table.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::getenv] {ESMCI::VM::getenv - get environment variable}


\bigskip{\sf INTERFACE:}
\begin{verbatim} char const *VM::getenv(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      pointer to value or NULL\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char const *name){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Access environment variables in the global VM object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::initialize] {ESMCI::VM::initialize}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} VM *VM::initialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      VM * to GlobalVM\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   MPI_Comm mpiCommunicator,
   int *rc){   // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Initialize the global virtual machine as an all MPI VM and return a
      handle to the local instance of the GlobalVM.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::finalize] {ESMCI::VM::finalize}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::finalize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ESMC_Logical *keepMpiFlag,
   int *rc){   // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Finalize the global virtual machine referenced by GlobalVM
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::abort] {ESMCI::VM::abort}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::abort(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *rc){   // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Abort the global virtual machine referenced by GlobalVM
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::isInitialized] {ESMCI::VM::isInitialized}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool VM::isInitialized(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      true/false indicating initialized status\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *rc){   // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Query ESMF initialized status.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::isFinalized] {ESMCI::VM::isFinalized}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool VM::isFinalized(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      true/false indicating finalized status\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *rc){   // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Query ESMF finalized status.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::timerLog] {ESMCI::VM::timerLog}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void VM::timerLog(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   std::string timer){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Log the timer information to the default log
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::VM::MPIError] {ESMCI::VM::MPIError - Check for MPI error and log if true}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool VM::MPIError(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int mpiErrorToCheck,
   int LINE, 
   const std::string &FILE,
   const std::string &method,
   int *rcToReturn){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Check for MPI error and log if an error is found
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
