%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_Util.C,  Date: Tue May  5 20:59:25 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_TypeKind\_FlagSize] {ESMC\_TypeKind\_FlagSize - Return number of bytes in a TypeKind}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     int ESMC_TypeKind_FlagSize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    int number of bytes (negative for error)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     ESMC_TypeKind_Flag dk) {       // in - a data kind\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_StatusString] {ESMC\_StatusString - Return fixed char string for printing}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     const char *ESMC_StatusString(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    const char * to string name of value\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     ESMC_Status stat) {       // in - a status value\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_TypeKind\_FlagString] {ESMC\_TypeKind\_FlagString - Return fixed char string for printing}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     const char *ESMC_TypeKind_FlagString(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    const char * to string name of value\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     ESMC_TypeKind_Flag dk) {       // in - a datakind value\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_LogicalString] {ESMC\_LogicalString - Return fixed char string for printing}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     const char *ESMC_LogicalString(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    const char * to string name of value\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     ESMC_Logical tf) {       // in - a logical value\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_cxxtoF90string] {ESMC\_cxxtoF90string - Conversion routine from C++ string to F90 character}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   void  ESMC_cxxtoF90string(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    converts a C++ string into an F90, space padded string.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const std::string &src,        // in - C++ string source buffer
     char *dst,                     // out - pointer to a buffer to hold F90 string
     int *rc,                       // out - return code
     ESMCI_FortranStrLenArg dlen) { // *hidden* in - max len of F90 dst buffer\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_F90lentrim] {ESMC\_F90lentrim - Returns the trimmed length of a F90 string}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     size_t ESMC_F90lentrim (\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    Returns the length of a Fortran character string, minus trailing blanks.
    Analoguous to the Fortran LEN_TRIM intrinsic.  Return type is size_t for
    compatibility with the C++ string constructor and other places where
    string lengths are needed.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const char *src,                // in - Fortran character string
     ESMCI_FortranStrLenArg slen) {   // in - length of the string\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_F90toCstring] {ESMC\_F90toCstring - Convert an F90 string into a C string}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     char *ESMC_F90toCstring(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    returns pointer to a newly allocated C string buffer.  This space
    must be deleted by the caller when finished!\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const char *src,                // in - F90 character source buffer
     ESMCI_FortranStrLenArg slen) {   // in - length of the F90 source buffer\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_F90toCstring] {ESMC\_F90toCstring - Convert an F90 string into a C string}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     int ESMC_F90toCstring(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    converts an F90, space padded string into a C++ null terminated string
    returns ESMF_SUCCESS or ESMF_FAILURE.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const char *src,               // in - F90 character source buffer
     ESMCI_FortranStrLenArg slen,   // in - length of the F90 source buffer
     char *dst,                     // inout - pointer to a buffer to hold C string
     ESMCI_FortranStrLenArg dlen) { // in - max len of C dst buffer, inc term NULL\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_CtoF90string] {ESMC\_CtoF90string - Convert a C string into an F90 string}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     int ESMC_CtoF90string(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    constructs a space padded F90, non-null terminated string in dst buffer.
    returns ESMF_SUCCESS or ESMF_FAILURE.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const char *src,               // in - C null term string source buffer
     char *dst,                     // inout - pointer to a buffer holding F90 string
 
     ESMCI_FortranStrLenArg dlen) {  // in - length of dst buffer, space padded\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMF\_F90toCstring] {ESMF\_F90toCstring - Fortran-callable conversion routine from F90 character to C string}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} extern "C" {
     void  FTN_X(esmf_f90tocstring)(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    converts an F90, space padded string into a C null terminated string
    sets *rc to ESMF_SUCCESS or ESMF_FAILURE, returns nothing.
    the arguments below labeled *hidden* are added by the fortran compiler
    and should not appear in the fortran argument list\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const char *src,               // in - F90 character source buffer
     char *dst,                     // inout - pointer to a buffer to hold C string
     int *rc,                       // out - return code
     ESMCI_FortranStrLenArg slen,   // *hidden* in - length of the F90 source buffer
     ESMCI_FortranStrLenArg dlen) { // *hidden* in - max len of C dst buffer, inc term NULL\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMF\_CtoF90string] {ESMF\_CtoF90string - Fortran-callable conversion routine from C string to F90 character}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} extern "C" {
     void  FTN_X(esmf_ctof90string)(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    converts a C null terminated string into an F90, space padded string
    sets *rc to ESMF_SUCCESS or ESMF_FAILURE, returns nothing.
    the arguments below labeled *hidden* are added by the fortran compiler
    and should not appear in the fortran argument list\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const char *src,               // in - F90 character source buffer
     char *dst,                     // inout - pointer to a buffer to hold C string
     int *rc,                       // out - return code
     ESMCI_FortranStrLenArg slen,   // *hidden* in - length of the F90 source buffer
     ESMCI_FortranStrLenArg dlen) { // *hidden* in - max len of C dst buffer, inc term NULL\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMF\_PointerToInt] {ESMF\_PointerToInt - Fortran-callable routine which returns}


     the value of a fortran address as a simple integer.
  
\bigskip{\sf INTERFACE:}
\begin{verbatim} extern "C" {
     void  FTN_X(esmf_pointertoint)(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    converts a F90 pointer into a normal integer.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int *n,                    // in - number of expected bytes in a pointer
     short *s,                  // in - F90 pointer of some kind
     ESMC_POINTER *len) {  // out - that same value cast to an int/long\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMF\_PointerDifference] {ESMF\_PointerDifference - Fortran-callable routine which returns}


     the difference between 2 addresses as a simple integer.
  
\bigskip{\sf INTERFACE:}
\begin{verbatim} extern "C" {
     void  FTN_X(esmf_pointerdifference)(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    converts the difference between 2 F90 pointers into a normal integer.
    the pointers should be close enough to each other to be less than
    2 ^ 32 apart so the result fits in to a standard integer return val.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int *n,            // in - number of expected bytes in a pointer
     short *s1,         // in - F90 pointer of some kind
     short *s2,         // in - F90 pointer of some kind
     int *len) {        // out - that same value cast to an int\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_InitializeGUID] {ESMC\_InitializeGUID - Initialize/reset a Globally Unique ID (GUID) sequence}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     int ESMC_InitializeGUID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    returns ESMF_SUCCESS or ESMF_FAILURE.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     void) {
 \end{verbatim}
{\sf DESCRIPTION:\\ }


   Initialize a sequence of Globally Unique IDs (GUIDs) in a platform
   independent way (e.g. does not require UUID library).  Uses <cstdlib> srand() 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_GenerateGUID] {ESMC\_GenerateGUID - Generate a Globally Unique ID (GUID)}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     int ESMC_GenerateGUID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    returns ESMF_SUCCESS or ESMF_FAILURE.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     string &guid) {    // inout - caller's buffer to hold GUID string
 \end{verbatim}
{\sf DESCRIPTION:\\ }


   Generate a Globally Unique ID (GUID) in a platform independent way (e.g.
     does not require UUID library).  Uses <cstdlib> srand(), rand(). 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_FindAndReplaceAll] {ESMC\_FindAndReplaceAll - Find and replace all occurrences of a string in a given string with another}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     int ESMC_FindAndReplaceAll(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    returns ESMF_SUCCESS or ESMF_FAILURE.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}           string& subjectStr,    // inout - caller's subject string
     const string& searchStr,     // in    - string to search for in subject str
     const string& replaceStr) {  // in    - replacement string
 \end{verbatim}
{\sf DESCRIPTION:\\ }


   Find and replace all occurrences of searchStr within subjectStr with
   replaceStr.  TODO:  When C++11 STL becomes supported in all our supported
   compilers/versions, replace with std::tr1::regex_replace() or simply
   std::regex_replace().
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
