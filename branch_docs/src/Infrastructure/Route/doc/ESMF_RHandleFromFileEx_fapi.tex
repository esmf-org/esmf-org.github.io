%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_RHandleFromFileEx.F90,  Date: Tue May  5 20:59:40 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

   \subsubsection{Write a RouteHandle to file and creating a RouteHandle from file}
   \label{RH:RHfromFile}
  
   Communication Store() methods, like {\tt ESMF\_FieldRegridStore()}, are used
   to create RouteHandles. These methods can be expensive, both with respect to
   temporary memory requirements as well as the time they require to execute.
   Often the associated cost is acceptable because Store() calls are typically
   used during the initialization phase of the application. The cost of 
   RouteHandle generation is therefore armorized over the entire run phase
   of the application, where the RouteHandle is applied over and over to 
   transfer data according to the same communication pattern.
  
   However, especially for short production runs, an expensive initialization
   time can become problematic. In such cases it is useful to write the
   RouteHandle to file. Subsequent application runs can then re-create the
   RouteHandle during initialization, simply from file at a fraction of the time
   of the original Store() call. 
%/////////////////////////////////////////////////////////////

   First a RouteHandle must be created using one of the ESMF Store() methods. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_FieldRedistStore(srcField=fieldA, dstField=fieldB, &
    routehandle=rh1, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Now the RouteHandle object {\tt rh1} can be written to file using the
   {\em collective} {\tt ESMF\_RouteHandleWrite()} method. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_RouteHandleWrite(rh1, fileName="testWrite.RH", rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   This creates a single binary file with name {\tt testWrite.RH}. The 
   information from across all PETs that define {\tt rh1} is contained in this
   file.
  
   At this point, the original RouteHandle is no longer needed and can be
   destroyed. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_RouteHandleDestroy(rh1, noGarbage=.true., rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The RouteHandle just deleted can easily be re-created using the
   {\tt ESMF\_RouteHandleCreate()} method that accepts the file name as an 
   argument. This is a {\em collective} method that must be called on exactly
   the same number of PETs that was used for the original Store() and Write()
   calls that generated the file. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  rh2 = ESMF_RouteHandleCreate(fileName="testWrite.RH", rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Finally the re-created RouteHandle, {\tt rh2}, can be used to execute the
   communication pattern originally computed in {\tt rh1}. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_FieldRedist(srcField=fieldA, dstField=fieldB, &
    routehandle=rh2, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Once done with {\tt rh2}, the RouteHandle can be destroyed as usual. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_RouteHandleDestroy(rh2, noGarbage=.true., rc=rc)
 
\end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
