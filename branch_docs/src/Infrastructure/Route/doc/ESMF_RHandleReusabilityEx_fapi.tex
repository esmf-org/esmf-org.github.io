%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_RHandleReusabilityEx.F90,  Date: Tue May  5 20:59:40 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

   \subsubsection{Reusablity of RouteHandles and interleaved distributed 
   and undistributed dimensions}
   \label{RH:Reusability}
  
   A RouteHandle object is typically created during a communication {\tt Store()}
   call, e.g. an {\tt ESMF\_FieldRegridStore()}. Other communication methods
   with {\tt Store()} are {\tt Halo}, {\tt Redist}, and {\tt SMM}. The primary
   input objects of a {\tt Store()} call are either Fields, Arrays,
   FieldBundles, or ArrayBundles. There will be an object for the source side,
   and another object for the destination side. Both objects must be of the
   same type. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  srcField = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  dstField = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_FieldRegridStore(srcField=srcField, dstField=dstField, &
    routehandle=routehandle, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The purpose of the explicit {\tt Store()} call is to separate out the 
   expensive part of creating the RouteHandle object for a specific
   communication patter, from the less expensive part of applying it.
   Applying the RouteHandle results in data movement between 
   the source and destination objects. Once a RouteHandle is available, it is
   reusable. This means it can be applied over and over again to communicate
   data from the source to the destination object. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  do i=1, 10
    ! repeatedly applying the routehandle
    call ESMF_FieldRegrid(srcField=srcField, dstField=dstField, &
      routehandle=routehandle, rc=rc)
  enddo
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Reusability of a RouteHandle object extends beyond re-applying it to the same
   source/destination object pair that was used during {\tt Store()}. The same
   RouteHandle can be applied to a different object pair, as long as these
   criterial are met:
   \begin{itemize}
   \item The new pair matches the original pair with respect to {\em type}, 
     and {\em kind}.
   \item The memory layout of the {\em distributed} (i.e. {\em gridded}) 
     dimensions of the new pair is congruent with the original pair. This means
     the {\em DistGrid}s must match, as well as any extra padding on the 
     distributed/gridded dimensions.
   \item Size, number, and position (i.e. index order) of potentially present
     {\em undistributed} (i.e. {\em ungridded}) dimensions does not affect the
     reusability of a RouteHandle.
   \end{itemize}
   The following examples will discuss in detail what this means in practice.
  
   First consider the case where a second pair of source and destination Fields
   is created identical to the first set. The precomputed RouteHandle is 
   immediatly reusable for this new Field pair to carry out the regrid operation. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  srcField2 = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  dstField2 = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  ! applying the same routehandle to a different pair of fields
  call ESMF_FieldRegrid(srcField=srcField2, dstField=dstField2, &
    routehandle=routehandle, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The same RouteHandle stays re-usable even for a Field pair where source and 
   destination have one or more additional undistributed dimensions. Here a
   single undistributed dimension is added. By default all undistributed 
   dimensions will be ordered {\em after} the distributed dimensions provided
   by the Grid object.  
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  srcField3 = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, &
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &  ! undistributed dim last
    rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  dstField3 = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, &
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), & ! undistributed dim last
    rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  ! applying the same routehandle to a different pair of fields
  call ESMF_FieldRegrid(srcField=srcField3, dstField=dstField3, &
    routehandle=routehandle, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The undistributed dimension can also be moved into the first position,
   and the same RouteHandle can still be re-used. Specifying the order
   of dimensions in a Field is accomplished by providing the
   {\tt gridToFieldMap}. Here the Grid dimensions are mapped to 2nd and 3rd
   Field dimensions, moving the undistributed dimension into the leading
   position. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  srcField4 = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, &
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &
    gridToFieldMap=(/2,3/), rc=rc)  ! undistributed dim 1st 
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  dstField4 = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, &
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &
    gridToFieldMap=(/2,3/), rc=rc)  ! undistributed dim 1st 
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  ! applying the same routehandle to a different pair of fields
  call ESMF_FieldRegrid(srcField=srcField4, dstField=dstField4, &
    routehandle=routehandle, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   It is not necessary that the undistributed dimension is in the same position
   on the source and destination Field. The only criteria that needs to be
   satisfied is that both source and destination have the {\em same number} of 
   undistributed elements. Here the RouteHandle is re-used for a 
   Field pair where the destination Field interleaves the undistributed dimension
   between the two distributed dimensions. At the same time the source Field
   keeps the undistributed dimension in leading position. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  srcField5 = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, &
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &
    gridToFieldMap=(/2,3/), rc=rc)  ! undistributed dim 1st 
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  dstField5 = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, &
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &
    gridToFieldMap=(/1,3/), rc=rc)  ! undistributed dim 2nd
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  ! applying the same routehandle to a different pair of fields
  call ESMF_FieldRegrid(srcField=srcField5, dstField=dstField5, &
    routehandle=routehandle, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   In the following example the undistributed elements on the source side are
   spread across two undistributed dimensions. Of course the product of the two
   dimension sizes must equal the number of undistributed elements on the 
   destination side, in order to fulfil the element count criteria. Here this 
   number is 10. At two undistributed dimension on the source side are placed
   in first and fourth position using the {\tt gridToFieldMap}. The same
   RouteHandle is applied to this Field pair, resulting in the desired 
   regrid operation. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  srcField6 = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, &
    ungriddedLBound=(/1,1/), ungriddedUBound=(/2,5/), &
    gridToFieldMap=(/2,3/), rc=rc)  ! undistributed dims 1st and 4th
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  dstField6 = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, &
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &
    gridToFieldMap=(/1,3/), rc=rc)  ! undistributed dim 2nd
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  ! applying the same routehandle to a different pair of fields
  call ESMF_FieldRegrid(srcField=srcField6, dstField=dstField6, &
    routehandle=routehandle, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   While the RouteHandle was precomputed using a specific source/destination
   Field pair, we have seen how it can be re-used as long as the memory layout 
   associated with the distributed (i.e. gridded) dimensions does not change.
   A natural extension of this feature is to allow the same RouteHandle to be 
   re-used when source and destination are FieldBundles instead of Fields. The
   only requirement here is that both sides contain the same number of elements,
   and that
   each pair constructed from the source and destination side is compatible with
   the original pair used as shown in the examples above. Here this criteria is
   simply met by constructing the source and destination FieldBundles from the
   exact Fields used in the previous examples. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  srcFieldBundle = ESMF_FieldBundleCreate(fieldList=(/srcField, &
    srcField2, srcField3, srcField4, srcField5, srcField6/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  dstFieldBundle = ESMF_FieldBundleCreate(fieldList=(/dstField, &
    dstField2, dstField3, dstField4, dstField5, dstField6/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  ! applying the same routehandle to a pair of FieldBundles
  call ESMF_FieldBundleRegrid(srcFieldBundle, dstFieldBundle, &
    routehandle=routehandle, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   On a fundamental level, RouteHandles are re-usable across objects that
   have the same memory layout for their distributed dimensions. Since ESMF
   Fields are built on top of ESMF Arrays, it is 
   possible to re-use the same RouteHandle that was precomputed for a Field
   pair and apply it to a matching Array pair. 
  
   For this example, the easiest way to create Arrays with the same memory 
   layout in the distributed dimensions is to query the source and destination
   Grid objects for their DistGrids. Then source and destination Arrays can be
   easily constructed. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_GridGet(srcGrid, distgrid=srcDistGrid, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_GridGet(dstGrid, distgrid=dstDistGrid, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  srcArray = ESMF_ArrayCreate(srcDistGrid, ESMF_TYPEKIND_R8, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  dstArray = ESMF_ArrayCreate(dstDistGrid, ESMF_TYPEKIND_R8, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  ! applying the same routehandle to an Array pair
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &
    routehandle=routehandle, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Finally the resources associated with the RouteHandle object are released.
   The recommended way to do this is by calling into the {\tt Release()} method
   associated with the {\tt Store()} method used to create the RouteHandle. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_FieldRegridRelease(routehandle, rc=rc)
 
\end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
