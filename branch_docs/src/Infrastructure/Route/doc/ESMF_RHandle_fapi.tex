%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_RHandle.F90,  Date: Tue May  5 20:59:39 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_RouteHandleCreate] {ESMF\_RouteHandleCreate - Create a new RouteHandle from RouteHandle}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_RouteHandleCreate()
   function ESMF_RouteHandleCreateRH(routehandle, &
     originPetList, targetPetList, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_RouteHandle) :: ESMF_RouteHandleCreateRH\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_RouteHandle), intent(in)            :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: originPetList(:)
     integer,                intent(in),  optional :: targetPetList(:)
     integer,                intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Create a new {\tt ESMF\_RouteHandle} object from and existing RouteHandle.
     The new RouteHandle can be created to function on a different petList than
     the incoming RouteHandle.
  
     The arguments are:
     \begin{description}
     \item[routehandle]
       The RouteHandle object to be duplicated.
     \item[{[originPetList]}]
       \begin{sloppypar}
       The petList on which the incoming {\tt routehandle} is defined to operate.
       If present, then {\tt targetPetList} must also be present and of the same
       size. The petLists are used to map origin PETs to target PETs. By 
       convention the petLists are constructed to first list the PETs of the
       source component, followed by the PETs of the destination component.
       Defaults, to the petList of the current component context, meaning that 
       the PETs in the RouteHandle are not modified.
       \end{sloppypar}
     \item[{[targetPetList]}]
       \begin{sloppypar}
       The petList on which the newly created RouteHandle is defined to operate.
       If present, then {\tt originPetList} must also be present and of the same
       size. The petLists are used to map origin PETs to target PETs. By 
       convention the petLists are constructed to first list the PETs of the
       source component, followed by the PETs of the destination component.
       Defaults, to the petList of the current component context, meaning that 
       the PETs in the RouteHandle are not modified.
       \end{sloppypar}
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_RouteHandleCreate] {ESMF\_RouteHandleCreate - Create a new RouteHandle from file}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_RouteHandleCreate()
   function ESMF_RouteHandleCreateFile(fileName, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_RouteHandle) :: ESMF_RouteHandleCreateFile\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     character(*),           intent(in)            :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Create a new {\tt ESMF\_RouteHandle} object from a file. This method must
     be called from a VM context that holds exactly as many PETs as were used
     when generating the file.
  
     The arguments are:
     \begin{description}
     \item[fileName]
       The name of the RouteHandle file to be read in.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_RouteHandleDestroy] {ESMF\_RouteHandleDestroy - Release resources associated with a RouteHandle}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_RouteHandleDestroy(routehandle, &
     noGarbage, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_RouteHandle), intent(inout)          :: routehandle   
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),   optional :: noGarbage
     integer,                intent(out),  optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Destroys an {\tt ESMF\_RouteHandle}, releasing the resources associated
     with the object.
  
     The arguments are:
     \begin{description}
     \item[routehandle] 
       The {\tt ESMF\_RouteHandle} to be destroyed.
     \item[{[noGarbage]}]
       If set to {\tt .TRUE.} the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases -- a situation which may lead to hard to debug 
       application crashes.
   
       It is generally recommended to leave the {\tt noGarbage} argument
       set to {\tt .FALSE.} (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully 
       removing the entire temporary object from memory.
     \item[{[rc]}] 
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_RouteHandleGet] {ESMF\_RouteHandleGet - Get values from a RouteHandle}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_RouteHandleGet()
   subroutine ESMF_RouteHandleGetP(routehandle, name, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_RouteHandle), intent(in)            :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),       intent(out), optional :: name
     integer,                intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


       Returns information about an {\tt ESMF\_RouteHandle}.
  
       The arguments are:
       \begin{description}
       \item[routehandle] 
            {\tt ESMF\_RouteHandle} to be queried.
       \item [{[name]}]
            Name of the RouteHandle object.
       \item[{[rc]}] 
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_RouteHandleIsCreated] {ESMF\_RouteHandleIsCreated - Check whether a RouteHandle object has been created}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   function ESMF_RouteHandleIsCreated(routehandle, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: ESMF_RouteHandleIsCreated\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_RouteHandle), intent(in)            :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     Return {\tt .true.} if the {\tt routehandle} has been created. Otherwise return 
     {\tt .false.}. If an error occurs, i.e. {\tt rc /= ESMF\_SUCCESS} is 
     returned, the return value of the function will also be {\tt .false.}.
  
   The arguments are:
     \begin{description}
     \item[routehandle]
       {\tt ESMF\_RouteHandle} queried.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_RouteHandlePrint] {ESMF\_RouteHandlePrint - Print the contents of a RouteHandle}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_RouteHandlePrint(routehandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_RouteHandle), intent(in)            :: routehandle      
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Print information about an {\tt ESMF\_RouteHandle}.
  
     The arguments are:
     \begin{description}
     \item[routehandle] 
       {\tt ESMF\_RouteHandle} to print contents of.
     \item[{[rc]}] 
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_RouteHandleSet] {ESMF\_RouteHandleSet - Set values in a RouteHandle}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_RouteHandleSet()
   subroutine ESMF_RouteHandleSetP(routehandle, name, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len = *),     intent(in),  optional :: name    
     integer,                intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     Set an {\tt ESMF\_RouteHandle} attribute with the given value.
  
     The arguments are:
     \begin{description}
     \item[routehandle] 
       {\tt ESMF\_RouteHandle} to be modified.
     \item [{[name]}]
       The RouteHandle name.
     \item[{[rc]}] 
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_RouteHandleWrite] {ESMF\_RouteHandleWrite - Write the RouteHandle to file}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_RouteHandleWrite(routehandle, fileName, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_RouteHandle), intent(inout)         :: routehandle   
     character(*),           intent(in)            :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


     Write the RouteHandle to file. The generated file can then be used to
     re-create the same RouteHandle, on the same number of PETs, using the 
     {\tt ESMF\_RouteHandleCreate(fileName=...)} method.
  
     The arguments are:
     \begin{description}
     \item[routehandle] 
       The {\tt ESMF\_RouteHandle} to be written.
     \item[fileName]
       The name of the output file to which the RouteHandle is written.
     \item[{[rc]}] 
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
