%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_GridCreateFromF90ArraysEx.F90,  Date: Tue May  5 20:59:48 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

   \subsubsection{Create a Grid from existing F90 arrays}~\label{sec:example5}
  
   This example illustrates the creation of a simple 2D Grid from coordinate data
    contained in fortan arrays.  The new Grid contains just the center stagger location.
    Each processor contains a pair of 10x10 Fortran 90 arrays named fptrX and fptrY.
    These arrays contain the coordinates for the piece of the global Grid held by each
    processor. The final global Grid will be 20x20 and the pieces of this Grid held
   by each processor are as follows:
  
   \begin{verbatim}
  
    
         20  +--------------+--------------+
             |              |              |                       
             |              |              |                       
             |     PET3     |     PET4     |                       
             |              |              |                       
             |              |              |  
         10  +--------------+--------------+ 
             |              |              |                       
             |              |              |                       
             |     PET 1    |     PET2     |                       
             |              |              |  
             |              |              |                      
          1  +--------------+--------------+
             1             10             20  
  
  
   \end{verbatim}
  
     As illustrated by the diagram, the arrays on processor 1 hold piece (1,1)-(10,10) of the 
     global index space. The arrays on processor 2 hold piece (11,1)-(20,10). The arrays on 
     processor 3 hold piece (1,11)-(10,20), and the arrays on processor 4 hold piece (11,11)-(20,20).
   
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
      ! Use ESMF framework module
      use ESMF
      implicit none

      ! Local variables  
      integer:: rc, finalrc
      integer:: myPet, npets, rootPet
      type(ESMF_VM):: vm
      type(ESMF_Config) :: config
      type(ESMF_DistGrid) :: distgrid
      type(ESMF_Array) :: gridCoordArrays(1,1)
      type(ESMF_StaggerLoc) :: staggerLocs(1)
      type(ESMF_ArraySpec) ::  arrayspec
      real(ESMF_KIND_R8), pointer :: fptrX(:,:),fptrY(:,:)
      integer  ::  deBlockList(2,3,4)
      integer :: petList(4)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Create a distgrid to describe how the arrays are to be joined together into the
   global Grid. The {\it deBlockList} actually describes the location of
   DEs, but the default mapping between PETs and DEs is DE m <-> PET m, so
   this is essentially the same thing (assuming the number of PETs and DEs is the 
   same). 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}

      ! Describe how DEs are arranged
      deBlockList(:,1,1)  = (/1,1/)   ! min corner of PET 1
      deBlockList(:,2,1)  = (/1,10/) ! max corner of PET 1
      deBlockList(:,1,2)  = (/1,11/)   ! min corner of PET 2
      deBlockList(:,2,2)  = (/1,20/)  ! max corner of PET 2
      deBlockList(:,1,3)  = (/11,1/)   ! min corner of PET 3
      deBlockList(:,2,3)  = (/11,10/)  ! max corner of PET 3
      deBlockList(:,1,4)  = (/11,11/)   ! min corner of PET 4
      deBlockList(:,2,4)  = (/11,20/)  ! max corner of PET 4
      
      ! Construct distgrid
      distgrid = ESMF_DistGridCreate( minCorner=(/1,1/),  &
                          maxCorner=(/20,20/),    &
                          deBlockList=deBlockList, rc=rc)  

 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

    Create coordinate arrays from the fortan pointers and the distgrid.
  
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
      gridCoordArrays(1,1)=ESMF_ArrayCreate(fptrX,  &
                             distgrid=distgrid, rc=rc)

      gridCoordArrays(1,2)=ESMF_ArrayCreate(fptrY,  &
                             distgrid=distgrid, rc=rc)

 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Load Stagger location corresponding to coordinate arrays. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
     staggerlocs(1)=ESMF_STAGGERLOC_CENTER
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

      Create a Grid from the coordinate arrays and the stagger location.  
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
     tileGrid = ESMF_GridCreate(arrays=gridCoordArrays, &
                               staggerLocs=staggerlocs,rc=rc)
 
\end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
