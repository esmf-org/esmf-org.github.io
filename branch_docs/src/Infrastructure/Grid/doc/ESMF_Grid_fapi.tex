%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_Grid.F90,  Date: Tue May  5 20:59:48 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_GridAssignment(=)] {ESMF\_GridAssignment(=) - Grid assignment}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     interface assignment(=)
     grid1 = grid2\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Grid) :: grid1
     type(ESMF_Grid) :: grid2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Assign grid1 as an alias to the same ESMF Grid object in memory
     as grid2. If grid2 is invalid, then grid1 will be equally invalid after
     the assignment.
  
     The arguments are:
     \begin{description}
     \item[grid1]
       The {\tt ESMF\_Grid} object on the left hand side of the assignment.
     \item[grid2]
       The {\tt ESMF\_Grid} object on the right hand side of the assignment.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridOperator(==)] {ESMF\_GridOperator(==) - Grid equality operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(==)
     if (grid1 == grid2) then ... endif
               OR
     result = (grid1 == grid2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Grid), intent(in) :: grid1
     type(ESMF_Grid), intent(in) :: grid2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Test whether grid1 and grid2 are valid aliases to the same ESMF
     Grid object in memory. For a more general comparison of two ESMF Grids,
     going beyond the simple alias test, the ESMF\_GridMatch() function
     must be used.
  
     The arguments are:
     \begin{description}
     \item[grid1]
       The {\tt ESMF\_Grid} object on the left hand side of the equality
       operation.
     \item[grid2]
       The {\tt ESMF\_Grid} object on the right hand side of the equality
       operation.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridOperator(/=)] {ESMF\_GridOperator(/=) - Grid not equal operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(/=)
     if (grid1 /= grid2) then ... endif
               OR
     result = (grid1 /= grid2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Grid), intent(in) :: grid1
     type(ESMF_Grid), intent(in) :: grid2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     Test whether grid1 and grid2 are {\it not} valid aliases to the
     same ESMF Grid object in memory. For a more general comparison of two ESMF
     Grids, going beyond the simple alias test, the ESMF\_GridMatch() function
     (not yet fully implemented) must be used.
  
     The arguments are:
     \begin{description}
     \item[grid1]
       The {\tt ESMF\_Grid} object on the left hand side of the non-equality
       operation.
     \item[grid2]
       The {\tt ESMF\_Grid} object on the right hand side of the non-equality
       operation.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridAddCoord] {ESMF\_GridAddCoord - Allocate coordinate arrays but don't set their values}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridAddCoord()
      subroutine ESMF_GridAddCoordNoValues(grid, staggerloc,  &
        staggerEdgeLWidth, staggerEdgeUWidth, staggerAlign, &
        staggerLBound,rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),        intent(in)            :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: staggerEdgeLWidth(:)
       integer,                intent(in),  optional :: staggerEdgeUWidth(:)
       integer,                intent(in),  optional :: staggerAlign(:)
       integer,                intent(in),  optional :: staggerLBound(:)
       integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


  
    When a Grid is created all of its potential stagger locations can hold coordinate
    data, but none of them have storage allocated. This call allocates coordinate
    storage (creates internal ESMF\_Arrays and associated memory) for  a particular
    stagger location. Note that this
    call doesn't assign any values to the storage, it only allocates it. The
    remaining options {\tt staggerEdgeLWidth}, etc. allow the user to adjust the
    padding on the coordinate arrays.
  
   The arguments are:
   \begin{description}
       \item[grid]
         Grid to allocate coordinate storage in.
   \item[{[staggerloc]}]
        The stagger location to add. Please see Section~\ref{const:staggerloc} for a list
        of predefined stagger locations. If not present, defaults to ESMF\_STAGGERLOC\_CENTER.
   \item[{[staggerEdgeLWidth]}]
        This array should be the same dimCount as the grid. It specifies the lower corner of the stagger
        region with respect to the lower corner of the exclusive region.
   \item[{[staggerEdgeUWidth]}]
        This array should be the same dimCount as the grid. It specifies the upper corner of the stagger
        region with respect to the upper corner of the exclusive region.
   \item[{[staggerAlign]}]
        This array is of size  grid dimCount.
        For this stagger location, it specifies which element
        has the same index value as the center. For example,
        for a 2D cell with corner stagger it specifies which
        of the 4 corners has the same index as the center.
        If this is set and either staggerEdgeUWidth or staggerEdgeLWidth is not,
        this determines the default array padding for a stagger.
        If not set, then this defaults to all negative. (e.g.
        The most negative part of the stagger in a cell is aligned with the
        center and the padding is all on the positive side.)
   \item[{[staggerLBound]}]
        Specifies the lower index range of the memory of every DE in this staggerloc in this Grid.
        Only used when Grid indexflag is {\tt ESMF\_INDEX\_USER}.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridAddItem] {ESMF\_GridAddItem - Allocate item array but don't set their values}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridAddItem()
      subroutine ESMF_GridAddItemNoValues(grid, itemflag,  &
        staggerloc, itemTypeKind, staggerEdgeLWidth, staggerEdgeUWidth, &
        staggerAlign, staggerLBound,rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),          intent(in)           :: grid
       type (ESMF_GridItem_Flag),intent(in)           :: itemflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc)  , intent(in), optional :: staggerloc
       type (ESMF_TypeKind_Flag),intent(in), optional :: itemTypeKind
       integer,                  intent(in), optional :: staggerEdgeLWidth(:)
       integer,                  intent(in), optional :: staggerEdgeUWidth(:)
       integer,                  intent(in), optional :: staggerAlign(:)
       integer,                  intent(in), optional :: staggerLBound(:)
       integer,                  intent(out),optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


  
    When a Grid is created all of its potential stagger locations can hold item
    data, but none of them have storage allocated. This call allocates item
    storage (creates an internal ESMF\_Array and associated memory) for  a particular
    stagger location. Note that this
    call doesn't assign any values to the storage, it only allocates it. The
    remaining options {\tt staggerEdgeLWidth}, etc. allow the user to adjust the
    padding on the item array.
  
   The arguments are:
   \begin{description}
       \item[grid]
         Grid to allocate coordinate storage in.
   \item[itemflag]
        The grid item to add. Please see Section~\ref{const:griditem} for a list of valid items.
   \item[{[staggerloc]}]
        The stagger location to add. Please see Section~\ref{const:staggerloc} for a list
        of predefined stagger locations. If not present, defaults to ESMF\_STAGGERLOC\_CENTER.
   \item[{[itemTypeKind]}]
        The typekind of the  item to add.
   \item[{[staggerEdgeLWidth]}]
        This array should be the same dimCount as the grid. It specifies the lower corner of the stagger
        region with respect to the lower corner of the exclusive region.
   \item[{[staggerEdgeUWidth]}]
        This array should be the same dimCount as the grid. It specifies the upper corner of the stagger
        region with respect to the upper corner of the exclusive region.
   \item[{[staggerAlign]}]
        This array is of size  grid dimCount.
        For this stagger location, it specifies which element
        has the same index value as the center. For example,
        for a 2D cell with corner stagger it specifies which
        of the 4 corners has the same index as the center.
        If this is set and either staggerEdgeUWidth or staggerEdgeLWidth is not,
        this determines the default array padding for a stagger.
        If not set, then this defaults to all negative. (e.g.
        The most negative part of the stagger in a cell is aligned with the
        center and the padding is all on the positive side.)
   \item[{[staggerLBound]}]
        Specifies the lower index range of the memory of every DE in this staggerloc in this Grid.
        Only used when Grid indexflag is {\tt ESMF\_INDEX\_USER}.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate] {ESMF\_GridCreate - Create a copy of a Grid with a new DistGrid}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateCopyFromNewDG(grid, distgrid, &
         name, copyAttributes, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateCopyFromNewDG\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type(ESMF_Grid),       intent(in)              :: grid
        type(ESMF_DistGrid),   intent(in)              :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        character (len=*),     intent(in),   optional  :: name
        logical,               intent(in),   optional  :: copyAttributes
        integer,               intent(out),  optional  :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.1.0r] Added argument {\tt copyAttributes} to support attribute
                 propagation from the existing to the newly created grid object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   This call allows the user to copy of an existing ESMF Grid, but with a new distribution.
   All internal data from the old Grid (coords, items) is redistributed to the new Grid.
  
   The arguments are:
   \begin{description}
   \item[grid]
       {\tt ESMF\_Grid} to copy.
   \item[distgrid]
        {\tt ESMF\_DistGrid} object which describes how the Grid is decomposed and
        distributed over DEs.
   \item[{[name]}]
        Name of the new Grid. If not specified, a new unique name will be created
        for the Grid.
   \item[{[copyAttributes]}]
        A flag to indicate whether to copy the attributes of the existing grid
        to the new grid.  The default value is .false..
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate] {ESMF\_GridCreate - Create a copy of a Grid with a different regular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateCopyFromReg(grid, &
         regDecomp, decompFlag, name, copyAttributes, rc)
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateCopyFromReg\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type(ESMF_Grid),        intent(in)              :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                intent(in),   optional  :: regDecomp(:)
        type(ESMF_Decomp_Flag), intent(in),   optional  :: decompflag(:)
        character (len=*),      intent(in),   optional  :: name
        logical,                intent(in),   optional  :: copyAttributes
        integer,                intent(out),  optional  :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.1.0r] Added argument {\tt copyAttributes} to support attribute
                 propagation from the existing to the newly created grid object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


  
   This method creates a copy of an existing Grid, the new Grid is
   regularly distributed (see Figure \ref{fig:GridDecomps}).
   To specify the new distribution, the user passes in an array
   ({\tt regDecomp}) specifying the number of DEs to divide each
   dimension into. The array {\tt decompFlag} indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.
  
   The arguments are:
   \begin{description}
   \item[grid]
       {\tt ESMF\_Grid} to copy.
   \item[{[regDecomp]}]
        List that has the same number of elements as {\tt maxIndex}.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   \item[{[decompflag]}]
        List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is {\tt ESMF\_DECOMP\_BALANCED} in all dimensions. Please see
        Section~\ref{const:decompflag} for a full description of the
        possible options. Note that currently the option
        {\tt ESMF\_DECOMP\_CYCLIC} isn't supported in Grid creation.
   \item[{[name]}]
        Name of the new Grid. If not specified, a new unique name will be
        created for the Grid.
   \item[{[copyAttributes]}]
        A flag to indicate whether to copy the attributes of the existing grid
        to the new grid.  The default value is .false..
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate] {ESMF\_GridCreate - Create a Grid with user set edge connections and an irregular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateEdgeConnI(minIndex,         &
         countsPerDEDim1,countsPerDeDim2,                  &
         countsPerDEDim3,                                  &
         connflagDim1, connflagDim2, connflagDim3,         &
         coordSys, coordTypeKind,                          &
         coordDep1, coordDep2, coordDep3,                  &
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &
         gridMemLBound, indexflag, petMap, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateEdgeConnI\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: countsPerDEDim1(:)
        integer,                  intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                  intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional :: gridAlign(:)
        integer,                  intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
        integer,                  intent(in),  optional :: petMap(:,:,:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, irregularly distributed grid
   (see Figure \ref{fig:GridDecomps}).
   To specify the irregular distribution, the user passes in an array
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension.  Currently this call only
   supports creating 2D or 3D Grids. A 2D Grid can be specified using the
   countsPerDEDim1 and countsPerDEDim2 arguments.  A 3D Grid can
   be specified by also using the optional countsPerDEDim3 argument.
   The index of each array element in these arguments corresponds to
   a DE number.  The array value at the index is the number of grid
   cells on the DE in that dimension.
  
   Section \ref{example:2DIrregUniGrid} shows an example
   of using this method to create a 2D Grid with uniformly spaced
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.
  
   The arguments are:
   \begin{description}
   \item[{[minIndex]}]
        Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   \item[countsPerDEDim1]
       This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   \item[countsPerDEDim2]
       This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location).
   \item[{[countsPerDEDim3]}]
       This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).
       If not specified  then grid is 2D.
   \item[{[connflagDim1]}]
        Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connflagDim2]}]
        Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connflagDim3]}]
        Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep2]}]
       This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep3]}]
       This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[gridEdgeLWidth]}]
        The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   \item[{[gridMemLBound]}]
        Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is {\tt ESMF\_INDEX\_USER}. May be overridden
        by staggerMemLBound.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        Section~\ref{const:indexflag} for the list of options. If not present,
        defaults to ESMF\_INDEX\_DELOCAL.
   \item[{[petMap]}]
         \begin{sloppypar}
         Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.
         \end{sloppypar}
   \item[{[name]}]
            {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate] {ESMF\_GridCreate - Create a Grid with user set edge connections and a regular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateEdgeConnR(regDecomp, decompFlag, &
         minIndex, maxIndex,                                    &
         connflagDim1, connflagDim2, connflagDim3,                       &
         coordSys, coordTypeKind,                            &
         coordDep1, coordDep2, coordDep3,                    &
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,          &
         gridMemLBound, indexflag, petMap, name, rc)
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateEdgeConnR\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                  intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),   intent(in),  optional :: decompflag(:)
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional :: gridAlign(:)
        integer,                  intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
        integer,                  intent(in),  optional :: petMap(:,:,:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, regularly distributed grid
   (see Figure \ref{fig:GridDecomps}).
   To specify the distribution, the user passes in an array
   ({\tt regDecomp}) specifying the number of DEs to divide each
   dimension into. The array {\tt decompFlag} indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
   The arguments are:
   \begin{description}
   \item[{[regDecomp]}]
        List that has the same number of elements as {\tt maxIndex}.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   \item[{[decompflag]}]
        List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is {\tt ESMF\_DECOMP\_BALANCED} in all dimensions. Please see
        Section~\ref{const:decompflag} for a full description of the
        possible options. Note that currently the option
        {\tt ESMF\_DECOMP\_CYCLIC} isn't supported in Grid creation.
   \item[{[minIndex]}]
        The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extent of the grid array.
   \item[{[connflagDim1]}]
        Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connflagDim2]}]
        Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connflagDim3]}]
        Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep2]}]
       This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep3]}]
       This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[gridEdgeLWidth]}]
        The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   \item[{[gridMemLBound]}]
        Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is {\tt ESMF\_INDEX\_USER}. May be overridden
        by staggerMemLBound.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        Section~\ref{const:indexflag} for the list of options. If not present,
        defaults to ESMF\_INDEX\_DELOCAL.
   \item[{[petMap]}]
         Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   \item[{[name]}]
        {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate] {ESMF\_GridCreate - Create a Grid with user set edge connections and an arbitrary distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateEdgeConnA(minIndex, maxIndex,  &
         arbIndexCount, arbIndexList,                         &
         connflagDim1, connflagDim2, connflagDim3,                     &
         coordSys, coordTypeKind,                          &
         coordDep1, coordDep2, coordDep3,                  &
         distDim, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateEdgeConnA\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
        integer,                  intent(in)            :: arbIndexCount
        integer,                  intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: distDim(:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, arbitrarily distributed grid
   (see Figure \ref{fig:GridDecomps}).
   To specify the arbitrary distribution, the user passes in an 2D array
   of local indices, where the first dimension is the number of local grid cells
   specified by {\tt localArbIndexCount} and the second dimension is the number of distributed
   dimensions.
  
   {\tt distDim} specifies which grid dimensions are arbitrarily distributed. The
   size of {\tt distDim} has to agree with the size of the second dimension of
   {\tt localArbIndex}.
  
   Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
  
   The arguments are:
   \begin{description}
   \item[{[minIndex]}]
        Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extend of the grid index ranges.
   \item[arbIndexCount]
        The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.
   \item[arbIndexList]
        This 2D array specifies the indices of the PET LOCAL grid cells.  The
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   \item[{[connflagDim1]}]
        Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connflagDim2]}]
        Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connflagDim3]}]
        Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       The size of the array specifies the number of dimensions of the
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[coordDep2]}]
       The size of the array specifies the number of dimensions of the
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[coordDep3]}]
       The size of the array specifies the number of dimensions of the
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
        Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[distDim]}]
         This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of {\tt localArbIndex}.
   \item[{[name]}]
            {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate] {ESMF\_GridCreate - Create a Grid from a DistGrid}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateFrmDistGrid(distgrid, &
         distgridToGridMap, &
         coordSys, coordTypeKind, coordDimCount, coordDimMap, &
         gridEdgeLWidth, gridEdgeUWidth, gridAlign, &
         gridMemLBound, indexflag, name, vm, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateFrmDistGrid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type(ESMF_DistGrid),     intent(in)            :: distgrid
        integer,                 intent(in),  optional :: distgridToGridMap(:)
        type(ESMF_CoordSys_Flag),intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),intent(in),  optional :: coordTypeKind
        integer,                 intent(in),  optional :: coordDimCount(:)
        integer,                 intent(in),  optional :: coordDimMap(:,:)
        integer,                 intent(in),  optional :: gridEdgeLWidth(:)
        integer,                 intent(in),  optional :: gridEdgeUWidth(:)
        integer,                 intent(in),  optional :: gridAlign(:)
        integer,                 intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),   intent(in),  optional :: indexflag
        character (len=*),       intent(in),  optional :: name
        type(ESMF_VM),           intent(in),  optional :: vm
        integer,                 intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   This is the most general form of creation for an {\tt ESMF\_Grid}
   object. It allows the user to fully specify the topology and index space
   using the DistGrid methods and then build a grid out
   of the resulting DistGrid. Note that since the Grid created by this call
   uses {\tt distgrid} as a description of its index space, the resulting Grid
   will have exactly the same number of dimensions (i.e. the same dimCount) as
   {\tt distgrid}. The {\tt distgridToGridMap} argument
   specifies how the Grid dimensions are mapped to the {\tt distgrid}.
   The {\tt coordDimCount} and {\tt coordDimMap} arguments
   allow the user to specify how the coordinate arrays should map to the grid
   dimensions. (Note, though, that creating a grid does not allocate coordinate
   storage. A method such as {\tt ESMF\_GridAddCoord()} must be called
   before adding coordinate values.)
  
   The arguments are:
   \begin{description}
   \item[distgrid]
        {\tt ESMF\_DistGrid} object that describes how the array is decomposed and
        distributed over DEs.
   \item[{[distgridToGridMap]}]
        List that has dimCount elements.
        The elements map each dimension of distgrid to a dimension in the grid.
         (i.e. the values should range from 1 to dimCount). If not specified, the default
         is to map all of distgrid's dimensions against the dimensions of the
         grid in sequence.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDimCount]}]
        List that has dimCount elements.
        Gives the dimension of each component (e.g. x) array. This is
        to allow factorization of the coordinate arrays. If not specified
        all arrays are the same size as the grid.
   \item[{[coordDimMap]}]
        2D list of size dimCount x  dimCount. This array describes the
        map of each component array's dimensions onto the grids
        dimensions. Each entry {\tt coordDimMap(i,j)} tells which
        grid dimension component i's, jth dimension maps to.
        Note that if j is bigger than {\tt coordDimCount(i)} it is ignored.
        The default for each row i is {\tt coordDimMap(i,:)=(1,2,3,4,...)}.
   \item[{[gridEdgeLWidth]}]
        The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   \item[{[gridMemLBound]}]
        Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is {\tt ESMF\_INDEX\_USER}. May be overridden
        by staggerMemLBound.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        Section~\ref{const:indexflag} for the list of options. If not present,
        defaults to ESMF\_INDEX\_DELOCAL.
   \item[{[name]}]
       {\tt ESMF\_Grid} name.
   \item[{[vm]}]
       If present, the Grid object is created on the specified
       {\tt ESMF\_VM} object. The default is to create on the VM of the
       current context.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate] {ESMF\_GridCreate - Create a Arbitrary Grid from a DistGrid}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateFrmDistGridArb(distgrid, &
         indexArray, distDim, &
         coordSys, coordTypeKind, coordDimCount, coordDimMap, &
         name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateFrmDistGridArb\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type(ESMF_DistGrid),      intent(in)              :: distgrid
        integer,                  intent(in)              :: indexArray(:,:)
        integer,                  intent(in),   optional  :: distDim(:)
        type(ESMF_CoordSys_Flag), intent(in),   optional  :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),   optional  :: coordTypeKind
        integer,                  intent(in),   optional  :: coordDimCount(:)
        integer,                  intent(in),   optional  :: coordDimMap(:,:)
        character (len=*),        intent(in),   optional  :: name
        integer,                  intent(out),  optional  :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   This is the lower level function to create an arbitrarily distributed {\tt ESMF\_Grid}
   object. It allows the user to fully specify the topology and index space
   (of the distributed dimensions) using the DistGrid methods and then build a grid out
   of the resulting {\tt distgrid}.  The {\tt indexArray(2,dimCount)},
   argument is required to specifies the topology of the grid.
  
   The arguments are:
   \begin{description}
   \item[distgrid]
        {\tt ESMF\_DistGrid} object that describes how the array is decomposed and
        distributed over DEs.
   \item[indexArray]
        The minIndex and maxIndex array of size {\tt 2} x {\tt dimCount}
        {\tt indexArray(1,:)} is the minIndex and {\tt indexArray(2,:)} is the maxIndex
   \item[{[distDim]}]
         This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, the default is that all dimensions will be arbitrarily
         distributed.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDimCount]}]
        List that has dimCount elements.
        Gives the dimension of each component (e.g. x) array. This is
        to allow factorization of the coordinate arrays. If not specified
        each component is assumed to be size 1. Note, the default value is different
        from the same argument for a non-arbitrarily distributed grid.
   \item[{[coordDimMap]}]
        2D list of size dimCount x dimCount. This array describes the
        map of each coordinate array's dimensions onto the grids
        dimensions.  {\tt coordDimMap(i,j)} is the grid dimension of the jth dimension
        of the i'th coordinate array.  If not specified, the default value of
        {\tt coordDimMap(i,1)} is /ESMF\_DIM\_ARB/ if the ith dimension of the grid is
        arbitrarily distributed, or {\tt i} if the ith dimension is not distributed.
        Note that if j is bigger than {\tt coordDimCount(i)} then it's ignored.
        Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[name]}]
       {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate] {ESMF\_GridCreate - Create a Grid from a SCRIP or GRIDSPEC format grid file with a user specified distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate()
      function ESMF_GridCreateFrmNCFileDG(filename, fileformat, distgrid, &
        isSphere, polekindflag, addCornerStagger, coordTypeKind, addUserArea, indexflag, &
        addMask, varname, coordNames, rc)
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateFrmNCFileDG\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} 
     character(len=*),       intent(in)             :: filename
     type(ESMF_FileFormat_Flag), intent(in), optional :: fileformat
     type(ESMF_DistGrid),    intent(in)             :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional  :: isSphere
     type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
     logical,                intent(in),  optional  :: addCornerStagger
     type(ESMF_TypeKind_Flag),intent(in), optional  :: coordTypeKind
     logical,                intent(in),  optional  :: addUserArea
     type(ESMF_Index_Flag),  intent(in),  optional  :: indexflag
     logical,                intent(in),  optional  :: addMask
     character(len=*),       intent(in),  optional  :: varname
     character(len=*),       intent(in),  optional  :: coordNames(:)
     integer,                intent(out), optional  :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


   This function creates a {\tt ESMF\_Grid} object using the grid definition from
   a grid file in NetCDF that is either in the SCRIP format or in the CF convention.
   To specify the distribution, the user passes in a {\tt distGrid}.
   The grid defined in the file has to be a 2D logically rectangular grid.
   This function first call {\tt ESMF\_GridCreateFrmNCFile()} to create a {\tt ESMF\_Grid}
   object using a pre-calculated block distribution, then redistribute the Grid to
   create a new Grid object using the user specified {\tt distGrid}.
  
   This call is {\em collective} across the current VM.
  
   The arguments are:
   \begin{description}
   \item[filename]
       The NetCDF Grid filename.
   \item[{[fileformat]}]
       The file format.  The valid options are {\tt ESMF\_FILEFORMAT\_SCRIP} and {\tt ESMF\_FILEFORMAT\_GRIDSPEC}.
       If it is the SCRIP format, the dimension {\tt grid\_rank} in the file has to be equal to 2.
        Please see section~\ref{const:fileformatflag} for a detailed description of the options.  
        If not specified, the file type will be detected automatically.
   \item[distGrid]
        A distGrid defines how the grid is distributed
   \item[{[isSphere]}]
        If .true., create a periodic Grid. If .false., create a regional Grid. Defaults to .true.
   \item[{[polekindflag]}]
        Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section~\ref{const:polekind} for a full list of options. If not specified,
        the default is {\tt ESMF\_POLEKIND\_MONOPOLE} for both.
   \item[{[addCornerStagger]}]
        Uses the information in the grid file to add the Corner stagger to
        the Grid. The coordinates for the corner stagger is required for conservative
        regridding. If not specified, defaults to false.
   \item[{[coordTypeKind]}]
            The type/kind of the grid coordinate data. Only ESMF\_TYPEKIND\_R4
            and ESMF\_TYPEKIND\_R8 are allowed.  Currently, ESMF\_TYPEKIND\_R4 is only
            supported for the GRIDSPEC fileformat. 
            If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[addUserArea]}]
        If .true., read in the cell area from the Grid file, otherwise, ESMF will calculate it. The feature
        is only supported when the grid file is in the SCRIP format.  If not set, the default value is
        .false.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        section~\ref{const:indexflag} for the list of options. If not present,
        defaults to {\tt ESMF\_INDEX\_DELOCAL}.
   \item[{[addMask]}]
        If .true., generate the mask using the missing\_value attribute defined in 'varname'.
        This flag is only needed for the GRIDSPEC file format.  If not set, the default value is .false.
   \item[{[varname]}]
        If addMask is true, provide a variable name stored in the grid file and
        the mask will be generated using the missing value of the data value of
        this variable.  The first two dimensions of the variable has to be the
        the longitude and the latitude dimension and the mask is derived from the
        first 2D values of this variable even if this data is 3D, or 4D array.
  \item[{[coordNames]}]
        a two-element array containing the longitude and latitude variable names in a
        GRIDSPEC file if there are multiple coordinates defined in the file
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridCreateFrmNCFile}\subsubsection [ESMF\_GridCreate] {ESMF\_GridCreate - Create a Grid from a SCRIP or GRIDSPEC format grid file}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate()
      function ESMF_GridCreateFrmNCFile(filename, fileformat, regDecomp, &
        decompflag, delayout, isSphere, polekindflag, addCornerStagger, coordTypeKind, &
        addUserArea, indexflag, addMask, varname, coordNames, rc)
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateFrmNCFile\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} 
     character(len=*),       intent(in)                :: filename
     type(ESMF_FileFormat_Flag), intent(in), optional  :: fileformat
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional     :: regDecomp(:)
     type(ESMF_Decomp_Flag), intent(in),  optional     :: decompflag(:)
     type(ESMF_DELayout),    intent(in),  optional     :: delayout
     logical,                intent(in),  optional     :: isSphere
     type(ESMF_PoleKind_Flag),  intent(in),  optional  :: polekindflag(2)
     logical,                intent(in),  optional     :: addCornerStagger 
     type(ESMF_TypeKind_Flag),intent(in), optional     :: coordTypeKind
     logical,                intent(in),  optional     :: addUserArea
     type(ESMF_Index_Flag),  intent(in),  optional     :: indexflag
     logical,                intent(in),  optional     :: addMask
     character(len=*),       intent(in),  optional     :: varname
     character(len=*),       intent(in),  optional     :: coordNames(:)
     integer,                intent(out), optional     :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


   This function creates a {\tt ESMF\_Grid} object using the grid definition from
   a grid file in NetCDF that is either in the SCRIP format or in the CF convention.
   To specify the distribution, the user passes in an array
   ({\tt regDecomp}) specifying the number of DEs to divide each
   dimension into. The array {\tt decompflag} indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.
   The grid defined in the file has to be a 2D logically rectangular
   grid.
  
   This call is {\em collective} across the current VM.
  
   The arguments are:
   \begin{description}
   \item[filename]
       The NetCDF Grid filename.
   \item[{[fileformat]}]
       The file format.  The valid options are {\tt ESMF\_FILEFORMAT\_SCRIP} and {\tt ESMF\_FILEFORMAT\_GRIDSPEC}.
       If it is the SCRIP format, the dimension {\tt grid\_rank} in the file has to be equal to 2.
       Please see section~\ref{const:fileformatflag} for a detailed
       description of the options. If not specified, the filetype will be automatically detected.
   \item[{[regDecomp]}]
        A 2 element array specifying how the grid is decomposed.
        Each entry is the number of decounts for that dimension.
        The total decounts cannot exceed the total number of PETs.  In other
        word, at most one DE is allowed per processor.
        If not specified, the default decomposition will be petCountx1.
   \item[{[decompflag]}]
        List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is {\tt ESMF\_DECOMP\_BALANCED} in all dimensions. Please see
        section~\ref{const:decompflag} for a full description of the
        possible options. Note that currently the option
        {\tt ESMF\_DECOMP\_CYCLIC} isn't supported in Grid creation.
   \item[{[delayout]}]
        The DELayout that determines DE layout of DEs across PETs. The default is to create a default
        DELayout with the correct number of DEs according to the {\tt regDecomp}. See the documentation of
        the {\tt ESMF\_DELayoutCreate()} method for details about the default DELayout.
   \item[{[isSphere]}]
        If .true., create a periodic Grid. If .false., create a regional Grid. Defaults to .true.
   \item[{[polekindflag]}]
        Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section~\ref{const:polekind} for a full list of options. If not specified,
        the default is {\tt ESMF\_POLEKIND\_MONOPOLE} for both.
   \item[{[addCornerStagger]}]
        Uses the information in the grid file to add the Corner stagger to
        the Grid. The coordinates for the corner stagger is required for conservative
        regridding. If not specified, defaults to false.
   \item[{[coordTypeKind]}]
            The type/kind of the grid coordinate data. Only ESMF\_TYPEKIND\_R4
            and ESMF\_TYPEKIND\_R8 are allowed.  Currently, ESMF\_TYPEKIND\_R4 is only
            supported for the GRIDSPEC fileformat. 
            If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[addUserArea]}]
        If .true., read in the cell area from the Grid file, otherwise, ESMF will calculate it.  The feature
        is only supported when the grid file is in the SCRIP format.  If not set, the default value is
        .false.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        section~\ref{const:indexflag} for the list of options. If not present,
        defaults to {\tt ESMF\_INDEX\_DELOCAL}.
   \item[{[addMask]}]
        If .true., generate the mask using the missing\_value attribute defined in 'varname'. This flag
        is only needed for the GRIDSPEC file format.  If not set, the default value is .false.
   \item[{[varname]}]
        If addMask is true, provide a variable name stored in the grid file and
        the mask will be generated using the missing value of the data value of
        this variable.  The first two dimensions of the variable has to be the
        the longitude and the latitude dimension and the mask is derived from the
        first 2D values of this variable even if this data is 3D, or 4D array.
  \item[{[coordNames]}]
        a two-element array containing the longitude and latitude variable names in a
        GRIDSPEC file if there are multiple coordinates defined in the file
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate1PeriDim] {ESMF\_GridCreate1PeriDim - Create a Grid with one periodic dim and an irregular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate1PeriDim()
       function ESMF_GridCreate1PeriDimI(minIndex,         &
         countsPerDEDim1,countsPerDeDim2,                  &
         countsPerDEDim3,                                  &
         polekindflag, periodicDim, poleDim,                   &
         coordSys, coordTypeKind,                          &
         coordDep1, coordDep2, coordDep3,                  &
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &
         gridMemLBound, indexflag, petMap, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreate1PeriDimI\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: countsPerDEDim1(:)
        integer,                   intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
        integer,                   intent(in),  optional :: periodicDim
        integer,                   intent(in),  optional :: poleDim
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, irregularly distributed grid
   (see Figure \ref{fig:GridDecomps}) with one periodic dimension.
   To specify the irregular distribution, the user passes in an array
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension. Currently this call only
   supports creating 2D or 3D Grids. A 2D Grid can be specified using the
   countsPerDEDim1 and countsPerDEDim2 arguments.  A 3D Grid can
   be specified by also using the optional countsPerDEDim3 argument.
   The index of each array element in these arguments corresponds to
   a DE number.  The array value at the index is the number of grid
   cells on the DE in that dimension.
  
   Section \ref{example:2DIrregUniGrid} shows an example
   of using this method to create a 2D Grid with uniformly spaced
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.
  
   The arguments are:
   \begin{description}
   \item[{[minIndex]}]
        Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   \item[countsPerDEDim1]
       This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   \item[countsPerDEDim2]
       This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location).
   \item[{[countsPerDEDim3]}]
       This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).
       If not specified  then grid is 2D.
   \item[{[polekindflag]}]
        Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section~\ref{const:polekind} for a full list of options. If not specified,
        the default is {\tt ESMF\_POLEKIND\_MONOPOLE} for both.
   \item[{[periodicDim]}]
        The periodic dimension. If not specified, defaults to 1.
   \item[{[poleDim]}]
        The dimension at who's ends the poles are located. If not specified defaults to 2.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep2]}]
       This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep3]}]
       This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[gridEdgeLWidth]}]
        The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   \item[{[gridMemLBound]}]
        Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is {\tt ESMF\_INDEX\_USER}. May be overridden
        by staggerMemLBound.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        Section~\ref{const:indexflag} for the list of options. If not present,
        defaults to ESMF\_INDEX\_DELOCAL.
   \item[{[petMap]}]
         \begin{sloppypar}
         Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.
         \end{sloppypar}
   \item[{[name]}]
            {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate1PeriDim] {ESMF\_GridCreate1PeriDim - Create a Grid with one periodic dim and a regular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate1PeriDim()
       function ESMF_GridCreate1PeriDimR(regDecomp, decompFlag, &
         minIndex, maxIndex,                                    &
         polekindflag, periodicDim, poleDim,                        &
         coordSys, coordTypeKind,                               &
         coordDep1, coordDep2, coordDep3,                       &
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,             &
         gridMemLBound, indexflag, petMap, name, rc)
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreate1PeriDimR\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
        integer,                   intent(in),  optional :: periodicDim
        integer,                   intent(in),  optional :: poleDim
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, regularly distributed grid
   (see Figure \ref{fig:GridDecomps}) with one periodic dimension.
   To specify the distribution, the user passes in an array
   ({\tt regDecomp}) specifying the number of DEs to divide each
   dimension into. The array {\tt decompFlag} indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
   The arguments are:
   \begin{description}
   \item[{[regDecomp]}]
        List that has the same number of elements as {\tt maxIndex}.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   \item[{[decompflag]}]
        List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is {\tt ESMF\_DECOMP\_BALANCED} in all dimensions. Please see
        Section~\ref{const:decompflag} for a full description of the
  !      possible options. Note that currently the option
        {\tt ESMF\_DECOMP\_CYCLIC} isn't supported in Grid creation.
   \item[{[minIndex]}]
        The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extent of the grid array.
   \item[{[polekindflag]}]
        Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section~\ref{const:polekind} for a full list of options. If not specified,
        the default is {\tt ESMF\_POLEKIND\_MONOPOLE} for both.
   \item[{[periodicDim]}]
        The periodic dimension. If not specified, defaults to 1.
   \item[{[poleDim]}]
        The dimension at who's ends the poles are located. If not specified defaults to 2.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep2]}]
       This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep3]}]
       This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[gridEdgeLWidth]}]
        The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   \item[{[gridMemLBound]}]
        Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is {\tt ESMF\_INDEX\_USER}. May be overridden
        by staggerMemLBound.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        Section~\ref{const:indexflag} for the list of options. If not present,
        defaults to ESMF\_INDEX\_DELOCAL.
   \item[{[petMap]}]
         Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   \item[{[name]}]
        {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate1PeriDim] {ESMF\_GridCreate1PeriDim - Create a Grid with one periodic dim and an arbitrary distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate1PeriDim()
       function ESMF_GridCreate1PeriDimA(minIndex, maxIndex,  &
         arbIndexCount, arbIndexList,                         &
         polekindflag, periodicDim, poleDim,                      &
         coordSys, coordTypeKind,                             &
         coordDep1, coordDep2, coordDep3,                     &
         distDim, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreate1PeriDimA\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                   intent(in),  optional :: minIndex(:)
         integer,                   intent(in)            :: maxIndex(:)
        integer,                   intent(in)                    :: arbIndexCount
        integer,                   intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
        integer,                   intent(in),  optional :: periodicDim
        integer,                   intent(in),  optional :: poleDim
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: distDim(:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, arbitrarily distributed grid
   (see Figure \ref{fig:GridDecomps}) with one periodic dimension.
   To specify the arbitrary distribution, the user passes in an 2D array
   of local indices, where the first dimension is the number of local grid cells
   specified by {\tt localArbIndexCount} and the second dimension is the number of distributed
   dimensions.
  
   {\tt distDim} specifies which grid dimensions are arbitrarily distributed. The
   size of {\tt distDim} has to agree with the size of the second dimension of
   {\tt localArbIndex}.
  
   Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
  
   The arguments are:
   \begin{description}
   \item[{[minIndex]}]
        Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extend of the grid index ranges.
   \item[arbIndexCount]
        The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.
   \item[arbIndexList]
        This 2D array specifies the indices of the PET LOCAL grid cells.  The
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   \item[{[polekindflag]}]
        Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section~\ref{const:polekind} for a full list of options. If not specified,
        the default is {\tt ESMF\_POLEKIND\_MONOPOLE} for both.
   \item[{[periodicDim]}]
        The periodic dimension. If not specified, defaults to 1.
   \item[{[poleDim]}]
        The dimension at who's ends the poles are located. If not specified defaults to 2.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       The size of the array specifies the number of dimensions of the
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[coordDep2]}]
       The size of the array specifies the number of dimensions of the
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[coordDep3]}]
       The size of the array specifies the number of dimensions of the
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
  !     arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
       Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[distDim]}]
         This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of {\tt localArbIndex}.
   \item[{[name]}]
            {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate2PeriDim] {ESMF\_GridCreate2PeriDim - Create a Grid with two periodic dims and an irregular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate2PeriDim()
       function ESMF_GridCreate2PeriDimI(minIndex,         &
         countsPerDEDim1,countsPerDeDim2,                  &
         countsPerDEDim3,                                  &
         coordSys, coordTypeKind,                          &
         coordDep1, coordDep2, coordDep3,                  &
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &
         gridMemLBound, indexflag, petMap, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreate2PeriDimI\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: countsPerDEDim1(:)
        integer,                   intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, irregularly distributed grid
   (see Figure \ref{fig:GridDecomps}) with two periodic dimensions.
   To specify the irregular distribution, the user passes in an array
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension. Currently this call only
   supports creating 2D or 3D Grids. A 2D Grid can be specified using the
   countsPerDEDim1 and countsPerDEDim2 arguments.  A 3D Grid can
   be specified by also using the optional countsPerDEDim3 argument.
   The index of each array element in these arguments corresponds to
   a DE number.  The array value at the index is the number of grid
  ! cells on the DE in that dimension.
  
   Section \ref{example:2DIrregUniGrid} shows an example
   of using this method to create a 2D Grid with uniformly spaced
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.
  
   The arguments are:
   \begin{description}
   \item[{[minIndex]}]
        Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   \item[countsPerDEDim1]
       This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   \item[countsPerDEDim2]
       This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location).
   \item[{[countsPerDEDim3]}]
       This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).
       If not specified  then grid is 2D.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep2]}]
       This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
  ! \item[{[coordDep3]}]
       This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[gridEdgeLWidth]}]
        The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   \item[{[gridMemLBound]}]
        Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is {\tt ESMF\_INDEX\_USER}. May be overridden
        by staggerMemLBound.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        Section~\ref{const:indexflag} for the list of options. If not present,
        defaults to ESMF\_INDEX\_DELOCAL.
   \item[{[petMap]}]
         \begin{sloppypar}
         Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.
         \end{sloppypar}
   \item[{[name]}]
            {\tt ESMF\_Grid} name.
   \item[{[rc]}]
  !      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate2PeriDim] {ESMF\_GridCreate2PeriDim - Create a Grid with two periodic dims and a regular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate2PeriDim()
       function ESMF_GridCreate2PeriDimR(regDecomp, decompFlag, &
         minIndex, maxIndex,                                    &
         coordSys, coordTypeKind,                               &
         coordDep1, coordDep2, coordDep3,                       &
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,             &
         gridMemLBound, indexflag, petMap, name, rc)
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreate2PeriDimR\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, regularly distributed grid
   (see Figure \ref{fig:GridDecomps}) with two periodic dimensions.
   To specify the distribution, the user passes in an array
   ({\tt regDecomp}) specifying the number of DEs to divide each
   dimension into. The array {\tt decompFlag} indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
   The arguments are:
   \begin{description}
   \item[{[regDecomp]}]
        List that has the same number of elements as {\tt maxIndex}.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   \item[{[decompflag]}]
        List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is {\tt ESMF\_DECOMP\_BALANCED} in all dimensions. Please see
        Section~\ref{const:decompflag} for a full description of the
        possible options. Note that currently the option
        {\tt ESMF\_DECOMP\_CYCLIC} isn't supported in Grid creation.
   \item[{[minIndex]}]
        The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extent of the grid array.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep2]}]
       This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep3]}]
       This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[gridEdgeLWidth]}]
        The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   \item[{[gridMemLBound]}]
        Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is {\tt ESMF\_INDEX\_USER}. May be overridden
        by staggerMemLBound.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        Section~\ref{const:indexflag} for the list of options. If not present,
        defaults to ESMF\_INDEX\_DELOCAL.
   \item[{[petMap]}]
         Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   \item[{[name]}]
        {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate2PeriDim] {ESMF\_GridCreate2PeriDim - Create a Grid with two periodic dims and an arbitrary distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate2PeriDim()
       function ESMF_GridCreate2PeriDimA(minIndex, maxIndex, &
         arbIndexCount, arbIndexList,                        &
         coordSys, coordTypeKind,                            &
         coordDep1, coordDep2, coordDep3,                    &
         distDim, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreate2PeriDimA\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
        integer,                   intent(in)                    :: arbIndexCount
         integer,                   intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: distDim(:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, arbitrarily distributed grid
   (see Figure \ref{fig:GridDecomps}) with two periodic dimensions.
   To specify the arbitrary distribution, the user passes in an 2D array
   of local indices, where the first dimension is the number of local grid cells
   specified by {\tt localArbIndexCount} and the second dimension is the number of distributed
   dimensions.
  
   {\tt distDim} specifies which grid dimensions are arbitrarily distributed. The
   size of {\tt distDim} has to agree with the size of the second dimension of
   {\tt localArbIndex}.
  
   Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
  
   The arguments are:
   \begin{description}
   \item[{[minIndex]}]
        Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extend of the grid index ranges.
   \item[arbIndexCount]
        The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.
   \item[arbIndexList]
        This 2D array specifies the indices of the PET LOCAL grid cells.  The
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       The size of the array specifies the number of dimensions of the
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
       Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[coordDep2]}]
       The size of the array specifies the number of dimensions of the
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[coordDep3]}]
       The size of the array specifies the number of dimensions of the
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
       Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[distDim]}]
         This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of {\tt localArbIndex}.
   \item[{[name]}]
         {\tt ESMF\_Grid} name.
  ! \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreateNoPeriDim] {ESMF\_GridCreateNoPeriDim - Create a Grid with no periodic dim and an irregular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreateNoPeriDim()
       function ESMF_GridCreateNoPeriDimI(minIndex,        &
         countsPerDEDim1,countsPerDeDim2,                  &
         countsPerDEDim3,                                  &
         coordSys, coordTypeKind,                          &
         coordDep1, coordDep2, coordDep3,                  &
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &
         gridMemLBound, indexflag, petMap, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateNoPeriDimI\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: countsPerDEDim1(:)
        integer,                   intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, irregularly distributed grid
   (see Figure \ref{fig:GridDecomps}) without a periodic dimension.
   To specify the irregular distribution, the user passes in an array
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension. Currently this call only
   supports creating 2D or 3D Grids. A 2D Grid can be specified using the
   countsPerDEDim1 and countsPerDEDim2 arguments.  A 3D Grid can
   be specified by also using the optional countsPerDEDim3 argument.
   The index of each array element in these arguments corresponds to
   a DE number.  The array value at the index is the number of grid
   cells on the DE in that dimension.
  
   Section \ref{example:2DIrregUniGrid} shows an example
   of using this method to create a 2D Grid with uniformly spaced
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.
  
   The arguments are:
   \begin{description}
   \item[{[minIndex]}]
        Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   \item[countsPerDEDim1]
       This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   \item[countsPerDEDim2]
       This array specifies the number of cells per DE for index dimension 2
  !     for the exclusive region (center stagger location).
   \item[{[countsPerDEDim3]}]
       This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).
       If not specified  then grid is 2D.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
  ! \item[{[coordDep2]}]
       This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep3]}]
       This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[gridEdgeLWidth]}]
        The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   \item[{[gridMemLBound]}]
        Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is {\tt ESMF\_INDEX\_USER}. May be overridden
        by staggerMemLBound.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        Section~\ref{const:indexflag} for the list of options. If not present,
        defaults to ESMF\_INDEX\_DELOCAL.
   \item[{[petMap]}]
         \begin{sloppypar}
         Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.
         \end{sloppypar}
   \item[{[name]}]
            {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreateNoPeriDim] {ESMF\_GridCreateNoPeriDim - Create a Grid with no periodic dim and a regular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreateNoPeriDim()
       function ESMF_GridCreateNoPeriDimR(regDecomp, decompFlag, &
         minIndex, maxIndex,                                     &
         coordSys, coordTypeKind,                                &
         coordDep1, coordDep2, coordDep3,                        &
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,              &
         gridMemLBound, indexflag, petMap, name, rc)
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateNoPeriDimR\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
         integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, regularly distributed grid
   (see Figure \ref{fig:GridDecomps}) with no periodic dimension.
   To specify the distribution, the user passes in an array
   ({\tt regDecomp}) specifying the number of DEs to divide each
   dimension into. The array {\tt decompFlag} indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
   The arguments are:
   \begin{description}
   \item[{[regDecomp]}]
        List that has the same number of elements as {\tt maxIndex}.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   \item[{[decompflag]}]
        List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is {\tt ESMF\_DECOMP\_BALANCED} in all dimensions. Please see
        Section~\ref{const:decompflag} for a full description of the
        possible options. Note that currently the option
        {\tt ESMF\_DECOMP\_CYCLIC} isn't supported in Grid creation.
   \item[{[minIndex]}]
        The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extent of the grid array.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
  !     of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep2]}]
       This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep3]}]
       This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[gridEdgeLWidth]}]
        The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   \item[{[gridMemLBound]}]
        Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is {\tt ESMF\_INDEX\_USER}. May be overridden
        by staggerMemLBound.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        Section~\ref{const:indexflag} for the list of options. If not present,
        defaults to ESMF\_INDEX\_DELOCAL.
   \item[{[petMap]}]
         Sets the mapping of pets to the created DEs. This 3D
  !       should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   \item[{[name]}]
        {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreateNoPeriDim] {ESMF\_GridCreateNoPeriDim - Create a Grid with no periodic dim and an arbitrary distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreateNoPeriodic()
       function ESMF_GridCreateNoPeriDimA(minIndex, maxIndex, &
         arbIndexCount, arbIndexList,                         &
         coordSys, coordTypeKind,                             &
         coordDep1, coordDep2, coordDep3,                     &
         distDim, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}        type(ESMF_Grid) :: ESMF_GridCreateNoPeriDimA\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
        integer,                   intent(in)                    :: arbIndexCount
        integer,                   intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: distDim(:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, arbitrarily distributed grid
   (see Figure \ref{fig:GridDecomps}) with no periodic dimension.
   To specify the arbitrary distribution, the user passes in an 2D array
   of local indices, where the first dimension is the number of local grid cells
   specified by {\tt localArbIndexCount} and the second dimension is the number of distributed
   dimensions.
  
   {\tt distDim} specifies which grid dimensions are arbitrarily distributed. The
   size of {\tt distDim} has to agree with the size of the second dimension of
   {\tt localArbIndex}.
  
   Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
  
   The arguments are:
   \begin{description}
   \item[{[minIndex]}]
        Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extend of the grid index ranges.
   \item[arbIndexCount]
        The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.
   \item[arbIndexList]
  !      This 2D array specifies the indices of the PET LOCAL grid cells.  The
        dimensions should be arbIndexCount * number of Distributed grid dimensions
  !      where arbIndexCount is the input argument specified below
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       The size of the array specifies the number of dimensions of the
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[coordDep2]}]
       The size of the array specifies the number of dimensions of the
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[coordDep3]}]
       The size of the array specifies the number of dimensions of the
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_DIM\_ARB/ where
       /ESMF\_DIM\_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_DIM\_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
       Please see Section~\ref{const:arbdim} for a definition of ESMF\_DIM\_ARB.
   \item[{[distDim]}]
         This array specifies which dimensions are arbitrarily distributed.
   !       The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of {\tt localArbIndex}.
   \item[{[name]}]
            {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate1PeriDimUfrm] {ESMF\_GridCreate1PeriDimUfrm - Create a uniform Grid with one periodic dim and a regular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate1PeriDimUfrm()
       function ESMF_GridCreate1PeriDimUfrmR(minIndex, maxIndex, &
            minCornerCoord, maxCornerCoord, &
            regDecomp, decompFlag, &
            polekindflag, coordSys, staggerLocList, &
            ignoreNonPeriCoord, petMap, name, rc)
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}        type(ESMF_Grid) :: ESMF_GridCreate1PeriDimUfrmR\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
        real(ESMF_KIND_R8),        intent(in)            :: minCornerCoord(:)
        real(ESMF_KIND_R8),        intent(in)            :: maxCornerCoord(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_StaggerLoc),     intent(in),  optional :: staggerLocList(:)
        logical,                   intent(in),  optional :: ignoreNonPeriCoord
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, regularly distributed grid
   (see Figure \ref{fig:GridDecomps}) with one periodic dimension.
   The periodic dimension in the resulting grid will be dimension 1.
   The dimension with the poles at either end (i.e. the pole dimension)
   will be dimension 2.
  
   The grid will have its coordinates uniformly spread between the
   ranges specified by the user. The coordinates are ESMF\_TYPEKIND\_R8.
   Currently, this method only fills the center stagger with coordinates, and
   the {\tt minCornerCoord} and {\tt maxCornerCoord} arguments give the boundaries of
   the center stagger.
  
   To specify the distribution, the user passes in an array
   ({\tt regDecomp}) specifying the number of DEs to divide each
   dimension into. The array {\tt decompFlag} indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
    The following arguments have been set to non-typical values and so
    there is a reasonable possibility that they may change in the future
    to be inconsistent with other Grid create interfaces:
  
    The arguments coordDep1, coordDep2, and coordDep3 have internally
    been set to 1, 2, and 3 respectively.
    This was done because this call creates a uniform grid and so only 1D arrays
    are needed to hold the coordinates. This means the coordinate arrays
    will be 1D.
  
    The argument indexFlag has internally been set to ESMF\_INDEX\_GLOBAL. This
    means that the grid created from this function will have a global index space.
  
   The arguments are:
   \begin{description}
   \item[{[minIndex]}]
        The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extent of the grid array.
   \item[minCornerCoord]
        The coordinates of the corner of the grid that corresponds to {\tt minIndex}.
        size(minCornerCoord) must be equal to size(maxIndex).
   \item[maxCornerCoord]
        The coordinates of the corner of the grid that corresponds to {\tt maxIndex}.
        size(maxCornerCoord) must be equal to size(maxIndex).
   \item[{[regDecomp]}]
        A ndims-element array specifying how the grid is decomposed.
        Each entry is the number of decounts for that dimension.
   \item[{[decompflag]}]
        List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is {\tt ESMF\_DECOMP\_BALANCED} in all dimensions. Please see
        Section~\ref{const:decompflag} for a full description of the
        possible options. Note that currently the option
        {\tt ESMF\_DECOMP\_CYCLIC} isn't supported in Grid creation.
   \item[{[polekindflag]}]
        Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section~\ref{const:polekind} for a full list of options. If not specified,
        the default is {\tt ESMF\_POLEKIND\_MONOPOLE} for both.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[staggerLocList]}]
       The list of stagger locations to fill with coordinates. Please see Section~\ref{const:staggerloc}
       for a description of the available stagger locations. If not present, then
       no staggers are added or filled.
   \item[{[ignoreNonPeriCoord]}]
       If .true., do not check if the coordinates for the periodic dimension (i.e. dim=1) specify a full periodic range (e.g. 0 to 360 degrees).
       If not specified, defaults to .false. .
   \item[{[petMap]}]
         Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   \item[{[name]}]
        {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreate1PeriDimUfrm] {ESMF\_GridCreate1PeriDimUfrm - Create a uniform Grid with one periodic dim and a block distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreate1PeriDimUfrm()
   function ESMF_GridCreate1PeriDimUfrmB(minIndex, maxIndex, &
             minCornerCoord, maxCornerCoord, &
             deBlockList, deLabelList, &
             polekindflag, coordSys, staggerLocList, &
             ignoreNonPeriCoord, petMap, name, rc)
 
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Grid) :: ESMF_GridCreate1PeriDimUfrmB\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     integer,                   intent(in),  optional :: minIndex(:)
     integer,                   intent(in)            :: maxIndex(:)
     real(ESMF_KIND_R8),        intent(in)            :: minCornerCoord(:)
     real(ESMF_KIND_R8),        intent(in)            :: maxCornerCoord(:)
     integer,                   intent(in)            :: deBlockList(:,:,:)
     integer,                   intent(in),  optional :: deLabelList(:)
     type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
     type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
     type(ESMF_StaggerLoc),     intent(in),  optional :: staggerLocList(:)
     logical,                   intent(in),  optional :: ignoreNonPeriCoord
     integer,                   intent(in),  optional :: petMap(:,:,:)
     character (len=*),         intent(in),  optional :: name
     integer,                   intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, regularly distributed grid
   (see Figure \ref{fig:GridDecomps}) with one periodic dimension.
   The periodic dimension in the resulting grid will be dimension 1.
   The dimension with the poles at either end (i.e. the pole dimension)
   will be dimension 2.
  
   The grid will have its coordinates uniformly spread between the
   ranges specified by the user. The coordinates are ESMF\_TYPEKIND\_R8.
   Currently, this method only fills the center stagger with coordinates, and
   the {\tt minCornerCoord} and {\tt maxCornerCoord} arguments give the boundaries of
   the center stagger.
  
   To specify the distribution, the user passes in an array
   ({\tt deBlockList}) specifying index space blocks for each DE.
  
    The following arguments have been set to non-typical values and so
    there is a reasonable possibility that they may change in the future
    to be inconsistent with other Grid create interfaces:
  
    The arguements coordDep1, coordDep2, and coordDep3 have internally
    been set to 1, 2, and 3 respectively.
    This was done because this call creates a uniform grid and so only 1D arrays
    are needed to hold the coordinates. This means the coordinate arrays
    will be 1D.
  
    The argument indexFlag has internally been set to ESMF\_INDEX\_GLOBAL. This
    means that the grid created from this function will have a global index space.
  
   The arguments are:
   \begin{description}
   \item[{[minIndex]}]
        The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extent of the grid array.
   \item[minCornerCoord]
        The coordinates of the corner of the grid that corresponds to {\tt minIndex}.
        size(minCornerCoord) must be equal to size(maxIndex).
   \item[maxCornerCoord]
        The coordinates of the corner of the grid that corresponds to {\tt maxIndex}.
        size(maxCornerCoord) must be equal to size(maxIndex).
   \item[deBlockList]
        List of DE-local LR blocks. The third index of {\tt deBlockList}
        steps through the deBlock elements, which are defined by the first
        two indices. The first index must be of size {\tt dimCount} and the
        second index must be of size 2. Each 2D element of {\tt deBlockList}
        defined by the first two indices hold the following information.
        \begin{verbatim}
                 +---------------------------------------> 2nd index
                 |    1               2
                 | 1  minIndex(1)    maxIndex(1)
                 | 2  minIndex(2)    maxIndex(2)
                 | .  minIndex(.)    maxIndex(.)
                 | .
                 v
                1st index
        \end{verbatim}
        It is required that there be no overlap between the LR segments
        defined by deBlockList.
   \item[{[deLabelList]}]
        List assigning DE labels to the default sequence of DEs. The default
        sequence is given by the order of DEs in the {\tt deBlockList}
        argument.
   \item[{[polekindflag]}]
        Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section~\ref{const:polekind} for a full list of options. If not specified,
        the default is {\tt ESMF\_POLEKIND\_MONOPOLE} for both.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[staggerLocList]}]
       The list of stagger locations to fill with coordinates. Please see Section~\ref{const:staggerloc}
       for a description of the available stagger locations. If not present, then
       no staggers are added or filled.
   \item[{[ignoreNonPeriCoord]}]
       If .true., do not check if the coordinates for the periodic dimension (i.e. dim=1) specify a full periodic range (e.g. 0 to 360 degrees).
       If not specified, defaults to .false. .
   \item[{[petMap]}]
         Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   \item[{[name]}]
        {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreateNoPeriDimUfrm] {ESMF\_GridCreateNoPeriDimUfrm - Create a uniform Grid with no periodic dim and a regular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}  ! Private name; call using ESMF_GridCreateNoPeriDimUfrm()
       function ESMF_GridCreateNoPeriDimUfrmR(minIndex, maxIndex, &
         minCornerCoord, maxCornerCoord, &
         regDecomp, decompFlag, &
         coordSys, staggerLocList, petMap, name, rc)
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       type(ESMF_Grid) :: ESMF_GridCreateNoPeriDimUfrmR\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
        real(ESMF_KIND_R8),        intent(in)            :: minCornerCoord(:)
        real(ESMF_KIND_R8),        intent(in)            :: maxCornerCoord(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_StaggerLoc),     intent(in),  optional :: staggerLocList(:)
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method creates a single tile, regularly distributed grid
   (see Figure \ref{fig:GridDecomps}) with no periodic dimension.
  
   The resulting grid will have its coordinates uniformly spread between the
   ranges specified by the user. The coordinates are ESMF\_TYPEKIND\_R8.
   Currently, this method only fills the center stagger with coordinates, and
   the {\tt minCornerCoord} and {\tt maxCornerCoord} arguments give the boundaries of
   the center stagger.
  
   To specify the distribution, the user passes in an array
   ({\tt regDecomp}) specifying the number of DEs to divide each
   dimension into. The array {\tt decompFlag} indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
    The following arguments have been set to non-typical values and so
    there is a reasonable possibility that they may change in the future
    to be inconsistent with other Grid create interfaces:
  
    The arguements coordDep1, coordDep2, and coordDep3 have internally
    been set to 1, 2, and 3 respectively.
    This was done because this call creates a uniform grid and so only 1D arrays
    are needed to hold the coordinates. This means the coordinate arrays
    will be 1D.
  
    The argument indexFlag has internally been set to ESMF\_INDEX\_GLOBAL. This
    means that the grid created from this function will have a global index space.
  
   The arguments are:
   \begin{description}
   \item[{[minIndex]}]
        The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extent of the grid array.
   \item[minCornerCoord]
        The coordinates of the corner of the grid that corresponds to {\tt minIndex}.
        size(minCornerCoord) must be equal to size(maxIndex).
   \item[maxCornerCoord]
        The coordinates of the corner of the grid that corresponds to {\tt maxIndex}.
        size(maxCornerCoord) must be equal to size(maxIndex).
   \item[{[regDecomp]}]
        A ndims-element array specifying how the grid is decomposed.
        Each entry is the number of decounts for that dimension.
   \item[{[decompflag]}]
        List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is {\tt ESMF\_DECOMP\_BALANCED} in all dimensions. Please see
        Section~\ref{const:decompflag} for a full description of the
        possible options. Note that currently the option
        {\tt ESMF\_DECOMP\_CYCLIC} isn't supported in Grid creation.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[staggerLocList]}]
       The list of stagger locations to fill with coordinates. Please see Section~\ref{const:staggerloc}
       for a description of the available stagger locations. If not present, then
       no staggers are added or filled.
   \item[{[petMap]}]
         Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   \item[{[name]}]
        {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreateCubedSphere] {ESMF\_GridCreateCubedSphere - Create a multi-tile cubed sphere Grid with regular decomposition}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreateCubedSphere()
   function ESMF_GridCreateCubedSphereReg(tileSize,&
         regDecompPTile, decompflagPTile,                        &
         coordSys, coordTypeKind,                                &
         deLabelList, staggerLocList,                            &
         delayout, indexflag, name, transformArgs, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Grid) :: ESMF_GridCreateCubedSphereReg\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     integer,                        intent(in)            :: tilesize
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                        intent(in),  optional :: regDecompPTile(:,:)
     type(ESMF_Decomp_Flag), target, intent(in),  optional :: decompflagPTile(:,:)
     type(ESMF_CoordSys_Flag),       intent(in),  optional :: coordSys
     type(ESMF_TypeKind_Flag),       intent(in),  optional :: coordTypeKind
     integer,                        intent(in),  optional :: deLabelList(:)
     type(ESMF_StaggerLoc),          intent(in),  optional :: staggerLocList(:)
     type(ESMF_DELayout),            intent(in),  optional :: delayout
     type(ESMF_Index_Flag),          intent(in),  optional :: indexflag
     character(len=*),               intent(in),  optional :: name
     type(ESMF_CubedSphereTransform_Args), intent(in),  optional :: transformArgs
     integer,                        intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     Create a six-tile {\tt ESMF\_Grid} for a Cubed Sphere grid using regular decomposition.  Each tile can
     have different decomposition.  The grid coordinates are generated based on the algorithm used by GEOS-5,
     The tile resolution is defined by tileSize.
  
       The arguments are:
       \begin{description}
       \item[tilesize]
            The number of elements on each side of the tile of the Cubed Sphere grid.
       \item[{[regDecompPTile]}]
            List of DE counts for each dimension. The second index steps through
            the tiles. The total {\tt deCount} is determined as the sum over
            the products of {\tt regDecompPTile} elements for each tile.
            By default every tile is decomposed in the same way.  If the total
            PET count is less than 6, one tile will be assigned to one DE and the DEs
            will be assigned to PETs sequentially, therefore, some PETs may have
            more than one DEs.  If the total PET count is greater than 6, the total
            number of DEs will be a multiple of 6 and less than or equal to the total
            PET count.  For instance, if the total PET count is 16, the total DE count
            will be 12 with each tile decomposed into 1x2 blocks.  The 12 DEs are mapped
            to the first 12 PETs and the remainding 4 PETs have no DEs locally, unless
            an optional {\tt delayout} is provided.
       \item[{[decompflagPTile]}]
            List of decomposition flags indicating how each dimension of each
            tile is to be divided between the DEs. The default setting
            is {\tt ESMF\_DECOMP\_BALANCED} in all dimensions for all tiles.
            See section \ref{const:decompflag} for a list of valid decomposition
            flag options. The second index indicates the tile number.
       \item[{[deLabelList]}]
            List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the {\tt regDecompPTile}
            elements in the sequence as they appear following the tile index.
       \item[{[staggerLocList]}]
            The list of stagger locations to fill with coordinates. Only {\tt ESMF\_STAGGERLOC\_CENTER}
            and {\tt ESMF\_STAGGERLOC\_CORNER} are supported.  If not present, no coordinates
            will be added or filled.
       \item[{[coordSys]}]
            The coordinate system of the grid coordinate data.
            Only ESMF\_COORDSYS\_SPH\_DEG and ESMF\_COORDSYS\_SPH\_RAD are supported. 
            If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
       \item[{[coordTypeKind]}]
            The type/kind of the grid coordinate data. Only ESMF\_TYPEKIND\_R4
            and ESMF\_TYPEKIND\_R8 are supported.
            If not specified then defaults to ESMF\_TYPEKIND\_R8.
       \item[{[delayout]}]
            Optional {\tt ESMF\_DELayout} object to be used. By default a new
            DELayout object will be created with as many DEs as there are PETs,
            or tiles, which ever is greater. If a DELayout object is specified,
            the number of DEs must match {\tt regDecompPTile}, if present. In the
            case that {\tt regDecompPTile} was not specified, the {\tt deCount}
            must be at least that of the default DELayout. The
            {\tt regDecompPTile} will be constructed accordingly.
       \item[{[indexflag]}]
            Indicates the indexing scheme to be used in the new Grid. Please see
            Section~\ref{const:indexflag} for the list of options. If not present,
            defaults to ESMF\_INDEX\_DELOCAL.
       \item[{[name]}]
            {\tt ESMF\_Grid} name.
       \item[{[transformArgs]}]
            A data type containing the stretch factor, target longitude, and target latitude
            to perform a Schmidt transformation on the Cubed-Sphere grid. See section
            \ref{sec:usage:cubedspherewttransform} for details.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreateCubedSphere] {ESMF\_GridCreateCubedSphere - Create a multi-tile cubed sphere Grid with irregular decomposition}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridCreateCubedSphere()
   function ESMF_GridCreateCubedSphereIReg(tileSize,             &
         countsPerDEDim1PTile, countsPerDEDim2PTile,             &
                                                &        
         coordSys, coordTypeKind,                                &
         deLabelList, staggerLocList,                            &
         delayout, indexflag, name, transformArgs, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Grid) :: ESMF_GridCreateCubedSphereIReg\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     integer,                        intent(in)            :: tilesize
     integer,                        intent(in)            :: countsPerDEDim1PTile(:,:)
     integer,                        intent(in)            :: countsPerDEDim2PTile(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_CoordSys_Flag),       intent(in),  optional :: coordSys
     type(ESMF_TypeKind_Flag),       intent(in),  optional :: coordTypeKind
     integer,                        intent(in),  optional :: deLabelList(:)
     type(ESMF_StaggerLoc),          intent(in),  optional :: staggerLocList(:)
     type(ESMF_DELayout),            intent(in),  optional :: delayout
     type(ESMF_Index_Flag),          intent(in),  optional :: indexflag
     character(len=*),               intent(in),  optional :: name
     type(ESMF_CubedSphereTransform_Args), intent(in),  optional :: transformArgs
     integer,                        intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     Create a six-tile {\tt ESMF\_Grid} for a Cubed Sphere grid using irregular decomposition.  Each tile can
     have different decomposition.  The grid coordinates are generated based on the algorithm used by GEOS-5,
     The tile resolution is defined by tileSize.
  
       The arguments are:
       \begin{description}
       \item[tilesize]
            The number of elements on each side of the tile of the Cubed Sphere grid.
       \item[countsPerDEDim1PTile]
            This array specifies the number of cells per DE for index dimension 1 for the
            center stagger location. The second index steps through the tiles. If each tile is 
            decomposed into different number of DEs, the first dimension is the maximal DEs of 
            all the tiles.  
       \item[countsPerDEDim2PTile]
            This array specifies the number of cells per DE for index dimension 2 for the
            center stagger location. The second index steps through the tiles. If each tile is 
            decomposed into different number of DEs, the first dimension is the maximal DEs of 
            all the tiles.  
       \item[{[coordSys]}]
            The coordinate system of the grid coordinate data.
            Only ESMF\_COORDSYS\_SPH\_DEG and ESMF\_COORDSYS\_SPH\_RAD are supported. 
            If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
       \item[{[coordTypeKind]}]
            The type/kind of the grid coordinate data. Only ESMF\_TYPEKIND\_R4
            and ESMF\_TYPEKIND\_R8 are supported.
            If not specified then defaults to ESMF\_TYPEKIND\_R8.
       \item[{[deLabelList]}]
            List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order in the sequence as they appear
            in {\tt countsPerDEDim1PTile}, followed by {\tt countsPerDEDim2PTile}, then the 
            tile index.
       \item[{[staggerLocList]}]
            The list of stagger locations to fill with coordinates. Only {\tt ESMF\_STAGGERLOC\_CENTER}
            and {\tt ESMF\_STAGGERLOC\_CORNER} are supported.  If not present, no coordinates
            will be added or filled.
       \item[{[delayout]}]
            Optional ESMF\_DELayout object to be used. If a delayout object is specified,
            the number of DEs must match with the total DEs defined in {\tt countsPerDEDim1PTile}
            and {\tt countsPerDEDim2PTile}.
       \item[{[indexflag]}]
            Indicates the indexing scheme to be used in the new Grid. Please see
            Section~\ref{const:indexflag} for the list of options. If not present,
            defaults to ESMF\_INDEX\_DELOCAL.
       \item[{[name]}]
            {\tt ESMF\_Grid} name.
       \item[{[transformArgs]}]
            A data type containing the stretch factor, target longitude, and target latitude
            to perform a Schmidt transformation on the Cubed-Sphere grid. See section
            \ref{sec:usage:cubedspherewttransform} for details.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreateMosaic] {ESMF\_GridCreateMosaic - Create a multi-tile Grid object with regular decomposition using the grid definition from a GRIDSPEC Mosaic file.}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   function ESMF_GridCreateMosaicReg(filename,regDecompPTile, decompflagPTile, &
         coordTypeKind, deLabelList, staggerLocList, delayout, indexflag, name, tileFilePath, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Grid) :: ESMF_GridCreateMosaicReg\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     character(len=*),               intent(in)            :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                        intent(in),  optional :: regDecompPTile(:,:)
     type(ESMF_Decomp_Flag), target, intent(in),  optional :: decompflagPTile(:,:)
     type(ESMF_TypeKind_Flag),       intent(in),  optional :: coordTypeKind
     integer,                        intent(in),  optional :: deLabelList(:)
     type(ESMF_StaggerLoc),          intent(in),  optional :: staggerLocList(:)
     type(ESMF_DELayout),            intent(in),  optional :: delayout
     type(ESMF_Index_Flag),          intent(in),  optional :: indexflag
     character(len=*),               intent(in),  optional :: name
     character(len=*),               intent(in),  optional :: tileFilePath
     integer,                        intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     Create a multiple-tile {\tt ESMF\_Grid} based on the definition from a GRIDSPEC Mosaic file and its associated
     tile files using regular decomposition.  Each tile can have different decomposition.  The tile connections
     are defined in a GRIDSPEC format Mosaic file.
     And each tile's coordination is defined in a separate NetCDF file.  The coordinates defined
     in the tile file is so-called "Super Grid".  In other words, the dimensions of the coordinate variables are
     {\tt (2*xdim+1, 2*ydim+1)} if {\tt (xdim, ydim)} is the size of the tile.  The Super Grid combines the corner,
     the edge and the center coordinates in one big array.  A Mosaic file may contain just one tile.  If a Mosaic contains
     multiple tiles.  Each tile is a logically rectangular lat/lon grid.  Currently, all the tiles have to be the same size.
     We will remove this limitation in the future release.
  
  
       The arguments are:
       \begin{description}
       \item[filename]
            The name of the GRIDSPEC Mosaic file.
       \item[{[regDecompPTile]}]
            List of DE counts for each dimension. The second index steps through
            the tiles. The total {\tt deCount} is determined as th sum over
            the products of {\tt regDecompPTile} elements for each tile.
            By default every tile is decomposed in the same way.  If the total
            PET count is less than 6, one tile will be assigned to one DE and the DEs
            will be assigned to PETs sequentially, therefore, some PETs may have
            more than one DEs.  If the total PET count is greater than 6, the total
            number of DEs will be multiple of 6 and less than or equal to the total
            PET count.  For instance, if the total PET count is 16, the total DE count
            will be 12 with each tile decomposed into 1x2 blocks.  The 12 DEs are mapped
            to the first 12 PETs and the remainding 4 PETs have no DEs locally, unless
            an optional {\tt delayout} is provided.
       \item[{[decompflagPTile]}]
            List of decomposition flags indicating how each dimension of each
            tile is to be divided between the DEs. The default setting
            is {\tt ESMF\_DECOMP\_BALANCED} in all dimensions for all tiles.
            See section \ref{const:decompflag} for a list of valid decomposition
            flag options. The second index indicates the tile number.
       \item[{[coordTypeKind]}]
            The type/kind of the grid coordinate data. Only ESMF\_TYPEKIND\_R4
            and ESMF\_TYPEKIND\_R8 are supported.
            If not specified then defaults to ESMF\_TYPEKIND\_R8.
       \item[{[deLabelList]}]
            List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the {\tt regDecompPTile}
            elements in the sequence as they appear following the tile index.
       \item[{[staggerLocList]}]
            The list of stagger locations to fill with coordinates. Please see Section~\ref{const:staggerloc}
            for a description of the available stagger locations. If not present, no coordinates
            will be added or filled.
       \item[{[delayout]}]
            Optional {\tt ESMF\_DELayout} object to be used. By default a new
            DELayout object will be created with as many DEs as there are PETs,
            or tiles, which ever is greater. If a DELayout object is specified,
            the number of DEs must match {\tt regDecompPTile}, if present. In the
            case that {\tt regDecompPTile} was not specified, the {\tt deCount}
            must be at least that of the default DELayout. The
            {\tt regDecompPTile} will be constructed accordingly.
       \item[{[indexflag]}]
            Indicates the indexing scheme to be used in the new Grid. Please see
            Section~\ref{const:indexflag} for the list of options. If not present,
            defaults to ESMF\_INDEX\_DELOCAL.
       \item[{[name]}]
            {\tt ESMF\_Grid} name.
       \item[{[tileFilePath]}]
            Optional argument to define the path where the tile files reside. If it
            is given, it overwrites the path defined in {\tt gridlocation} variable
            in the mosaic file.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridCreateMosaic] {ESMF\_GridCreateMosaic - Create a multi-tile Grid object with irregular decomposition using the grid definition from a GRIDSPEC Mosaic file.}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   function ESMF_GridCreateMosaicIReg(filename,                  &
           countsPerDEDim1PTile, countsPerDEDim2PTile,           &
                                                &
           coordTypeKind,                                        &
           deLabelList, staggerLocList,                          &
           delayout, indexflag, name, tileFilePath, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_Grid) :: ESMF_GridCreateMosaicIReg\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     character(len=*),               intent(in)            :: filename
     integer,                        intent(in)            :: countsPerDEDim1PTile(:,:)
     integer,                        intent(in)            :: countsPerDEDim2PTile(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_TypeKind_Flag),       intent(in),  optional :: coordTypeKind
     integer,                        intent(in),  optional :: deLabelList(:)
     type(ESMF_StaggerLoc),          intent(in),  optional :: staggerLocList(:)
     type(ESMF_DELayout),            intent(in),  optional :: delayout
     type(ESMF_Index_Flag),          intent(in),  optional :: indexflag
     character(len=*),               intent(in),  optional :: name
     character(len=*),               intent(in),  optional :: tileFilePath
     integer,                        intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     Create a multiple-tile {\tt ESMF\_Grid} based on the definition from a GRIDSPEC Mosaic file and its associated
     tile files using irregular decomposition.  Each tile can have different decomposition.  The tile connections
     are defined in a GRIDSPEC format Mosaic file.
     And each tile's coordination is defined in a separate NetCDF file.  The coordinates defined
     in the tile file is so-called "Super Grid".  In other words, the dimensions of the coordinate variables are
     {\tt (2*xdim+1, 2*ydim+1)} if {\tt (xdim, ydim)} is the size of the tile.  The Super Grid combines the corner,
     the edge and the center coordinates in one big array.  A Mosaic file may contain just one tile.  If a Mosaic contains
     multiple tiles.  Each tile is a logically rectangular lat/lon grid.  Currently, all the tiles have to be the same size.
     We will remove this limitation in the future release.
  
  
       The arguments are:
       \begin{description}
       \item[filename]
            The name of the GRIDSPEC Mosaic file.
       \item[countsPerDEDim1PTile]
            This array specifies the number of cells per DE for index dimension 1 for the
            center stagger location. The second index steps through the tiles. If each tile is 
            decomposed into different number of DEs, the first dimension is the maximal DEs of 
            all the tiles.  
       \item[countsPerDEDim2PTile]
            This array specifies the number of cells per DE for index dimension 2 for the
            center stagger location. The second index steps through the tiles. If each tile is 
            decomposed into different number of DEs, the first dimension is the maximal DEs of 
            all the tiles.  
       \item[{[coordTypeKind]}]
            The type/kind of the grid coordinate data. Only ESMF\_TYPEKIND\_R4
            and ESMF\_TYPEKIND\_R8 are supported.
            If not specified then defaults to ESMF\_TYPEKIND\_R8.
       \item[{[deLabelList]}]
            List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order in the sequence as they appear
            in {\tt countsPerDEDim1PTile}, followed by {\tt countsPerDEDim2PTile}, then the 
            tile index.
       \item[{[staggerLocList]}]
            The list of stagger locations to fill with coordinates. Please see Section~\ref{const:staggerloc}
            for a description of the available stagger locations. If not present, no coordinates
            will be added or filled.
       \item[{[delayout]}]
            Optional ESMF\_DELayout object to be used. If a delayout object is specified,
            the number of DEs must match with the total DEs defined in {\tt countsPerDEDim1PTile}
            and {\tt countsPerDEDim2PTile}.
       \item[{[indexflag]}]
            Indicates the indexing scheme to be used in the new Grid. Please see
            Section~\ref{const:indexflag} for the list of options. If not present,
            defaults to ESMF\_INDEX\_DELOCAL.
       \item[{[name]}]
            {\tt ESMF\_Grid} name.
       \item[{[tileFilePath]}]
            Optional argument to define the path where the tile files reside. If it
            is given, it overwrites the path defined in {\tt gridlocation} variable
            in the mosaic file.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridDestroy] {ESMF\_GridDestroy - Release resources associated with a Grid}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_GridDestroy(grid, noGarbage, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid), intent(inout)         :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,         intent(in),  optional :: noGarbage
       integer,         intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.0.0] Added argument {\tt noGarbage}.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Destroys an {\tt ESMF\_Grid} object and related internal structures.
   This call does destroy internally created DistGrid and DELayout classes,
   for example those created by {\tt ESMF\_GridCreateShapeTile()}. It also
   destroys internally created coordinate/item Arrays, for example those
   created by {\tt ESMF\_GridAddCoord()}. However, if the user uses an
   externally created class, for example creating an Array and setting it
   using {\tt ESMF\_GridSetCoord()}, then that class is not destroyed by
   this method.
  
     By default a small remnant of the object is kept in memory in order to
     prevent problems with dangling aliases. The default garbage collection
     mechanism can be overridden with the {\tt noGarbage} argument.
  
   The arguments are:
   \begin{description}
   \item[grid]
        {\tt ESMF\_Grid} to be destroyed.
   \item[{[noGarbage]}]
        If set to {\tt .TRUE.} the object will be fully destroyed and removed
        from the ESMF garbage collection system. Note however that under this
        condition ESMF cannot protect against accessing the destroyed object
        through dangling aliases -- a situation which may lead to hard to debug
        application crashes.
  
        It is generally recommended to leave the {\tt noGarbage} argument
        set to {\tt .FALSE.} (the default), and to take advantage of the ESMF
        garbage collection system which will prevent problems with dangling
        aliases or incorrect sequences of destroy calls. However this level of
        support requires that a small remnant of the object is kept in memory
        past the destroy call. This can lead to an unexpected increase in memory
        consumption over the course of execution in applications that use
        temporary ESMF objects. For situations where the repeated creation and
        destruction of temporary objects leads to memory issues, it is
        recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully
        removing the entire temporary object from memory.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridEmptyComplete] {ESMF\_GridEmptyComplete - Complete a Grid with user set edge connections and an irregular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridEmptyComplete()
       subroutine ESMF_GridEmptyCompleteEConnI(grid, minIndex,         &
         countsPerDEDim1,countsPerDeDim2,                  &
         countsPerDEDim3,                                  &
         connDim1, connDim2, connDim3,                     &
         coordSys, coordTypeKind,                          &
         coordDep1, coordDep2, coordDep3,                  &
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &
         gridMemLBound, indexflag, petMap, name, rc)
 
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type (ESMF_Grid)                                :: grid
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: countsPerDEDim1(:)
        integer,                  intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                  intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional :: gridAlign(:)
        integer,                  intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
        integer,                  intent(in),  optional :: petMap(:,:,:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method takes in an empty Grid created by {\tt ESMF\_GridEmptyCreate()}.
   It then completes the grid to form a single tile, irregularly distributed grid
   (see Figure \ref{fig:GridDecomps}). To specify the irregular distribution, the user passes in an array
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension. Currently this call only
   supports creating 2D or 3D Grids. A 2D Grid can be specified using the
   countsPerDEDim1 and countsPerDEDim2 arguments.  A 3D Grid can
   be specified by also using the optional countsPerDEDim3 argument.
   The index of each array element in these arguments corresponds to
   a DE number.  The array value at the index is the number of grid
   cells on the DE in that dimension.
  
   Section \ref{example:2DIrregUniGrid} shows an example
   of using an irregular distribution to create a 2D Grid with uniformly spaced
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.
  
   For consistency's sake the {\tt ESMF\_GridEmptyComplete()} call
   should be executed in the same set or a subset of the PETs in which the
   {\tt ESMF\_GridEmptyCreate()} call was made. If the call
   is made in a subset, the Grid objects outside that subset will
   still be "empty" and not usable.
  
   The arguments are:
   \begin{description}
   \item[grid]
       The empty {\tt ESMF\_Grid} to set information into and then commit.
   \item[{[minIndex]}]
        Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   \item[countsPerDEDim1]
       This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   \item[countsPerDEDim2]
       This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location).
   \item[{[countsPerDEDim3]}]
       This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).
       If not specified  then grid is 2D.
   \item[{[connDim1]}]
        Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connDim2]}]
        Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connDim3]}]
        Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep2]}]
       This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep3]}]
       This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[gridEdgeLWidth]}]
        The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   \item[{[gridMemLBound]}]
        Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is {\tt ESMF\_INDEX\_USER}. May be overridden
        by staggerMemLBound.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        Section~\ref{const:indexflag} for the list of options. If not present,
        defaults to ESMF\_INDEX\_DELOCAL.
   \item[{[petMap]}]
         \begin{sloppypar}
         Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.
         \end{sloppypar}
   \item[{[name]}]
            {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridEmptyComplete] {ESMF\_GridEmptyComplete - Complete a Grid with user set edge connections and a regular distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridEmptyComplete()
      subroutine ESMF_GridEmptyCompleteEConnR(grid, regDecomp, decompFlag, &
         minIndex, maxIndex,                                    &
         connDim1, connDim2, connDim3,                       &
         coordSys, coordTypeKind,                            &
         coordDep1, coordDep2, coordDep3,                    &
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,          &
         gridMemLBound, indexflag, petMap, name, rc)
 
  !\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type (ESMF_Grid)                                :: grid
        integer,                  intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),   intent(in),  optional :: decompflag(:)
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional :: gridAlign(:)
        integer,                  intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
        integer,                  intent(in),  optional :: petMap(:,:,:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method takes in an empty Grid created by {\tt ESMF\_GridEmptyCreate()}.
   It then completes the grid to form a single tile, regularly distributed grid
   (see Figure \ref{fig:GridDecomps}).
   To specify the distribution, the user passes in an array
   ({\tt regDecomp}) specifying the number of DEs to divide each
   dimension into. The array {\tt decompFlag} indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
   For consistency's sake the {\tt ESMF\_GridEmptyComplete()} call
   should be executed in the same set or a subset of the PETs in which the
   {\tt ESMF\_GridEmptyCreate()} call was made. If the call
   is made in a subset, the Grid objects outside that subset will
   still be "empty" and not usable.
  
   The arguments are:
   \begin{description}
   \item[grid]
       The empty {\tt ESMF\_Grid} to set information into and then commit.
   \item[{[regDecomp]}]
        List that has the same number of elements as {\tt maxIndex}.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   \item[{[decompflag]}]
        List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is {\tt ESMF\_DECOMP\_BALANCED} in all dimensions. Please see
        Section~\ref{const:decompflag} for a full description of the
        possible options. Note that currently the option
        {\tt ESMF\_DECOMP\_CYCLIC} isn't supported in Grid creation.
   \item[{[minIndex]}]
        The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extent of the grid array.
   \item[{[connDim1]}]
        Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connDim2]}]
        Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connDim3]}]
        Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep2]}]
       This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[coordDep3]}]
       This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by {\tt coordsPerDEDim1,2,3}. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   \item[{[gridEdgeLWidth]}]
        The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   \item[{[gridMemLBound]}]
        Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is {\tt ESMF\_INDEX\_USER}. May be overridden
        by staggerMemLBound.
   \item[{[indexflag]}]
        Indicates the indexing scheme to be used in the new Grid. Please see
        Section~\ref{const:indexflag} for the list of options. If not present,
        defaults to ESMF\_INDEX\_DELOCAL.
   \item[{[petMap]}]
         Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   \item[{[name]}]
        {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridEmptyComplete] {ESMF\_GridEmptyComplete - Complete a Grid with user set edge connections and an arbitrary distribution}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridEmptyComplete()
       subroutine ESMF_GridEmptyCompleteEConnA(grid, minIndex, maxIndex,  &
         arbIndexCount, arbIndexList,                         &
         connDim1, connDim2, connDim3,                     &
         coordSys, coordTypeKind,                          &
         coordDep1, coordDep2, coordDep3,                  &
         distDim, name, rc)
  !\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}        type (ESMF_Grid)                                :: grid
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
        integer,                  intent(in)            :: arbIndexCount
        integer,                  intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: distDim(:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   This method takes in an empty Grid created by {\tt ESMF\_GridEmptyCreate()}.
   It then completes the grid to form a single tile, arbitrarily distributed grid
   (see Figure \ref{fig:GridDecomps}).
   To specify the arbitrary distribution, the user passes in an 2D array
   of local indices, where the first dimension is the number of local grid cells
   specified by {\tt localArbIndexCount} and the second dimension is the number of distributed
   dimensions.
  
   {\tt distDim} specifies which grid dimensions are arbitrarily distributed. The
   size of {\tt distDim} has to agree with the size of the second dimension of
   {\tt localArbIndex}.
  
   Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, {\tt maxIndex} must be of size 2 or 3.
  
   For consistency's sake the {\tt ESMF\_GridEmptyComplete()} call
   should be executed in the same set or a subset of the PETs in which the
   {\tt ESMF\_GridEmptyCreate()} call was made. If the call
   is made in a subset, the Grid objects outside that subset will
   still be "empty" and not usable.
  
   The arguments are:
   \begin{description}
   \item[grid]
       The empty {\tt ESMF\_Grid} to set information into and then commit.
   \item[{[minIndex]}]
        Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   \item[maxIndex]
        The upper extend of the grid index ranges.
   \item[arbIndexCount]
        The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.
   \item[arbIndexList]
        This 2D array specifies the indices of the PET LOCAL grid cells.  The
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   \item[{[connDim1]}]
        Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connDim2]}]
        Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[connDim3]}]
        Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section~\ref{const:gridconn} for a list of valid
        options. If not present, defaults to ESMF\_GRIDCONN\_NONE.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
       For a full list of options, please see Section~\ref{const:coordsys}.
       If not specified then defaults to ESMF\_COORDSYS\_SPH\_DEG.
   \item[{[coordTypeKind]}]
       The type/kind of the grid coordinate data. All {\em numerical} types
       listed under section~\ref{const:typekind} are supported.
       If not specified then defaults to ESMF\_TYPEKIND\_R8.
   \item[{[coordDep1]}]
       The size of the array specifies the number of dimensions of the
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_GRID\_ARBDIM/ where
       /ESMF\_GRID\_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_GRID\_ARBDIM/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section~\ref{const:arbdim} for a definition of ESMF\_GRID\_ARBDIM.
   \item[{[coordDep2]}]
       The size of the array specifies the number of dimensions of the
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_GRID\_ARBDIM/ where
       /ESMF\_GRID\_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_GRID\_ARBDIM/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section~\ref{const:arbdim} for a definition of ESMF\_GRID\_ARBDIM.
   \item[{[coordDep3]}]
       The size of the array specifies the number of dimensions of the
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF\_GRID\_ARBDIM/ where
       /ESMF\_GRID\_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF\_GRID\_ARBDIM/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
        Please see Section~\ref{const:arbdim} for a definition of ESMF\_GRID\_ARBDIM.
   \item[{[distDim]}]
         This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of {\tt localArbIndex}.
   \item[{[name]}]
            {\tt ESMF\_Grid} name.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridEmptyCreate] {ESMF\_GridEmptyCreate - Create a Grid that has no contents}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}      function ESMF_GridEmptyCreate(vm, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      type(ESMF_Grid) :: ESMF_GridEmptyCreate\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_VM),           intent(in),  optional :: vm
        integer,                 intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.1.0r] Added argument {\tt vm} to support object creation on a
                 different VM than that of the current context.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Partially create an {\tt ESMF\_Grid} object. This function allocates
   an {\tt ESMF\_Grid} object, but doesn't allocate any coordinate storage or other
   internal structures. The {\tt ESMF\_GridEmptyComplete()} calls
   can be used to set the values in the grid object and to construct the
   internal structure.
  
   The arguments are:
   \begin{description}
   \item[{[vm]}]
       If present, the Grid object is created on the specified
       {\tt ESMF\_VM} object. The default is to create on the VM of the
       current context.
   \item[{[rc]}]
        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGet}\subsubsection [ESMF\_GridGet] {ESMF\_GridGet - Get object-wide Grid information}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetDefault(grid, coordTypeKind, &
         dimCount, tileCount, staggerlocCount, localDECount, distgrid, &
         distgridToGridMap, coordSys, coordDimCount, coordDimMap, arbDim, &
         rank, arbDimCount, gridEdgeLWidth, gridEdgeUWidth, gridAlign,  &
         indexFlag, status, name, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),            intent(in)            :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TypeKind_Flag),  intent(out), optional :: coordTypeKind
       integer,                   intent(out), optional :: dimCount
       integer,                   intent(out), optional :: tileCount
       integer,                   intent(out), optional :: staggerlocCount
       integer,                   intent(out), optional :: localDECount
       type(ESMF_DistGrid),       intent(out), optional :: distgrid
       integer,       target,     intent(out), optional :: distgridToGridMap(:)
       type(ESMF_CoordSys_Flag),  intent(out), optional :: coordSys
       integer,       target,     intent(out), optional :: coordDimCount(:)
       integer,       target,     intent(out), optional :: coordDimMap(:,:)
       integer,                   intent(out), optional :: arbDim
       integer,                   intent(out), optional :: rank
       integer,                   intent(out), optional :: arbDimCount
       integer,       target,     intent(out), optional :: gridEdgeLWidth(:)
       integer,       target,     intent(out), optional :: gridEdgeUWidth(:)
       integer,       target,     intent(out), optional :: gridAlign(:)
       type(ESMF_Index_Flag),     intent(out), optional :: indexflag
       type(ESMF_GridStatus_Flag),intent(out), optional :: status
       character (len=*),         intent(out), optional :: name
       integer,                   intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


      Gets various types of information about a grid.
  
  The arguments are:
  \begin{description}
  \item[grid]
     Grid to get the information from.
  \item[{[coordTypeKind]}]
     The type/kind of the grid coordinate data. All {\em numerical} types
     listed under section~\ref{const:typekind} are supported.
  \item[{[dimCount]}]
     DimCount of the Grid object.
  \item[{[tileCount]}]
     The number of logically rectangular tiles in the grid.
  \item[{[staggerlocCount]}]
     The number of stagger locations.
  \item[{[localDECount]}]
     The number of DEs in this grid on this PET.
  \item[{[distgrid]}]
     The structure describing the distribution of the grid.
  \item[{[distgridToGridMap]}]
     List that has as many elements as the distgrid dimCount. This array describes
     mapping between the grids dimensions and the distgrid.
   \item[{[coordSys]}]
       The coordinate system of the grid coordinate data.
   \item[{[coordDimCount]}]
     This argument needs to be of size equal to the Grid's dimCount.
     Each entry in the argument will be filled with the dimCount of the corresponding coordinate component (e.g. the
     dimCount of coordDim=1 will be put into entry 1).
     This is useful because it describes the factorization of the coordinate components in the Grid.
  \item[{[coordDimMap]}]
     2D list of size grid dimCount x grid dimCount. This array describes the
     map of each component array's dimensions onto the grids
     dimensions.
   \item[{[arbDim]}]
     The distgrid dimension that is mapped by the arbitrarily distributed grid dimensions.
   \item[{[rank]}]
     The count of the memory dimensions, it is the same as dimCount for a non-arbitrarily distributed grid,
     and equal or less for a arbitrarily distributed grid.
   \item[{[arbDimCount]}]
     The number of dimensions distributed arbitrarily for an arbitrary grid, 0 if the grid is non-arbitrary.
   \item[{[gridEdgeLWidth]}]
     The padding around the lower edges of the grid. The array should
     be of size greater or equal to the Grid dimCount.
   \item[{[gridEdgeUWidth]}]
        The padding around the upper edges of the grid. The array should
     be of size greater or equal to the Grid dimCount.
   \item[{[gridAlign]}]
       Specification of how the stagger locations should align with the cell
       index space. The array should be of size greater or equal to the Grid dimCount.
   \item[{[indexflag]}]
      Flag indicating the indexing scheme being used in the Grid. Please
      see Section~\ref{const:indexflag} for the list of options.
   \item[{[status]}]
      Flag indicating the status of the Grid. Please
      see Section~\ref{const:gridstatus} for the list of options.
  \item[{[name]}]
     {\tt ESMF\_Grid} name.
  \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetPLocalDe}\subsubsection [ESMF\_GridGet] {ESMF\_GridGet - Get DE-local Grid information}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPLocalDe(grid, localDE, &
         isLBound,isUBound, arbIndexCount, arbIndexList, tile, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: localDE
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,                intent(out), optional :: isLBound(:)
       logical,                intent(out), optional :: isUBound(:)
       integer,                intent(out), optional :: arbIndexCount
       integer,        target, intent(out), optional :: arbIndexList(:,:)
       integer,                intent(out), optional :: tile
       integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.1.0r] Added argument {\tt tile}. This new argument allows the user to 
                 query the tile within which the localDE is contained. 
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   This call gets information about a particular local DE in a Grid.
  
  The arguments are:
  \begin{description}
  \item[grid]
      Grid to get the information from.
  \item[localDE]
       The local DE from which to get the information. {\tt [0,..,localDECount-1]}
  \item[{[isLBound]}]
       Upon return, for each dimension this indicates if the DE is a lower bound of the Grid.
       {\tt isLBound} must be allocated to be of size equal to the Grid dimCount.
  \item[{[isUBound]}]
       Upon return, for each dimension this indicates if the DE is an upper bound of the Grid.
       {\tt isUBound} must be allocated to be of size equal to the Grid dimCount.
   \item[{[arbIndexCount]}]
     The number of local cells for an arbitrarily distributed grid
   \item[{[arbIndexList]}]
     The 2D array storing the local cell indices for an arbitrarily distributed grid. The size of the array
     is arbIndexCount * arbDimCount
  \item[{[tile]}]
       The number of the tile in which localDE is contained. Tile numbers range from 1 to TileCount.
  \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetPLocalDePSloc}\subsubsection [ESMF\_GridGet] {ESMF\_GridGet - Get DE-local information for a specific stagger location in a Grid}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPLocalDePSloc(grid, staggerloc, localDE, &
         exclusiveLBound, exclusiveUBound, exclusiveCount,  &
         computationalLBound, computationalUBound, computationalCount, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in)            :: staggerloc
       integer,                intent(in)            :: localDE
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


    This method gets information about the range of index space which a
    particular stagger location occupies. This call differs from the coordinate
    bound calls (e.g. {\tt ESMF\_GridGetCoord}) in that a given coordinate
    array may only occupy a subset of the Grid's dimensions, and
    so these calls may not give all the bounds of the stagger location.
    The bounds from this call are the full bounds, and so
    for example, give the appropriate bounds for allocating a Fortran array to hold
    data residing on the stagger location.
    Note that unlike the output from the Array, these values also include the
    undistributed dimensions and are
    ordered to reflect the order of the indices in the Grid. This call will
    still give correct values even if the stagger location does not contain
    coordinate arrays (e.g. if  {\tt ESMF\_GridAddCoord} hasn't yet
    been called on the stagger location).
  
  The arguments are:
  \begin{description}
  \item[grid]
      Grid to get the information from.
  \item[staggerloc]
       The stagger location to get the information for.
       Please see Section~\ref{const:staggerloc} for a list
       of predefined stagger locations.
  \item[localDE]
       The local DE from which to get the information. {\tt [0,..,localDECount-1]}
  \item[{[exclusiveLBound]}]
       Upon return this holds the lower bounds of the exclusive region.
       {\tt exclusiveLBound} must be allocated to be of size equal to the Grid dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[exclusiveUBound]}]
       Upon return this holds the upper bounds of the exclusive region.
       {\tt exclusiveUBound} must be allocated to be of size equal to the Grid dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[exclusiveCount]}]
       Upon return this holds the number of items,{\tt exclusiveUBound-exclusiveLBound+1},
       in the exclusive region per dimension.
       {\tt exclusiveCount} must
       be allocated to be of size equal to the Grid dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[computationalLBound]}]
       \begin{sloppypar}
       Upon return this holds the lower bounds of the computational region.
       {\tt computationalLBound} must be allocated to be of size equal to the Grid dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
       \end{sloppypar}
  \item[{[computationalUBound]}]
       \begin{sloppypar}
       Upon return this holds the upper bounds of the computational region.
       {\tt computationalUBound} must be allocated to be of size equal to the Grid dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
       \end{sloppypar}
  \item[{[computationalCount]}]
       \begin{sloppypar}
       Upon return this holds the number of items in the computational region per dimension.
       (i.e. {\tt computationalUBound-computationalLBound+1}). {\tt computationalCount} must
        be allocated to be of size equal to the Grid dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
       \end{sloppypar}
  \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetPSloc}\subsubsection [ESMF\_GridGet] {ESMF\_GridGet - Get information about a specific stagger location in a Grid}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPSloc(grid, staggerloc, &
         distgrid, &
         staggerEdgeLWidth, staggerEdgeUWidth, &
         staggerAlign, staggerLBound, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in)            :: staggerloc
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_DistGrid),    intent(out), optional :: distgrid
       integer,                intent(out), optional :: staggerEdgeLWidth(:)
       integer,                intent(out), optional :: staggerEdgeUWidth(:)
       integer,                intent(out), optional :: staggerAlign(:)
       integer,                intent(out), optional :: staggerLBound(:)
       integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.1.0r] Added arguments {\tt staggerEdgeLWidth}, {\tt staggerEdgeUWidth},
                 {\tt staggerAlign}, and {\tt staggerLBound}. These new arguments 
                  allow the user to get width, alignment, and bound information for
                  the given stagger location. 
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


    This method gets information about a particular stagger location.
    This information is useful for creating an ESMF Array to hold
    the data at the stagger location.
  
  The arguments are:
  \begin{description}
  \item[grid]
      Grid to get the information from.
  \item[staggerloc]
       The stagger location to get the information for.
       Please see Section~\ref{const:staggerloc} for a list
       of predefined stagger locations.
  \item[{[distgrid]}]
     The structure describing the distribution of this staggerloc in this grid.
   \item[{[staggerEdgeLWidth]}]
        This array should be the same dimCount as the grid. It specifies the lower corner of the stagger
        region with respect to the lower corner of the exclusive region.
   \item[{[staggerEdgeUWidth]}]
        This array should be the same dimCount as the grid. It specifies the upper corner of the stagger
        region with respect to the upper corner of the exclusive region.
   \item[{[staggerAlign]}]
        This array is of size  grid dimCount.
        For this stagger location, it specifies which element
        has the same index value as the center. For example,
        for a 2D cell with corner stagger it specifies which
        of the 4 corners has the same index as the center.
   \item[{[staggerLBound]}]
        Specifies the lower index range of the memory of every DE in this staggerloc in this Grid.
        Only used when Grid indexflag is {\tt ESMF\_INDEX\_USER}.
  \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetPSlocPTile}\subsubsection [ESMF\_GridGet] {ESMF\_GridGet - Get information about a specific stagger location and tile in a Grid}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPSlocPTile(grid, tile, staggerloc, &
         minIndex, maxIndex, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: tile
       type (ESMF_StaggerLoc), intent(in)            :: staggerloc
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,        target, intent(out), optional :: minIndex(:)
       integer,        target, intent(out), optional :: maxIndex(:)
       integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


    This method gets information about a particular stagger location.
    This information is useful for creating an ESMF Array to hold
    the data at the stagger location.
  
  The arguments are:
  \begin{description}
  \item[grid]
      Grid to get the information from.
  \item[tile]
       The tile number to get the data from. Tile numbers range from 1 to TileCount.
  \item[staggerloc]
       The stagger location to get the information for.
       Please see Section~\ref{const:staggerloc} for a list
       of predefined stagger locations.
  \item[{[minIndex]}]
       Upon return this holds the global lower index of this stagger location.
       {\tt minIndex} must be allocated to be of size equal to the grid DimCount.
       Note that this value is only for the first Grid tile, as multigrid support
       is added, this interface will likely be changed or moved to adapt.
  \item[{[maxIndex]}]
       Upon return this holds the global upper index of this stagger location.
       {\tt maxIndex} must be allocated to be of size equal to the grid DimCount.
       Note that this value is only for the first Grid tile, as multigrid support
       is added, this interface will likely be changed or moved to adapt.
  \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetCoord}\subsubsection [ESMF\_GridGetCoord] {ESMF\_GridGetCoord - Get a DE-local Fortran array pointer to Grid coord data and coord bounds}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}        subroutine ESMF_GridGetCoord<rank><type><kind>(grid, coordDim,    &
          staggerloc, localDE, farrayPtr, datacopyflag,                  &
          exclusiveLBound, exclusiveUBound, exclusiveCount,              &
          computationalLBound, computationalUBound, computationalCount,  &
          totalLBound, totalUBound, totalCount, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),       intent(in)              :: grid
       integer,               intent(in)              :: coordDim
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc) intent(in),    optional :: staggerloc
       integer,               intent(in),    optional :: localDE
       <type> (ESMF_KIND_<kind>), pointer             :: farrayPtr(<rank>)
       type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
       integer,               intent(out),   optional :: exclusiveLBound(:)
       integer,               intent(out),   optional :: exclusiveUBound(:)
       integer,               intent(out),   optional :: exclusiveCount(:)
       integer,               intent(out),   optional :: computationalLBound(:)
       integer,               intent(out),   optional :: computationalUBound(:)
       integer,               intent(out),   optional :: computationalCount(:)
       integer,               intent(out),   optional :: totalLBound(:)
       integer,               intent(out),   optional :: totalUBound(:)
       integer,               intent(out),   optional :: totalCount(:)
       integer,               intent(out),   optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       This method gets a Fortran pointer to the piece of memory which holds the
       coordinate data on the local DE for the given coordinate dimension and stagger
       locations.
       This is useful, for example, for setting the coordinate values in a Grid, or
       for reading the coordinate values.  Currently this method supports up to three
       coordinate dimensions, of either R4 or R8 datatype.  See below for specific
       supported values.  If the coordinates that you are trying to retrieve are of
       higher dimension, use the {\tt ESMF\_GetCoord()} interface that returns coordinate
       values in an {\tt ESMF\_Array} instead.  That interface supports the retrieval of
       coordinates up to 7D.
  
       Supported values for the farrayPtr argument are:
       \begin{description}
       \item real(ESMF\_KIND\_R4), pointer :: farrayPtr(:)
       \item real(ESMF\_KIND\_R4), pointer :: farrayPtr(:,:)
       \item real(ESMF\_KIND\_R4), pointer :: farrayPtr(:,:,:)
       \item real(ESMF\_KIND\_R8), pointer :: farrayPtr(:)
       \item real(ESMF\_KIND\_R8), pointer :: farrayPtr(:,:)
       \item real(ESMF\_KIND\_R8), pointer :: farrayPtr(:,:,:)
       \end{description}
  
       The arguments are:
       \begin{description}
       \item[grid]
            Grid to get the information from.
       \item[coordDim]
            The coordinate dimension to get the data from (e.g. 1=x).
       \item[{[staggerloc]}]
            The stagger location to get the information for.
            Please see Section~\ref{const:staggerloc} for a list
            of predefined stagger locations. If not present, defaults to ESMF\_STAGGERLOC\_CENTER.
       \item[{[localDE]}]
           The local DE for which information is requested. {\tt [0,..,localDECount-1]}.
           For {\tt localDECount==1} the {\tt localDE} argument may be omitted,
            in which case it will default to {\tt localDE=0}.
       \item[{farrayPtr}]
            The pointer to the coordinate data.
       \item[{[datacopyflag]}]
            If not specified, default to {\tt ESMF\_DATACOPY\_REFERENCE}, in this case
            farrayPtr is a reference to the data in the Grid coordinate arrays.
            Please see Section~\ref{const:datacopyflag} for further description and a
            list of valid values.
       \item[{[exclusiveLBound]}]
            Upon return this holds the lower bounds of the exclusive region.
            {\tt exclusiveLBound} must be allocated to be of size equal to the coord dimCount.
       \item[{[exclusiveUBound]}]
            Upon return this holds the upper bounds of the exclusive region.
            {\tt exclusiveUBound} must be allocated to be of size equal to the coord dimCount.
       \item[{[exclusiveCount]}]
            Upon return this holds the number of items, {\tt exclusiveUBound-exclusiveLBound+1},
            in the exclusive region per dimension.
            {\tt exclusiveCount} must
            be allocated to be of size equal to the coord dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
       \item[{[computationalLBound]}]
            Upon return this holds the lower bounds of the stagger region.
            {\tt computationalLBound} must be allocated to be of size equal to the coord dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
       \item[{[computationalUBound]}]
            Upon return this holds the upper bounds of the stagger region.
            {\tt exclusiveUBound} must be allocated to be of size equal to the coord dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
       \item[{[computationalCount]}]
            Upon return this holds the number of items in the computational region per dimension
            (i.e. {\tt computationalUBound-computationalLBound+1}). {\tt computationalCount}
            must be allocated to be of size equal to the coord dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
       \item[{[totalLBound]}]
            Upon return this holds the lower bounds of the total region.
            {\tt totalLBound} must be allocated to be of size equal to the coord dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
       \item[{[totalUBound]}]
            Upon return this holds the upper bounds of the total region.
            {\tt totalUBound} must be allocated to be of size equal to the coord dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
       \item[{[totalCount]}]
            \begin{sloppypar}
            Upon return this holds the number of items in the total region per dimension
            (i.e. {\tt totalUBound-totalLBound+1}). {\tt totalCount} must
            be allocated to be of size equal to the coord dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
            \end{sloppypar}
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetCoordIntoArray}\subsubsection [ESMF\_GridGetCoord] {ESMF\_GridGetCoord - Get coordinates and put into an Array}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordIntoArray(grid, coordDim, staggerloc, &
         array, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: coordDim
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       type(ESMF_Array),       intent(out)           :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


      This method allows the user to get access to the ESMF Array holding
      coordinate data at a particular stagger location. This is useful, for example,
      to set the coordinate values. To have an Array to access, the coordinate Arrays
      must have already been allocated, for example by {\tt ESMF\_GridAddCoord} or
      {\tt ESMF\_GridSetCoord}.
  
       The arguments are:
       \begin{description}
       \item[grid]
            The grid to get the coord array from.
       \item[coordDim]
            The coordinate dimension to get the data from (e.g. 1=x).
       \item[{[staggerloc]}]
            The stagger location from which to get the arrays.
            Please see Section~\ref{const:staggerloc} for a list
            of predefined stagger locations. If not present, defaults to ESMF\_STAGGERLOC\_CENTER.
       \item[array]
            An array into which to put the coordinate information.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetCoordR4}\subsubsection [ESMF\_GridGetCoord] {ESMF\_GridGetCoord - Get DE-local coordinates from a specific index location in a Grid}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordR4(grid, staggerloc, localDE, &
         index, coord, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,                intent(in)            :: index(:)
       real(ESMF_KIND_R4),     intent(out)           :: coord(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Given a specific index location in a Grid, this method returns the full set
     of coordinates from that index location. This method should work no matter what
     the factorization of the Grid's coordinate components.
  
       The arguments are:
       \begin{description}
       \item[grid]
            Grid to get the information from.
       \item[{[staggerloc]}]
            The stagger location to get the information for.
            Please see Section~\ref{const:staggerloc} for a list
            of predefined stagger locations. If not present, defaults to
            ESMF\_STAGGERLOC\_CENTER.
       \item[{[localDE]}]
            The local DE for which information is requested. {\tt [0,..,localDECount-1]}.
            For {\tt localDECount==1} the {\tt localDE} argument may be omitted,
            in which case it will default to {\tt localDE=0}.
       \item[index]
            This array holds the index location to be queried in the Grid. This array must
            at least be of the size Grid rank.
       \item[coord]
            This array will be filled with the coordinate data. This array must
            at least be of the size Grid rank.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetCoordR8}\subsubsection [ESMF\_GridGetCoord] {ESMF\_GridGetCoord - Get DE-local coordinates from a specific index location in a Grid}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordR8(grid, staggerloc, localDE, &
         index, coord, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,                intent(in)            :: index(:)
       real(ESMF_KIND_R8),     intent(out)           :: coord(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       Given a specific index location in a Grid, this method returns the full set
     of coordinates from that index location. This method should work no matter what
     the factorization of the Grid's coordinate components.
  
       The arguments are:
       \begin{description}
       \item[grid]
            Grid to get the information from.
       \item[{[staggerloc]}]
            The stagger location to get the information for.
            Please see Section~\ref{const:staggerloc} for a list
            of predefined stagger locations. If not present, defaults to
            ESMF\_STAGGERLOC\_CENTER.
       \item[{[localDE]}]
            The local DE for which information is requested. {\tt [0,..,localDECount-1]}.
            For {\tt localDECount==1} the {\tt localDE} argument may be omitted,
            in which case it will default to {\tt localDE=0}.
       \item[index]
            This array holds the index location to be queried in the Grid. This array must
            at least be of the size Grid rank.
       \item[coord]
            This array will be filled with the coordinate data. This array must
            at least be of the size Grid rank.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetCoordInfo}\subsubsection [ESMF\_GridGetCoord] {ESMF\_GridGetCoord - Get information about the coordinates at a particular stagger location}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordInfo(grid, &
         staggerloc, isPresent, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),           intent(in)            :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
       logical,                   intent(out), optional :: isPresent
       integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


      This method allows the user to get information about the coordinates on a given
      stagger.
  
       The arguments are:
       \begin{description}
       \item[grid]
            Grid to get the information from.
       \item[{[staggerloc]}]
            The stagger location from which to get information.
            Please see Section~\ref{const:staggerloc} for a list
            of predefined stagger locations. If not present, defaults to ESMF\_STAGGERLOC\_CENTER.
       \item[{[isPresent]}]
            If .true. then coordinates have been added on this staggerloc.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridGetCoordBounds] {ESMF\_GridGetCoordBounds - Get Grid coordinate bounds}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_GridGetCoordBounds(grid, coordDim,   &
         staggerloc, localDE, exclusiveLBound, exclusiveUBound, &
         exclusiveCount, computationalLBound, computationalUBound , &
         computationalCount, totalLBound, totalUBound, totalCount, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: coordDim
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,        target, intent(out), optional :: totalLBound(:)
       integer,        target, intent(out), optional :: totalUBound(:)
       integer,        target, intent(out), optional :: totalCount(:)
       integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


    This method gets information about the range of index space which a particular
    piece of coordinate data occupies.  In other words, this method returns the
    bounds of the coordinate arrays.  Note that unlike the output from the
    Array, these values also include the undistributed dimensions and are
    ordered to reflect the order of the indices in the coordinate. So, for example,
    {\tt totalLBound} and {\tt totalUBound} should match the bounds of the Fortran array
    retrieved by {\tt ESMF\_GridGetCoord}.
  
  The arguments are:
  \begin{description}
  \item[grid]
      Grid to get the information from.
  \item[coordDim]
       The coordinate dimension to get the information for (e.g. 1=x).
  \item[{[staggerloc]}]
       The stagger location to get the information for.
       Please see Section~\ref{const:staggerloc} for a list
       of predefined stagger locations. If not present, defaults to
       ESMF\_STAGGERLOC\_CENTER.
  \item[{[localDE]}]
            The local DE for which information is requested. {\tt [0,..,localDECount-1]}.
            For {\tt localDECount==1} the {\tt localDE} argument may be omitted,
            in which case it will default to {\tt localDE=0}.
  \item[{[exclusiveLBound]}]
       Upon return this holds the lower bounds of the exclusive region.
       {\tt exclusiveLBound} must be allocated to be of size equal to the coord dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[exclusiveUBound]}]
       Upon return this holds the upper bounds of the exclusive region.
       {\tt exclusiveUBound} must be allocated to be of size equal to the coord dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[exclusiveCount]}]
       Upon return this holds the number of items, {\tt exclusiveUBound-exclusiveLBound+1},
       in the exclusive region per dimension.
       {\tt exclusiveCount} must
       be allocated to be of size equal to the coord dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[computationalLBound]}]
       Upon return this holds the lower bounds of the stagger region.
       {\tt computationalLBound} must be allocated to be of size equal to the coord dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[computationalUBound]}]
       Upon return this holds the upper bounds of the stagger region.
       {\tt computationalUBound} must be allocated to be of size equal to the coord dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[computationalCount]}]
       Upon return this holds the number of items in the computational region per dimension
       (i.e. {\tt computationalUBound-computationalLBound+1}). {\tt computationalCount}
        must be allocated to be of size equal to the coord dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[totalLBound]}]
       Upon return this holds the lower bounds of the total region.
       {\tt totalLBound} must be allocated to be of size equal to the coord dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[totalUBound]}]
       Upon return this holds the upper bounds of the total region.
       {\tt totalUBound} must be allocated to be of size equal to the coord dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[totalCount]}]
       \begin{sloppypar}
       Upon return this holds the number of items in the total region per dimension
       (i.e. {\tt totalUBound-totalLBound+1}). {\tt totalCount} must
        be allocated to be of size equal to the coord dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
       \end{sloppypar}
  \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetItem}\subsubsection [ESMF\_GridGetItem] {ESMF\_GridGetItem - Get a DE-local Fortran array pointer to Grid item data and item bounds}


\bigskip{\sf INTERFACE:}
\begin{verbatim}        subroutine ESMF_GridGetItem<rank><type><kind>(grid, itemflag,  &
          staggerloc, localDE, farrayPtr, datacopyflag,                  &
          exclusiveLBound, exclusiveUBound, exclusiveCount,              &
          computationalLBound, computationalUBound, computationalCount,  &
          totalLBound, totalUBound, totalCount, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),      intent(in)               :: grid
       type (ESMF_GridItem_Flag),intent(in)           :: itemflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional  :: staggerloc
       integer,              intent(in),    optional  :: localDE
       <type> (ESMF_KIND_<kind>), pointer             :: farrayPtr(<rank>)
       type(ESMF_DataCopy_Flag),intent(in), optional  :: datacopyflag
       integer,              intent(out),   optional  :: exclusiveLBound(:)
       integer,              intent(out),   optional  :: exclusiveUBound(:)
       integer,              intent(out),   optional  :: exclusiveCount(:)
       integer,              intent(out),   optional  :: computationalLBound(:)
       integer,              intent(out),   optional  :: computationalUBound(:)
       integer,              intent(out),   optional  :: computationalCount(:)
       integer,              intent(out),   optional  :: totalLBound(:)
       integer,              intent(out),   optional  :: totalUBound(:)
       integer,              intent(out),   optional  :: totalCount(:)
       integer,              intent(out),   optional  :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


       This method gets a Fortran pointer to the piece of memory which holds the
       item data on the local DE for the given stagger locations.
       This is useful, for example, for setting the item values in a Grid, or
       for reading the item values.  Currently this method supports up to three
       grid dimensions, but is limited to the I4 datatype.  See below for specific
       supported values.  If the item values that you are trying to retrieve are of
       higher dimension, use the {\tt ESMF\_GetItem()} interface that returns coordinate
       values in an {\tt ESMF\_Array} instead.  That interface supports the retrieval of
       coordinates up to 7D.
  
       Supported values for the farrayPtr argument are:
       \begin{description}
       \item integer(ESMF\_KIND\_I4), pointer :: farrayPtr(:)
       \item integer(ESMF\_KIND\_I4), pointer :: farrayPtr(:,:)
       \item integer(ESMF\_KIND\_I4), pointer :: farrayPtr(:,:,:)
       \item real(ESMF\_KIND\_R4),    pointer :: farrayPtr(:)
       \item real(ESMF\_KIND\_R4),    pointer :: farrayPtr(:,:)
       \item real(ESMF\_KIND\_R4),    pointer :: farrayPtr(:,:,:)
       \item real(ESMF\_KIND\_R8),    pointer :: farrayPtr(:)
       \item real(ESMF\_KIND\_R8),    pointer :: farrayPtr(:,:)
       \item real(ESMF\_KIND\_R8),    pointer :: farrayPtr(:,:,:)
       \end{description}
  
       The arguments are:
       \begin{description}
       \item[grid]
            Grid to get the information from.
       \item[itemflag]
            The item to get the information for. Please see Section~\ref{const:griditem} for a
            list of valid items.
       \item[{[staggerloc]}]
            The stagger location to get the information for.
            Please see Section~\ref{const:staggerloc} for a list
            of predefined stagger locations. If not present, defaults to ESMF\_STAGGERLOC\_CENTER.
       \item[{[localDE]}]
            The local DE for which information is requested. {\tt [0,..,localDECount-1]}.
            For {\tt localDECount==1} the {\tt localDE} argument may be omitted,
            in which case it will default to {\tt localDE=0}.
       \item[farrayPtr]
            The pointer to the item data.
       \item[{[datacopyflag]}]
            If not specified, default to {\tt ESMF\_DATACOPY\_REFERENCE}, in this case
            farrayPtr is a reference to the data in the Grid item arrays.
            Please see Section~\ref{const:datacopyflag} for further description and a
            list of valid values.
       \item[{[exclusiveLBound]}]
            Upon return this holds the lower bounds of the exclusive region.
            {\tt exclusiveLBound} must be allocated to be of size equal to the grid dimCount.
       \item[{[exclusiveUBound]}]
            Upon return this holds the upper bounds of the exclusive region.
            {\tt exclusiveUBound} must be allocated to be of size equal to the grid dimCount.
       \item[{[exclusiveCount]}]
            \begin{sloppypar}
            Upon return this holds the number of items in the exclusive region per dimension
            (i.e. {\tt exclusiveUBound-exclusiveLBound+1}). {\tt exclusiveCount} must
            be allocated to be of size equal to the grid dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
            \end{sloppypar}
       \item[{[computationalLBound]}]
            Upon return this holds the lower bounds of the stagger region.
            {\tt computationalLBound} must be allocated to be of size equal to the grid dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
       \item[{[computationalUBound]}]
            Upon return this holds the upper bounds of the stagger region.
            {\tt exclusiveUBound} must be allocated to be of size equal to the grid dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
       \item[{[computationalCount]}]
            Upon return this holds the number of items in the computational region per dimension
            (i.e. {\tt computationalUBound-computationalLBound+1}). {\tt computationalCount}
            must be allocated to be of size equal to the grid dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
       \item[{[totalLBound]}]
            Upon return this holds the lower bounds of the total region.
            {\tt totalLBound} must be allocated to be of size equal to the grid dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
       \item[{[totalUBound]}]
            Upon return this holds the upper bounds of the total region.
            {\tt totalUBound} must be allocated to be of size equal to the grid dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
       \item[{[totalCount]}]
            \begin{sloppypar}
            Upon return this holds the number of items in the total region per dimension
            (i.e. {\tt totalUBound-totalLBound+1}). {\tt totalCount} must
            be allocated to be of size equal to the grid dimCount.
            Please see Section~\ref{sec:grid:usage:bounds} for a description
            of the regions and their associated bounds and counts.
            \end{sloppypar}
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetItemIntoArray}\subsubsection [ESMF\_GridGetItem] {ESMF\_GridGetItem - Get a Grid item and put into an Array}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridGetItem()
       subroutine ESMF_GridGetItemIntoArray(grid, itemflag,  staggerloc, &
         array, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),           intent(in)            :: grid
       type (ESMF_GridItem_Flag), intent(in)            :: itemflag
       type (ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
       type(ESMF_Array),          intent(out)           :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                   intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


      This method allows the user to get access to the ESMF Array holding
      item data at a particular stagger location. This is useful, for example,
      to set the item values. To have an Array to access, the item Array
      must have already been allocated, for example by {\tt ESMF\_GridAddItem} or
      {\tt ESMF\_GridSetItem}.
  
       The arguments are:
       \begin{description}
       \item[grid]
            Grid to get the information from.
       \item[itemflag]
            The item from which to get the arrays. Please see Section~\ref{const:griditem} for a
            list of valid items.
       \item[{[staggerloc]}]
            The stagger location from which to get the arrays.
            Please see Section~\ref{const:staggerloc} for a list
            of predefined stagger locations. If not present, defaults to ESMF\_STAGGERLOC\_CENTER.
       \item[array]
            An array into which to put the item information.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

  \label{API:GridGetItemInfo}\subsubsection [ESMF\_GridGetItem] {ESMF\_GridGetItem - Get information about an item at a particular stagger location}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridGetItem()
       subroutine ESMF_GridGetItemInfo(grid, itemflag, &
         staggerloc, isPresent, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),           intent(in)            :: grid
       type (ESMF_GridItem_Flag), intent(in)            :: itemflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
       logical,                   intent(out), optional :: isPresent
       integer,                   intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


      This method allows the user to get information about a given item on a given
      stagger.
  
       The arguments are:
       \begin{description}
       \item[grid]
            Grid to get the information from.
       \item[itemflag]
            The item for which to get information. Please see Section~\ref{const:griditem} for a
            list of valid items.
       \item[{[staggerloc]}]
            The stagger location for which to get information.
            Please see Section~\ref{const:staggerloc} for a list
            of predefined stagger locations. If not present, defaults to ESMF\_STAGGERLOC\_CENTER.
       \item[{[isPresent]}]
            If .true. then an item of type itemflag has been added to this staggerloc.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridGetItemBounds] {ESMF\_GridGetItemBounds - Get DE-local item bounds from a Grid}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_GridGetItemBounds(grid, itemflag,  &
         staggerloc, localDE, &
         exclusiveLBound, exclusiveUBound, exclusiveCount, &
         computationalLBound, computationalUBound, computationalCount,  &
         totalLBound, totalUBound, totalCount, rc)
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_GridItem_Flag), intent(in)         :: itemflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,        target, intent(out), optional :: totalLBound(:)
       integer,        target, intent(out), optional :: totalUBound(:)
       integer,        target, intent(out), optional :: totalCount(:)
       integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


    This method gets information about the range of index space which a particular
    piece of item data occupies.  In other words, this method returns the
    bounds of the item arrays.  Note that unlike the output from the
    Array, these values also include the undistributed dimensions and are
    ordered to reflect the order of the indices in the item. So, for example,
    {\tt totalLBound} and {\tt totalUBound} should match the bounds of the Fortran array
    retrieved by {\tt ESMF\_GridGetItem}.
  
  The arguments are:
  \begin{description}
  \item[grid]
       Grid to get the information from.
  \item[itemflag]
       The item to get the information for. Please see Section~\ref{const:griditem} for a
       list of valid items.
  \item[{[staggerloc]}]
       The stagger location to get the information for.
       Please see Section~\ref{const:staggerloc} for a list
       of predefined stagger locations. If not present, defaults to
       ESMF\_STAGGERLOC\_CENTER.
  \item[{[localDE]}]
            The local DE for which information is requested. {\tt [0,..,localDECount-1]}.
            For {\tt localDECount==1} the {\tt localDE} argument may be omitted,
            in which case it will default to {\tt localDE=0}.
  \item[{[exclusiveLBound]}]
       Upon return this holds the lower bounds of the exclusive region.
       {\tt exclusiveLBound} must be allocated to be of size equal to the item dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[exclusiveUBound]}]
       Upon return this holds the upper bounds of the exclusive region.
       {\tt exclusiveUBound} must be allocated to be of size equal to the item dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[exclusiveCount]}]
       Upon return this holds the number of items, {\tt exclusiveUBound-exclusiveLBound+1},
       in the exclusive region per dimension.
       {\tt exclusiveCount} must
       be allocated to be of size equal to the item dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[computationalLBound]}]
       Upon return this holds the lower bounds of the stagger region.
       {\tt computationalLBound} must be allocated to be of size equal to the item dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[computationalUBound]}]
       Upon return this holds the upper bounds of the stagger region.
       {\tt computationalUBound} must be allocated to be of size equal to the item dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[computationalCount]}]
       Upon return this holds the number of items in the computational region per dimension
       (i.e. {\tt computationalUBound-computationalLBound+1}). {\tt computationalCount}
        must be allocated to be of size equal to the item dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[totalLBound]}]
       Upon return this holds the lower bounds of the total region.
       {\tt totalLBound} must be allocated to be of size equal to the item dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[totalUBound]}]
       Upon return this holds the upper bounds of the total region.
       {\tt totalUBound} must be allocated to be of size equal to the item dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
  \item[{[totalCount]}]
       \begin{sloppypar}
       Upon return this holds the number of items in the total region per dimension
       (i.e. {\tt totalUBound-totalLBound+1}). {\tt totalCount} must
        be allocated to be of size equal to the item dimCount.
       Please see Section~\ref{sec:grid:usage:bounds} for a description
       of the regions and their associated bounds and counts.
       \end{sloppypar}
  \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridIsCreated] {ESMF\_GridIsCreated - Check whether a Grid object has been created}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   function ESMF_GridIsCreated(grid, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: ESMF_GridIsCreated\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Grid), intent(in)            :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
 \end{verbatim}
{\sf DESCRIPTION:\\ }


     Return {\tt .true.} if the {\tt grid} has been created. Otherwise return
     {\tt .false.}. If an error occurs, i.e. {\tt rc /= ESMF\_SUCCESS} is
     returned, the return value of the function will also be {\tt .false.}.
  
   The arguments are:
     \begin{description}
     \item[grid]
       {\tt ESMF\_Grid} queried.
     \item[{[rc]}]
       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
     \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridMatch] {ESMF\_GridMatch - Check if two Grid objects match}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   function ESMF_GridMatch(grid1, grid2, globalflag, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_GridMatch_Flag) :: ESMF_GridMatch
 \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Grid),  intent(in)              :: grid1
     type(ESMF_Grid),  intent(in)              :: grid2
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,          intent(in),   optional  :: globalflag
     integer,          intent(out),  optional  :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


    Check if {\tt grid1} and {\tt grid2} match. Returns a range of values of type
    ESMF\_GridMatch indicating how closely the Grids match. For a description of
    the possible return values, please see~\ref{const:gridmatch}.
    Please also note that by default this call is not collective and only
    returns the match for the piece of the Grids on the local PET. In this case,
    it is possible for this call to return a different match on different PETs
    for the same Grids. To do a global match operation set the {\tt globalflag}
    argument to .true.. In this case, the call becomes collective across the
    current VM, ensuring the same result is returned on all PETs.
  
       The arguments are:
       \begin{description}
       \item[grid1]
            {\tt ESMF\_Grid} object.
       \item[grid2]
            {\tt ESMF\_Grid} object.
       \item[{[globalflag]}]
            By default this flag is set to false. When it's set to true, the
            function performs the match check globally. In this case,
            the method becomes collective across the current VM.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridSetCoord] {ESMF\_GridSetCoord - Set coordinates using Arrays}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}       subroutine ESMF_GridSetCoordFromArray(grid, coordDim, staggerloc, &
         array, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: coordDim
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       type(ESMF_Array),       intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   This method sets the passed in Array as the holder of the coordinate
   data for stagger location staggerloc and coordinate coord. This method
   can be used in place of ESMF\_GridAddCoord(). In fact, if the Grid
   location already contains an Array for this coordinate, then this one
   replaces it. For this method to replace ESMF\_GridAddCoord() and produce
   a valid set of coordinates, then this method must be used to set
   an Array for each coordDim ranging from 1 to the dimCount of the passed in Grid.
  
       The arguments are:
  \begin{description}
  \item[grid]
      The grid to set the coord in.
  \item[coordDim]
      The coordinate dimension to put the data in (e.g. 1=x).
  \item[{[staggerloc]}]
      The stagger location into which to copy the arrays.
      Please see Section~\ref{const:staggerloc} for a list
      of predefined stagger locations. If not present, defaults to
      ESMF\_STAGGERLOC\_CENTER.
  \item[array]
      An array to set the grid coordinate information from.
  \item[{[rc]}]
      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridSetItem] {ESMF\_GridSetItem - Set an item using an Array}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_GridSetItem()
       subroutine ESMF_GridSetItemFromArray(grid, itemflag,  staggerloc, &
         array, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_Grid),           intent(in)            :: grid
       type (ESMF_GridItem_Flag), intent(in)            :: itemflag
       type (ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
       type(ESMF_Array),          intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                   intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


     This method sets the passed in Array as the holder of the item data
     for stagger location {\tt staggerloc} and item {\tt itemflag}. If the location
     already contains an Array, then this one overwrites it. This method can
     be used as a replacement for ESMF\_GridAddItem().
  
       The arguments are:
  \begin{description}
  \item[grid]
      The grid in which to set the array.
  \item[itemflag]
      The item into which to copy the arrays. Please see Section~\ref{const:griditem} for a
      list of valid items.
  \item[{[staggerloc]}]
      The stagger location into which to copy the arrays.
      Please see Section~\ref{const:staggerloc} for a list
      of predefined stagger locations. If not present, defaults to
      ESMF\_STAGGERLOC\_CENTER.
  \item[array]
      An array to set the grid item information from.
  \item[{[rc]}]
      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_GridValidate] {ESMF\_GridValidate - Validate Grid internals}


 
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_GridValidate(grid, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_Grid), intent(in)              :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,         intent(out),  optional  :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


        Validates that the {\tt Grid} is internally consistent.
        Note that one of the checks that the Grid validate does
        is the Grid status. Currently, the validate will return
        an error if the grid is not at least
        {\tt ESMF\_GRIDSTATUS\_COMPLETE}. This means that
        if a Grid was created with the {\tt ESMF\_GridEmptyCreate}
        method, it must also have been finished with
        {\tt ESMF\_GridEmptyComplete()}
        to be valid. If a Grid was created with another create
        call it should automatically have the correct status level
        to pass the status part of the validate.
        The Grid validate at this time doesn't check for the presence
        or consistency of the Grid coordinates.
        The method returns an error code if problems are found.
  
       The arguments are:
       \begin{description}
       \item[grid]
            Specified {\tt ESMF\_Grid} object.
       \item[{[rc]}]
            Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
       \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
