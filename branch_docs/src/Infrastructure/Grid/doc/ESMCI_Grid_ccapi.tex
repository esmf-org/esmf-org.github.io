%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_Grid.C,  Date: Tue May  5 20:59:48 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMCI::Grid::create] {ESMCI::Grid::create - Create a new Grid}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}        Grid* Grid::createnoperidim(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       pointer to newly allocated ESMCI::Grid object\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     ESMC_InterArrayInt *maxIndex, 
     ESMC_CoordSys_Flag *coordSys,
     ESMC_TypeKind_Flag *coordTypeKind,
     ESMC_IndexFlag *indexflag,
     int *rc) {           // out - return code\end{verbatim}
{\sf DESCRIPTION:\\ }


        Create a new Grid.
  
        Note: this is a class helper function, not a class method
        (see declaration in ESMC\_Grid.h)
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI::Grid::create] {ESMCI::Grid::create - Create a new Grid}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Grid* Grid::create1peridim(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       pointer to newly allocated ESMCI::Grid object\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     ESMC_InterArrayInt *maxIndex, 
     ESMC_InterArrayInt *polekindflag,
     int *periodicDim,
     int *poleDim,
     ESMC_CoordSys_Flag *coordSys,
     ESMC_TypeKind_Flag *coordTypeKind,
     ESMC_IndexFlag *indexflag,
     int *rc) {           // out - return code\end{verbatim}
{\sf DESCRIPTION:\\ }


        Create a new Grid.
  
        Note: this is a class helper function, not a class method
        (see declaration in ESMC\_Grid.h)
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI::Grid::createcubedsphere] {ESMCI::Grid::createcubedsphere - Create a new cubed sphere Grid}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Grid* Grid::createcubedsphere(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       pointer to newly allocated ESMCI::Grid object\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     int *tilesize,
     ESMC_InterArrayInt *regDecompPTile,
     ESMC_InterArrayInt *decompFlagPTile,
     ESMC_InterArrayInt *deLabelList,
     //ESMC_DELayout *delayout,
     ESMC_InterArrayInt *staggerLocList,
     const char *name,
     int *rc) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Create a new Grid.
  
        Note: this is a class helper function, not a class method
        (see declaration in ESMC\_Grid.h)
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI::Grid::createfromfile] {ESMCI::Grid::createfromfile - Create a new Grid from file}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       Grid* Grid::createfromfile(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       pointer to newly allocated ESMCI::Grid object\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     const char *filename,
     int fileTypeFlag,
     int *regDecomp,
     int *decompflag,
     int *isSphere,
     ESMC_InterArrayInt *polekindflag,
     int *addCornerStagger,
     int *addUserArea,
     ESMC_IndexFlag *indexflag,
     int *addMask,
     const char *varname,
     const char **coordNames,
     int *rc) {           // out - return code\end{verbatim}
{\sf DESCRIPTION:\\ }


        Create a new Grid from NetCDF file.
  
        Note: this is a class helper function, not a class method
        (see declaration in ESMC\_Grid.h)
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMCI::Grid::write] {ESMCI::Grid::write - Write a grid in vtk format}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int Grid::write(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       return value\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     ESMC_StaggerLoc staggerloc,
     const char *fname) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Write a Grid
  
        Note: this is a class helper function, not a class method
        (see declaration in ESMC\_Grid.h)
  
        Note2:  this code is duplicated in ESMCI_GridUtil_F.C in gridio
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [addCoordArray] {addCoordArray}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::addCoordArray(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     Return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                           int *staggerlocArg,             // (in) optional
                           InterArray<int> *staggerEdgeLWidthArg, // (in) optional
                           InterArray<int> *staggerEdgeUWidthArg, // (in) optional
                           InterArray<int> *staggerAlignArg,   // (in) optional 
                           InterArray<int> *staggerMemLBoundArg   // (in) optional 
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


     Create the storage (ESMF Array objects) to hold the coordinates for a
   stagger location. Note that this subroutine creates an Array for each 
   coordinate component in the stagger location. The Arrays are, of course,
   created with the correct size and shape to hold the coordinates.  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [addCoordArrayArb] {addCoordArrayArb}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::addCoordArrayArb(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     Return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                           int *staggerlocArg             // (in) optional
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


     Create the storage (ESMF Array objects) to hold the coordinates for a
   stagger location for an arbitrarily distributed grid. Only STAGGER_CENTER is
   supported. Note that this subroutine creates an Array for each 
   coordinate component in the stagger location. The Coordinate Arrays are
   always 1D arrays regardless the dimension of the grid. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [addCoordFromArrayList] {addCoordFromArrayList}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::addCoordFromArrayList(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     Return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                         int *staggerlocArg,        // (in) optional
                         int arrayCount,             // (in) 
                         Array **arrayList,           // (in)
                         CopyFlag *docopyArg,   // (in) optional
                         InterArray<int> *staggerEdgeLWidthArg, // (in) optional
                         InterArray<int> *staggerEdgeUWidthArg, // (in) optional
                         InterArray<int> *staggerAlignArg   // (in) optional 
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set {\tt arrayArg} as the coordinate Array for stagger location 
   {\tt staggerlocArg} and coordinate component {\tt coordArg}. Use either
   a copy or a direct reference depending on the value of {\tt docopyArg}. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [addItemArray] {addItemArray}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::addItemArray(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     Return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                           int *staggerlocArg,             // (in) optional
                           int *itemArg,
               ESMC_TypeKind_Flag *typekindArg,          
                           InterArray<int> *staggerEdgeLWidthArg, // (in) optional
                           InterArray<int> *staggerEdgeUWidthArg, // (in) optional
                           InterArray<int> *staggerAlignArg,   // (in) optional 
                           InterArray<int> *staggerMemLBoundArg   // (in) optional 
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


     Create the storage (ESMF Array objects) to hold the item for a
   stagger location.  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [addItemArrayArb] {addItemArrayArb}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::addItemArrayArb(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     Return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                           int *staggerlocArg,             // (in) optional
               int *itemArg,                   // (in) required
               ESMC_TypeKind_Flag *typekindArg     // (in) optional          
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


     Create the storage (ESMF Array objects) to hold the item for a
   stagger location.  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [commit] {commit}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::commit(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     Error code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     This call is the final step of the create empty/set/commit incremental
   method for creating a Grid. The \gridArg parameter passed in here should
   have been created with create(rc), then filled with information using set 
   set().
   After this call the grid object will be usable in other methods, but may
   no longer be the subject of set(). 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [create] {create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Grid *Grid::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Grid * to newly allocated ESMC_Grid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int nameLenArg,                           // (in) 
   char *nameArg,                            // (in) optional
   ESMC_TypeKind_Flag *typekindArg,               // (in) optional
   DistGrid *distgridArg,                    // (in) optional
   InterArray<int> *gridEdgeLWidthArg,           // (in) optional
   InterArray<int> *gridEdgeUWidthArg,           // (in) optional
   InterArray<int> *gridAlignArg,                // (in) optional
   InterArray<int> *distgridToGridMapArg,                  // (in) optional
   ESMC_CoordSys_Flag *coordSys, 
   InterArray<int> *coordDimCountArg,               // (in) optional
   InterArray<int> *coordDimMapArg,             // (in) optional
   InterArray<int> *gridMemLBoundArg,          // (in) optional
   ESMC_IndexFlag *indexflagArg,             // (in) optional
   bool *destroyDistgridArg,
   bool *destroyDELayoutArg,
   int *rcArg,                                // (out) return code optional
   VM *vm                                     // (in)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Create an {\tt ESMC\gridArg} object from a DistGrid. This method sets up
    the internal structures of the Grid. After calling this create the 
    returned Grid object may be used in most other Grid methods.  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [create] {create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Grid *Grid::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Grid * to newly allocated ESMC_Grid \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int nameLenArg,                           // (in) 
   char *nameArg,                            // (in) optional
   ESMC_TypeKind_Flag *typekindArg,               // (in) optional
   DistGrid *distgridArg,                    // (in) optional
   InterArray<int> *minIndexArg,                // (in) optional
   InterArray<int> *maxIndexArg,                // (in)
   InterArray<int> *localArbIndexArg,            // (in)
   int  localArbIndexCount,                          // (in)
   InterArray<int> *distDimArg,                 // (in) 
   int  arbDim,                              // (in)
   ESMC_CoordSys_Flag *coordSys, 
   InterArray<int> *coordDimCountArg,               // (in) optional
   InterArray<int> *coordDimMapArg,             // (in) optional
   bool *destroyDistgridArg,
   bool *destroyDELayoutArg,
   int *rcArg                                // (out) return code optional
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Create an {\tt ESMC\gridArg} object from a DistGrid. This method sets up
    the internal structures of the Grid. After calling this create the 
    returned Grid object may be used in most other Grid methods.  This is an
    overloaded function for an arbitrarily distributed grid.  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [create] {create empty}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Grid *Grid::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Grid * to newly allocated ESMC_Grid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                    int *rcArg  // (out) optional return code 
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Create an empty {\tt ESMC\_Grid} object. The returned Grid object may
   only be used with set and commit. To make this object usable employ
   {\tt set} to fill the object with parameters and then {\tt commit} to
   construct a usable Grid based on those parameters.  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [destroy] {destroy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::destroy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Grid **gridArg,               // in - Grid to destroy
   bool noGarbage){              // in - remove from garbage collection\end{verbatim}
{\sf DESCRIPTION:\\ }


   Deallocate a Grid's internal memory and then deallocate the Grid object 
   itself. The grid parameter is set to ESMC_NULL_POINTER. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [gridCoordArray] {gridCoordArray}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Array *Grid::getCoordArray(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     The requested array\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                         int *staggerlocArg,        // (in) optional
                         int coordArg,              // (in) base-1
                         CopyFlag *docopyArg,  // (in) optional
                         int *rcArg                 // (out) optional return code 
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the Array object holding the coordinates values for stagger location
      {\tt staggerloc} and coordinate component {\tt coord} (coord is 1 based). 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [gridItemArray] {gridItemArray}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Array *Grid::getItemArray(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     The requested array\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                         int *staggerlocArg,        // (in) optional
                         int *itemArg,              // (in) required
                         CopyFlag *docopyArg,  // (in) optional
                         int *rcArg                 // (out) optional return code 
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get the Array object holding the coordinates values for stagger location
      {\tt staggerloc}. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getExclusiveLBound()"] {Grid::getExclusiveLBound()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::getExclusiveLBound(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  int staggerlocArg, //(in)
                                  int localDEArg,     // (in)
                                  int *lBndArg      // (out) needs to be of size > distDimCount
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    The exclusive lower bound for this localde.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getExclusiveUBound()"] {Grid::getExclusiveUBound()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::getExclusiveUBound(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  int staggerlocArg, //(in)
                                  int localDEArg,     // (in)
                                  int *uBndArg      // (out) needs to be of size > distDimCount
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    The computational lower bound for this localde.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getDistExclusiveLBound()"] {Grid::getDistExclusiveLBound()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::getDistExclusiveLBound(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int localDEArg,     // (in)
   int *lBndArg      // (out) needs to be of size > distDimCount
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    The exclusive lower bound for this localde.
   TODO: eventually this should return all the grid bounds, not just
         the distributed ones.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getDistExclusiveUBound()"] {Grid::getDistExclusiveUBound()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::getDistExclusiveUBound(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int localDEArg,     // (in)
   int *uBndArg      // (out) needs to be of size > distDimCount
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    The exclusive upper bound for this localde
   TODO: eventually this should return all the grid bounds, not just
         the distributed ones.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getCoordInternal()"] {Grid::getCoordInternal()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}  template <class TYPE>
 void Grid::getCoordInternal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  int staggerloc, // (in)
                                  int localDE,    // (in)
                                  int *index,     // (in)  needs to be of size Grid dimCount
                                  TYPE *coord     // (out) needs to be of size Grid dimCount
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


  
     WARNING: NO ERROR CHECKING OR TYPE CONVERSION MAKE SURE THIS IS BEING DONE IN CALLING ROUTINE
   
    Get coordinates from an index tuple. For efficiency reasons this version doesn't do error checking or
    type conversion for a public version with error checking see  Grid::getCoord().  
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getCoordInternalConvert()"] {Grid::getCoordInternalConvert()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 int Grid::getCoordInternalConvert(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  int staggerloc, // (in)
                                  int localDE,    // (in)
                                  int *index,     // (in)  needs to be of size Grid dimCount
                                  TYPE *coord     // (out) needs to be of size Grid dimCount
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


  
    WARNING: NO ERROR CHECKING EXCEPT FOR TYPEKIND, MAKE SURE OTHER CHECKING IS BEING DONE IN CALLING ROUTINE
  
    Get coordinates from an index tuple. For efficiency reasons this version doesn't do error checking, except
    on the typekind. For a public version with full error checking see  Grid::getCoord(). 
    However, this version does convert types of the coordinates if necessary
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getCoord()"] {Grid::getCoord()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 int Grid::getCoord(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code
     \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  int staggerloc, // (in)
                                  int localDE,    // (in)
                                  int *index,     // (in)  needs to be of size Grid dimCount
                                  TYPE *coord     // (out) needs to be of size Grid dimCount
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Get coordinates from an index tuple. For efficiency reasons this version doesn't do error checking
    for a public version with error checking see  Grid::getCoord().  
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getItemInternal()"] {Grid::getItemInternal()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 void Grid::getItemInternal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}  //   void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  int staggerloc, // (in)
                                  int item,       // (in)
                                  int localDE,    // (in)
                                  int *index,     // (in)  needs to be of size Grid dimCount
                                  TYPE *value     // (out) needs to just be a single value
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
    WARNING: NO ERROR CHECKING OR TYPE CONVERSION MAKE SURE THAT THIS IS BEING DONE IN CALLING ROUTINE 
  
    Get item value from an index tuple. For efficiency reasons this version doesn't do error checking
    for a public version with error checking see  Grid::getItem().  
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getItemInternalConvert()"] {Grid::getItemInternalConvert()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 int Grid::getItemInternalConvert(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  int staggerloc, // (in)
                                  int item,       // (in)
                                  int localDE,    // (in)
                                  int *index,     // (in)  needs to be of size Grid dimCount
                                  TYPE *value     // (out) needs to be just a single value
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


  
    WARNING: NO ERROR CHECKING MAKE SURE THIS IS BEING DONE IN CALLING ROUTINE
  
    Get coordinates from an index tuple. For efficiency reasons this version doesn't do error checking
    for a public version with error checking see  Grid::getCoord(). However, this version does convert
    types of the coordinates if necessary
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getItem()"] {Grid::getItem()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 int Grid::getItem(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code
  //   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  int staggerloc, // (in)
                                  int item,       // (in)
                                  int localDE,    // (in)
                                  int *index,     // (in)  needs to be of size Grid dimCount
                                  TYPE *value     // (out) needs to be only 1 value
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Get item value from an index tuple. For efficiency reasons this version doesn't do error checking
    for a public version with error checking see  Grid::getItem().  
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::convertIndex()] {Grid::convertIndex()}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::convertIndex(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return the 1D index of the distgrid for a nD arbitrary grid index
     \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  int *index   // (in)
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    convert the grid index into the 1D index of the associated grid, for arbitrary 
    grid only.  If the index is not found in the local DE, return ERROR
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::hasCoordStaggerLoc()] {Grid::hasCoordStaggerLoc()}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool Grid::hasCoordStaggerLoc(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     true if staggerloc is allocated in the Grid
     \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  int staggerloc // (in)
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Used to detect if staggerloc has been allocated in the Grid.
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::hasItemStaggerLoc()] {Grid::hasItemStaggerLoc()}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool Grid::hasItemStaggerLoc(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     true if staggerloc has a item allocated in the Grid
     \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  int staggerloc,  // (in)
                                  int item         // (in)
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Used to detect if staggerloc has been allocated in the Grid.
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getLDEStaggerLOffset()"] {Grid::getLDEStaggerLOffset()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::getLDEStaggerLOffset(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int staggerlocArg,  // (in)
   int localDEArg,     // (in)
   int *LWidthArg      // (out) needs to be of the same size as the grid dimCount
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Returns the amount the lower end of the exclusive region of
     this local DE should be shifted upward
     to match the lower side of the computational region for this stagger location.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getLDEStaggerUOffset()"] {Grid::getLDEStaggerUOffset()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::getLDEStaggerUOffset(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int staggerlocArg, // (in)
   int localDEArg,    // (in)
   int *UWidthArg     // (out) needs to be of the same size as the grid dimCount
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Returns the amount the Upper end of the exclusive region of
     this local DE should be shifted downward
     to get to the upper side of the computational region for this stagger location.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [set] {set}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::set(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     Error code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int nameLenArg,                // (in) optional
   char *nameArg,                 // (in) optional
   ESMC_TypeKind_Flag *typekindArg,    // (in) optional
   DistGrid *distgridArg,         // (in) optional
   InterArray<int> *gridEdgeLWidthArg,  // (in) optional
   InterArray<int> *gridEdgeUWidthArg,  // (in) optional
   InterArray<int> *gridAlignArg,       // (in) optional
   InterArray<int> *distgridToGridMapArg,       // (in) optional
   InterArray<int> *distDimArg,          // (in) optional
   InterArray<int> *minIndexArg,           // (int) optional
   InterArray<int> *maxIndexArg,           // (int) optional
   InterArray<int> *localArbIndexArg,           // (int) optional
   int  *localArbIndexCountArg,                    // (int) optional
   ESMC_CoordSys_Flag *coordSysArg, 
   InterArray<int> *coordDimCountArg,    // (in) optional
   InterArray<int> *coordDimMapArg,  // (in) optional
   InterArray<int> *gridMemLBoundArg,          // (in)
   ESMC_IndexFlag *indexflagArg,   // (in) optional
   bool *destroyDistgridArg,
   bool *destroyDELayoutArg
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     As the second part of the create empty/set/commit incremental grid 
    creation paradigm, this subroutine is used to set values in a Grid in
    preparation for  a later commit. This method may be called multiple times 
    to set different sets of parameters. If the same parameter is set twice,
    the second value overwrites the first. 
     
     TODO: eventually separate this into a bunch of separate sets to allow 
           easier access from C. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [setCoordArray] {setCoordArray}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::setCoordArray(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     Return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                         int *staggerlocArg,        // (in) optional
                         int *coordArg,             // (in) 
                         Array *arrayArg,           // (in)
                         CopyFlag *docopyArg   // (in) optional
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set {\tt arrayArg} as the coordinate Array for stagger location 
   {\tt staggerlocArg} and coordinate component {\tt coordArg}. Use either
   a copy or a direct reference depending on the value of {\tt docopyArg}. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [setItemArray] {setItemArray}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::setItemArray(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     Return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                         int *staggerlocArg,        // (in) optional
                         int *itemArg,              // (in)
                         Array *arrayArg,           // (in)
                         CopyFlag *docopyArg   // (in) optional
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set {\tt arrayArg} as the item Array for stagger location 
   {\tt staggerlocArg} and coordinate component {\tt coordArg}. Use either
   a copy or a direct reference depending on the value of {\tt docopyArg}. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [addProtoGrid] {addProtoGrid}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::addProtoGrid(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      error code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Adds a protogrid to a grid. The protogrid is to hold data for the 
   set/commit paradigm
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [constructInternal] {constructInternal}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::constructInternal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      error code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char *nameArg,                          // (in)
   ESMC_TypeKind_Flag typekindArg,              // (in)
   DistGrid *distgridArg,                  // (in)
   int distDimCountArg,                    // (in)
   int *distgridToGridMapArg,              // (in)
   int undistDimCountArg,                  // (in)
   int *undistLBoundArg,                   // (in)
   int *undistUBoundArg,                   // (in)
   int dimCountArg,                        // (in)
   int *gridEdgeLWidthArg,                 // (in)
   int *gridEdgeUWidthArg,                 // (in)
   int *gridAlignArg,                      // (in)
   ESMC_CoordSys_Flag coordSysArg, 
   int *coordDimCountArg,                  // (in)
   int **coordDimMapArg,                   // (in)
   int *gridMemLBoundArg,                  // (in)
   ESMC_IndexFlag indexflagArg,            // (in)
   int *minIndexArg,                       // (in)
   int *maxIndexArg,                       // (in)
   int **localArbIndexArg,                  // (in)
   int localArbIndexCountArg,                      // (in)
   int arbDimArg,                          // (in)
   bool destroyDistgridArg, 
   bool destroyDELayoutArg 
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Construct the internal information structure of an ESMC\_Grid object.
    No error checking wrt consistency of input arguments is needed because
    constructInternal() is only to be called by construct() interfaces which
    are responsible for providing consistent arguments to this layer.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [delProtoGrid] {delProtoGrid}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::delProtoGrid(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      error code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Removes a protogrid from a grid. The protogrid is used to record
     values for the incremental grid creation paradigm 
     (create empty/set/commit).
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getCoordArrayInternal] {Grid::getCoordArrayInternal}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::getCoordArrayInternal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int staggerlocArg, // (in)
   int coordArg,      // (in)
   Array **arrayArg   // (out)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Get a coordinate array from the grid structure
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getItemArrayInternal] {Grid::getItemArrayInternal}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::getItemArrayInternal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int staggerlocArg, // (in)
   int itemArg,       // (in)
   Array **arrayArg   // (out)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Get a item array from the grid structure
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridConstruct] {GridConstruct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Grid::Grid(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Pointer to a new grid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    none
   VM *vm):ESMC_Base(vm){  // allow specific VM instead default\end{verbatim}
{\sf DESCRIPTION:\\ }


      Because of the possible use of incremental create this just
      sets default values, the real construction of the internal
      grid structures is done in constructInternal.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridConstruct] {GridConstruct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} Grid::Grid(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Pointer to a new grid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int baseID
   ):ESMC_Base(baseID){  // prevent baseID counter increment\end{verbatim}
{\sf DESCRIPTION:\\ }


      Because of the possible use of incremental create this just
      sets default values, the real construction of the internal
      grid structures is done in constructInternal.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Grid::destruct] {ESMCI::Grid::destruct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void Grid::destruct(bool followCreator, bool noGarbage){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   none\end{verbatim}
{\sf DESCRIPTION:\\ }


      Destruct Grid, deallocates all internal memory, etc. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ProtoGridConstruct] {ProtoGridConstruct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} ProtoGrid::ProtoGrid(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Pointer to a new proto grid\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    none
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Construct the internal information structure of an ESMC\_ProtoGrid object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [~ProtoGrid] {~ProtoGrid}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}  ProtoGrid::~ProtoGrid(void){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   none\end{verbatim}
{\sf DESCRIPTION:\\ }


    Destructor for ProtoGrid, deallocates all internal memory, etc. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::setCoordArrayInternal] {Grid::setCoordArrayInternal}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::setCoordArrayInternal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int staggerlocArg, // (in)
   int coordArg,      // (in)
   Array *arrayArg,   // (in)
   bool didIAlloc   // (in)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set a coordinate array in the grid structure
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::setItemArrayInternal] {Grid::setItemArrayInternal}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::setItemArrayInternal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int staggerlocArg, // (in)
   int itemArg, // (in)
   Array *arrayArg,   // (in)
   bool didIAlloc   // (in)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Set a item array in the grid structure
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [setStaggerInfo] {setStaggerInfo}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   int Grid::setStaggerInfo(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     Return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                           int staggerloc,             // (in) optional
                           InterArray<int> *staggerEdgeLWidthArg, // (in) optional
                           InterArray<int> *staggerEdgeUWidthArg, // (in) optional
                           InterArray<int> *staggerAlignArg,   // (in) optional 
                           InterArray<int> *staggerMemLBoundArg   // (in) optional 
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


    This call sets the stagger location info based on user input.
    It is an error to change these once the internal distgrid has been set, 
    but this call detects this and  just passes through transparently if the user
    isn't attempting to change anything. This call also error checks the user input. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [getStaggerDistgrid] {getStaggerDistgrid}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::getStaggerDistgrid(
 \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     Return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                           int staggerloc,      // (in) optional
                            DistGrid **distgridArg   // (in) optional 
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


   This call gets the distgrid for a particular staggerloc. If the distgrid hasn't 
   been created yet, this call creates and sets it. This call error checks its input.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Grid::serialize] {ESMCI::Grid::serialize - Turn Grid into a byte stream}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::serialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char *buffer,          // inout - byte stream to fill
   int *length,           // inout - buf length
   int *offset,           // inout - original offset
   const ESMC_AttReconcileFlag &attreconflag, // attreconcile flag
   const ESMC_InquireFlag &inquireflag)       // inquiry flag
 {
                          \end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn info in grid class into a stream of bytes.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Grid::deserialize] {ESMCI::Grid::deserialize - Turn a byte stream into an Grid}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::deserialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char *buffer,          // in - byte stream to read
   int *offset,          // inout - original offset 
   const ESMC_AttReconcileFlag &attreconflag) // attreconcile flag
 {\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn a stream of bytes into an object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [construct] {construct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int construct(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     error code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Grid *gridArg, 
   int nameLenArg,                           // (in)
   char *nameArg,                            // (in) optional
   ESMC_TypeKind_Flag *typekindArg,               // (in) optional
   DistGrid *distgridArg,                    // (in) 
   InterArray<int> *gridEdgeLWidthArg,             // (in) optional
   InterArray<int> *gridEdgeUWidthArg,             // (in) optional
   InterArray<int> *gridAlignArg,             // (in) optional
   InterArray<int> *distgridToGridMapArg,                  // (in) optional
   InterArray<int> *undistLBoundArg,                 // (in) optional
   InterArray<int> *undistUBoundArg,                 // (in) optional
    ESMC_CoordSys_Flag *coordSysArg, 
   InterArray<int> *coordDimCountArg,               // (in) optional
   InterArray<int> *coordDimMapArg,             // (in) optional
   InterArray<int> *gridMemLBoundArg,             // (in) optional
   ESMC_IndexFlag *indexflagArg,              // (in) optional
   bool *destroyDistgridArg,
   bool *destroyDELayoutArg
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Take an existing {\tt ESMCI_Grid} object and setup its internal structure
     so that its usable in other Grid methods. Note that this routine
     does error checking of input parameters and sets a default if an optional
     parameter isn't passed in. (A non-present optional parameters is passed with 
     the value NULL).The consturction routine is for a non-arbitrarily distributed
     grid. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [construct] {construct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int construct(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     error code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Grid *gridArg, 
   int nameLenArg,                           // (in)
   char *nameArg,                            // (in) optional
   ESMC_TypeKind_Flag *typekindArg,               // (in) optional
   DistGrid *distgridArg,                    // (in) 
   InterArray<int> *minIndexArg,               // (in) optional
   InterArray<int> *maxIndexArg,                // (in)  
   InterArray<int> *localArbIndexArg,            // (in)  
   int localArbIndexCountArg,                           // (in)  
   InterArray<int> *distDimArg,                // (in) 
   int arbDimArg,                           // (in)
   InterArray<int> *undistLBoundArg,            // (in) optional
   InterArray<int> *undistUBoundArg,            // (in) optional
   ESMC_CoordSys_Flag *coordSysArg, 
   InterArray<int> *coordDimCountArg,               // (in) optional
   InterArray<int> *coordDimMapArg,             // (in) optional
   InterArray<int> *gridMemLBoundArg,             // (in) optional
   ESMC_IndexFlag *indexflagArg,             // (in) optional
   bool *destroyDistgridArg,
   bool *destroyDELayoutArg
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Take an existing {\tt ESMCI_Grid} object and setup its internal structure
     so that its usable in other Grid methods. Note that this routine
     is the construction routine for a arbitrarily distributed grid 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::setGridDefaultsLUA] {Grid::setGridDefaultsLUA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int setGridDefaultsLUA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                        int dimCount,                // Size of the input arrays
                        InterArray<int> *gridEdgeLWidthIn,  // (in) optional
                        InterArray<int> *gridEdgeUWidthIn,  // (in) optional
                        InterArray<int> *gridAlignIn,   // (in) optional
                        int *gridEdgeLWidthOut,          // (out)
                        int *gridEdgeUWidthOut,          // (out)
                        int *gridAlignOut            // (out)
                        ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     This routine takes in gridEdgeLWidth, gridEdgeUWidth and gridAlignment 
   information provided by the user and sets the output variables appropriately.
   If the user provides a value its used
   (or an error may be generated), otherwise a sensible default is used.
   This logic is encapsulated in one place so it'll be consistent everywhere. 
  
   NOTE: all the input arrays must at least be of size dimCount. (not present, optional,
         InterArrays need not obey this)
     
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::process] {Grid::process}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int setDefaultsLUA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                    int dimCount,                // all of the input arrays must be of at least this size 
                    InterArray<int> *lWidthIn,  // (in) optional
                    InterArray<int> *uWidthIn,  // (in) optional
                    InterArray<int> *alignIn,   // (in) optional
                    int *lWidthDefault,      // (in)
                    int *uWidthDefault,      // (in)
                    int *alignDefault,       // (in)
                    int *lWidthOut,          // (out)
                    int *uWidthOut,          // (out)
                    int *alignOut            // (out)
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     This routine takes in LWidth, UWidth and Alignment information provided by the user
   and sets the output variables appropriately. If the user provides a value its used
   (or an error may be generated), otherwise a (hopefully) sensible default is used.
   This logic is encapsulated in one place so it'll be consistent everywhere. 
  
   NOTE: all the input arrays must at least be of size dimCount. (not present, optional,
         InterArrays need not obey this)
    
   NOTE: This routine only does minimal error checking of the inputs.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getDEBnds] {getDEBnds}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void GridIter::getDEBnds(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    
                          int localDE,
                          int *uBnd,
                          int *lBnd
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Get the bounds for this iterator corresponding to the given localDE. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [setDEBnds] {setDEBnds}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void GridIter::setDEBnds(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    
    int localDE
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Set the bounds in this iterator to the values corresponding to
   this DE. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [advToNonZeroDE()] {advToNonZeroDE()}


  //
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool GridIter::advToNonEmptyDE(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      true - advanced to next DEs
      false - there were no more non-empty DEs\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    
    int *_localDE
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Starting with the current value of localDE advance to the next non-empty one. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridIter] {GridIter Construct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} GridIter::GridIter(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Pointer to a new Grid Iterator\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    
  Grid *gridArg,
  int  staggerlocArg,
  bool cellNodesArg
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [toBeg] {toBeg}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} GridIter *GridIter::toBeg(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      GridIter object\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   //  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Move to beginning of iteration list
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridIter] {GridIter advance}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} GridIter *GridIter::adv(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   //  
 
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Move to next item in grid index list
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridIter] {GridIter }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int GridIter::getGlobalID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      global id\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   return the global identifier of this item
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridIter] {GridIter }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int GridIter::getPoleID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      if this node is next to a pole then return the pole id, otherwise 
    return 0.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      if this node is next to a pole then return the pole id, otherwise 
    return 0.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridIter::getCount] {GridIter::getCount}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int GridIter::getCount(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      the number of nodes in this iterator\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Return the number of nodes in this iterator. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridIter::getDE] {GridIter::getDE}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int GridIter::getDE(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      the DE of the current position\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Return the DE of the current position
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [isLocal] {isLocal }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool GridIter::isLocal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      returns true if current index location is on this processor\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   return true if this item is on this processor
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [isShared] {isShared }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool GridIter::isShared(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      returns true if the current index MAY have a copy on another processor.  
      return false otherwise\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      returns true if current index location MAY  have a ghost copy on another processor 
   due to the overlap of cell nodes. Note, if the iterator is not through cell nodes then
   there isn't an overlap.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getLocalID] {getLocalID}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int GridIter::getLocalID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    local id\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     returns a local ID (an id unique on this processor) for an iteration location. 
     Note that the range of local IDs is not necessarily continuous or contiguous
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getCoord] {getCoord}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 void GridIter::getCoord(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     Coordinate output 
   
                          TYPE *coord // (out) input array needs to be at
                                        // least of size grid dimCount    
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Returns the coordinates for an iteration location. Array should be at least
   be of size Grid dimCount. Converts coords to input typekind.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getCartCoord] {getCartCoord}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 void GridIter::getCartCoord(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     Coordinate output 
   
                         TYPE *coord // (out) input array needs to be at
                                        // least of size grid CartCoordDimCount    
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Returns the cartesian coordinates for an iteration location. Array should be at least
   be of size Grid CartCoordDimCount.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getItem] {getItem}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 void GridIter::getItem(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     Value output 
   
                 int item,     // item type
                TYPE *value // (out) input array needs to be at
                                        // least of the size of 1 item    
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Returns the item value for an iteration location.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getArrayData] {getArrayData}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 void GridIter::getArrayData(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     Data output
   
                              Array *array,
                             TYPE *data // (out) input array needs to be at
                                        // least of size grid dimCount    
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Get data from a passed in Array
   TODO: Need to come up with a way to handle Arrays with more dimensions than the Grid
   TODO: Need error checking!!!!!
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getArrayData] {getArrayData}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 void GridIter::setArrayData(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     Data output
   
                             Array *array,
                             TYPE data 
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Set data to a passed in Array
   TODO: Need to come up with a way to handle Arrays with more dimensions than the Grid
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [moveToLocalID] {moveToLocalID}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} GridIter *GridIter::moveToLocalID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      returns the grid iterator\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     
  int localID){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Move to the position in the iteration list represented by local id
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridIter] {GridIter Destruct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}  GridIter::~GridIter(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  void  
 ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getDEBnds] {getDEBnds}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void GridCellIter::getDEBnds(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    
                           int localDE,
                          int *uBnd,
                          int *lBnd
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Get the bounds for this iterator corresponding to the given localDE. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [setDEBnds] {setDEBnds}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void GridCellIter::setDEBnds(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    
    int localDE
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Set the bounds in this iterator to the values corresponding to
   this DE. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [advToNonZeroDE()] {advToNonZeroDE()}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool GridCellIter::advToNonEmptyDE(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      true - advanced to next DEs
      false - there were no more non-empty DEs\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  //  
    int *_localDE
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Starting with the current value of localDE advance to the next non-empty one. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridCellIter] {GridCellIter Construct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} GridCellIter::GridCellIter(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Pointer to a new Grid Iterator\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    
  Grid *gridArg,
  int  staggerlocArg
 
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [toBeg] {toBeg}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} GridCellIter *GridCellIter::toBeg(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      GridCellIter object\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Move to beginning of iteration list
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridCellIter] {GridCellIter advance}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} GridCellIter *GridCellIter::adv(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}    
 
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Move to next item in grid index list
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridCellIter] {GridCellIter }


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int GridCellIter::getGlobalID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      global id\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   return the global identifier of this item
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridCellIter::getDE] {GridCellIter::getDE}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int GridCellIter::getDE(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}  //    the DE of the current position\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


  // Return the DE of the current position
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridCellIter::getCount] {GridCellIter::getCount}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int GridCellIter::getCount(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      the number of nodes in this iterator\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Return the number of nodes in this iterator. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getLocalID] {getLocalID}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int GridCellIter::getLocalID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    local id\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     none  
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     returns a local ID (an id unique on this processor) for an iteration location. 
     Note that the range of local IDs is not necessarily continuous or contiguous
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getCornersCellNodeLocalID()"] {getCornersCellNodeLocalID()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void GridCellIter::getCornersCellNodeLocalID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                               int *cnrCount,
                                              int *cnrList
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


     Returns the corners of the current Grid Cell. The corners
   are identified by the localID that would be returned by
   a grid cell node iterator on that corner. 
  
   NOTE: cnrList must at least be allocated to size 2^grid rank
         currently this only returns cubes, but may eventually
         return other shapes as more complex grids can be created
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getArrayData] {getArrayData}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 void GridCellIter::setArrayData(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     Data output
   
                             Array *array,
                             TYPE data 
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Set data to a passed in Array
   TODO: Need to come up with a way to handle Arrays with more dimensions than the Grid
  // 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getArrayData] {getArrayData}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 void GridCellIter::getArrayData(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     Data output
  // 
                             Array *array,
                             TYPE *data // (out) input array needs to be at
                                        // least of size grid dimCount    
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Get data from a passed in Array
   TODO: Need to come up with a way to handle Arrays with more dimensions than the Grid
   TODO: Need error checking!!!!!
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [getItem] {getItem}


  //
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 void GridCellIter::getItem(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}    void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     Value output 
   
                 int item,     // item type
                TYPE *value // (out) input array needs to be at
                                        // least of the size of 1 item    
  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Returns the item value for an iteration location.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [moveToLocalID] {moveToLocalID}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}  GridCellIter *GridCellIter::moveToLocalID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      returns the grid iterator\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     
  int localID){\end{verbatim}
{\sf DESCRIPTION:\\ }


   Move to the position in the iteration list represented by local id
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [GridCellIter] {GridCellIter Destruct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} GridCellIter::~GridCellIter(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}  void  
 ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::matchCoordInternal()"] {Grid::matchCoordInternal()"}


  //
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 bool Grid:: matchCoordInternal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                  Grid *grid1,
                  Grid *grid2
                                  ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    This internal function returns true if all of the coords in grid1 and grid2 match. 
   NOTE: This function assumes that other items in the grids (e.g. dimCount) match. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::matchItemInternal()"] {Grid::matchItemInternal()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} template <class TYPE>
 bool Grid:: matchItemInternal(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     void\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     
                               int staggerloc,
                   int item,
                    Grid *grid1,
                    Grid *grid2
                   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    This internal function returns true if all of the elements in item in grid1 and grid2 match. 
   NOTE: This function assumes that other items in the grids (e.g. dimCount) match. 
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::Grid::match] {ESMCI::Grid::match}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool Grid::match(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      bool according to match\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Grid *grid1,                          // in
   Grid *grid2,                          // in
   int *rc                               // (out) return code
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Determine if grid1 and grid2 match.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getDistExclusiveUBound()"] {Grid::getDistExclusiveUBound()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::getDistExclusiveUBound(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  DistGrid *distgridArg, 
                                  int localDEArg,     // (in)
                                  int *uBndArg      // (out) needs to be of size > distDimCount
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    The exclusive upper bound for this localde
   TODO: eventually this should return all the grid bounds, not just
         the distributed ones.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [Grid::getDistExclusiveLBound()"] {Grid::getDistExclusiveLBound()"}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int Grid::getDistExclusiveLBound(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}                                  DistGrid *distgridArg, 
                                  int localDEArg,     // (in)
                                  int *lBndArg      // (out) needs to be of size > distDimCount
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    The exclusive lower bound for this localde.
   TODO: eventually this should return all the grid bounds, not just
         the distributed ones.
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
