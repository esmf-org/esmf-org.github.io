%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_ArrayBundleEx.F90,  Date: Tue May  5 20:59:45 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

   \subsubsection{Creating an ArrayBundle from a list of Arrays}
  
   An ArrayBundle is created from a list of {\tt ESMF\_Array} objects. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &
    regDecomp=(/2,3/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(arrayList(2))
  arrayList(1) = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &
                 rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  arrayList(2) = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &
                 rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Now {\tt arrayList} is used to create an ArrayBundle object. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  arraybundle = ESMF_ArrayBundleCreate(arrayList=arrayList, &
    name="MyArrayBundle", rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Here the temporary {\tt arrayList} can be deallocated. This will not affect
   the ESMF Array objects inside the ArrayBundle. However, the Array objects
   must not be deallocated while the ArrayBundle references them. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  deallocate(arrayList)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \subsubsection{Adding, removing, replacing Arrays in the ArrayBundle}
  
   Individual Arrays can be added using the Fortran array constructor syntax
   {\tt (/ ... /)}. Here an ESMF\_Array is created on the fly and immediately
   added to the ArrayBundle. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayBundleAdd(arraybundle, arrayList=(/ &
    ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, name="AonFly")/), &
    rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Items in the ArrayBundle can be replaced by items with the same name. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArraySpecSet(arrayspec2, typekind=ESMF_TYPEKIND_R4, rank=2, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayBundleReplace(arraybundle, arrayList=(/ &
    ESMF_ArrayCreate(arrayspec=arrayspec2, distgrid=distgrid, name="AonFly")/), &
    rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Items can be removed from the ArrayBundle by providing their name. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayBundleRemove(arraybundle, arrayNameList=(/"AonFly"/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The ArrayBundle AddReplace() method can be used to conveniently add an
   item to the ArrayBundle, or replacing an existing item of the same name. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayBundleAddReplace(arraybundle, arrayList=(/ &
    ESMF_ArrayCreate(arrayspec=arrayspec2, distgrid=distgrid, name="AonFly")/), &
    rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The ArrayBundle object can be printed at any time to list its contents by name. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayBundlePrint(arraybundle, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \subsubsection{Accessing Arrays inside the ArrayBundle}
  
   Individual items in the ArrayBundle can be accessed directly by their
   name. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayBundleGet(arraybundle, arrayName="AonFly", array=arrayOut, &
    rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   A list containing all of the Arrays in the ArrayBundle can also be requested
   in a single call.
   This requires that a large enough list argument is passed into the
   {\tt ESMF\_ArrayBundleGet()} method. The exact number of items in the
   ArrayBundle can be queried using the {\tt arrayCount} argument first. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayBundleGet(arraybundle, arrayCount=arrayCount, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \begin{sloppypar}
   Then use {\tt arrayCount} to correctly allocate the {\tt arrayList}
   variable for a second call to {\tt ESMF\_ArrayBundleGet()}.
   \end{sloppypar} 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(arrayList(arrayCount))
  call ESMF_ArrayBundleGet(arraybundle, arrayList=arrayList, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Now the {\tt arrayList} variable can be used to access the individual Arrays,
   e.g. to print them. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  do i=1, arrayCount
    call ESMF_ArrayPrint(arrayList(i), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  enddo
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \begin{sloppypar}
   By default the {\tt arrayList} returned by {\tt ESMF\_ArrayBundleGet()}
   contains the items in alphabetical order. To instead return the items in the
   same order in which they were added to the ArrayBundle, the
   {\tt itemorderflag} argument is passed with a value of 
   {\tt ESMF\_ITEMORDER\_ADDORDER}.
   
   \end{sloppypar} 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayBundleGet(arraybundle, arrayList=arrayList, &
    itemorderflag=ESMF_ITEMORDER_ADDORDER, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \subsubsection{Destroying an ArrayBundle and its constituents}
   
%/////////////////////////////////////////////////////////////

   Destroying an ArrayBundle does not destroy the Arrays. In fact, it leaves the
   Arrays totally unchanged. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayBundleDestroy(arraybundle, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   The Arrays must be destroyed separately. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayDestroy(arrayList(1), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  call ESMF_ArrayDestroy(arrayList(2), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  deallocate(arrayList)
  
  call ESMF_DistGridDestroy(distgrid, rc=rc)
 
\end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
