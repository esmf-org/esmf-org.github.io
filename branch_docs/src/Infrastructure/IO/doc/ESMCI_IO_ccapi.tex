%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_IO.C,  Date: Tue May  5 20:59:46 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMCI::IO::destruct] {ESMCI::IO::destruct - release IO}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void IO::destruct(void) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which deallocates any space allocated by
        {\tt ESMCI::IO::construct}, or for the object's use.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::IO::create] {ESMCI::IO::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} IO *IO::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      IO * to newly allocated IO\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *rc                                  // (out) return code
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


      Create an empty {\tt IO} object. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [IO::destroy] {IO::destroy - free an IO created with Create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int IO::destroy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   IO **ioclass) {  // (in) - IO to destroy\end{verbatim}
{\sf DESCRIPTION:\\ }


        ESMF routine which destroys an IO object previously allocated
        via an {\tt ESMCI\_IOCreate} routine.  Define for deep classes only.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::read] {IO::read - Read the items in an IO object from a file}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int IO::read(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} 
   const std::string &file,        // (in)    - name of file being read
   ESMC_IOFmt_Flag iofmt,          // (in)    - I/O format flag
   int   *timeslice                // (in)    - timeslice option
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Reads an {\tt ESMC\_IO} object from file
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::read] {IO::read - Read the items in an IO object from an open file}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int IO::read(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} 
   int   *timeslice                // (in)    - timeslice option
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Read the items in an {\tt ESMC\_IO} object from an open file or stream
        controlled by the object's IO_Handler member.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::write] {IO::write - Performs a write on an IO object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int IO::write(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   const std::string &file,        // (in)    - name of file being written
   ESMC_IOFmt_Flag iofmt,          // (in)    - I/O format flag
   bool overwrite,                 // (in)    - overwrite fields if true
   ESMC_FileStatus_Flag status,    // (in)    - file status flag
   int   *timeslice                // (in)    - timeslice option
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Writes an {\tt ESMC\_IO} object to file
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::write] {IO::write - Write the items in an IO object to an open file}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int IO::write(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} 
   int   *timeslice                // (in)    - timeslice option
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Write the items in an {\tt ESMC\_IO} object to an open file or stream
        controlled by the object's IO_Handler member.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::open] {IO::open - Open a file or stream for I/O}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int IO::open(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} 
   const std::string &file,             // (in)  - name of file being read
   ESMC_FileStatus_Flag filestatusflag, // (in)  - file status flag
   ESMC_IOFmt_Flag iofmt,               // (in)  - I/O format flag
   bool overwrite,                      // (in)  - overwrite fields?
   bool readonly                        // (in)  - If false then read/write
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Open a file or stream for I/O. Create a new IO_Handler if necessary
        It is an error if a handler exists with a different I/O format (iofmt)
        It is an error if the IO_Handler is already connected to an open stream
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::flush] {IO::flush - Flush data to an open file or stream}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int IO::flush(void\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       int error return code
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Flush data to an open file or stream
        It is not an error if the file is not open
        It is an error if no IOHandler exists
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::close] {IO::close - Close an open file or stream}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int IO::close(void\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       int error return code
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Close an open file or stream
        It is an error if the file is not open
        It is an error if no IOHandler exists
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::addArray] {IO::addArray - Add an array to the list of I/O objects}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int IO::addArray(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *arr_p  // (in) - The array to add
   ) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Add an array to the list of objects to read or write.
        {\tt arr_p} is required
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::addArray] {IO::addArray - Add an array to the list of I/O objects}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int IO::addArray(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       int error return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   Array *arr_p,                             // (in) - The array to add
   const std::string &variableName,          // (in) - Name to use for array
   Attribute *dimAttPack,                    // (in) - Attribute for dimension names
   Attribute *varAttPack,                    // (in) - Attribute for variable attributes
   Attribute *gblAttPack) {                  // (in) - Attribute for global attributes\end{verbatim}
{\sf DESCRIPTION:\\ }


        Add an array to the list of objects to read or write. The
        {\tt variableName} argument will be used as the field name for
        NetCDF files (or other formats requiring a name).
        {\tt arr_p} is required
        {\tt variableName} is not required (may be NULL), however, this
           may cause an error when I/O is attempted.
        {\tt dimAttPack} optional Attribute package for dimension names
        {\tt varAttPack} optional Attribute package for variable attributes
        {\tt gblAttPack} optional Attribute package for global attributes
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::dimlabel\_get] {IO::dimlabel\_get}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void IO::dimlabel_get (Attribute *dimAttPack, // in - AttPack with potential dimLabel attributes
     std::string labeltype,                    // in - attribute to look for (e.g., gridded or ungridded)
     std::vector<std::string> &dimLabels,      // out - labels found
     int *rc) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Extract dimension labels from an AttPack.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::dimlabel\_merge] {IO::dimlabel\_merge}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void IO::dimlabel_merge (
     std::vector<std::string> &dimLabels,    // inout - labels associated with the Grid on input,
                                             //         merged labels on output
     std::vector<std::string> &ugdimLabels,  // in - labels
     Array *array,                           //
     int *rc) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Merge dimension labels from Grid with ungridded dimension labels.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::redist\_check] {IO::redist\_check}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool IO::redist_check(Array *array_p, int *rc) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Check for any PET that has DE count != 1.  Redist will be required.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::redist\_array] {IO::redist\_array}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void IO::redist_arraycreate1de(Array *src_array_p, Array **dest_array_p, int petCount, int *rc) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Create a dest Array with DE count on each PET = 1, based on src Array.
        Assumes that incoming Array has tileCount==1.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::undist\_check] {IO::undist\_check - check for undistributed dimensions}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} bool IO::undist_check(Array *array_p, int *rc) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Check for presence of undistributed dimensions
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::undist\_arraycreate\_alldist] {IO::undist\_arraycreate\_alldist}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void IO::undist_arraycreate_alldist(Array *src_array_p, Array **dest_array_p, int *rc) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Create a dest Array with all dimensions considered distributed,
        even though some are not.  Data elements are aliased to those in
        the src Array.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [IO::clear] {IO::clear - Clear all objects from this IO's I/O queue}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} void IO::clear(void) {\end{verbatim}
{\sf DESCRIPTION:\\ }


        Clear all objects from this IO's I/O queue (e.g., arrays's, attributes)
        The IO_Handler object belonging to this is not affected
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
