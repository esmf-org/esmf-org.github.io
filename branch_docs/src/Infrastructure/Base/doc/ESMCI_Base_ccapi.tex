%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_Base.C,  Date: Tue May  5 20:59:32 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

  
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Base\_operator=] {ESMC\_Base\_operator= - empty private operator =}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ESMC_Base& ESMC_Base::operator=(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const ESMC_Base&) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Base object.\end{verbatim}
{\sf DESCRIPTION:\\ }


      Empty private operator =.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Base] {ESMC\_Base - empty private copy constructor}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ESMC_Base::ESMC_Base(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const ESMC_Base&) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Base object.\end{verbatim}
{\sf DESCRIPTION:\\ }


      Empty private copy constructor.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseGetClassName] {ESMC\_BaseGetClassName - Get Base class name}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       char *ESMC_Base::ESMC_BaseGetClassName(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       void)  const {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Character pointer to class name.\end{verbatim}
{\sf DESCRIPTION:\\ }


      Accessor method for the class name of the object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseGetF90ClassName] {ESMC\_BaseGetF90ClassName - Get Base class name in Fortran format}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_BaseGetF90ClassName(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      char *name,         // in - Location to copy name into
      int nlen) const {   // in - Maximum length of string buffer\end{verbatim}
{\sf DESCRIPTION:\\ }


       Return a separate copy of the base class name, in Fortran friendly
       format, which means not null terminated, and space filled.
       Will not copy more than {\tt nlen} bytes into {\tt name} string.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseGetID] {ESMC\_BaseGetID - Get Base class unique ID}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_BaseGetID(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       void) const {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Unique object ID.\end{verbatim}
{\sf DESCRIPTION:\\ }


      Returns the unique object ID.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseGetVMId] {ESMC\_BaseGetVMId - Get Base class VMId}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ESMCI::VMId *ESMC_Base::ESMC_BaseGetVMId(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       void) const {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Unique VMId of the context in which this base object was created\end{verbatim}
{\sf DESCRIPTION:\\ }


      Returns the object's VMId.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseSetVMId] {ESMC\_BaseSetVMId - Set Base class VMId}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       void ESMC_Base::ESMC_BaseSetVMId(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       ESMCI::VMId *vmID) {\end{verbatim}
{\sf DESCRIPTION:\\ }


      Set the unique VMId of the context in which this base object was created
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseGetVM] {ESMC\_BaseGetVM - Get Base class VM}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ESMCI::VM *ESMC_Base::ESMC_BaseGetVM(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       void) const {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Unique VM of the context in which this base object was created\end{verbatim}
{\sf DESCRIPTION:\\ }


      Returns the object's VM.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseGetName] {ESMC\_BaseGetName - Get Base object name}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       char *ESMC_Base::ESMC_BaseGetName(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       void) const {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Character pointer to {\tt ESMC\_Base} name.\end{verbatim}
{\sf DESCRIPTION:\\ }


      Accessor method for the {\tt ESMC\_Base} name.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseGetF90Name] {ESMC\_BaseGetF90Name - Get Base object name in Fortran format}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       char *ESMC_Base::ESMC_BaseGetF90Name(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       void) const {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}       Pointer to object name, not null terminated and space filled.\end{verbatim}
{\sf DESCRIPTION:\\ }


       Accessor to base class name returned in Fortran friendly format, which
       means not null terminated, and space filled.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseGetRefCount] {ESMC\_BaseGetRefCount - Get Base class reference count}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_BaseGetRefCount(\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       void) const {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Integer reference count.\end{verbatim}
{\sf DESCRIPTION:\\ }


      Accessor method for base class reference count.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseSetClassName] {ESMC\_BaseSetClassName - Set Base class name}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_BaseSetClassName(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *classname) { // in - context in which name should be unique\end{verbatim}
{\sf DESCRIPTION:\\ }


      Accessor method to set base class name.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseSetF90ClassName] {ESMC\_BaseSetF90ClassName - Set Base class name}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_BaseSetF90ClassName(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *name,// in - contains name to set in fortran format
       int nlen) {      // in - length of the input name buffer\end{verbatim}
{\sf DESCRIPTION:\\ }


      Accessor method to set base class name.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseSetID] {ESMC\_BaseSetID - Set Base class unique ID}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       void ESMC_Base::ESMC_BaseSetID(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int id) {   // in - ID to set\end{verbatim}
{\sf DESCRIPTION:\\ }


       override default ID (see constructor)
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseSetName] {ESMC\_BaseSetName - Set Base class name}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_BaseSetName(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *name,           // in - base name to set
       const char *classname) {    // in - context in which name should be unique\end{verbatim}
{\sf DESCRIPTION:\\ }


       Accessor method for base class name.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseSetF90Name] {ESMC\_BaseSetF90Name - Set Base class name}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_BaseSetF90Name(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *name,// in - class name to set, in fortran format
       int nlen) {      // in - length of class name buffer\end{verbatim}
{\sf DESCRIPTION:\\ }


       Accessor method to set base class name.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_BaseSetRefCount] {ESMC\_BaseSetRefCount - Set Base class reference count}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       void ESMC_Base::ESMC_BaseSetRefCount(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int count) {\end{verbatim}
{\sf DESCRIPTION:\\ }


       Accessor method for reference count.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Deserialize] {ESMC\_Deserialize - Turn a byte stream into an object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_Deserialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       char *buffer,          // in - byte stream to read
       int *offset,           // inout - original offset
       const ESMC_AttReconcileFlag &attreconflag) {  // in - attreconcile flag\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn a stream of bytes into an object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Deserialize] {ESMC\_Deserialize - ID and vmID inquiry of a serialized object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       // static
       int ESMC_Base::ESMC_Deserialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *buffer,   // in - byte stream to read
       const int *offset,    // in - original offset
       int *ID,              // out - Object ID
       ESMCI::VMId *vmID,    // in/out - VMId
       std::string &objname) { // out - base name\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn a stream of bytes into an object.  VMId is assumed to have the
      vmkey array pre-allocated.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Print] {ESMC\_Print - Print contents of a Base object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_Print(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       int level,                    //  in - print level for recursive prints
       const char *options,          //  in - print options
       bool tofile,                  //  in - from file flag
       const char *filename,         //  in - filename
       bool append) const {          //  in - append\end{verbatim}
{\sf DESCRIPTION:\\ }


      Print the contents of an {\tt ESMC\_Base} object.  Expected to be
      called internally from the object-specific print routines.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Print] {ESMC\_Print - Print contents of a Base object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_Print(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *options) const { //  in - print options\end{verbatim}
{\sf DESCRIPTION:\\ }


      Print the contents of an {\tt ESMC\_Base} object.  Expected to be
      called internally from the object-specific print routines.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Read] {ESMC\_Read - Read in contents of a Base object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_Read(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       void) {\end{verbatim}
{\sf DESCRIPTION:\\ }


      Base class provides stubs for optional read/write methods.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Serialize] {ESMC\_Serialize - Turn the object information into a byte stream}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_Serialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       char *buffer,          // inout - byte stream to fill
       int *length,           // inout - buf length; realloc'd here if needed
       int *offset,           // inout - original offset
       const ESMC_AttReconcileFlag &attreconflag,     // in - attreconcile flag
       const ESMC_InquireFlag &inquireflag) const {   // in - inquire flag\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn info in base class into a stream of bytes.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Validate] {ESMC\_Validate - Internal consistency check for Base object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_Validate(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       const char *options) const {    // in - validate options\end{verbatim}
{\sf DESCRIPTION:\\ }


       Validation of the {\tt ESMC\_Base} object.  Expected to be called
       internally from the object-specific validation methods.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMC\_Write] {ESMC\_Write - Write out contents of a Base object}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       int ESMC_Base::ESMC_Write(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      {\tt ESMF\_SUCCESS} or error code on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       void) const {\end{verbatim}
{\sf DESCRIPTION:\\ }


      Base class provides stubs for optional read/write methods.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Base] {ESMC\_Base - native C++ constructor for ESMC\_Base class}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ESMC_Base::ESMC_Base(ESMCI::VM *vmArg) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


     default initialization
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Base] {ESMC\_Base - native C++ constructor for ESMC\_Base class}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ESMC_Base::ESMC_Base(int id) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


     Initialization with a specified id. If id==-1 then this is a proxy member.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_Base] {ESMC\_Base - native C++ constructor for ESMC\_Base class}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ESMC_Base::ESMC_Base(const char *superclass, const char *name, int nattrs,
         ESMCI::VM *vmArg){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


     initialization with known class name, object name, initial number
     of attributes to make space for.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [~ESMC\_Base] {~ESMC\_Base - native C++ destructor for ESMC\_Base class}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ESMC_Base::~ESMC_Base(void) {\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      none\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}      none\end{verbatim}
{\sf DESCRIPTION:\\ }


  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
