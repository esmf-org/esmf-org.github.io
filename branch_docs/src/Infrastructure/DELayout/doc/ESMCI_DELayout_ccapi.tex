%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMCI\_DELayout.C,  Date: Tue May  5 20:59:35 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMCI::DELayout::create] {ESMCI::DELayout::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DELayout *DELayout::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      DELayout * to newly allocated DELayout object.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *petMap,              // (in) pointer to petMap list
   int petMapCount,          // (in) number of element in petMap
   ESMC_Pin_Flag *pinFlag,   // (in) type of resources DEs are pinned to
   VM *vm,                   // (in) VM context
   int *rc){                 // (out) return code\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::create] {ESMCI::DELayout::create}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DELayout *DELayout::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      DELayout * to newly allocated DELayout object.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int *deCountArg,              // (in) number of DEs
   InterArray<int> *deGrouping,  // (in) deGrouping vector
   ESMC_Pin_Flag *pinFlag,       // (in) type of resources DEs are pinned to
   InterArray<int> *petListArg,  // (in) list of PETs to be used in delayout
   VM *vm,                       // (in) VM context
   int *rc){                     // (out) return code\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::create] {ESMCI::DELayout::create - deprecated}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DELayout *DELayout::create(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      DELayout * to newly allocated DELayout object. - deprecated\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VM &vm,                   // reference to ESMCI::VM object
   int *deCountArg,          // number of DEs
   int ndim,                 // number of dimensions
   int *DEtoPET,             // DEtoPET list
   int len,                  // number of DEs in DEtoPET list
   ESMC_Logical *cyclic_opt, // cyclic boundary option
   int *rc){                 // return code\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::destroy] {ESMCI::DELayout::destroy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::destroy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   DELayout **delayout,          // in - DELayout to destroy
   bool noGarbage){              // in - remove from garbage collection\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::construct] {ESMCI::DELayout::construct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::construct(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VM *vmArg,                    // (in) VM context
   ESMC_Pin_Flag *pinFlagArg,    // (in) type of resources DEs are pinned to
   int *petMap,                  // (in) pointer to petMap list
   int petMapCount               // (in) number of element in petMap
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      Construct the internal information structure of an ESMC\_DELayout object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::construct1D] {ESMCI::DELayout::construct1D - deprecated}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::construct1D(VM &vmArg, int deCountArg,
   int *DEtoPET, int len, ESMC_Logical cyclic){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Construct the internal information structure in a new DELayout
       - deprecated
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::constructND] {ESMCI::DELayout::constructND - deprecated}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::constructND(VM &vmArg, int *deCountArg, int nndim,
   int *DEtoPET, int len, ESMC_Logical cyclic){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Construct the internal information structure in a new DELayout
       - deprecated
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::destruct] {ESMCI::DELayout::destruct}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::destruct(){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Destruct the internal information structure of an DELayout object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutFillLocal] {ESMC\_DELayoutFillLocal}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutFillLocal(int mypet){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Fill local part of layout object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::getDEMatchDE] {ESMCI::DELayout::getDEMatchDE}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::getDEMatchDE(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int de,                       // in  - DE id of DE to be queried
   DELayout &layoutMatch,        // in  - layout to match against
   int *deMatchCount,            // out - number of matching DEs in layoutMatch
   int *deMatchList,             // out - list of matching DEs in layoutMatch
   int len_deMatchList           // in  - size of deMatchList
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get information about a DELayout object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::getDEMatchPET] {ESMCI::DELayout::getDEMatchPET}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::getDEMatchPET(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int de,                       // in  - DE id of DE to be matched
   VM &vmMatch,                  // in  - vm to match against
   int *petMatchCount,           // out - number of matching PETs in vmMatch
   int *petMatchList,            // out - list of matching PETs in vmMatch
   int len_petMatchList          // in  - size of petMatchList
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Match de in the current DELayout object against the PETs in the
      provided vmMatch VM. Return number of matched PETs and a list of the
      matching pet id's that operate in the same virtual address space in which
      de lies.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::getDeprecated] {ESMCI::DELayout::getDeprecated}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::getDeprecated(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int  *deCountArg,           // out - Total number of DEs
   int  *ndim,                 // out - Number of dimensions in coordinate tuple
   int  *localDeCountArg,      // out - number of DEs for my PET instance
   int  *localDeToDeMapArg,    // out - list DEs for my PET instance
   int  len_localDeToDeMap,    // in  - number of elements in localDeToDeMapArg
   int *localDe,               // out - local DE id for 1-to-1 layouts
   ESMC_Logical *oneToOneFlag, // out - 1-to-1 layout flag
   ESMC_Logical *logRectFlag,  // out - logical rectangular layout flag
   int  *deCountPerDim,        // out - list of dimension sizes
   int  len_deCountPerDim      // in  - number of elements in deCountPerDim list
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get information about a DELayout object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::getDELocalInfo] {ESMCI::DELayout::getDELocalInfo}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::getDELocalInfo(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int  de,                // in  - DE id of DE to be queried
   int  *DEcoord,          // out - DE's coordinate tuple
   int  len_coord,         // in  - dimensions in DEcoord
   int  *DEcde,            // out - DE's connection table
   int  len_cde,           // in  - dimensions in DEcde
   int  *DEcw,             // out - DE's connection weight table
   int  len_cw,            // in  - dimensions in DEcw
   int  *nDEc,             // out - DE's number of connections
   int  *vas               // out - vas for this DE
   )const{\end{verbatim}
{\sf DESCRIPTION:\\ }


      Get information about a DELayout object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::print] {ESMCI::DELayout::print}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::print()const{\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Print details of DELayout object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::validate] {ESMCI::DELayout::validate}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::validate()const{\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Validate details of DELayout object
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::serialize] {ESMCI::DELayout::serialize - Turn delayout into a byte stream}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::serialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char *buffer,          // inout - byte stream to fill
   int *length,           // inout - buf length; realloc'd here if needed
   int *offset,           // inout - original offset, updated to point
                          //         to first free byte after current obj info
   ESMC_InquireFlag inquireflag) const { // in - inquiry flag\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn info in delayout class into a stream of bytes.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::deserialize] {ESMCI::DELayout::deserialize - Turn a byte stream into delayout}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} DELayout *DELayout::deserialize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      Pointer to DELayout, NULL on failure.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char *buffer,          // in - byte stream to read
   int *offset) {         // inout - original offset, updated to point
                          // to first free byte after current obj info\end{verbatim}
{\sf DESCRIPTION:\\ }


      Turn a stream of bytes into an object.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::serviceOffer] {ESMCI::DELayout::serviceOffer}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} ServiceReply DELayout::serviceOffer(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      ServiceReply reply to serviceOffer.\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int de,                   // in  - de for which service is offered
   int *rc){                 // out - optional return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Calling PET offers service for {\tt de} in DELayout. The
      offer is either accepted or denied.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::DELayout::serviceComplete] {ESMCI::DELayout::serviceComplete}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::serviceComplete(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int de                    // in  - de for which service is complete
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


      The PET whose serviceOffer() was accepted must call serviceComplete() in
      order to close the service window for this DE.
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutCopy] {ESMC\_DELayoutCopy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutCopy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *srcdata,  // input array
   void *destdata, // output array
   int blen,       // size in bytes that need to be copied from src to dest
   int srcDE,      // input DE
   int destDE      // output DE
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutCopy] {ESMC\_DELayoutCopy}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutCopy(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *srcdata,    // input array
   void *destdata,   // output array
   int len,          // size in elements that need to be copied from src to dest
   ESMC_TypeKind_Flag dtk,// data type kind
   int srcDE,        // input DE
   int destDE        // output DE
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutExchange] {ESMC\_DELayoutExchange}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutExchange(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *srcData1,     // input array
   void *srcData2,     // input array
   void *dstData1,     // output array
   void *dstData2,     // output array
   int blen1,          // size in bytes to copy from srcData1 to dstData2
   int blen2,          // size in bytes to copy from srcData2 to dstData1
   int de1,            // de for data1
   int de2             // de for data2
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutExchange] {ESMC\_DELayoutExchange}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutExchange(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *srcData1,     // input array
   void *srcData2,     // input array
   void *dstData1,     // output array
   void *dstData2,     // output array
   int len1,           // size in elements to copy from srcData1 to dstData2
   int len2,           // size in elements to copy from srcData2 to dstData1
   ESMC_TypeKind_Flag dtk1, // data type kind
   ESMC_TypeKind_Flag dtk2, // data type kind
   int de1,            // de for data1
   int de2             // de for data2
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutBcast] {ESMC\_DELayoutBcast}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutBcast(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *data,     // data
   int blen,       // message size in bytes
   int rootDE      // root DE
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutBcast] {ESMC\_DELayoutBcast}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutBcast(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *data,    // data
   int len,       // message size in elements
   ESMC_TypeKind_Flag dtk,// data type kind
   int rootDE      // root DE
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutScatter] {ESMC\_DELayoutScatter}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutScatter(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *srcdata,  // input array
   void *destdata, // output array
   int blen,       // message size in bytes
   int rootDE      // root DE
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutScatter] {ESMC\_DELayoutScatter}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutScatter(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *srcdata,    // input array
   void *destdata,   // output array
   int len,          // message size in elements
   ESMC_TypeKind_Flag dtk,// data type kind
   int rootDE        // root DE
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutGather] {ESMC\_DELayoutGather}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutGather(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *srcdata,  // input array
   void *destdata, // output array
   int blen,       // message size in bytes
   int rootDE      // root DE
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutGather] {ESMC\_DELayoutGather}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutGather(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *srcdata,    // input array
   void *destdata,   // output array
   int len,          // message size in bytes
   ESMC_TypeKind_Flag dtk,// data type kind
   int rootDE        // root DE
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutGatherV] {ESMC\_DELayoutGatherV}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutGatherV(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *srcdata,  // input array
   void *destdata, // output array
   int *blen,      // array of message sizes in bytes for each DE
                   // - the PET that holds rootDE must provide all blen elementes
                   // - all other PETs only need to fill elements for their DEs
   int *bdestdispl,// displacement vector for destdata for each DE mes. in bytes
   int rootDE      // root DE
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutGatherV] {ESMC\_DELayoutGatherV}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutGatherV(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   void *srcdata,  // input array
   void *destdata, // output array
   int *len,       // array of message sizes in elements for each DE
                   // - the PET that holds rootDE must provide all blen elementes
                   // - all other PETs only need to fill elements for their DEs
   int *destdispl, // displacement vector for destdata for each DE mes. in elem.
   ESMC_TypeKind_Flag dtk,// data type kind
   int rootDE      // root DE
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMC\_DELayoutFindDEtoPET] {ESMC\_DELayoutFindDEtoPET}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int DELayout::ESMC_DELayoutFindDEtoPET(int npets){\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}
{\sf DESCRIPTION:\\ }


      Find best DE-to-PET mapping for the layout
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::exec] {ESMCI::XXE::exec}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::exec(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int rraCount,       // in  - number of relative run-time address in rraList
   char **rraList,     // in  - relative run-time addresses
   int *vectorLength,  // in  - run-time vectorLength
   int filterBitField, // in  - filter operations according to predicateBitField
   bool *finished,     // out - TEST ops executed as per filterBitField are
                       //       finished, or need additional FINISH calls
   bool *cancelled,    // out - indicates whether there are any cancelled ops
   double *dTime,      // out - execution time, NULL to disable
   int indexStart,     // in  - start index, < 0 for default (full stream)
   int indexStop,      // in  - stop index, < 0 for default (full stream)
   int *srcLocalDeCount,   // in  - in order to determine dst index from rraIndex
   SuperVectP *superVectP  // in  - super vector support
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Execute the XXE stream. For performance reasons there is _no_ checking
    during execution to ensure relative run-time addressing (RRA) references
    in the XXE stream are within the rraList bounds, i.e. [0...rraCount-1]. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::print] {ESMCI::XXE::print}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::print(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   FILE *fp,           // in  - file pointer
   int rraCount,       // in  - number of relative run-time address in rraList
   char **rraList,     // in  - relative run-time addresses
   int filterBitField, // in  - filter operations according to predicateBitField
   int indexStart,     // in  - start index, < 0 for default (full stream)
   int indexStop       // in  - stop index, < 0 for default (full stream)
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Print XXE stream content. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::printProfile] {ESMCI::XXE::printProfile}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::printProfile(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   FILE *fp){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Print profile data collected during the XXE opstream execution. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::optimizeElement] {ESMCI::XXE::optimizeElement}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::optimizeElement(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int index){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Optimize element indexed by "index". 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::execReady] {ESMCI::XXE::execReady}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::execReady(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::optimize] {ESMCI::XXE::optimize}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::optimize(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::growStream] {ESMCI::XXE::growStream}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::growStream(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int increase){    // in - number of additional elements\end{verbatim}
{\sf DESCRIPTION:\\ }


    Increase the length of the XXE opstream.
    CAUTION: This method changes the location (in memory) of the entire opstream!
      Previously written opstream elements will be moved to a new location. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::growDataList] {ESMCI::XXE::growDataList}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::growDataList(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int increase){    // in - number of additional elements\end{verbatim}
{\sf DESCRIPTION:\\ }


    Increase the length of the XXE data.
    CAUTION: This method changes the location (in memory) of the entire dataList!
      Previously written dataList elements will be moved to a new location. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::growCommhandle] {ESMCI::XXE::growCommhandle}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::growCommhandle(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int increase){    // in - number of additional elements\end{verbatim}
{\sf DESCRIPTION:\\ }


    Increase the length of the XXE commhandle manager.
    CAUTION: This method changes the location (in memory) of the entire
             commhandle manager!
      Previously written commhandle manager elements will be moved to a new
      location. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::growXxeSub] {ESMCI::XXE::growXxeSub}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::growXxeSub(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int increase){    // in - number of additional elements\end{verbatim}
{\sf DESCRIPTION:\\ }


    Increase the length of the XXE Sub manager.
    CAUTION: This method changes the location (in memory) of the entire
             XXE Sub manager!
      Previously written XXE Sub manager elements will be moved to a new
      location. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::incCount] {ESMCI::XXE::incCount}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::incCount(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Increment the count by one.
    CAUTION: The location (in memory) of the entire opstream may be changed by
             this call! 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::incDataCount] {ESMCI::XXE::incDataCount}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::incDataCount(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Increment the dataCount by one.
    CAUTION: The location (in memory) of the entire dataList may be changed by
             this call! 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::incCommhandleCount] {ESMCI::XXE::incCommhandleCount}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::incCommhandleCount(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Increment the commhandleCount by one.
    CAUTION: The location (in memory) of the entire commhandle manager may be
             changed by this call! 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::incXxeSubCount] {ESMCI::XXE::incXxeSubCount}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::incXxeSubCount(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Increment the xxeSubCount by one.
    CAUTION: The location (in memory) of the entire SSE Sub manager may be
             changed by this call! 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::storeData] {ESMCI::XXE::storeData}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::storeData(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char *dataArg,
   unsigned long size
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append an element at the end of the dataList.
    CAUTION: The location (in memory) of the entire dataList may be changed by
             this call! 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::storeCommhandle] {ESMCI::XXE::storeCommhandle}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::storeCommhandle(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   VMK::commhandle **commhandleArg
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append an element at the end of the commhandle manager.
    CAUTION: The location (in memory) of the entire commhandle manager may be
             changed by this call! 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::storeXxeSub] {ESMCI::XXE::storeXxeSub}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::storeXxeSub(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   XXE *xxe
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append an element at the end of the XXE Sub manager.
    CAUTION: The location (in memory) of the entire XXE Sub manager may be
             changed by this call! 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::storeBufferInfo] {ESMCI::XXE::storeBufferInfo}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::storeBufferInfo(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   char *buffer,
   unsigned long size,
   int vectorLengthMultiplier
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append an element at the end of the buffer info vector. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendXxeSub] {ESMCI::XXE::appendXxeSub}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendXxeSub(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   XXE *xxe,
   int rraShift,
   int vectorLengthShift
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append an xxeSub at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendWtimer] {ESMCI::XXE::appendWtimer}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendWtimer(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   char *string,
   int id,
   int actualId,
   int relativeId,
   XXE *relativeXXE
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a wtimer element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendRecv] {ESMCI::XXE::appendRecv}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendRecv(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   void *buffer,
   int size,
   int srcPet,
   int tag,
   bool vectorFlag,
   bool indirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a recv element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendSend] {ESMCI::XXE::appendSend}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendSend(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   void *buffer,
   int size,
   int dstPet,
   int tag,
   bool vectorFlag,
   bool indirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a send element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendSendRRA] {ESMCI::XXE::appendSendRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendSendRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   int rraOffset,
   int size,
   int dstPet,
   int rraIndex,
   int tag,
   bool vectorFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a sendRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendSendRecv] {ESMCI::XXE::appendSendRecv}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendSendRecv(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   void *srcBuffer,
   void *dstBuffer,
   int srcSize,
   int dstSize,
   int srcPet,
   int dstPet,
   int srcTag,
   int dstTag,
   bool vectorFlag,
   bool srcIndirectionFlag,
   bool dstIndirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a sendrecv element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendSendRRARecv] {ESMCI::XXE::appendSendRRARecv}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendSendRRARecv(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   int rraOffset,
   void *dstBuffer,
   int srcSize,
   int dstSize,
   int srcPet,
   int dstPet,
   int rraIndex,
   int srcTag,
   int dstTag,
   bool vectorFlag,
   bool dstIndirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a sendRRArecv element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendRecvnb] {ESMCI::XXE::appendRecvnb}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendRecvnb(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   void *buffer,
   int size,
   int srcPet,
   int tag,
   bool vectorFlag,
   bool indirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a recvnb element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendSendnb] {ESMCI::XXE::appendSendnb}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendSendnb(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   void *buffer,
   int size,
   int dstPet,
   int tag,
   bool vectorFlag,
   bool indirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a sendnb element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendSendnbRRA] {ESMCI::XXE::appendSendnbRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendSendnbRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   int rraOffset,
   int size,
   int dstPet,
   int rraIndex,
   int tag,
   bool vectorFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a sendnbRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendMemCpySrcRRA] {ESMCI::XXE::appendMemCpySrcRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendMemCpySrcRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   int rraOffset,
   int size,
   void *dstMem,
   int rraIndex
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a memCpySrcRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendMemGatherSrcRRA] {ESMCI::XXE::appendMemGatherSrcRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendMemGatherSrcRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   void *dstBase,
   TKId dstBaseTK,
   int rraIndex,
   int chunkCount,
   bool vectorFlag,
   bool indirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a memGatherSrcRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendZeroScalarRRA] {ESMCI::XXE::appendZeroScalarRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendZeroScalarRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   TKId elementTK,
   int rraOffset,
   int rraIndex
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a zeroScalarRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendZeroSuperScalarRRA] {ESMCI::XXE::appendZeroSuperScalarRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendZeroSuperScalarRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   TKId elementTK,
   int rraIndex,
   int termCount,
   bool vectorFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a zeroSuperScalarRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendZeroMemset] {ESMCI::XXE::appendZeroMemset}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendZeroMemset(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   void *buffer,
   int byteCount,
   bool vectorFlag,
   bool indirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a zeroMemset element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendZeroMemsetRRA] {ESMCI::XXE::appendZeroMemsetRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendZeroMemsetRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   int byteCount,
   int rraIndex,
   bool vectorFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a zeroMemsetRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendProductSumScalarRRA] {ESMCI::XXE::appendProductSumScalarRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendProductSumScalarRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   TKId elementTK,
   TKId valueTK,
   TKId factorTK,
   int rraOffset,
   void *factor,
   void *value,
   int rraIndex
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a productSumScalarRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendSumSuperScalarDstRRA] {ESMCI::XXE::appendSumSuperScalarDstRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendSumSuperScalarDstRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   TKId elementTK,
   TKId valueTK,
   int rraIndex,
   int termCount,
   void *valueBase,
   bool vectorFlag,
   bool indirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a SumSuperScalarDstRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendSumSuperScalarListDstRRA] {ESMCI::XXE::appendSumSuperScalarListDstRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendSumSuperScalarListDstRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   TKId elementTK,
   TKId valueTK,
   std::vector<int> rraIndexList,
   int termCount,
   vector<void *>valueBaseList,
   bool vectorFlag,
   bool indirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a sumSuperScalarListDstRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendProductSumSuperScalarDstRRA] {ESMCI::XXE::appendProductSumSuperScalarDstRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendProductSumSuperScalarDstRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   TKId elementTK,
   TKId valueTK,
   TKId factorTK,
   int rraIndex,
   int termCount,
   void *valueBase,
   bool vectorFlag,
   bool indirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a productSumSuperScalarDstRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendProductSumSuperScalarListDstRRA] {ESMCI::XXE::appendProductSumSuperScalarListDstRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendProductSumSuperScalarListDstRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   TKId elementTK,
   TKId valueTK,
   TKId factorTK,
   std::vector<int> rraIndexList,
   int termCount,
   vector<void *>valueBaseList,
   bool vectorFlag,
   bool indirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a productSumSuperScalarListDstRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendProductSumSuperScalarSrcRRA] {ESMCI::XXE::appendProductSumSuperScalarSrcRRA}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendProductSumSuperScalarSrcRRA(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   TKId elementTK,
   TKId valueTK,
   TKId factorTK,
   int rraIndex,
   int termCount,
   void *elementBase,
   bool vectorFlag,
   bool indirectionFlag
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a productSumSuperScalarSrcRRA element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendWaitOnIndex] {ESMCI::XXE::appendWaitOnIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendWaitOnIndex(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   int index
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a waitOnIndex element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendTestOnIndex] {ESMCI::XXE::appendTestOnIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendTestOnIndex(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   int index
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a testOnIndex element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendWaitOnAnyIndexSub] {ESMCI::XXE::appendWaitOnAnyIndexSub}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendWaitOnAnyIndexSub(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   int countArg
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a waitOnAnyIndexSub element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendWaitOnAllSendnb] {ESMCI::XXE::appendWaitOnAllSendnb}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendWaitOnAllSendnb(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a waitOnAllSendnb element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendWaitOnIndexSub] {ESMCI::XXE::appendWaitOnIndexSub}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendWaitOnIndexSub(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   XXE *xxe,
   int rraShift,
   int vectorLengthShift,
   int index
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append an xxeSub at the end of the XXE opstream that is executed depending
    on test conditional 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendTestOnIndexSub] {ESMCI::XXE::appendTestOnIndexSub}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendTestOnIndexSub(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   XXE *xxe,
   int rraShift,
   int vectorLengthShift,
   int index
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append an xxeSub at the end of the XXE opstream that is executed depending
    on test conditional 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendCancelIndex] {ESMCI::XXE::appendCancelIndex}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendCancelIndex(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   int index
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a cancelIndex element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendProfileMessage] {ESMCI::XXE::appendProfileMessage}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendProfileMessage(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   char *messageString
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a profileMessage element at the end of the XXE opstream. 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\
 
\subsubsection [ESMCI::XXE::appendMessage] {ESMCI::XXE::appendMessage}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim} int XXE::appendMessage(\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}      int return code\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   int predicateBitField,
   char *messageString
   ){\end{verbatim}
{\sf DESCRIPTION:\\ }


    Append a Message element at the end of the XXE opstream.
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
