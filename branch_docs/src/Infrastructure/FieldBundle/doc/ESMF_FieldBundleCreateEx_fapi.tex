%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_FieldBundleCreateEx.F90,  Date: Tue May  5 21:00:04 MDT 2020
}

 
%/////////////////////////////////////////////////////////////

   \subsubsection{Creating a FieldBundle from a list of Fields}
   \label{sec:fieldbundle:usage:create_list}
   A user can create a FieldBundle from a predefined list of Fields. In the following
   example, we first create an {\tt ESMF\_Grid}, then build 3 different {\tt ESMF\_Field}s with 
   different names. The {\tt ESMF\_FieldBundle} is created from the list of 3 Fields.
   
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
!-------------------------------------------------------------------------
!   !  Create several Fields and add them to a new FieldBundle.
 
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/100,200/), &
                                  regDecomp=(/2,2/), name="atmgrid", rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}

    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R8, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    field(1) = ESMF_FieldCreate(grid, arrayspec, &
                                staggerloc=ESMF_STAGGERLOC_CENTER, &
                                name="temperature", rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    field(2) = ESMF_FieldCreate(grid, arrayspec, &
                                staggerloc=ESMF_STAGGERLOC_CENTER, &
                                name="pressure", rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    field(3) = ESMF_FieldCreate(grid, arrayspec, &
                                staggerloc=ESMF_STAGGERLOC_CENTER, &
                                name="heat flux", rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    bundle1 = ESMF_FieldBundleCreate(fieldList=field(1:3), &
                                name="atmosphere data", rc=rc)

    print *, "FieldBundle example 1 returned"
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \subsubsection{Creating an empty FieldBundle then add one Field to it}
   \label{sec:fieldbundle:usage:create_empty}
   A user can create an empty FieldBundle then add Fields to the empty FieldBundle.
   In the following example, we use the previously defined {\tt ESMF\_Grid}
   to build an {\tt ESMF\_Field}.
   An empty {\tt ESMF\_FieldBundle} is created, then the Field is added
   to the FieldBundle. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
!-------------------------------------------------------------------------
!   !  Create an empty FieldBundle and then add a single field to it.


    simplefield = ESMF_FieldCreate(grid, arrayspec, &
                  staggerloc=ESMF_STAGGERLOC_CENTER, name="rh", rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    bundle2 = ESMF_FieldBundleCreate(name="time step 1", rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    call ESMF_FieldBundleAdd(bundle2, (/simplefield/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    call ESMF_FieldBundleGet(bundle2, fieldCount=fieldcount, rc=rc)

    print *, "FieldBundle example 2 returned, fieldcount =", fieldcount
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \subsubsection{Creating an empty FieldBundle then add a list of Fields to it}
   \label{sec:fieldbundle:usage:create_emptylist}
   A user can create an empty FieldBundle then add multiple 
   Fields to the empty FieldBundle.
   In the following example, we use the previously defined {\tt ESMF\_Grid}
   and {\tt ESMF\_Field}s.
   An empty {\tt ESMF\_FieldBundle} is created, then three Fields are added
   to the FieldBundle. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
!-------------------------------------------------------------------------
!   !  Create an empty FieldBundle and then add multiple fields to it.

    bundle3 = ESMF_FieldBundleCreate(name="southern hemisphere", rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    call ESMF_FieldBundleAdd(bundle3, field(1:3), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    call ESMF_FieldBundleGet(bundle3, fieldCount=fieldcount, rc=rc)

    print *, "FieldBundle example 3 returned, fieldcount =", fieldcount
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \subsubsection{Query a Field stored in the FieldBundle by name or index}
   \label{sec:fieldbundle:usage:get}
   Users can query a Field stored in a FieldBundle by the Field's name or index.
   In the following example, the pressure Field stored in FieldBundle
   is queried by its name then by its index through {\tt ESMF\_FieldBundleGet()}
   method. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
!-------------------------------------------------------------------------
!   !  Get a Field back from a FieldBundle, first by name and then by index.
!   !  Also get the FieldBundle name.

    call ESMF_FieldBundleGet(bundle1, "pressure", field=returnedfield1, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    call ESMF_FieldGet(returnedfield1, name=fname1, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    call ESMF_FieldBundleGet(bundle1, 2, returnedfield2, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    call ESMF_FieldGet(returnedfield2, name=fname2, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    call ESMF_FieldBundleGet(bundle1, name=bname1, rc=rc)

    print *, "FieldBundle example 4 returned, field names = ", &
                   trim(fname1), ", ", trim(fname2)
    print *, "FieldBundle name = ", trim(bname1)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \subsubsection{Query FieldBundle for Fields list either alphabetical or in order of addition}
   \label{sec:fieldbundle:usage:getlist}
   Users can query the list of Fields stored in a FieldBundle.
   By default the returned list of Fields are ordered alphabetically by
   the Field names. Users can also retrieve the list of Fields in the order by which
   the Fields were added to the FieldBundle. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    call ESMF_FieldBundleGet(bundle1, fieldList=r_fields, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    do i = 1, 3
      call ESMF_FieldGet(r_fields(i), name=fname1, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
      print *, fname1
    enddo
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    call ESMF_FieldBundleGet(bundle1, fieldList=r_fields, &
      itemorderflag=ESMF_ITEMORDER_ADDORDER, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    do i = 1, 3
      call ESMF_FieldGet(r_fields(i), name=fname1, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
      print *, fname1
    enddo
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \subsubsection{Create a packed FieldBundle on a Grid}
   \label{sec:fieldbundle:usage:packedFBGrid}
   Create a packed fieldbundle from user supplied 
   field names and a packed Fortran array pointer that contains
   the data of the packed fields on a Grid.  
%/////////////////////////////////////////////////////////////

   Create a 2D grid of 4x1 regular decomposition on 4 PETs, each PET has 10x50 elements.
   The index space of the entire Grid is 40x50. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  gridxy = ESMF_GridCreateNoPeriDim(maxIndex=(/40,50/), regDecomp=(/4,1/), rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   Allocate a packed Fortran array pointer containing 10 packed fields, each field has
   3 time slices and uses the 2D grid created. Note that gridToFieldMap uses the position
   of the grid dimension as elements, 3rd element of the packedPtr is 10, 4th element
   of the packedPtr is 50. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
  allocate(packedPtr(10, 3, 10, 50)) ! fieldDim, time, y, x
  fieldDim = 1
  packedFB = ESMF_FieldBundleCreate(fieldNameList, packedPtr, gridxy, fieldDim, &
  gridToFieldMap=(/3,4/), staggerloc=ESMF_Staggerloc_Center, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

   \subsubsection{Create a packed FieldBundle on a Mesh}
   \label{sec:fieldbundle:usage:packedFBMesh}
   Similarly we could create a packed fieldbundle from user supplied 
   field names and a packed Fortran array pointer that contains
   the data of the packed fields on a Mesh. 
   
   Due to the verbosity of the MeshCreate process, the code for MeshCreate is
   not shown below, user can either refer to the MeshCreate section
   \ref{sec:mesh:usage:meshCreation}
   or examine the FieldBundleCreate example source code contained
   in the ESMF source distribution directly.
   A ESMF Mesh on 4 PETs with one mesh element on each PET is created. 
%/////////////////////////////////////////////////////////////

   Allocate the packed Fortran array pointer, the first dimension
   is fieldDim; second dimension is the data associated with mesh element,
   since there is only one mesh element on each processor in this example,
   the allocation is 1; last dimension is the time dimension which contains
   3 time slices. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
      allocate(packedPtr3D(10, 1, 3))
      fieldDim = 1
      packedFB = ESMF_FieldBundleCreate(fieldNameList, packedPtr3D, meshEx, fieldDim, &
        gridToFieldMap=(/2/), meshloc=ESMF_MESHLOC_ELEMENT, rc=rc)
 
\end{verbatim}
 
%/////////////////////////////////////////////////////////////

  \subsubsection{Destroy a FieldBundle}
  
  The user must call {\tt ESMF\_FieldBundleDestroy()} before 
  deleting any of the Fields it contains.  Because Fields
  can be shared by multiple FieldBundles and States, they are
  not deleted by this call. 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
!-------------------------------------------------------------------------

     call ESMF_FieldBundleDestroy(bundle1, rc=rc)
 
\end{verbatim}

%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
