%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.1
% Any changes made to this file will likely be lost next time
% this file is regenerated from its source. Send questions 
% to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\setlength{\oldparskip}{\parskip}
\setlength{\parskip}{1.5ex}
\setlength{\oldparindent}{\parindent}
\setlength{\parindent}{0pt}
\setlength{\oldbaselineskip}{\baselineskip}
\setlength{\baselineskip}{11pt}
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------

\markboth{Left}{Source File: ESMF\_FieldBundle.F90,  Date: Tue May  5 21:00:03 MDT 2020
}

 
%/////////////////////////////////////////////////////////////
\subsubsection [ESMF\_FieldBundleAssignment(=)] {ESMF\_FieldBundleAssignment(=) - FieldBundle assignment}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface assignment(=)
   fieldbundle1 = fieldbundle2\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_FieldBundle) :: fieldbundle1
   type(ESMF_FieldBundle) :: fieldbundle2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Assign fieldbundle1 as an alias to the same ESMF fieldbundle object in memory
   as fieldbundle2. If fieldbundle2 is invalid, then fieldbundle1 will be equally invalid after
   the assignment.
  
   The arguments are:
   \begin{description}
   \item[fieldbundle1]
   The {\tt ESMF\_FieldBundle} object on the left hand side of the assignment.
   \item[fieldbundle2]
   The {\tt ESMF\_FieldBundle} object on the right hand side of the assignment.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleOperator(==)] {ESMF\_FieldBundleOperator(==) - FieldBundle equality operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(==)
   if (fieldbundle1 == fieldbundle2) then ... endif
   OR
   result = (fieldbundle1 == fieldbundle2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_FieldBundle), intent(in) :: fieldbundle1
   type(ESMF_FieldBundle), intent(in) :: fieldbundle2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   \begin{sloppypar}
   Test whether fieldbundle1 and fieldbundle2 are valid aliases to the same ESMF
   fieldbundle object in memory. For a more general comparison of two ESMF FieldBundles,
   going beyond the simple alias test, the ESMF\_FieldBundleMatch() function (not yet
   implemented) must be used.
   \end{sloppypar}
  
   The arguments are:
   \begin{description}
   \item[fieldbundle1]
   The {\tt ESMF\_FieldBundle} object on the left hand side of the equality
   operation.
   \item[fieldbundle2]
   The {\tt ESMF\_FieldBundle} object on the right hand side of the equality
   operation.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleOperator(/=)] {ESMF\_FieldBundleOperator(/=) - FieldBundle not equal operator}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   interface operator(/=)
   if (fieldbundle1 /= fieldbundle2) then ... endif
   OR
   result = (fieldbundle1 /= fieldbundle2)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   logical :: result\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_FieldBundle), intent(in) :: fieldbundle1
   type(ESMF_FieldBundle), intent(in) :: fieldbundle2\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   \begin{sloppypar}
   Test whether fieldbundle1 and fieldbundle2 are {\it not} valid aliases to the
   same ESMF fieldbundle object in memory. For a more general comparison of two ESMF
   FieldBundles, going beyond the simple alias test, the ESMF\_FieldBundleMatch() function
   (not yet implemented) must be used.
   \end{sloppypar}
  
   The arguments are:
   \begin{description}
   \item[fieldbundle1]
   The {\tt ESMF\_FieldBundle} object on the left hand side of the non-equality
   operation.
   \item[fieldbundle2]
   The {\tt ESMF\_FieldBundle} object on the right hand side of the non-equality
   operation.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleAdd] {ESMF\_FieldBundleAdd - Add Fields to a FieldBundle}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     ! Private name; call using ESMF_FieldBundleAdd()
     subroutine ESMF_FieldBundleAddList(fieldbundle, fieldList, &
       multiflag, relaxedflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     type(ESMF_Field), intent(in) :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: multiflag
     logical, intent(in), optional :: relaxedflag
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Add Field(s) to a FieldBundle. It is an error if {\tt fieldList} contains
   Fields that match by name Fields already contained in
   {\tt fieldbundle} when multiflag
   is set to {\tt .false.} and relaxedflag is set to {\tt .false.}.
  
   \begin{description}
   \item [fieldbundle]
   {\tt ESMF\_FieldBundle} to be added to.
   \item [fieldList]
   List of {\tt ESMF\_Field} objects to be added.
   \item [{[multiflag]}]
   A setting of {\tt .true.} allows multiple items with the same name
   to be added to {\tt ESMF\_FieldBundle}. For {\tt .false.} added items must
   have unique names. The default setting is {\tt .false.}.
   \item [{[relaxedflag]}]
   A setting of {\tt .true.} indicates a relaxed definition of "add"
   under {\tt multiflag=.false.} mode, where it is {\em not} an error if
   {\tt fieldList} contains items with names that are also found in
   {\tt ESMF\_FieldBundle}. The {\tt ESMF\_FieldBundle} is left unchanged for these items.
   For {\tt .false.} this is treated as an error condition.
   The default setting is {\tt .false.}.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleAddReplace] {ESMF\_FieldBundleAddReplace - Conditionally add or replace Fields in a FieldBundle}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     subroutine ESMF_FieldBundleAddReplace(fieldbundle, fieldList, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     type(ESMF_Field), intent(in) :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Fields in {\tt fieldList} that do not match any Fields by name in
   {\tt fieldbundle} are added to the FieldBundle. Fields in {\tt fieldList}
   that match any Fields by name in {\tt fieldbundle} replace those Fields.
  
   \begin{description}
   \item [fieldbundle]
   {\tt ESMF\_FieldBundle} to be manipulated.
   \item [fieldList]
   List of {\tt ESMF\_Field} objects to be added or used as replacement.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleCreate] {ESMF\_FieldBundleCreate - Create a non packed FieldBundle from a list of Fields}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldBundleCreate()
   function ESMF_FieldBundleCreateDefault(fieldList, &
       multiflag, relaxedflag, name, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     type(ESMF_FieldBundle) :: ESMF_FieldBundleCreateDefault\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim} -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Field), intent(in), optional :: fieldList(:)
     logical, intent(in), optional :: multiflag
     logical, intent(in), optional :: relaxedflag
     character (len=*),intent(in), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Create an {\tt ESMF\_FieldBundle} object from a list of existing Fields.
  
   The creation of a FieldBundle leaves the bundled Fields unchanged, they
   remain valid individual objects. a FieldBundle is a light weight container
   of Field references. The actual data remains in place, there are no
   data movements or duplications associated with the creation of an
   FieldBundle.
  
   \begin{description}
   \item [{[fieldList]}]
   List of {\tt ESMF\_Field} objects to be bundled.
   \item [{[multiflag]}]
   A setting of {\tt .true.} allows multiple items with the same name
   to be added to {\tt fieldbundle}. For {\tt .false.} added items must
   have unique names. The default setting is {\tt .false.}.
   \item [{[relaxedflag]}]
   A setting of {\tt .true.} indicates a relaxed definition of "add"
   under {\tt multiflag=.false.} mode, where it is {\em not} an error if
   {\tt fieldList} contains items with names that are also found in
   {\tt fieldbundle}. The {\tt fieldbundle} is left unchanged for these items.
   For {\tt .false.} this is treated as an error condition.
   The default setting is {\tt .false.}.
   \item [{[name]}]
   Name of the created {\tt ESMF\_FieldBundle}. A default name is generated
   if not specified.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleCreate] {ESMF\_FieldBundleCreate - Create a packed FieldBundle from Fortran array pointer and Grid }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldBundleCreate() 
   function ESMF_FieldBundleCreateGrid<rank><type><kind>(fieldNameList, & 
   farrayPtr, grid, fieldDim, & 
   indexflag, staggerLoc, & 
   gridToFieldMap, & 
   totalLWidth, totalUWidth, name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_FieldBundle) :: ESMF_FieldBundleCreateGridDataPtr<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   character(len=*), intent(in) :: fieldNameList(:) 
   <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer :: farrayPtr 
   type(ESMF_Grid), intent(in) :: grid 
   integer, intent(in) :: fieldDim 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_Index_Flag), intent(in), optional :: indexflag 
   type(ESMF_StaggerLoc), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Create a packed FieldBundle from user supplied list of field names, pre-allocated 
   Fortran array pointer, and {\tt ESMF\_Grid} object. 
   
   The arguments are: 
   \begin{description} 
   \item [fieldNameList] 
   A list of field names for the Fields held by the packed {\tt FieldBundle}. 
   \item[farrayPtr] 
   Pre-allocated Fortran array pointer holding the memory of the list of Fields. 
   \item [grid] 
   The {\tt ESMF\_Grid} object on which the Fields in the packed FieldBundle are built. 
   \item [fieldDim] 
   The dimension in the {\tt farrayPtr} that contains the indices of Fields to be packed. 
   \item [{[indexflag]}] 
   Indicate how DE-local indices are defined. See section 
   \ref{const:indexflag} for a list of valid indexflag options. 
   All Fields in packed FieldBundle use identical indexflag setting. 
   \item [{[staggerloc]}] 
   Stagger location of data in grid cells. For valid 
   predefined values see section \ref{const:staggerloc}. 
   To create a custom stagger location see section 
   \ref{sec:usage:staggerloc:adv}. The default 
   value is {\tt ESMF\_STAGGERLOC\_CENTER}. 
   All Fields in packed FieldBundle use identical staggerloc setting. 
   \item [{[gridToFieldMap]}] 
   List with number of elements equal to the 
   {\tt grid}'s dimCount. The list elements map each dimension 
   of the {\tt grid} to a dimension in the {\tt farrayPtr} by 
   specifying the appropriate {\tt farrayPtr} dimension index. 
   The default is to 
   map all of the {\tt grid}'s dimensions against the lowest dimensions of 
   the {\tt farrayPtr} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
   The values of all {\tt gridToFieldMap} entries must be greater than or equal 
   to one and smaller than or equal to the {\tt farrayPtr} rank. 
   It is erroneous to specify the same {\tt gridToFieldMap} entry 
   multiple times. The total ungridded dimensions in the {\tt field} 
   are the total {\tt farrayPtr} dimensions less 
   the total (distributed + undistributed) dimensions in 
   the {\tt grid}. Ungridded dimensions must be in the same order they are 
   stored in the {\t farrayPtr}. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the {\tt ESMF\_ArrayRedist()} operation. 
   All Fields in packed FieldBundle use identical gridToFieldMap setting. 
   \item [{[totalLWidth]}] 
   Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the {\tt farrayPtr}. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the {\tt farrayPtr}. That is, for each gridded dimension the 
   {\tt farrayPtr} size should be max( {\tt totalLWidth} + {\tt totalUWidth} 
   + {\tt computationalCount}, {\tt exclusiveCount} ). 
   All Fields in packed FieldBundle use identical totalLWidth setting. 
   \item [{[totalUWidth]}] 
   Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the {\tt farrayPtr}. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the {\tt farrayPtr}. That is, for each gridded dimension the 
   {\tt farrayPtr} size should max( {\tt totalLWidth} + {\tt totalUWidth} 
   + {\tt computationalCount}, {\tt exclusiveCount} ). 
   All Fields in packed FieldBundle use identical totalUWidth setting. 
   \item [{[name]}] 
   FieldBundle name. 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleCreate] {ESMF\_FieldBundleCreate - Create a packed FieldBundle from Fortran array pointer and Mesh }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldBundleCreate() 
   function ESMF_FieldBundleCreateMesh<rank><type><kind>(fieldNameList, & 
   farrayPtr, Mesh, fieldDim, & 
   meshLoc, gridToFieldMap, name, rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_FieldBundle) :: ESMF_FieldBundleCreateMeshDataPtr<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   character(len=*), intent(in) :: fieldNameList(:) 
   <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer :: farrayPtr 
   type(ESMF_Mesh), intent(in) :: mesh 
   integer, intent(in) :: fieldDim 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_MeshLoc), intent(in), optional:: meshloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: name 
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Create a packed FieldBundle from user supplied list of field names, pre-allocated 
   Fortran array pointer, and {\tt ESMF\_Mesh} object. 
   
   The arguments are: 
   \begin{description} 
   \item [fieldNameList] 
   A list of field names for the Fields held by the packed {\tt FieldBundle}. 
   \item[farrayPtr] 
   Pre-allocated Fortran array pointer holding the memory of the list of Fields. 
   \item [mesh] 
   The {\tt ESMF\_Mesh} object on which the Fields in the packed FieldBundle are built. 
   \item [fieldDim] 
   The dimension in the {\tt farrayPtr} that contains the indices of Fields to be packed. 
   \item [{[meshloc]}] 
   \begin{sloppypar} 
   The part of the Mesh on which to build the Field. For valid 
   predefined values see Section~\ref{const:meshloc}. 
   If not set, defaults to {\tt ESMF\_MESHLOC\_NODE}. 
   \end{sloppypar} 
   \item [{[gridToFieldMap]}] 
   List with number of elements equal to the 
   {\tt mesh}'s dimCount. The list elements map each dimension 
   of the {\tt mesh} to a dimension in the {\tt farrayPtr} by 
   specifying the appropriate {\tt farrayPtr} dimension index. 
   The default is to 
   map all of the {\tt mesh}'s dimensions against the lowest dimensions of 
   the {\tt farrayPtr} in sequence, i.e. {\tt gridToFieldMap} = (/1,2,3,.../). 
   The values of all {\tt gridToFieldMap} entries must be greater than or equal 
   to one and smaller than or equal to the {\tt farrayPtr} rank. 
   It is erroneous to specify the same {\tt gridToFieldMap} entry 
   multiple times. The total ungridded dimensions in the {\tt field} 
   are the total {\tt farrayPtr} dimensions less 
   the total (distributed + undistributed) dimensions in 
   the {\tt mesh}. Ungridded dimensions must be in the same order they are 
   stored in the {\t farrayPtr}. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the {\tt ESMF\_ArrayRedist()} operation. 
   All Fields in packed FieldBundle use identical gridToFieldMap setting. 
   \item [{[name]}] 
   FieldBundle name. 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleDestroy] {ESMF\_FieldBundleDestroy - Release resources associated with a FieldBundle}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleDestroy(fieldbundle, noGarbage, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: noGarbage
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.0.0] Added argument {\tt noGarbage}.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Destroy an {\tt ESMF\_FieldBundle} object. The member Fields are not
   touched by this operation and remain valid objects that need to be
   destroyed individually if necessary.
  
   The arguments are:
   \begin{description}
   \item[fieldbundle]
   {\tt ESMF\_FieldBundle} object to be destroyed.
   \item[{[noGarbage]}]
   If set to {\tt .TRUE.} the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases -- a situation which may lead to hard to debug
   application crashes.
  
   It is generally recommended to leave the {\tt noGarbage} argument
   set to {\tt .FALSE.} (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully
   removing the entire temporary object from memory.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleGet] {ESMF\_FieldBundleGet - Get object-wide information from a FieldBundle}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     ! Private name; call using ESMF_FieldBundleGet()
     subroutine ESMF_FieldBundleGetListAll(fieldbundle, &
       itemorderflag, geomtype, grid, locstream, mesh, xgrid, &
       fieldCount, fieldList, fieldNameList, isPacked, name, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(in) :: fieldbundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_ItemOrder_Flag), intent(in), optional :: itemorderflag
     type(ESMF_GeomType_Flag), intent(out), optional :: geomtype
     type(ESMF_Grid), intent(out), optional :: grid
     type(ESMF_LocStream), intent(out), optional :: locstream
     type(ESMF_Mesh), intent(out), optional :: mesh
     type(ESMF_XGrid), intent(out), optional :: xgrid
     integer, intent(out), optional :: fieldCount
     type(ESMF_Field), intent(out), optional :: fieldList(:)
     character(len=*), intent(out), optional :: fieldNameList(:)
     logical, intent(out), optional :: isPacked
     character(len=*), intent(out), optional :: name
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[6.1.0] Added argument {\tt itemorderflag}.
   The new argument gives the user control over the order in which
   the items are returned.
   \item[8.0.0] Added argument {\tt isPacked}.
   The new argument allows the user to query if this is a packed FieldBundle.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Get the list of all Fields and field names bundled in a FieldBundle.
  
   \begin{description}
   \item [fieldbundle]
   {\tt ESMF\_FieldBundle} to be queried.
   \item [{[itemorderflag]}]
   Specifies the order of the returned items in the {\tt fieldList} or the
   {\tt fieldNameList}.
   The default is {\tt ESMF\_ITEMORDER\_ABC}.
   See \ref{const:itemorderflag} for a full list of options.
   \item[{[geomtype]}]
   Flag that indicates what type of geometry this FieldBundle object holds.
   Can be {\tt ESMF\_GEOMTYPE\_GRID}, {\tt ESMF\_GEOMTYPE\_MESH}, {\tt ESMF\_GEOMTYPE\_LOCSTREAM},
   {\tt ESMF\_GEOMTYPE\_XGRID}
   \item[{[grid]}]
   The Grid object that this FieldBundle object holds.
   \item[{[locstream]}]
   The LocStream object that this FieldBundle object holds.
   \item[{[mesh]}]
   The Mesh object that this FieldBundle object holds.
   \item[{[xgrid]}]
   The XGrid object that this FieldBundle object holds.
   \item [{[fieldCount]}]
   Upon return holds the number of Fields bundled in the fieldbundle.
   \item [{[fieldList]}]
   Upon return holds a list of Fields bundled in {\tt ESMF\_FieldBundle}. The
   argument must be allocated to be at least of size {\tt fieldCount}.
   \item [{[fieldNameList]}]
   Upon return holds a list of the names of the fields bundled in
   {\tt ESMF\_FieldBundle}. The argument must be allocated to be at least of
   size {\tt fieldCount}.
   \item [{[isPacked]}]
   Upon return holds the information if this FieldBundle is packed.
   \item [{[name]}]
   Name of the fieldbundle object.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleGet] {ESMF\_FieldBundleGet - Get information about a Field by name and optionally return a Field}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     ! Private name; call using ESMF_FieldBundleGet()
     subroutine ESMF_FieldBundleGetItem(fieldbundle, fieldName, &
       field, fieldCount, isPresent, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(in) :: fieldbundle
     character(len=*), intent(in) :: fieldName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Field), intent(out), optional :: field
     integer, intent(out), optional :: fieldCount
     logical, intent(out), optional :: isPresent
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Get information about items that match {\tt fieldName} in FieldBundle.
  
   \begin{description}
   \item [fieldbundle]
   {\tt ESMF\_FieldBundle} to be queried.
   \item [fieldName]
   Specified name.
   \item [{[field]}]
   Upon return holds the requested field item. It is an error if this
   argument was specified and there is not exactly one field item in
   {\tt ESMF\_FieldBundle} that matches {\tt fieldName}.
   \item [{[fieldCount]}]
   Number of Fields with {\tt fieldName} in {\tt ESMF\_FieldBundle}.
   \item [{[isPresent]}]
   Upon return indicates whether field(s) with {\tt fieldName} exist
   in {\tt ESMF\_FieldBundle}.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleGet] {ESMF\_FieldBundleGet - Get a list of Fields by name}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     ! Private name; call using ESMF_FieldBundleGet()
     subroutine ESMF_FieldBundleGetList(fieldbundle, fieldName, fieldList, &
       itemorderflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(in) :: fieldbundle
     character(len=*), intent(in) :: fieldName
     type(ESMF_Field), intent(out) :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_ItemOrder_Flag), intent(in), optional :: itemorderflag
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[6.1.0] Added argument {\tt itemorderflag}.
   The new argument gives the user control over the order in which
   the items are returned.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Get the list of Fields from fieldbundle that match fieldName.
  
   \begin{description}
   \item [fieldbundle]
   {\tt ESMF\_FieldBundle} to be queried.
   \item [fieldName]
   Specified name.
   \item [fieldList]
   List of Fields in {\tt ESMF\_FieldBundle} that match {\tt fieldName}. The
   argument must be allocated to be at least of size {\tt fieldCount}
   returned for this {\tt fieldName}.
   \item [{[itemorderflag]}]
   Specifies the order of the returned items in the {\tt fieldList}.
   The default is {\tt ESMF\_ITEMORDER\_ABC}.
   See \ref{const:itemorderflag} for a full list of options.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleGet] {ESMF\_FieldBundleGet - Get Fortran array pointer from a packed FieldBundle }


   
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldBundleGet() 
   function ESMF_FieldBundleGetDataPtr<rank><type><kind>(fieldBundle, & 
   localDe, farrayPtr, & 
   rc) 
   \end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}   type(ESMF_FieldBundle) :: ESMF_FieldBundleGetDataPtr<rank><type><kind> 
   \end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_FieldBundle), intent(in) :: fieldBundle 
   integer, intent(in), optional :: localDe 
   <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer :: farrayPtr 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc 
   \end{verbatim}
{\sf DESCRIPTION:\\ }

 
   Get a Fortran pointer to DE-local memory allocation within packed FieldBundle. 
   It's erroneous to perform this call on a FieldBundle that's not packed. 
   
   The arguments are: 
   \begin{description} 
   \item [fieldBundle] 
   {\tt ESMF\_FieldBundle} object. 
   \item [{[localDe]}] 
   Local DE for which information is requested. [0,..,localDeCount-1]. 
   For localDeCount==1 the localDe argument may be omitted, 
   in which case it will default to localDe=0. In the case where 
   packed FieldBundle is created on a Grid, the number of localDes can 
   be queried from the Grid attached to the FieldBundle. In the case where 
   packed FieldBundle is created on a Mesh, the number of localDes is 1. 
   \item[farrayPtr] 
   Fortran array pointer which will be pointed at DE-local memory allocation 
   in packed FieldBundle. 
   \item [{[rc]}] 
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
   \end{description} 
    
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleHalo] {ESMF\_FieldBundleHalo - Execute a FieldBundle halo operation}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleHalo(fieldbundle, routehandle, &
     checkflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         type(ESMF_FieldBundle), intent(inout) :: fieldbundle
         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: checkflag
         integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   \begin{sloppypar}
   Execute a precomputed halo operation for the Fields in {\tt fieldbundle}.
   The FieldBundle must match the respective FieldBundle used during
   {\tt ESMF\_FieldBundleHaloStore()} in {\em type}, {\em kind}, and
   memory layout of the {\em gridded} dimensions. However, the size, number,
   and index order of {\em ungridded} dimensions may be different. See section
   \ref{RH:Reusability} for a more detailed discussion of RouteHandle
   reusability.
   \end{sloppypar}
  
   See {\tt ESMF\_FieldBundleHaloStore()} on how to precompute
   {\tt routehandle}.
  
   \begin{description}
   \item [fieldbundle]
   {\tt ESMF\_FieldBundle} with source data. The data in this
   FieldBundle may be destroyed by this call.
   \item [routehandle]
   Handle to the precomputed Route.
   \item [{[checkflag]}]
   If set to {\tt .TRUE.} the input FieldBundle pair will be checked for
   consistency with the precomputed operation provided by {\tt routehandle}.
   If set to {\tt .FALSE.} {\em (default)} only a very basic input check
   will be performed, leaving many inconsistencies undetected. Set
   {\tt checkflag} to {\tt .FALSE.} to achieve highest performance.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleHaloRelease] {ESMF\_FieldBundleHaloRelease - Release resources associated with a FieldBundle halo operation}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleHaloRelease(routehandle, &
     noGarbage, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: noGarbage
         integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[8.0.0] Added argument {\tt noGarbage}.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Release resources associated with a FieldBundle halo operation. After this call
   {\tt routehandle} becomes invalid.
  
   \begin{description}
   \item [routehandle]
   Handle to the precomputed Route.
   \item[{[noGarbage]}]
   If set to {\tt .TRUE.} the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases -- a situation which may lead to hard to debug
   application crashes.
  
   It is generally recommended to leave the {\tt noGarbage} argument
   set to {\tt .FALSE.} (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully
   removing the entire temporary object from memory.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleHaloStore] {ESMF\_FieldBundleHaloStore - Precompute a FieldBundle halo operation}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}     subroutine ESMF_FieldBundleHaloStore(fieldbundle, routehandle, &
       rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Store a FieldBundle halo operation over the data in {\tt fieldbundle}.
   By definition, all elements in the total Field regions that lie
   outside the exclusive regions will be considered potential destination
   elements for the halo operation. However, only those elements that have a corresponding
   halo source element, i.e. an exclusive element on one of the DEs, will be
   updated under the halo operation. Elements that have no associated source
   remain unchanged under halo.
  
   The routine returns an {\tt ESMF\_RouteHandle} that can be used to call
   {\tt ESMF\_FieldBundleHalo()} on any pair of FieldBundles that matches
   {\tt srcFieldBundle} and {\tt dstFieldBundle} in {\em type}, {\em kind},
   and memory layout of the {\em gridded} dimensions. However, the size,
   number, and index order of {\em ungridded} dimensions may be different.
   See section \ref{RH:Reusability} for a more detailed discussion of
   RouteHandle reusability.
  
   This call is {\em collective} across the current VM.
  
   \begin{description}
   \item [fieldbundle]
   {\tt ESMF\_FieldBundle} containing data to be haloed. The data in this
   FieldBundle may be destroyed by this call.
   \item [routehandle]
   Handle to the precomputed Route.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleIsCreated] {ESMF\_FieldBundleIsCreated - Check whether a FieldBundle object has been created}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   function ESMF_FieldBundleIsCreated(fieldbundle, rc)\end{verbatim}{\em RETURN VALUE:}
\begin{verbatim}     logical :: ESMF_FieldBundleIsCreated\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(in) :: fieldbundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Return {\tt .true.} if the {\tt fieldbundle} has been created. Otherwise return
   {\tt .false.}. If an error occurs, i.e. {\tt rc /= ESMF\_SUCCESS} is
   returned, the return value of the function will also be {\tt .false.}.
  
   The arguments are:
   \begin{description}
   \item[fieldbundle]
   {\tt ESMF\_FieldBundle} queried.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundlePrint] {ESMF\_FieldBundlePrint - Print FieldBundle information}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundlePrint(fieldbundle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(in) :: fieldbundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Print internal information of the specified {\tt fieldbundle} object.
  
   The arguments are:
   \begin{description}
   \item[fieldbundle]
   {\tt ESMF\_FieldBundle} object.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleRead] {ESMF\_FieldBundleRead - Read Fields to a FieldBundle from file(s)}


   \label{api:FieldBundleRead}
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleRead(fieldbundle, fileName, &
     singleFile, timeslice, iofmt, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     character(*), intent(in) :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: singleFile
     integer, intent(in), optional :: timeslice
     type(ESMF_IOFmt_Flag), intent(in), optional :: iofmt
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Read field data to a FieldBundle object from file(s).
   For this API to be functional, the environment variable {\tt ESMF\_PIO}
   should be set to "internal" when the ESMF library is built.
   Please see the section on Data I/O,~\ref{io:dataio}.
  
   Limitations:
   \begin{itemize}
   \item Only single tile Arrays within Fields are supported.
   \item Not supported in {\tt ESMF\_COMM=mpiuni} mode.
   \end{itemize}
  
   The arguments are:
   \begin{description}
   \item[fieldbundle]
   An {\tt ESMF\_FieldBundle} object.
   \item[fileName]
   The name of the file from which fieldbundle data is read.
   \item[{[singleFile]}]
   A logical flag, the default is .true., i.e., all Fields in the bundle
   are stored in one single file. If .false., each field is stored
   in separate files; these files are numbered with the name based on the
   argument "file". That is, a set of files are named: [file\_name]001,
   [file\_name]002, [file\_name]003,...
   \item[{[timeslice]}]
   The time-slice number of the variable read from file.
   \item[{[iofmt]}]
   \begin{sloppypar}
   The I/O format. Please see Section~\ref{opt:iofmtflag} for the list
   of options. If not present, file names with a {\tt .bin} extension will
   use {\tt ESMF\_IOFMT\_BIN}, and file names with a {\tt .nc} extension
   will use {\tt ESMF\_IOFMT\_NETCDF}. Other files default to
   {\tt ESMF\_IOFMT\_NETCDF}.
   \end{sloppypar}
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleRedist] {ESMF\_FieldBundleRedist - Execute a FieldBundle redistribution}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleRedist(srcFieldBundle, dstFieldBundle, &
     routehandle, checkflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         type(ESMF_FieldBundle), intent(in), optional :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout), optional :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: checkflag
         integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   \begin{sloppypar}
   Execute a precomputed redistribution from {\tt srcFieldBundle}
   to {\tt dstFieldBundle}.
   Both {\tt srcFieldBundle} and {\tt dstFieldBundle} must match the
   respective FieldBundles used during {\tt ESMF\_FieldBundleRedistStore()}
   in {\em type}, {\em kind}, and memory layout of the {\em gridded}
   dimensions. However, the size, number,
   and index order of {\em ungridded} dimensions may be different. See section
   \ref{RH:Reusability} for a more detailed discussion of RouteHandle
   reusability.
   \end{sloppypar}
  
   The {\tt srcFieldBundle} and {\tt dstFieldBundle} arguments are optional in support of
   the situation where {\tt srcFieldBundle} and/or {\tt dstFieldBundle} are not defined on
   all PETs. The {\tt srcFieldBundle} and {\tt dstFieldBundle} must be specified on those
   PETs that hold source or destination DEs, respectively, but may be omitted
   on all other PETs. PETs that hold neither source nor destination DEs may
   omit both arguments.
  
   It is erroneous to specify the identical FieldBundle object for {\tt srcFieldBundle} and
   {\tt dstFieldBundle} arguments.
  
   See {\tt ESMF\_FieldBundleRedistStore()} on how to precompute
   {\tt routehandle}.
  
   This call is {\em collective} across the current VM.
  
   For examples and associated documentation regarding this method see Section
   \ref{sec:fieldbundle:usage:redist_1dptr}.
  
   \begin{description}
   \item [{[srcFieldBundle]}]
   {\tt ESMF\_FieldBundle} with source data.
   \item [{[dstFieldBundle]}]
   {\tt ESMF\_FieldBundle} with destination data.
   \item [routehandle]
   Handle to the precomputed Route.
   \item [{[checkflag]}]
   If set to {\tt .TRUE.} the input FieldBundle pair will be checked for
   consistency with the precomputed operation provided by {\tt routehandle}.
   If set to {\tt .FALSE.} {\em (default)} only a very basic input check
   will be performed, leaving many inconsistencies undetected. Set
   {\tt checkflag} to {\tt .FALSE.} to achieve highest performance.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleRedistRelease] {ESMF\_FieldBundleRedistRelease - Release resources associated with a FieldBundle redistribution}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleRedistRelease(routehandle, &
     noGarbage, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: noGarbage
         integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[8.0.0] Added argument {\tt noGarbage}.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Release resources associated with a FieldBundle redistribution. After this call
   {\tt routehandle} becomes invalid.
  
   \begin{description}
   \item [routehandle]
   Handle to the precomputed Route.
   \item[{[noGarbage]}]
   If set to {\tt .TRUE.} the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases -- a situation which may lead to hard to debug
   application crashes.
  
   It is generally recommended to leave the {\tt noGarbage} argument
   set to {\tt .FALSE.} (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully
   removing the entire temporary object from memory.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleRedistStore] {ESMF\_FieldBundleRedistStore - Precompute a FieldBundle redistribution with local factor argument}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldBundleRedistStore()
   subroutine ESMF_FieldBundleRedistStore<type><kind>(srcFieldBundle, &
   dstFieldBundle, routehandle, factor, &
   srcToDstTransposeMap, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
   type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
   type(ESMF_RouteHandle), intent(inout) :: routehandle
   <type>(ESMF_KIND_<kind>), intent(in) :: factor
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: srcToDstTransposeMap(:)
   integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


  
   Store a FieldBundle redistribution operation from {\tt srcFieldBundle} to {\tt dstFieldBundle}.
   PETs that
   specify a {\tt factor} argument must use the <type><kind> overloaded interface. Other
   PETs call into the interface without {\tt factor} argument. If multiple PETs specify
   the {\tt factor} argument its type and kind as well as its value must match across
   all PETs. If none of the PETs specifies a {\tt factor} argument the default will be a
   factor of 1.
  
   Both {\tt srcFieldBundle} and {\tt dstFieldBundle} are interpreted as sequentialized
   vectors. The
   sequence is defined by the order of DistGrid dimensions and the order of
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See
   section \ref{Array:SparseMatMul} for details on the definition of {\em sequence indices}.
   Redistribution corresponds to an identity mapping of the source FieldBundle vector to
   the destination FieldBundle vector.
  
   Source and destination FieldBundles may be of different <type><kind>. Further source
   and destination FieldBundles may differ in shape, however, the number of elements
   must match.
  
   It is erroneous to specify the identical FieldBundle object for srcFieldBundle
   and dstFieldBundle arguments.
  
   The routine returns an {\tt ESMF\_RouteHandle} that can be used to call
   {\tt ESMF\_FieldBundleRedist()} on any pair of FieldBundles that matches
   {\tt srcFieldBundle} and {\tt dstFieldBundle} in {\em type}, {\em kind},
   and memory layout of the {\em gridded} dimensions. However, the size,
   number, and index order of {\em ungridded} dimensions may be different.
   See section \ref{RH:Reusability} for a more detailed discussion of
   RouteHandle reusability.
  
   This method is overloaded for:\newline
   {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},\newline
   {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
   \newline
  
   This call is collective across the current VM.
  
   For examples and associated documentation regarding this method see Section
   \ref{sec:fieldbundle:usage:redist_1dptr}.
  
   The arguments are:
   \begin{description}
   \item [srcFieldBundle]
   {\tt ESMF\_FieldBundle} with source data.
   \item [dstFieldBundle]
   {\tt ESMF\_FieldBundle} with destination data. The data in this
   FieldBundle may be destroyed by this call.
   \item [routehandle]
   Handle to the precomputed Route.
   \item [factor]
   Factor by which to multiply source data.
   \item [{[srcToDstTransposeMap]}]
   List with as many entries as there are dimensions in {\tt srcFieldBundle}. Each
   entry maps the corresponding {\tt srcFieldBundle} dimension
   against the specified {\tt dstFieldBundle}
   dimension. Mixing of distributed and undistributed dimensions is supported.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleRedistStore] {ESMF\_FieldBundleRedistStore - Precompute a FieldBundle redistribution with local factor argument}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldBundleRedistStore()
   subroutine ESMF_FieldBundleRedistStoreNF(srcFieldBundle, dstFieldBundle, &
   routehandle, factor, srcToDstTransposeMap, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
   type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
   type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: srcToDstTransposeMap(:)
   integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


  
   \begin{sloppypar}
   Store a FieldBundle redistribution operation from {\tt srcFieldBundle}
   to {\tt dstFieldBundle}. PETs that specify non-zero matrix coefficients must use
   the <type><kind> overloaded interface and provide the {\tt factorList} and
   {\tt factorIndexList} arguments. Providing {\tt factorList} and
   {\tt factorIndexList} arguments with {\tt size(factorList) = (/0/)} and
   {\tt size(factorIndexList) = (/2,0/)} or {\tt (/4,0/)} indicates that a
   PET does not provide matrix elements. Alternatively, PETs that do not
   provide matrix elements may also call into the overloaded interface
   {\em without} {\tt factorList} and {\tt factorIndexList} arguments.
   \end{sloppypar}
  
   Both {\tt srcFieldBundle} and {\tt dstFieldBundle} are interpreted as sequentialized
   vectors. The
   sequence is defined by the order of DistGrid dimensions and the order of
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See
   section \ref{Array:SparseMatMul} for details on the definition of {\em sequence indices}.
   Redistribution corresponds to an identity mapping of the source FieldBundle vector to
   the destination FieldBundle vector.
  
   Source and destination Fields may be of different <type><kind>. Further source
   and destination Fields may differ in shape, however, the number of elements
   must match.
  
   It is erroneous to specify the identical FieldBundle object for srcFieldBundle and dstFieldBundle
   arguments.
  
   The routine returns an {\tt ESMF\_RouteHandle} that can be used to call
   {\tt ESMF\_FieldBundleRedist()} on any pair of FieldBundles that matches
   {\tt srcFieldBundle} and {\tt dstFieldBundle} in {\em type}, {\em kind},
   and memory layout of the {\em gridded} dimensions. However, the size,
   number, and index order of {\em ungridded} dimensions may be different.
   See section \ref{RH:Reusability} for a more detailed discussion of
   RouteHandle reusability.
  
   This method is overloaded for:\newline
   {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},\newline
   {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
   \newline
  
   This call is collective across the current VM.
  
   For examples and associated documentation regarding this method see Section
   \ref{sec:fieldbundle:usage:redist_1dptr}.
  
   The arguments are:
   \begin{description}
   \item [srcFieldBundle]
   {\tt ESMF\_FieldBundle} with source data.
   \item [dstFieldBundle]
   {\tt ESMF\_FieldBundle} with destination data. The data in this
   FieldBundle may be destroyed by this call.
   \item [routehandle]
   Handle to the precomputed Route.
   \item [{[srcToDstTransposeMap]}]
   List with as many entries as there are dimensions in {\tt srcFieldBundle}. Each
   entry maps the corresponding {\tt srcFieldBundle} dimension
   against the specified {\tt dstFieldBundle}
   dimension. Mixing of distributed and undistributed dimensions is supported.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleRegrid] {ESMF\_FieldBundleRegrid - Execute a FieldBundle regrid operation}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleRegrid(srcFieldBundle, dstFieldBundle, &
          routehandle, zeroregion, termorderflag, checkflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         type(ESMF_FieldBundle), intent(in), optional :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout), optional :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         type(ESMF_Region_Flag), intent(in), optional :: zeroregion
         type(ESMF_TermOrder_Flag), intent(in), optional :: termorderflag(:)
         logical, intent(in), optional :: checkflag
         integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.0.0] Added argument {\tt termorderflag}.
   The new argument gives the user control over the order in which
   the src terms are summed up.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   \begin{sloppypar}
   Execute a precomputed regrid from {\tt srcFieldBundle}
   to {\tt dstFieldBundle}.
   Both {\tt srcFieldBundle} and {\tt dstFieldBundle} must match the
   respective FieldBundles used during {\tt ESMF\_FieldBundleRedistStore()}
   in {\em type}, {\em kind}, and memory layout of the {\em gridded}
   dimensions. However, the size, number,
   and index order of {\em ungridded} dimensions may be different. See section
   \ref{RH:Reusability} for a more detailed discussion of RouteHandle
   reusability.
   \end{sloppypar}
  
   The {\tt srcFieldBundle} and {\tt dstFieldBundle} arguments are optional in support of
   the situation where {\tt srcFieldBundle} and/or {\tt dstFieldBundle} are not defined on
   all PETs. The {\tt srcFieldBundle} and {\tt dstFieldBundle} must be specified on those
   PETs that hold source or destination DEs, respectively, but may be omitted
   on all other PETs. PETs that hold neither source nor destination DEs may
   omit both arguments.
  
   It is erroneous to specify the identical FieldBundle object for {\tt srcFieldBundle} and
   {\tt dstFieldBundle} arguments.
  
   See {\tt ESMF\_FieldBundleRegridStore()} on how to precompute
   {\tt routehandle}.
  
   This call is {\em collective} across the current VM.
  
   \begin{description}
   \item [{[srcFieldBundle]}]
   {\tt ESMF\_FieldBundle} with source data.
   \item [{[dstFieldBundle]}]
   {\tt ESMF\_FieldBundle} with destination data.
   \item [routehandle]
   Handle to the precomputed Route.
   \item [{[zeroregion]}]
   \begin{sloppypar}
   If set to {\tt ESMF\_REGION\_TOTAL} {\em (default)} the total regions of
   all DEs in {\tt dstFieldBundle} will be initialized to zero before updating the
   elements with the results of the sparse matrix multiplication. If set to
   {\tt ESMF\_REGION\_EMPTY} the elements in {\tt dstFieldBundle} will not be
   modified prior to the sparse matrix multiplication and results will be
   added to the incoming element values. Setting {\tt zeroregion} to
   {\tt ESMF\_REGION\_SELECT} will only zero out those elements in the
   destination FieldBundle that will be updated by the sparse matrix
   multiplication. See section \ref{const:region} for a complete list of
   valid settings.
   \end{sloppypar}
   \item [{[termorderflag]}]
   Specifies the order of the source side terms in all of the destination
   sums. The {\tt termorderflag} only affects the order of terms during
   the execution of the RouteHandle. See the \ref{RH:bfb} section for an
   in-depth discussion of {\em all} bit-for-bit reproducibility
   aspects related to route-based communication methods.
   See \ref{const:termorderflag} for a full list of options.
   The size of this array argument must either be 1 or equal the number of
   Fields in the {\tt srcFieldBundle} and {\tt dstFieldBundle} arguments. In
   the latter case, the term order for each Field Regrid operation is
   indicated separately. If only one term order element is specified, it is
   used for {\em all} Field pairs.
   The default is {\tt (/ESMF\_TERMORDER\_FREE/)}, allowing maximum
   flexibility in the order of terms for optimum performance.
   \item [{[checkflag]}]
   If set to {\tt .TRUE.} the input FieldBundle pair will be checked for
   consistency with the precomputed operation provided by {\tt routehandle}.
   If set to {\tt .FALSE.} {\em (default)} only a very basic input check
   will be performed, leaving many inconsistencies undetected. Set
   {\tt checkflag} to {\tt .FALSE.} to achieve highest performance.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleRegridRelease] {ESMF\_FieldBundleRegridRelease - Release resources associated with a FieldBundle regrid operation}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleRegridRelease(routehandle, &
     noGarbage, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: noGarbage
         integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[8.0.0] Added argument {\tt noGarbage}.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Release resources associated with a FieldBundle regrid operation. After this call
   {\tt routehandle} becomes invalid.
  
   \begin{description}
   \item [routehandle]
   Handle to the precomputed Route.
   \item[{[noGarbage]}]
   If set to {\tt .TRUE.} the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases -- a situation which may lead to hard to debug
   application crashes.
  
   It is generally recommended to leave the {\tt noGarbage} argument
   set to {\tt .FALSE.} (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully
   removing the entire temporary object from memory.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleRegridStore] {ESMF\_FieldBundleRegridStore - Precompute a FieldBundle regrid operation}


   \label{api:esmf_fieldbundleregridstore}
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleRegridStore(srcFieldBundle, dstFieldBundle, &
        srcMaskValues, dstMaskValues, regridmethod, polemethod, regridPoleNPnts, &
        lineType, normType, extrapMethod, extrapNumSrcPnts, extrapDistExponent, &
        extrapNumLevels, unmappedaction, ignoreDegenerate, srcTermProcessing, &
        pipelineDepth, routehandle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
     type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
     integer(ESMF_KIND_I4), intent(in), optional :: srcMaskValues(:)
     integer(ESMF_KIND_I4), intent(in), optional :: dstMaskValues(:)
     type(ESMF_RegridMethod_Flag), intent(in), optional :: regridmethod
     type(ESMF_PoleMethod_Flag), intent(in), optional :: polemethod
     integer, intent(in), optional :: regridPoleNPnts
     type(ESMF_LineType_Flag), intent(in), optional :: lineType
     type(ESMF_NormType_Flag), intent(in), optional :: normType
     type(ESMF_ExtrapMethod_Flag), intent(in), optional :: extrapMethod
     integer, intent(in), optional :: extrapNumSrcPnts
     real, intent(in), optional :: extrapDistExponent
     integer, intent(in), optional :: extrapNumLevels
     type(ESMF_UnmappedAction_Flag),intent(in), optional :: unmappedaction
     logical, intent(in), optional :: ignoreDegenerate
     integer, intent(inout), optional :: srcTermProcessing
     integer, intent(inout), optional :: pipelineDepth
     type(ESMF_RouteHandle), intent(inout), optional :: routehandle
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.0.0] Added arguments {\tt ignoreDegenerate}, {\tt lineType},
   and {\tt normType}. The argument {\tt ignoreDegenerate} allows the user to skip degenerate
   cells in the regridding instead of stopping with an error.
   The argument {\tt lineType} allows the user to
   control the path of the line between two points on a sphere surface.
   This allows the user to use their preferred line path for the calculation
   of distances and the shape of cells during regrid weight calculation on
   a sphere. The argument {\tt normType} allows the user to
   control the type of normalization done during conservative weight generation.
   \item[7.1.0r] Added argument {\tt srcTermProcessing}.
   Added argument {\tt pipelineDepth}.
   The new arguments provide access to the tuning parameters
   affecting the performance and bit-for-bit behavior when applying
   the regridding weights.
  
   Added arguments {\tt extrapMethod}, {\tt extrapNumSrcPnts}, and
   {\tt extrapDistExponent}. These three new extrapolation arguments allow the
   user to extrapolate destination points not mapped by the regrid method.
   {\tt extrapMethod} allows the user to choose the extrapolation method.
   {\tt extrapNumSrcPnts} and {\tt extrapDistExponent} are parameters that
   allow the user to tune the behavior of the {\tt ESMF\_EXTRAPMETHOD\_NEAREST\_IDAVG}
   method.
   \item[8.0.0] Added argument {\tt extrapNumLevels}. For level based extrapolation methods
   (e.g. {\tt ESMF\_EXTRAPMETHOD\_CREEP}) this argument allows the user to
   set how many levels to extrapolate.
  !
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Store a FieldBundle regrid operation over the data in {\tt srcFieldBundle} and
   {\tt dstFieldBundle} pair.
  
   The routine returns an {\tt ESMF\_RouteHandle} that can be used to call
   {\tt ESMF\_FieldBundleRegrid()} on any pair of FieldBundles that matches
   {\tt srcFieldBundle} and {\tt dstFieldBundle} in {\em type}, {\em kind},
   and memory layout of the {\em gridded} dimensions. However, the size,
   number, and index order of {\em ungridded} dimensions may be different.
   See section \ref{RH:Reusability} for a more detailed discussion of
   RouteHandle reusability.
  
   This call is {\em collective} across the current VM.
  
   \begin{description}
   \item [srcFieldbundle]
   Source {\tt ESMF\_FieldBundle} containing data to be regridded.
   \item [dstFieldbundle]
   Destination {\tt ESMF\_FieldBundle}. The data in this FieldBundle may be overwritten by this call.
   \item [{[srcMaskValues]}]
   Mask information can be set in the Grids (see~\ref{sec:usage:items}) or Meshes (see~\ref{sec:mesh:mask}) upon which
   the Fields in the {\tt srcFieldbundle} are built.
   The {\tt srcMaskValues} argument specifies the values in that mask information which indicate a source point should be masked out.
   In other words, a location is masked if and only if the value for that location in the mask information matches
   one of the values listed in {\tt srcMaskValues}.
   If {\tt srcMaskValues} is not specified, no masking will occur.
   \item [{[dstMaskValues]}]
   Mask information can be set in the Grids (see~\ref{sec:usage:items}) or Meshes (see~\ref{sec:mesh:mask})
   upon which the Fields in the {\tt dstFieldbundle} are built.
   The {\tt dstMaskValues} argument specifies the values in that mask information which indicate a destination point should be masked out.
   In other words, a location is masked if and only if the value for that location in the mask information matches
   one of the values listed in {\tt dstMaskValues}.
   If {\tt dstMaskValues} is not specified, no masking will occur.
   \item [{[regridmethod]}]
   The type of interpolation. Please see Section~\ref{opt:regridmethod} for a list of
   valid options. If not specified, defaults to {\tt ESMF\_REGRIDMETHOD\_BILINEAR}.
   \item [{[polemethod]}]
   Which type of artificial pole
   to construct on the source Grid for regridding. Please see Section~\ref{const:polemethod} for a list of
   valid options. If not specified, defaults to {\tt ESMF\_POLEMETHOD\_ALLAVG}.
   \item [{[regridPoleNPnts]}]
   If {\tt polemethod} is {\tt ESMF\_POLEMETHOD\_NPNTAVG}.
   This parameter indicates how many points should be averaged
   over. Must be specified if {\tt polemethod} is
   {\tt ESMF\_POLEMETHOD\_NPNTAVG}.
   \item [{[lineType]}]
   This argument controls the path of the line which connects two points on a sphere surface. This in
   turn controls the path along which distances are calculated and the shape of the edges that make
   up a cell. Both of these quantities can influence how interpolation weights are calculated.
   As would be expected, this argument is only applicable when {\tt srcField} and {\tt dstField} are
   built on grids which lie on the surface of a sphere. Section~\ref{opt:lineType} shows a
   list of valid options for this argument. If not specified, the default depends on the
   regrid method. Section~\ref{opt:lineType} has the defaults by line type. Figure~\ref{line_type_support} shows
   which line types are supported for each regrid method as well as showing the default line type by regrid method.
   \item [{[normType]}]
   This argument controls the type of normalization used when generating conservative weights. This option
   only applies to weights generated with {\tt regridmethod=ESMF\_REGRIDMETHOD\_CONSERVE}. Please see
   Section~\ref{opt:normType} for a
   list of valid options. If not specified {\tt normType} defaults to {\tt ESMF\_NORMTYPE\_DSTAREA}.
   \item [{[extrapMethod]}]
   The type of extrapolation. Please see Section~\ref{opt:extrapmethod}
   for a list of valid options. If not specified, defaults to
   {\tt ESMF\_EXTRAPMETHOD\_NONE}.
   \item [{[extrapNumSrcPnts]}]
   The number of source points to use for the extrapolation methods that use more than one source point
   (e.g. {\tt ESMF\_EXTRAPMETHOD\_NEAREST\_IDAVG}). If not specified, defaults to 8.
   \item [{[extrapDistExponent]}]
   The exponent to raise the distance to when calculating weights for
   the {\tt ESMF\_EXTRAPMETHOD\_NEAREST\_IDAVG} extrapolation method. A higher value reduces the influence
   of more distant points. If not specified, defaults to 2.0.
   \item [{[extrapNumLevels]}]
   The number of levels to output for the extrapolation methods that fill levels
   (e.g. {\tt ESMF\_EXTRAPMETHOD\_CREEP}). When a method is used that requires this, then an error will be returned, if it
   is not specified.
   \item [{[unmappedaction]}]
   Specifies what should happen if there are destination points that
   can not be mapped to a source cell. Please see Section~\ref{const:unmappedaction} for a
   list of valid options. If not specified, {\tt unmappedaction} defaults to {\tt ESMF\_UNMAPPEDACTION\_ERROR}.
   \item [{[ignoreDegenerate]}]
   Ignore degenerate cells when checking the input Grids or Meshes for errors. If this is set to true, then the
   regridding proceeds, but degenerate cells will be skipped. If set to false, a degenerate cell produces an error.
   If not specified, {\tt ignoreDegenerate} defaults to false.
  
   \item [{[srcTermProcessing]}]
   The {\tt srcTermProcessing} parameter controls how many source terms,
   located on the same PET and summing into the same destination element,
   are summed into partial sums on the source PET before being transferred
   to the destination PET. A value of 0 indicates that the entire arithmetic
   is done on the destination PET; source elements are neither multiplied
   by their factors nor added into partial sums before being sent off by the
   source PET. A value of 1 indicates that source elements are multiplied
   by their factors on the source side before being sent to the destination
   PET. Larger values of {\tt srcTermProcessing} indicate the maximum number
   of terms in the partial sums on the source side.
  
   Note that partial sums may lead to bit-for-bit differences in the results.
   See section \ref{RH:bfb} for an in-depth discussion of {\em all}
   bit-for-bit reproducibility aspects related to route-based communication
   methods.
  
   \begin{sloppypar}
   The {\tt ESMF\_FieldRegridStore()} method implements an auto-tuning scheme
   for the {\tt srcTermProcessing} parameter. The intent on the
   {\tt srcTermProcessing} argument is "{\tt inout}" in order to
   support both overriding and accessing the auto-tuning parameter.
   If an argument $>= 0$ is specified, it is used for the
   {\tt srcTermProcessing} parameter, and the auto-tuning phase is skipped.
   In this case the {\tt srcTermProcessing} argument is not modified on
   return. If the provided argument is $< 0$, the {\tt srcTermProcessing}
   parameter is determined internally using the auto-tuning scheme. In this
   case the {\tt srcTermProcessing} argument is re-set to the internally
   determined value on return. Auto-tuning is also used if the optional
   {\tt srcTermProcessing} argument is omitted.
   \end{sloppypar}
  
   \item [{[pipelineDepth]}]
   The {\tt pipelineDepth} parameter controls how many messages a PET
   may have outstanding during a sparse matrix exchange. Larger values
   of {\tt pipelineDepth} typically lead to better performance. However,
   on some systems too large a value may lead to performance degradation,
   or runtime errors.
  
   Note that the pipeline depth has no effect on the bit-for-bit
   reproducibility of the results. However, it may affect the performance
   reproducibility of the exchange.
  
   The {\tt ESMF\_FieldRegridStore()} method implements an auto-tuning scheme
   for the {\tt pipelineDepth} parameter. The intent on the
   {\tt pipelineDepth} argument is "{\tt inout}" in order to
   support both overriding and accessing the auto-tuning parameter.
   If an argument $>= 0$ is specified, it is used for the
   {\tt pipelineDepth} parameter, and the auto-tuning phase is skipped.
   In this case the {\tt pipelineDepth} argument is not modified on
   return. If the provided argument is $< 0$, the {\tt pipelineDepth}
   parameter is determined internally using the auto-tuning scheme. In this
   case the {\tt pipelineDepth} argument is re-set to the internally
   determined value on return. Auto-tuning is also used if the optional
   {\tt pipelineDepth} argument is omitted.
  
   \item [{[routehandle]}]
   Handle to the precomputed Route.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleRemove] {ESMF\_FieldBundleRemove - Remove Fields from FieldBundle}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleRemove(fieldbundle, fieldNameList, &
     multiflag, relaxedflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     character(len=*), intent(in) :: fieldNameList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: multiflag
     logical, intent(in), optional :: relaxedflag
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Remove field(s) by name from FieldBundle. In the relaxed setting it is
   {\em not} an error if {\tt fieldNameList} contains names that are not
   found in {\tt fieldbundle}.
  
   \begin{description}
   \item [fieldbundle]
   {\tt ESMF\_FieldBundle} from which to remove items.
   \item [fieldNameList]
   List of items to remove.
   \item [{[multiflag]}]
   A setting of {\tt .true.} allows multiple Fields with the same name
   to be removed from {\tt fieldbundle}. For {\tt .false.}, items to be
   removed must have unique names. The default setting is {\tt .false.}.
   \item [{[relaxedflag]}]
   A setting of {\tt .true.} indicates a relaxed definition of "remove"
   where it is {\em not} an error if {\tt fieldNameList} contains item
   names that are not found in {\tt fieldbundle}. For {\tt .false.} this is
   treated as an error condition.
   Further, in {\tt multiflag=.false.} mode, the relaxed definition of
   "remove" also covers the case where there are multiple items in
   {\tt fieldbundle} that match a single entry in {\tt fieldNameList}.
   For {\tt relaxedflag=.false.} this is treated as an error condition.
   The default setting is {\tt .false.}.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleReplace] {ESMF\_FieldBundleReplace - Replace Fields in FieldBundle}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleReplace(fieldbundle, fieldList, &
     multiflag, relaxedflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     type(ESMF_Field), intent(in) :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: multiflag
     logical, intent(in), optional :: relaxedflag
     integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Replace field(s) by name in FieldBundle. In the relaxed setting it is not
   an error if {\tt fieldList} contains Fields that do not match by name any
   item in {\tt fieldbundle}. These Fields are simply ignored in this case.
  
   \begin{description}
   \item [fieldbundle]
   {\tt ESMF\_FieldBundle} in which to replace items.
   \item [fieldList]
   List of items to replace.
   \item [{[multiflag]}]
   A setting of {\tt .true.} allows multiple items with the same name
   to be replaced in {\tt fieldbundle}. For {\tt .false.}, items to be
   replaced must have unique names. The default setting is {\tt .false.}.
   \item [{[relaxedflag]}]
   A setting of {\tt .true.} indicates a relaxed definition of "replace"
   where it is {\em not} an error if {\tt fieldList} contains items with
   names that are not found in {\tt fieldbundle}. These items in
   {\tt fieldList} are ignored in the relaxed mode. For {\tt .false.} this
   is treated as an error condition.
   Further, in {\tt multiflag=.false.} mode, the relaxed definition of
   "replace" also covers the case where there are multiple items in
   {\tt fieldbundle} that match a single entry by name in {\tt fieldList}.
   For {\tt relaxedflag=.false.} this is treated as an error condition.
   The default setting is {\tt .false.}.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleSet] {ESMF\_FieldBundleSet - Associate a Grid with an empty FieldBundle}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_FieldBundleSet()
       subroutine ESMF_FieldBundleSetGrid(fieldbundle, grid, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_FieldBundle), intent(inout) :: fieldbundle
       type(ESMF_Grid), intent(in) :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   \begin{sloppypar}
   Sets the {\tt grid} for a {\tt fieldbundle}.
   \end{sloppypar}
  
   The arguments are:
   \begin{description}
   \item [fieldbundle]
   An {\tt ESMF\_FieldBundle} object.
   \item [grid]
   The {\tt ESMF\_Grid} which all {\tt ESMF\_Field}s added to this
   {\tt ESMF\_FieldBundle} must have.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleSet] {ESMF\_FieldBundleSet - Associate a Mesh with an empty FieldBundle}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_FieldBundleSet()
       subroutine ESMF_FieldBundleSetMesh(fieldbundle, mesh, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_FieldBundle), intent(inout) :: fieldbundle
       type(ESMF_Mesh), intent(in) :: mesh
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   \begin{sloppypar}
   Sets the {\tt mesh} for a {\tt fieldbundle}.
   \end{sloppypar}
  
   The arguments are:
   \begin{description}
   \item [fieldbundle]
   An {\tt ESMF\_FieldBundle} object.
   \item [mesh]
   The {\tt ESMF\_Mesh} which all {\tt ESMF\_Field}s added to this
   {\tt ESMF\_FieldBundle} must have.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleSet] {ESMF\_FieldBundleSet - Associate a LocStream with an empty FieldBundle}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_FieldBundleSet()
       subroutine ESMF_FieldBundleSetLS(fieldbundle, locstream, &
         rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_FieldBundle), intent(inout) :: fieldbundle
       type(ESMF_LocStream), intent(in) :: locstream
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   \begin{sloppypar}
   Sets the {\tt locstream} for a {\tt fieldbundle}.
   \end{sloppypar}
  
   The arguments are:
   \begin{description}
   \item [fieldbundle]
   An {\tt ESMF\_FieldBundle} object.
   \item [locstream]
   The {\tt ESMF\_LocStream} which all {\tt ESMF\_Field}s added to this
   {\tt ESMF\_FieldBundle} must have.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleSet] {ESMF\_FieldBundleSet - Associate a XGrid with an empty FieldBundle}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}       ! Private name; call using ESMF_FieldBundleSet()
       subroutine ESMF_FieldBundleSetXGrid(fieldbundle, xgrid, &
         rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}       type(ESMF_FieldBundle), intent(inout) :: fieldbundle
       type(ESMF_XGrid), intent(in) :: xgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   \begin{sloppypar}
   Sets the {\tt xgrid} for a {\tt fieldbundle}
   \end{sloppypar}
  
   The arguments are:
   \begin{description}
   \item [fieldbundle]
   An {\tt ESMF\_FieldBundle} object.
   \item [xgrid]
   The {\tt ESMF\_XGrid} which all {\tt ESMF\_Field}s added to this
   {\tt ESMF\_FieldBundle} must have.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
  
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleSMM] {ESMF\_FieldBundleSMM - Execute a FieldBundle sparse matrix multiplication}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleSMM(srcFieldBundle, dstFieldBundle, &
         routehandle, zeroregion, termorderflag, checkflag, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         type(ESMF_FieldBundle), intent(in), optional :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout), optional :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         type(ESMF_Region_Flag), intent(in), optional :: zeroregion
         type(ESMF_TermOrder_Flag), intent(in), optional :: termorderflag(:)
         logical, intent(in), optional :: checkflag
         integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.0.0] Added argument {\tt termorderflag}.
   The new argument gives the user control over the order in which
   the src terms are summed up.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Execute a precomputed sparse matrix multiplication from {\tt srcFieldBundle}
   to {\tt dstFieldBundle}.
   Both {\tt srcFieldBundle} and {\tt dstFieldBundle} must match the
   respective FieldBundles used during {\tt ESMF\_FieldBundleRedistStore()}
   in {\em type}, {\em kind}, and memory layout of the {\em gridded}
   dimensions. However, the size, number,
   and index order of {\em ungridded} dimensions may be different. See section
   \ref{RH:Reusability} for a more detailed discussion of RouteHandle
   reusability.
  
   The {\tt srcFieldBundle} and {\tt dstFieldBundle} arguments are optional in support of
   the situation where {\tt srcFieldBundle} and/or {\tt dstFieldBundle} are not defined on
   all PETs. The {\tt srcFieldBundle} and {\tt dstFieldBundle} must be specified on those
   PETs that hold source or destination DEs, respectively, but may be omitted
   on all other PETs. PETs that hold neither source nor destination DEs may
   omit both arguments.
  
   It is erroneous to specify the identical FieldBundle object for {\tt srcFieldBundle} and
   {\tt dstFieldBundle} arguments.
  
   See {\tt ESMF\_FieldBundleSMMStore()} on how to precompute
   {\tt routehandle}.
  
   This call is {\em collective} across the current VM.
  
   For examples and associated documentation regarding this method see Section
   \ref{sec:fieldbundle:usage:smm_1dptr}.
  
   \begin{description}
   \item [{[srcFieldBundle]}]
   {\tt ESMF\_FieldBundle} with source data.
   \item [{[dstFieldBundle]}]
   {\tt ESMF\_FieldBundle} with destination data.
   \item [routehandle]
   Handle to the precomputed Route.
   \item [{[zeroregion]}]
   If set to {\tt ESMF\_REGION\_TOTAL} {\em (default)} the total regions of
   all DEs in {\tt dstFieldBundle} will be initialized to zero before updating the
   elements with the results of the sparse matrix multiplication. If set to
   {\tt ESMF\_REGION\_EMPTY} the elements in {\tt dstFieldBundle} will not be
   modified prior to the sparse matrix multiplication and results will be
   added to the incoming element values. Setting {\tt zeroregion} to
  
   {\tt ESMF\_REGION\_SELECT} will only zero out those elements in the
   destination FieldBundle that will be updated by the sparse matrix
   multiplication. See section \ref{const:region} for a complete list of
   valid settings.
   \item [{[termorderflag]}]
   Specifies the order of the source side terms in all of the destination
   sums. The {\tt termorderflag} only affects the order of terms during
   the execution of the RouteHandle. See the \ref{RH:bfb} section for an
   in-depth discussion of {\em all} bit-for-bit reproducibility
   aspects related to route-based communication methods.
   See \ref{const:termorderflag} for a full list of options.
   The size of this array argument must either be 1 or equal the number of
   Fields in the {\tt srcFieldBundle} and {\tt dstFieldBundle} arguments. In
   the latter case, the term order for each Field SMM operation is
   indicated separately. If only one term order element is specified, it is
   used for {\em all} Field pairs.
   The default is {\tt (/ESMF\_TERMORDER\_FREE/)}, allowing maximum
   flexibility in the order of terms for optimum performance.
   \item [{[checkflag]}]
   If set to {\tt .TRUE.} the input FieldBundle pair will be checked for
   consistency with the precomputed operation provided by {\tt routehandle}.
   If set to {\tt .FALSE.} {\em (default)} only a very basic input check
   will be performed, leaving many inconsistencies undetected. Set
   {\tt checkflag} to {\tt .FALSE.} to achieve highest performance.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleSMMRelease] {ESMF\_FieldBundleSMMRelease - Release resources associated with a FieldBundle sparse matrix multiplication}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleSMMRelease(routehandle, &
     noGarbage, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: noGarbage
         integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[8.0.0] Added argument {\tt noGarbage}.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


   Release resources associated with a FieldBundle sparse matrix multiplication. After this call
   {\tt routehandle} becomes invalid.
  
   \begin{description}
   \item [routehandle]
   Handle to the precomputed Route.
   \item[{[noGarbage]}]
   If set to {\tt .TRUE.} the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases -- a situation which may lead to hard to debug
   application crashes.
  
   It is generally recommended to leave the {\tt noGarbage} argument
   set to {\tt .FALSE.} (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with {\tt noGarbage} set to {\tt .TRUE.}, fully
   removing the entire temporary object from memory.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleSMMStore] {ESMF\_FieldBundleSMMStore - Precompute a FieldBundle sparse matrix multiplication with local factors}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldBundleSMMStore()
   subroutine ESMF_FieldBundleSMMStore<type><kind>(srcFieldBundle, &
   dstFieldBundle, routehandle, factorList, factorIndexList, &
   srcTermProcessing, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}   type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
   type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
   type(ESMF_RouteHandle), intent(inout) :: routehandle
   <type>(ESMF_KIND_<kind>), intent(in) :: factorList(:)
   integer, intent(in), :: factorIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(inout), optional :: srcTermProcessing(:)
   integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.1.0r] Added argument {\tt srcTermProcessing}.
   The new argument gives the user access to the tuning parameter
   affecting the sparse matrix execution and bit-wise
   reproducibility.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


  
   \begin{sloppypar}
   Store a FieldBundle sparse matrix multiplication operation from {\tt srcFieldBundle}
   to {\tt dstFieldBundle}. PETs that specify non-zero matrix coefficients must use
   the <type><kind> overloaded interface and provide the {\tt factorList} and
   {\tt factorIndexList} arguments. Providing {\tt factorList} and
   {\tt factorIndexList} arguments with
   {\tt size(factorList) = (/0/)} and
   {\tt size(factorIndexList) = (/2,0/)} or {\tt (/4,0/)} indicates that a
   PET does not provide matrix elements. Alternatively, PETs that do not
   provide matrix elements may also call into the overloaded interface
   {\em without} {\tt factorList} and {\tt factorIndexList} arguments.
   \end{sloppypar}
  
   Both {\tt srcFieldBundle} and {\tt dstFieldBundle} are interpreted as sequentialized
   vectors. The
   sequence is defined by the order of DistGrid dimensions and the order of
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See
   section \ref{Array:SparseMatMul} for details on the definition of {\em sequence indices}.
   SMM corresponds to an identity mapping of the source FieldBundle vector to
   the destination FieldBundle vector.
  
   Source and destination Fields may be of different <type><kind>. Further source
   and destination Fields may differ in shape, however, the number of elements
   must match.
  
   It is erroneous to specify the identical FieldBundle object for srcFieldBundle
   and dstFieldBundle arguments.
  
   The routine returns an {\tt ESMF\_RouteHandle} that can be used to call
   {\tt ESMF\_FieldBundleSMM()} on any pair of FieldBundles that matches
   {\tt srcFieldBundle} and {\tt dstFieldBundle} in {\em type}, {\em kind},
   and memory layout of the {\em gridded} dimensions. However, the size,
   number, and index order of {\em ungridded} dimensions may be different.
   See section \ref{RH:Reusability} for a more detailed discussion of
   RouteHandle reusability.
  
   This method is overloaded for:\newline
   {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},\newline
   {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
   \newline
  
   This call is collective across the current VM.
  
   For examples and associated documentation regarding this method see Section
   \ref{sec:fieldbundle:usage:smm_1dptr}.
  
   The arguments are:
   \begin{description}
   \item [srcFieldBundle]
   {\tt ESMF\_FieldBundle} with source data.
   \item [dstFieldBundle]
   {\tt ESMF\_FieldBundle} with destination data. The data in this
   FieldBundle may be destroyed by this call.
   \item [routehandle]
   Handle to the precomputed Route.
   \item [factorList]
   List of non-zero coefficients.
   \item [factorIndexList]
   Pairs of sequence indices for the factors stored in {\tt factorList}.
  
   \begin{sloppypar}
   The second dimension of {\tt factorIndexList} steps through the list of
   pairs, i.e. {\tt size(factorIndexList,2) == size(factorList)}. The first
   dimension of {\tt factorIndexList} is either of size 2 or size 4.
   \end{sloppypar}
  
   In the {\em size 2 format} {\tt factorIndexList(1,:)} specifies the
   sequence index of the source element in the {\tt srcFieldBundle} while
   {\tt factorIndexList(2,:)} specifies the sequence index of the
   destination element in {\tt dstFieldBundle}. For this format to be a valid
   option source and destination FieldBundles must have matching number of
   tensor elements (the product of the sizes of all Field tensor dimensions).
   Under this condition an identity matrix can be applied within the space of
   tensor elements for each sparse matrix factor.
  
   The {\em size 4 format} is more general and does not require a matching
   tensor element count. Here the
  
   {\tt factorIndexList(1,:)} specifies the
   sequence index while {\tt factorIndexList(2,:)} specifies the tensor
   sequence index of the source element in the {\tt srcFieldBundle}. Further
   {\tt factorIndexList(3,:)} specifies the sequence index and
   {\tt factorIndexList(4,:)} specifies the tensor sequence index of the
   destination element in the {\tt dstFieldBundle}.
  
   See section \ref{Array:SparseMatMul} for details on the definition of
   {\em sequence indices} and {\em tensor sequence indices}.
   \item [{[srcTermProcessing]}]
   Source term summing options for route handle creation. See
   {\tt ESMF\_FieldRegridStore} documentation for a full parameter description.
   Two forms may be provided. If a single element list is provided, this
   integer value is applied across all bundle members. Otherwise, the list must
   contain as many elements as there are bundle members. For the special case
   of accessing the auto-tuned parameter (providing a negative integer value),
   the list length must equal the bundle member count.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleSMMStore] {ESMF\_FieldBundleSMMStore - Precompute a FieldBundle sparse matrix multiplication}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldBundleSMMStore()
     subroutine ESMF_FieldBundleSMMStoreNF(srcFieldBundle, dstFieldBundle, &
         routehandle, srcTermProcessing, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}         type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         integer, intent(inout), optional :: srcTermProcessing(:)
         integer, intent(out), optional :: rc\end{verbatim}
{\sf STATUS:}
   \begin{itemize}
   \item\apiStatusCompatibleVersion{5.2.0r}
   \item\apiStatusModifiedSinceVersion{5.2.0r}
   \begin{description}
   \item[7.1.0r] Added argument {\tt srcTermProcessing}.
   The new argument gives the user access to the tuning parameter
   affecting the sparse matrix execution and bit-wise
   reproducibility.
   \end{description}
   \end{itemize}
  
{\sf DESCRIPTION:\\ }


  
   \begin{sloppypar}
   Store a FieldBundle sparse matrix multiplication operation from {\tt srcFieldBundle}
   to {\tt dstFieldBundle}. PETs that specify non-zero matrix coefficients must use
   the <type><kind> overloaded interface and provide the {\tt factorList} and
   {\tt factorIndexList} arguments. Providing {\tt factorList} and
   {\tt factorIndexList} arguments with {\tt size(factorList) = (/0/)} and
   {\tt size(factorIndexList) = (/2,0/)} or {\tt (/4,0/)} indicates that a
   PET does not provide matrix elements. Alternatively, PETs that do not
   provide matrix elements may also call into the overloaded interface
   {\em without} {\tt factorList} and {\tt factorIndexList} arguments.
   \end{sloppypar}
  
   Both {\tt srcFieldBundle} and {\tt dstFieldBundle} are interpreted as sequentialized
   vectors. The
   sequence is defined by the order of DistGrid dimensions and the order of
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See
   section \ref{Array:SparseMatMul} for details on the definition of {\em sequence indices}.
   SMM corresponds to an identity mapping of the source FieldBundle vector to
   the destination FieldBundle vector.
  
   Source and destination Fields may be of different <type><kind>. Further source
   and destination Fields may differ in shape, however, the number of elements
   must match.
  
   It is erroneous to specify the identical FieldBundle object for srcFieldBundle and dstFieldBundle
   arguments.
  
   The routine returns an {\tt ESMF\_RouteHandle} that can be used to call
   {\tt ESMF\_FieldBundleSMM()} on any pair of FieldBundles that matches
   {\tt srcFieldBundle} and {\tt dstFieldBundle} in {\em type}, {\em kind},
   and memory layout of the {\em gridded} dimensions. However, the size,
   number, and index order of {\em ungridded} dimensions may be different.
   See section \ref{RH:Reusability} for a more detailed discussion of
   RouteHandle reusability.
  
   \begin{sloppypar}
   This method is overloaded for
   {\tt ESMF\_TYPEKIND\_I4}, {\tt ESMF\_TYPEKIND\_I8},
   {\tt ESMF\_TYPEKIND\_R4}, {\tt ESMF\_TYPEKIND\_R8}.
   \end{sloppypar}
  
   This call is collective across the current VM.
  
   For examples and associated documentation regarding this method see Section
   \ref{sec:fieldbundle:usage:smm_1dptr}.
  
   The arguments are:
   \begin{description}
   \item [srcFieldBundle]
   {\tt ESMF\_FieldBundle} with source data.
   \item [dstFieldBundle]
   {\tt ESMF\_FieldBundle} with destination data. The data in this
   FieldBundle may be destroyed by this call.
   \item [routehandle]
   Handle to the precomputed Route.
   \item [{[srcTermProcessing]}]
   Source term summing options for route handle creation. See
   {\tt ESMF\_FieldRegridStore} documentation for a full parameter description.
   Two forms may be provided. If a single element list is provided, this
   integer value is applied across all bundle members. Otherwise, the list must
   contain as many elements as there are bundle members. For the special case
   of accessing the auto-tuned parameter (providing a negative integer value),
   the list length must equal the bundle member count.
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleSMMStore] {ESMF\_FieldBundleSMMStore - Precompute field bundle sparse matrix multiplication using factors read from file}


  
\bigskip{\sf INTERFACE:}
\begin{verbatim}   ! Private name; call using ESMF_FieldBundleSMMStore()
     subroutine ESMF_FieldBundleSMMStoreFromFile(srcFieldBundle, dstFieldBundle, &
       filename, routehandle, srcTermProcessing, rc)
   ! ARGUMENTS:
       type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
       type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
       character(len=*), intent(in) :: filename
       type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(inout), optional :: srcTermProcessing(:)
       integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


  
   Compute an {\tt ESMF\_RouteHandle} using factors read from file.
  
   The arguments are:
  
   \begin{description}
  
   \item [srcFieldBundle]
   {\tt ESMF\_FieldBundle} with source data.
  
   \item [dstFieldBundle]
   {\tt ESMF\_FieldBundle} with destination data. The data in this field
   bundle may be destroyed by this call.
  
   \item [filename]
   Path to the file containing weights for creating an {\tt ESMF\_RouteHandle}.
   See ~(\ref{sec:weightfileformat}) for a description of the SCRIP weight
   file format. Only "row", "col", and "S" variables are required. They
   must be one-dimensionsal with dimension "n\_s".
  
   \item [routehandle]
   Handle to the {\tt ESMF\_RouteHandle}.
  
   \item [{[srcTermProcessing]}]
   Source term summing options for route handle creation. See
   {\tt ESMF\_FieldRegridStore} documentation for a full parameter description.
   Two forms may be provided. If a single element list is provided, this
   integer value is applied across all bundle members. Otherwise, the list must
   contain as many elements as there are bundle members. For the special case
   of accessing the auto-tuned parameter (providing a negative integer value),
   the list length must equal the bundle member count.
  
   \item [{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
  
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleValidate] {ESMF\_FieldBundleValidate - Validate fieldbundle internals}


\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleValidate(fieldbundle, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(in) :: fieldbundle
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Validates that the {\tt fieldbundle} is internally consistent.
   The method returns an error code if problems are found.
  
   The arguments are:
   \begin{description}
   \item[fieldbundle]
   Specified {\tt ESMF\_FieldBundle} object.
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
   
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 
\subsubsection [ESMF\_FieldBundleWrite] {ESMF\_FieldBundleWrite - Write the Fields into a file}


   \label{api:FieldBundleWrite}
\bigskip{\sf INTERFACE:}
\begin{verbatim}   subroutine ESMF_FieldBundleWrite(fieldbundle, fileName, &
       convention, purpose, singleFile, overwrite, status, timeslice, iofmt, rc)\end{verbatim}{\em ARGUMENTS:}
\begin{verbatim}     type(ESMF_FieldBundle), intent(in) :: fieldbundle
     character(*), intent(in) :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*), intent(in), optional :: convention
     character(*), intent(in), optional :: purpose
     logical, intent(in), optional :: singleFile
     logical , intent(in), optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in), optional :: status
     integer, intent(in), optional :: timeslice
     type(ESMF_IOFmt_Flag), intent(in), optional :: iofmt
     integer, intent(out), optional :: rc\end{verbatim}
{\sf DESCRIPTION:\\ }


   Write the Fields into a file. For this API to be functional,
   the environment variable {\tt ESMF\_PIO} should be set to "internal"
   when the ESMF library is built. Please see the section on
   Data I/O,~\ref{io:dataio}.
  
   When {\tt convention} and {\tt purpose} arguments are specified, NetCDF dimension
   labels and variable attributes are written from each Field in the FieldBundle
   from the corresponding Attribute package. Additionally, Attributes may be
   set on the FieldBundle level under the same Attribute package. This allows
   the specification of global attributes within the file.
   As with individual Fields, the value associated with each name may be either
   a scalar character string, or a scalar or array of type integer, real, or
   double precision.
  
   Limitations:
   \begin{itemize}
   \item Only single tile Fields are supported.
   \item Not supported in {\tt ESMF\_COMM=mpiuni} mode.
   \end{itemize}
  
   The arguments are:
   \begin{description}
   \item[fieldbundle]
   An {\tt ESMF\_FieldBundle} object.
   \item[fileName]
   The name of the output file to which field bundle data is written.
   \item[{[convention]}]
   Specifies an Attribute package associated with the FieldBundle, and the
   contained Fields, used to create NetCDF dimension labels and attributes
   in the file. When this argument is present, the {\tt purpose}
   argument must also be present. Use this argument only with a NetCDF
   I/O format. If binary format is used, ESMF will return an error code.
   \item[{[purpose]}]
   Specifies an Attribute package associated with the FieldBundle, and the
   contained Fields, used to create NetCDF dimension labels and attributes
   in the file. When this argument is present, the {\tt convention}
   argument must also be present. Use this argument only with a NetCDF
   I/O format. If binary format is used, ESMF will return an error code.
   \item[{[singleFile]}]
   A logical flag, the default is .true., i.e., all fields in the bundle
   are written in one single file. If .false., each field will be written
   in separate files; these files are numbered with the name based on the
   argument "file". That is, a set of files are named: [file\_name]001,
   [file\_name]002, [file\_name]003,...
   \item[{[overwrite]}]
   \begin{sloppypar}
   A logical flag, the default is .false., i.e., existing field data may
   {\em not} be overwritten. If .true., the overwrite behavior depends
   on the value of {\tt iofmt} as shown below:
   \begin{description}
   \item[{\tt iofmt} = {\tt ESMF\_IOFMT\_BIN}:]\ All data in the file will
   be overwritten with each fields data.
   \item[{\tt iofmt} = {\tt ESMF\_IOFMT\_NETCDF, ESMF\_IOFMT\_NETCDF\_64BIT\_OFFSET}:]\ Only the
   data corresponding to each fields name will be
   be overwritten. If the {\tt timeslice} option is given, only data for
   the given timeslice may be overwritten.
   Note that it is always an error to attempt to overwrite a NetCDF
   variable with data which has a different shape.
   \end{description}
   \end{sloppypar}
   \item[{[status]}]
   \begin{sloppypar}
   The file status. Please see Section~\ref{const:filestatusflag} for
   the list of options. If not present, defaults to
   {\tt ESMF\_FILESTATUS\_UNKNOWN}.
   \end{sloppypar}
   \item[{[timeslice]}]
   \begin{sloppypar}
   Some I/O formats (e.g. NetCDF) support the output of data in form of
   time slices. The {\tt timeslice} argument provides access to this
   capability. {\tt timeslice} must be positive. The behavior of this
   option may depend on the setting of the {\tt overwrite} flag:
   \begin{description}
   \item[{\tt overwrite = .false.}:]\ If the timeslice value is
   less than the maximum time already in the file, the write will fail.
   \item[{\tt overwrite = .true.}:]\ Any positive timeslice value is valid.
   \end{description}
   By default, i.e. by omitting the {\tt timeslice} argument, no
   provisions for time slicing are made in the output file,
   however, if the file already contains a time axis for the variable,
   a timeslice one greater than the maximum will be written.
   \end{sloppypar}
   \item[{[iofmt]}]
   \begin{sloppypar}
   The I/O format. Please see Section~\ref{opt:iofmtflag} for the list
   of options. If not present, file names with a {\tt .bin} extension will
   use {\tt ESMF\_IOFMT\_BIN}, and file names with a {\tt .nc} extension
   will use {\tt ESMF\_IOFMT\_NETCDF}. Other files default to
   {\tt ESMF\_IOFMT\_NETCDF}.
   \end{sloppypar}
   \item[{[rc]}]
   Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
   \end{description}
  
%...............................................................
\setlength{\parskip}{\oldparskip}
\setlength{\parindent}{\oldparindent}
\setlength{\baselineskip}{\oldbaselineskip}
