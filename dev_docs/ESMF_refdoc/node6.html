<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2012 (1.2)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>5 Infrastructure: Utilities</TITLE>
<META NAME="description" CONTENT="5 Infrastructure: Utilities">
<META NAME="keywords" CONTENT="ESMF_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2012">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node7.html">
<LINK REL="previous" HREF="node5.html">
<LINK REL="up" HREF="ESMF_refdoc.html">
<LINK REL="next" HREF="node7.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html2806"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2802"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2796"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2804"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2807"
  HREF="node7.html">6 References</A>
<B> Up:</B> <A NAME="tex2html2803"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html2797"
  HREF="node5.html">4 Infrastructure: Fields and</A>
 &nbsp; <B>  <A NAME="tex2html2805"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html2808"
  HREF="node6.html#SECTION06010000000000000000">38 Overview of Infrastructure Utility Classes</A>
<LI><A NAME="tex2html2809"
  HREF="node6.html#SECTION06020000000000000000">39 Attribute Class</A>
<UL>
<LI><A NAME="tex2html2810"
  HREF="node6.html#SECTION06021000000000000000">39.1 Description</A>
<UL>
<LI><A NAME="tex2html2811"
  HREF="node6.html#SECTION06021100000000000000">39.1.1 Schemas and Controlled Vocabularies</A>
<LI><A NAME="tex2html2812"
  HREF="node6.html#SECTION06021200000000000000">39.1.2 The Common Information Model (CIM)</A>
<LI><A NAME="tex2html2813"
  HREF="node6.html#SECTION06021300000000000000">39.1.3 The ESMF approach to Attributes</A>
<LI><A NAME="tex2html2814"
  HREF="node6.html#SECTION06021400000000000000">39.1.4 Attribute hierarchies</A>
</UL>
<LI><A NAME="tex2html2815"
  HREF="node6.html#SECTION06022000000000000000">39.2 Attribute Packages</A>
<UL>
<LI><A NAME="tex2html2816"
  HREF="node6.html#SECTION06022100000000000000">39.2.1 Component Attribute packages</A>
<LI><A NAME="tex2html2817"
  HREF="node6.html#SECTION06022200000000000000">39.2.2 State Attribute packages</A>
<LI><A NAME="tex2html2818"
  HREF="node6.html#SECTION06022300000000000000">39.2.3 Field Attribute packages</A>
<LI><A NAME="tex2html2819"
  HREF="node6.html#SECTION06022400000000000000">39.2.4 Array Attribute packages</A>
<LI><A NAME="tex2html2820"
  HREF="node6.html#SECTION06022500000000000000">39.2.5 Grid Attribute packages</A>
<LI><A NAME="tex2html2821"
  HREF="node6.html#SECTION06022600000000000000">39.2.6 Table of available Attributes</A>
<LI><A NAME="tex2html2822"
  HREF="node6.html#SECTION06022700000000000000">39.2.7 Custom Attribute packages</A>
</UL>
<LI><A NAME="tex2html2823"
  HREF="node6.html#SECTION06023000000000000000">39.3 Attribute Packages Nesting</A>
<LI><A NAME="tex2html2824"
  HREF="node6.html#SECTION06024000000000000000">39.4 Export Formats</A>
<UL>
<LI><A NAME="tex2html2825"
  HREF="node6.html#SECTION06024100000000000000">39.4.1 Tab-delimited ASCII</A>
<LI><A NAME="tex2html2826"
  HREF="node6.html#SECTION06024200000000000000">39.4.2 Simple XML</A>
<LI><A NAME="tex2html2827"
  HREF="node6.html#SECTION06024300000000000000">39.4.3 CIM XML</A>
<LI><A NAME="tex2html2828"
  HREF="node6.html#SECTION06024400000000000000">39.4.4 CIM 1.5.1 grids XML</A>
</UL>
<LI><A NAME="tex2html2829"
  HREF="node6.html#SECTION06025000000000000000">39.5 Accessing object information through Attribute</A>
<LI><A NAME="tex2html2830"
  HREF="node6.html#SECTION06026000000000000000">39.6 Constants</A>
<UL>
<LI><A NAME="tex2html2831"
  HREF="node6.html#SECTION06026100000000000000">39.6.1 ESMF_ATTCOPY</A>
<LI><A NAME="tex2html2832"
  HREF="node6.html#SECTION06026200000000000000">39.6.2 ESMF_ATTGETCOUNT</A>
<LI><A NAME="tex2html2833"
  HREF="node6.html#SECTION06026300000000000000">39.6.3 ESMF_ATTWRITE</A>
</UL>
<LI><A NAME="tex2html2834"
  HREF="node6.html#SECTION06027000000000000000">39.7 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2835"
  HREF="node6.html#SECTION06027100000000000000">39.7.1 Basic Attribute usage</A>
<LI><A NAME="tex2html2836"
  HREF="node6.html#SECTION06027200000000000000">39.7.2 Attribute packages</A>
<LI><A NAME="tex2html2837"
  HREF="node6.html#SECTION06027300000000000000">39.7.3 Custom Attribute package</A>
<LI><A NAME="tex2html2838"
  HREF="node6.html#SECTION06027400000000000000">39.7.4 Updating Attributes in a distributed environment</A>
<LI><A NAME="tex2html2839"
  HREF="node6.html#SECTION06027500000000000000">39.7.5 Accessing object information through Attribute</A>
<LI><A NAME="tex2html2840"
  HREF="node6.html#SECTION06027600000000000000">39.7.6 CIM Attribute packages</A>
<LI><A NAME="tex2html2841"
  HREF="node6.html#SECTION06027700000000000000">39.7.7 Read an XML file-based ESG Attribute package for a Gridded Component</A>
<LI><A NAME="tex2html2842"
  HREF="node6.html#SECTION06027800000000000000">39.7.8 Read an XML file-based CF Attribute package for a Field</A>
<LI><A NAME="tex2html2843"
  HREF="node6.html#SECTION06027900000000000000">39.7.9 Read and validate an XML file-based set of user-defined Attributes for a Coupler Component</A>
</UL>
<LI><A NAME="tex2html2844"
  HREF="node6.html#SECTION06028000000000000000">39.8 Restrictions and Future Work</A>
<UL>
<LI><A NAME="tex2html2845"
  HREF="node6.html#SECTION06028100000000000000">39.8.1 Attributes</A>
<LI><A NAME="tex2html2846"
  HREF="node6.html#SECTION06028200000000000000">39.8.2 Attribute packages</A>
<LI><A NAME="tex2html2847"
  HREF="node6.html#SECTION06028300000000000000">39.8.3 Attribute hierarchies</A>
<LI><A NAME="tex2html2848"
  HREF="node6.html#SECTION06028400000000000000">39.8.4 Attribute import and export</A>
</UL>
<LI><A NAME="tex2html2849"
  HREF="node6.html#SECTION06029000000000000000">39.9 Design and Implementation Notes</A>
<UL>
<LI><A NAME="tex2html2850"
  HREF="node6.html#SECTION06029100000000000000">39.9.1 Attribute memory deallocation</A>
<LI><A NAME="tex2html2851"
  HREF="node6.html#SECTION06029200000000000000">39.9.2 Using <TT>ESMF_AttributeGet()</TT> to retrieve Attribute lists</A>
<LI><A NAME="tex2html2852"
  HREF="node6.html#SECTION06029300000000000000">39.9.3 Using Attribute package nesting capabilites</A>
<LI><A NAME="tex2html2853"
  HREF="node6.html#SECTION06029400000000000000">39.9.4 Attributes in a distributed environment</A>
<LI><A NAME="tex2html2854"
  HREF="node6.html#SECTION06029500000000000000">39.9.5 Writing Attribute packages to file</A>
<LI><A NAME="tex2html2855"
  HREF="node6.html#SECTION06029600000000000000">39.9.6 Copying Attribute hierarchies</A>
<LI><A NAME="tex2html2856"
  HREF="node6.html#SECTION06029700000000000000">39.9.7 Reading and writing Attributes from XML files</A>
<LI><A NAME="tex2html2857"
  HREF="node6.html#SECTION06029800000000000000">39.9.8 Attribute duplicates</A>
</UL>
<LI><A NAME="tex2html2858"
  HREF="node6.html#SECTION060210000000000000000">39.10 Object Model</A>
<LI><A NAME="tex2html2859"
  HREF="node6.html#SECTION060211000000000000000">39.11 Class API</A>
<UL>
<LI><A NAME="tex2html2860"
  HREF="node6.html#SECTION060211100000000000000">39.11.1 ESMF_AttributeAdd</A>
<LI><A NAME="tex2html2861"
  HREF="node6.html#SECTION060211200000000000000">39.11.2 ESMF_AttributeAdd</A>
<LI><A NAME="tex2html2862"
  HREF="node6.html#SECTION060211300000000000000">39.11.3 ESMF_AttributeAdd</A>
<LI><A NAME="tex2html2863"
  HREF="node6.html#SECTION060211400000000000000">39.11.4 ESMF_AttributeAdd</A>
<LI><A NAME="tex2html2864"
  HREF="node6.html#SECTION060211500000000000000">39.11.5 ESMF_AttributeAdd</A>
<LI><A NAME="tex2html2865"
  HREF="node6.html#SECTION060211600000000000000">39.11.6 ESMF_AttributeCopy</A>
<LI><A NAME="tex2html2866"
  HREF="node6.html#SECTION060211700000000000000">39.11.7 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2867"
  HREF="node6.html#SECTION060211800000000000000">39.11.8 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2868"
  HREF="node6.html#SECTION060211900000000000000">39.11.9 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2869"
  HREF="node6.html#SECTION0602111000000000000000">39.11.10 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2870"
  HREF="node6.html#SECTION0602111100000000000000">39.11.11 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2871"
  HREF="node6.html#SECTION0602111200000000000000">39.11.12 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2872"
  HREF="node6.html#SECTION0602111300000000000000">39.11.13 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2873"
  HREF="node6.html#SECTION0602111400000000000000">39.11.14 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2874"
  HREF="node6.html#SECTION0602111500000000000000">39.11.15 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2875"
  HREF="node6.html#SECTION0602111600000000000000">39.11.16 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2876"
  HREF="node6.html#SECTION0602111700000000000000">39.11.17 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2877"
  HREF="node6.html#SECTION0602111800000000000000">39.11.18 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2878"
  HREF="node6.html#SECTION0602111900000000000000">39.11.19 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2879"
  HREF="node6.html#SECTION0602112000000000000000">39.11.20 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2880"
  HREF="node6.html#SECTION0602112100000000000000">39.11.21 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2881"
  HREF="node6.html#SECTION0602112200000000000000">39.11.22 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2882"
  HREF="node6.html#SECTION0602112300000000000000">39.11.23 ESMF_AttributeGetAttPack</A>
<LI><A NAME="tex2html2883"
  HREF="node6.html#SECTION0602112400000000000000">39.11.24 ESMF_AttributeLink</A>
<LI><A NAME="tex2html2884"
  HREF="node6.html#SECTION0602112500000000000000">39.11.25 ESMF_AttributeLink</A>
<LI><A NAME="tex2html2885"
  HREF="node6.html#SECTION0602112600000000000000">39.11.26 ESMF_AttributeLink</A>
<LI><A NAME="tex2html2886"
  HREF="node6.html#SECTION0602112700000000000000">39.11.27 ESMF_AttributeLink</A>
<LI><A NAME="tex2html2887"
  HREF="node6.html#SECTION0602112800000000000000">39.11.28 ESMF_AttributeLink</A>
<LI><A NAME="tex2html2888"
  HREF="node6.html#SECTION0602112900000000000000">39.11.29 ESMF_AttributeLinkRemove</A>
<LI><A NAME="tex2html2889"
  HREF="node6.html#SECTION0602113000000000000000">39.11.30 ESMF_AttributeLinkRemove</A>
<LI><A NAME="tex2html2890"
  HREF="node6.html#SECTION0602113100000000000000">39.11.31 ESMF_AttributeLinkRemove</A>
<LI><A NAME="tex2html2891"
  HREF="node6.html#SECTION0602113200000000000000">39.11.32 ESMF_AttributeLinkRemove</A>
<LI><A NAME="tex2html2892"
  HREF="node6.html#SECTION0602113300000000000000">39.11.33 ESMF_AttributeLinkRemove</A>
<LI><A NAME="tex2html2893"
  HREF="node6.html#SECTION0602113400000000000000">39.11.34 ESMF_AttributeRead</A>
<LI><A NAME="tex2html2894"
  HREF="node6.html#SECTION0602113500000000000000">39.11.35 ESMF_AttributeRemove</A>
<LI><A NAME="tex2html2895"
  HREF="node6.html#SECTION0602113600000000000000">39.11.36 ESMF_AttributeRemove</A>
<LI><A NAME="tex2html2896"
  HREF="node6.html#SECTION0602113700000000000000">39.11.37 ESMF_AttributeSet</A>
<LI><A NAME="tex2html2897"
  HREF="node6.html#SECTION0602113800000000000000">39.11.38 ESMF_AttributeSet</A>
<LI><A NAME="tex2html2898"
  HREF="node6.html#SECTION0602113900000000000000">39.11.39 ESMF_AttributeSet</A>
<LI><A NAME="tex2html2899"
  HREF="node6.html#SECTION0602114000000000000000">39.11.40 ESMF_AttributeSet</A>
<LI><A NAME="tex2html2900"
  HREF="node6.html#SECTION0602114100000000000000">39.11.41 ESMF_AttributeSet</A>
<LI><A NAME="tex2html2901"
  HREF="node6.html#SECTION0602114200000000000000">39.11.42 ESMF_AttributeSet</A>
<LI><A NAME="tex2html2902"
  HREF="node6.html#SECTION0602114300000000000000">39.11.43 ESMF_AttributeUpdate</A>
<LI><A NAME="tex2html2903"
  HREF="node6.html#SECTION0602114400000000000000">39.11.44 ESMF_AttributeWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html2904"
  HREF="node6.html#SECTION06030000000000000000">40 Time Manager Utility</A>
<UL>
<LI><A NAME="tex2html2905"
  HREF="node6.html#SECTION06031000000000000000">40.1 Time Manager Classes</A>
<LI><A NAME="tex2html2906"
  HREF="node6.html#SECTION06032000000000000000">40.2 Calendar</A>
<LI><A NAME="tex2html2907"
  HREF="node6.html#SECTION06033000000000000000">40.3 Time Instants and TimeIntervals</A>
<LI><A NAME="tex2html2908"
  HREF="node6.html#SECTION06034000000000000000">40.4 Clocks and Alarms</A>
<LI><A NAME="tex2html2909"
  HREF="node6.html#SECTION06035000000000000000">40.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html2910"
  HREF="node6.html#SECTION06036000000000000000">40.6 Object Model</A>
</UL>
<LI><A NAME="tex2html2911"
  HREF="node6.html#SECTION06040000000000000000">41 Calendar Class</A>
<UL>
<LI><A NAME="tex2html2912"
  HREF="node6.html#SECTION06041000000000000000">41.1 Description</A>
<LI><A NAME="tex2html2913"
  HREF="node6.html#SECTION06042000000000000000">41.2 Constants</A>
<UL>
<LI><A NAME="tex2html2914"
  HREF="node6.html#SECTION06042100000000000000">41.2.1 ESMF_CALKIND</A>
</UL>
<LI><A NAME="tex2html2915"
  HREF="node6.html#SECTION06043000000000000000">41.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2916"
  HREF="node6.html#SECTION06043100000000000000">41.3.1 Calendar creation</A>
<LI><A NAME="tex2html2917"
  HREF="node6.html#SECTION06043200000000000000">41.3.2 Calendar comparison</A>
<LI><A NAME="tex2html2918"
  HREF="node6.html#SECTION06043300000000000000">41.3.3 Time conversion between Calendars</A>
<LI><A NAME="tex2html2919"
  HREF="node6.html#SECTION06043400000000000000">41.3.4 Add a time interval to a time on a Calendar</A>
<LI><A NAME="tex2html2920"
  HREF="node6.html#SECTION06043500000000000000">41.3.5 Calendar destruction</A>
</UL>
<LI><A NAME="tex2html2921"
  HREF="node6.html#SECTION06044000000000000000">41.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html2922"
  HREF="node6.html#SECTION06045000000000000000">41.5 Class API</A>
<UL>
<LI><A NAME="tex2html2923"
  HREF="node6.html#SECTION06045100000000000000">41.5.1 ESMF_CalendarAssignment(=)</A>
<LI><A NAME="tex2html2924"
  HREF="node6.html#SECTION06045200000000000000">41.5.2 ESMF_CalendarOperator(==)</A>
<LI><A NAME="tex2html2925"
  HREF="node6.html#SECTION06045300000000000000">41.5.3 ESMF_CalendarOperator(/=)</A>
<LI><A NAME="tex2html2926"
  HREF="node6.html#SECTION06045400000000000000">41.5.4 ESMF_CalendarCreate</A>
<LI><A NAME="tex2html2927"
  HREF="node6.html#SECTION06045500000000000000">41.5.5 ESMF_CalendarCreate</A>
<LI><A NAME="tex2html2928"
  HREF="node6.html#SECTION06045600000000000000">41.5.6 ESMF_CalendarCreate</A>
<LI><A NAME="tex2html2929"
  HREF="node6.html#SECTION06045700000000000000">41.5.7 ESMF_CalendarDestroy</A>
<LI><A NAME="tex2html2930"
  HREF="node6.html#SECTION06045800000000000000">41.5.8 ESMF_CalendarGet</A>
<LI><A NAME="tex2html2931"
  HREF="node6.html#SECTION06045900000000000000">41.5.9 ESMF_CalendarIsCreated</A>
<LI><A NAME="tex2html2932"
  HREF="node6.html#SECTION060451000000000000000">41.5.10 ESMF_CalendarIsLeapYear</A>
<LI><A NAME="tex2html2933"
  HREF="node6.html#SECTION060451100000000000000">41.5.11 ESMF_CalendarPrint</A>
<LI><A NAME="tex2html2934"
  HREF="node6.html#SECTION060451200000000000000">41.5.12 ESMF_CalendarSet</A>
<LI><A NAME="tex2html2935"
  HREF="node6.html#SECTION060451300000000000000">41.5.13 ESMF_CalendarSet</A>
<LI><A NAME="tex2html2936"
  HREF="node6.html#SECTION060451400000000000000">41.5.14 ESMF_CalendarSetDefault</A>
<LI><A NAME="tex2html2937"
  HREF="node6.html#SECTION060451500000000000000">41.5.15 ESMF_CalendarSetDefault</A>
<LI><A NAME="tex2html2938"
  HREF="node6.html#SECTION060451600000000000000">41.5.16 ESMF_CalendarValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2939"
  HREF="node6.html#SECTION06050000000000000000">42 Time Class</A>
<UL>
<LI><A NAME="tex2html2940"
  HREF="node6.html#SECTION06051000000000000000">42.1 Description</A>
<LI><A NAME="tex2html2941"
  HREF="node6.html#SECTION06052000000000000000">42.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2942"
  HREF="node6.html#SECTION06052100000000000000">42.2.1 Time initialization</A>
<LI><A NAME="tex2html2943"
  HREF="node6.html#SECTION06052200000000000000">42.2.2 Time increment</A>
<LI><A NAME="tex2html2944"
  HREF="node6.html#SECTION06052300000000000000">42.2.3 Time comparison</A>
</UL>
<LI><A NAME="tex2html2945"
  HREF="node6.html#SECTION06053000000000000000">42.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html2946"
  HREF="node6.html#SECTION06054000000000000000">42.4 Class API</A>
<UL>
<LI><A NAME="tex2html2947"
  HREF="node6.html#SECTION06054100000000000000">42.4.1 ESMF_TimeAssignment(=)</A>
<LI><A NAME="tex2html2948"
  HREF="node6.html#SECTION06054200000000000000">42.4.2 ESMF_TimeOperator(+)</A>
<LI><A NAME="tex2html2949"
  HREF="node6.html#SECTION06054300000000000000">42.4.3 ESMF_TimeOperator(-)</A>
<LI><A NAME="tex2html2950"
  HREF="node6.html#SECTION06054400000000000000">42.4.4 ESMF_TimeOperator(-)</A>
<LI><A NAME="tex2html2951"
  HREF="node6.html#SECTION06054500000000000000">42.4.5 ESMF_TimeOperator(==)</A>
<LI><A NAME="tex2html2952"
  HREF="node6.html#SECTION06054600000000000000">42.4.6 ESMF_TimeOperator(/=)</A>
<LI><A NAME="tex2html2953"
  HREF="node6.html#SECTION06054700000000000000">42.4.7 ESMF_TimeOperator(&lt;)</A>
<LI><A NAME="tex2html2954"
  HREF="node6.html#SECTION06054800000000000000">42.4.8 ESMF_TimeOperator(&lt;=)</A>
<LI><A NAME="tex2html2955"
  HREF="node6.html#SECTION06054900000000000000">42.4.9 ESMF_TimeOperator(&gt;)</A>
<LI><A NAME="tex2html2956"
  HREF="node6.html#SECTION060541000000000000000">42.4.10 ESMF_TimeOperator(&gt;=)</A>
<LI><A NAME="tex2html2957"
  HREF="node6.html#SECTION060541100000000000000">42.4.11 ESMF_TimeGet</A>
<LI><A NAME="tex2html2958"
  HREF="node6.html#SECTION060541200000000000000">42.4.12 ESMF_TimeIsLeapYear</A>
<LI><A NAME="tex2html2959"
  HREF="node6.html#SECTION060541300000000000000">42.4.13 ESMF_TimeIsSameCalendar</A>
<LI><A NAME="tex2html2960"
  HREF="node6.html#SECTION060541400000000000000">42.4.14 ESMF_TimePrint</A>
<LI><A NAME="tex2html2961"
  HREF="node6.html#SECTION060541500000000000000">42.4.15 ESMF_TimeSet</A>
<LI><A NAME="tex2html2962"
  HREF="node6.html#SECTION060541600000000000000">42.4.16 ESMF_TimeSyncToRealTime</A>
<LI><A NAME="tex2html2963"
  HREF="node6.html#SECTION060541700000000000000">42.4.17 ESMF_TimeValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2964"
  HREF="node6.html#SECTION06060000000000000000">43 TimeInterval Class</A>
<UL>
<LI><A NAME="tex2html2965"
  HREF="node6.html#SECTION06061000000000000000">43.1 Description</A>
<LI><A NAME="tex2html2966"
  HREF="node6.html#SECTION06062000000000000000">43.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2967"
  HREF="node6.html#SECTION06062100000000000000">43.2.1 TimeInterval initialization</A>
<LI><A NAME="tex2html2968"
  HREF="node6.html#SECTION06062200000000000000">43.2.2 TimeInterval conversion</A>
<LI><A NAME="tex2html2969"
  HREF="node6.html#SECTION06062300000000000000">43.2.3 TimeInterval difference</A>
<LI><A NAME="tex2html2970"
  HREF="node6.html#SECTION06062400000000000000">43.2.4 TimeInterval multiplication</A>
<LI><A NAME="tex2html2971"
  HREF="node6.html#SECTION06062500000000000000">43.2.5 TimeInterval comparison</A>
</UL>
<LI><A NAME="tex2html2972"
  HREF="node6.html#SECTION06063000000000000000">43.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html2973"
  HREF="node6.html#SECTION06064000000000000000">43.4 Class API</A>
<UL>
<LI><A NAME="tex2html2974"
  HREF="node6.html#SECTION06064100000000000000">43.4.1 ESMF_TimeIntervalAssignment(=)</A>
<LI><A NAME="tex2html2975"
  HREF="node6.html#SECTION06064200000000000000">43.4.2 ESMF_TimeIntervalOperator(+)</A>
<LI><A NAME="tex2html2976"
  HREF="node6.html#SECTION06064300000000000000">43.4.3 ESMF_TimeIntervalOperator(-)</A>
<LI><A NAME="tex2html2977"
  HREF="node6.html#SECTION06064400000000000000">43.4.4 ESMF_TimeIntervalOperator(-)</A>
<LI><A NAME="tex2html2978"
  HREF="node6.html#SECTION06064500000000000000">43.4.5 ESMF_TimeIntervalOperator(/)</A>
<LI><A NAME="tex2html2979"
  HREF="node6.html#SECTION06064600000000000000">43.4.6 ESMF_TimeIntervalOperator(/)</A>
<LI><A NAME="tex2html2980"
  HREF="node6.html#SECTION06064700000000000000">43.4.7 ESMF_TimeIntervalFunction(MOD)</A>
<LI><A NAME="tex2html2981"
  HREF="node6.html#SECTION06064800000000000000">43.4.8 ESMF_TimeIntervalOperator(*)</A>
<LI><A NAME="tex2html2982"
  HREF="node6.html#SECTION06064900000000000000">43.4.9 ESMF_TimeIntervalOperator(==)</A>
<LI><A NAME="tex2html2983"
  HREF="node6.html#SECTION060641000000000000000">43.4.10 ESMF_TimeIntervalOperator(/=)</A>
<LI><A NAME="tex2html2984"
  HREF="node6.html#SECTION060641100000000000000">43.4.11 ESMF_TimeIntervalOperator(&lt;)</A>
<LI><A NAME="tex2html2985"
  HREF="node6.html#SECTION060641200000000000000">43.4.12 ESMF_TimeIntervalOperator(&lt;=)</A>
<LI><A NAME="tex2html2986"
  HREF="node6.html#SECTION060641300000000000000">43.4.13 ESMF_TimeIntervalOperator(&gt;)</A>
<LI><A NAME="tex2html2987"
  HREF="node6.html#SECTION060641400000000000000">43.4.14 ESMF_TimeIntervalOperator(&gt;=)</A>
<LI><A NAME="tex2html2988"
  HREF="node6.html#SECTION060641500000000000000">43.4.15 ESMF_TimeIntervalAbsValue</A>
<LI><A NAME="tex2html2989"
  HREF="node6.html#SECTION060641600000000000000">43.4.16 ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html2990"
  HREF="node6.html#SECTION060641700000000000000">43.4.17 ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html2991"
  HREF="node6.html#SECTION060641800000000000000">43.4.18 ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html2992"
  HREF="node6.html#SECTION060641900000000000000">43.4.19 ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html2993"
  HREF="node6.html#SECTION060642000000000000000">43.4.20 ESMF_TimeIntervalNegAbsValue</A>
<LI><A NAME="tex2html2994"
  HREF="node6.html#SECTION060642100000000000000">43.4.21 ESMF_TimeIntervalPrint</A>
<LI><A NAME="tex2html2995"
  HREF="node6.html#SECTION060642200000000000000">43.4.22 ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html2996"
  HREF="node6.html#SECTION060642300000000000000">43.4.23 ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html2997"
  HREF="node6.html#SECTION060642400000000000000">43.4.24 ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html2998"
  HREF="node6.html#SECTION060642500000000000000">43.4.25 ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html2999"
  HREF="node6.html#SECTION060642600000000000000">43.4.26 ESMF_TimeIntervalValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html3000"
  HREF="node6.html#SECTION06070000000000000000">44 Clock Class</A>
<UL>
<LI><A NAME="tex2html3001"
  HREF="node6.html#SECTION06071000000000000000">44.1 Description</A>
<LI><A NAME="tex2html3002"
  HREF="node6.html#SECTION06072000000000000000">44.2 Constants</A>
<UL>
<LI><A NAME="tex2html3003"
  HREF="node6.html#SECTION06072100000000000000">44.2.1 ESMF_DIRECTION</A>
</UL>
<LI><A NAME="tex2html3004"
  HREF="node6.html#SECTION06073000000000000000">44.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html3005"
  HREF="node6.html#SECTION06073100000000000000">44.3.1 Clock creation</A>
<LI><A NAME="tex2html3006"
  HREF="node6.html#SECTION06073200000000000000">44.3.2 Clock advance</A>
<LI><A NAME="tex2html3007"
  HREF="node6.html#SECTION06073300000000000000">44.3.3 Clock examination</A>
<LI><A NAME="tex2html3008"
  HREF="node6.html#SECTION06073400000000000000">44.3.4 Clock reversal</A>
<LI><A NAME="tex2html3009"
  HREF="node6.html#SECTION06073500000000000000">44.3.5 Clock destruction</A>
</UL>
<LI><A NAME="tex2html3010"
  HREF="node6.html#SECTION06074000000000000000">44.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html3011"
  HREF="node6.html#SECTION06075000000000000000">44.5 Class API</A>
<UL>
<LI><A NAME="tex2html3012"
  HREF="node6.html#SECTION06075100000000000000">44.5.1 ESMF_ClockAssignment(=)</A>
<LI><A NAME="tex2html3013"
  HREF="node6.html#SECTION06075200000000000000">44.5.2 ESMF_ClockOperator(==)</A>
<LI><A NAME="tex2html3014"
  HREF="node6.html#SECTION06075300000000000000">44.5.3 ESMF_ClockOperator(/=)</A>
<LI><A NAME="tex2html3015"
  HREF="node6.html#SECTION06075400000000000000">44.5.4 ESMF_ClockAdvance</A>
<LI><A NAME="tex2html3016"
  HREF="node6.html#SECTION06075500000000000000">44.5.5 ESMF_ClockCreate</A>
<LI><A NAME="tex2html3017"
  HREF="node6.html#SECTION06075600000000000000">44.5.6 ESMF_ClockCreate</A>
<LI><A NAME="tex2html3018"
  HREF="node6.html#SECTION06075700000000000000">44.5.7 ESMF_ClockDestroy</A>
<LI><A NAME="tex2html3019"
  HREF="node6.html#SECTION06075800000000000000">44.5.8 ESMF_ClockGet</A>
<LI><A NAME="tex2html3020"
  HREF="node6.html#SECTION06075900000000000000">44.5.9 ESMF_ClockGetAlarm</A>
<LI><A NAME="tex2html3021"
  HREF="node6.html#SECTION060751000000000000000">44.5.10 ESMF_ClockGetAlarmList</A>
<LI><A NAME="tex2html3022"
  HREF="node6.html#SECTION060751100000000000000">44.5.11 ESMF_ClockGetNextTime</A>
<LI><A NAME="tex2html3023"
  HREF="node6.html#SECTION060751200000000000000">44.5.12 ESMF_ClockIsCreated</A>
<LI><A NAME="tex2html3024"
  HREF="node6.html#SECTION060751300000000000000">44.5.13 ESMF_ClockIsDone</A>
<LI><A NAME="tex2html3025"
  HREF="node6.html#SECTION060751400000000000000">44.5.14 ESMF_ClockIsReverse</A>
<LI><A NAME="tex2html3026"
  HREF="node6.html#SECTION060751500000000000000">44.5.15 ESMF_ClockIsStopTime</A>
<LI><A NAME="tex2html3027"
  HREF="node6.html#SECTION060751600000000000000">44.5.16 ESMF_ClockIsStopTimeEnabled</A>
<LI><A NAME="tex2html3028"
  HREF="node6.html#SECTION060751700000000000000">44.5.17 ESMF_ClockPrint</A>
<LI><A NAME="tex2html3029"
  HREF="node6.html#SECTION060751800000000000000">44.5.18 ESMF_ClockSet</A>
<LI><A NAME="tex2html3030"
  HREF="node6.html#SECTION060751900000000000000">44.5.19 ESMF_ClockStopTimeDisable</A>
<LI><A NAME="tex2html3031"
  HREF="node6.html#SECTION060752000000000000000">44.5.20 ESMF_ClockStopTimeEnable</A>
<LI><A NAME="tex2html3032"
  HREF="node6.html#SECTION060752100000000000000">44.5.21 ESMF_ClockSyncToRealTime</A>
<LI><A NAME="tex2html3033"
  HREF="node6.html#SECTION060752200000000000000">44.5.22 ESMF_ClockValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html3034"
  HREF="node6.html#SECTION06080000000000000000">45 Alarm Class</A>
<UL>
<LI><A NAME="tex2html3035"
  HREF="node6.html#SECTION06081000000000000000">45.1 Description</A>
<LI><A NAME="tex2html3036"
  HREF="node6.html#SECTION06082000000000000000">45.2 Constants</A>
<UL>
<LI><A NAME="tex2html3037"
  HREF="node6.html#SECTION06082100000000000000">45.2.1 ESMF_ALARMLIST</A>
</UL>
<LI><A NAME="tex2html3038"
  HREF="node6.html#SECTION06083000000000000000">45.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html3039"
  HREF="node6.html#SECTION06083100000000000000">45.3.1 Clock initialization</A>
<LI><A NAME="tex2html3040"
  HREF="node6.html#SECTION06083200000000000000">45.3.2 Alarm initialization</A>
<LI><A NAME="tex2html3041"
  HREF="node6.html#SECTION06083300000000000000">45.3.3 Clock advance and Alarm processing</A>
<LI><A NAME="tex2html3042"
  HREF="node6.html#SECTION06083400000000000000">45.3.4 Alarm and Clock destruction</A>
</UL>
<LI><A NAME="tex2html3043"
  HREF="node6.html#SECTION06084000000000000000">45.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html3044"
  HREF="node6.html#SECTION06085000000000000000">45.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html3045"
  HREF="node6.html#SECTION06086000000000000000">45.6 Class API</A>
<UL>
<LI><A NAME="tex2html3046"
  HREF="node6.html#SECTION06086100000000000000">45.6.1 ESMF_AlarmAssignment(=)</A>
<LI><A NAME="tex2html3047"
  HREF="node6.html#SECTION06086200000000000000">45.6.2 ESMF_AlarmOperator(==)</A>
<LI><A NAME="tex2html3048"
  HREF="node6.html#SECTION06086300000000000000">45.6.3 ESMF_AlarmOperator(/=)</A>
<LI><A NAME="tex2html3049"
  HREF="node6.html#SECTION06086400000000000000">45.6.4 ESMF_AlarmCreate</A>
<LI><A NAME="tex2html3050"
  HREF="node6.html#SECTION06086500000000000000">45.6.5 ESMF_AlarmCreate</A>
<LI><A NAME="tex2html3051"
  HREF="node6.html#SECTION06086600000000000000">45.6.6 ESMF_AlarmDestroy</A>
<LI><A NAME="tex2html3052"
  HREF="node6.html#SECTION06086700000000000000">45.6.7 ESMF_AlarmDisable</A>
<LI><A NAME="tex2html3053"
  HREF="node6.html#SECTION06086800000000000000">45.6.8 ESMF_AlarmEnable</A>
<LI><A NAME="tex2html3054"
  HREF="node6.html#SECTION06086900000000000000">45.6.9 ESMF_AlarmGet</A>
<LI><A NAME="tex2html3055"
  HREF="node6.html#SECTION060861000000000000000">45.6.10 ESMF_AlarmIsCreated</A>
<LI><A NAME="tex2html3056"
  HREF="node6.html#SECTION060861100000000000000">45.6.11 ESMF_AlarmIsEnabled</A>
<LI><A NAME="tex2html3057"
  HREF="node6.html#SECTION060861200000000000000">45.6.12 ESMF_AlarmIsRinging</A>
<LI><A NAME="tex2html3058"
  HREF="node6.html#SECTION060861300000000000000">45.6.13 ESMF_AlarmIsSticky</A>
<LI><A NAME="tex2html3059"
  HREF="node6.html#SECTION060861400000000000000">45.6.14 ESMF_AlarmNotSticky</A>
<LI><A NAME="tex2html3060"
  HREF="node6.html#SECTION060861500000000000000">45.6.15 ESMF_AlarmPrint</A>
<LI><A NAME="tex2html3061"
  HREF="node6.html#SECTION060861600000000000000">45.6.16 ESMF_AlarmRingerOff</A>
<LI><A NAME="tex2html3062"
  HREF="node6.html#SECTION060861700000000000000">45.6.17 ESMF_AlarmRingerOn</A>
<LI><A NAME="tex2html3063"
  HREF="node6.html#SECTION060861800000000000000">45.6.18 ESMF_AlarmSet</A>
<LI><A NAME="tex2html3064"
  HREF="node6.html#SECTION060861900000000000000">45.6.19 ESMF_AlarmSticky</A>
<LI><A NAME="tex2html3065"
  HREF="node6.html#SECTION060862000000000000000">45.6.20 ESMF_AlarmValidate</A>
<LI><A NAME="tex2html3066"
  HREF="node6.html#SECTION060862100000000000000">45.6.21 ESMF_AlarmWasPrevRinging</A>
<LI><A NAME="tex2html3067"
  HREF="node6.html#SECTION060862200000000000000">45.6.22 ESMF_AlarmWillRingNext</A>
</UL>
</UL>
<LI><A NAME="tex2html3068"
  HREF="node6.html#SECTION06090000000000000000">46 Config Class</A>
<UL>
<LI><A NAME="tex2html3069"
  HREF="node6.html#SECTION06091000000000000000">46.1 Description</A>
<UL>
<LI><A NAME="tex2html3070"
  HREF="node6.html#SECTION06091100000000000000">46.1.1 Package history</A>
<LI><A NAME="tex2html3071"
  HREF="node6.html#SECTION06091200000000000000">46.1.2 Resource files</A>
</UL>
<LI><A NAME="tex2html3072"
  HREF="node6.html#SECTION06092000000000000000">46.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html3073"
  HREF="node6.html#SECTION06092100000000000000">46.2.1 Variable declarations</A>
<LI><A NAME="tex2html3074"
  HREF="node6.html#SECTION06092200000000000000">46.2.2 Creation of a Config</A>
<LI><A NAME="tex2html3075"
  HREF="node6.html#SECTION06092300000000000000">46.2.3 How to retrieve a label with a single value</A>
<LI><A NAME="tex2html3076"
  HREF="node6.html#SECTION06092400000000000000">46.2.4 How to retrieve a label with multiple values</A>
<LI><A NAME="tex2html3077"
  HREF="node6.html#SECTION06092500000000000000">46.2.5 How to retrieve a table</A>
<LI><A NAME="tex2html3078"
  HREF="node6.html#SECTION06092600000000000000">46.2.6 Destruction of a Config</A>
</UL>
<LI><A NAME="tex2html3079"
  HREF="node6.html#SECTION06093000000000000000">46.3 Class API</A>
<UL>
<LI><A NAME="tex2html3080"
  HREF="node6.html#SECTION06093100000000000000">46.3.1 ESMF_ConfigAssignment(=)</A>
<LI><A NAME="tex2html3081"
  HREF="node6.html#SECTION06093200000000000000">46.3.2 ESMF_ConfigOperator(==)</A>
<LI><A NAME="tex2html3082"
  HREF="node6.html#SECTION06093300000000000000">46.3.3 ESMF_ConfigOperator(/=)</A>
<LI><A NAME="tex2html3083"
  HREF="node6.html#SECTION06093400000000000000">46.3.4 ESMF_ConfigCreate</A>
<LI><A NAME="tex2html3084"
  HREF="node6.html#SECTION06093500000000000000">46.3.5 ESMF_ConfigCreate</A>
<LI><A NAME="tex2html3085"
  HREF="node6.html#SECTION06093600000000000000">46.3.6 ESMF_ConfigDestroy</A>
<LI><A NAME="tex2html3086"
  HREF="node6.html#SECTION06093700000000000000">46.3.7 ESMF_ConfigFindLabel</A>
<LI><A NAME="tex2html3087"
  HREF="node6.html#SECTION06093800000000000000">46.3.8 ESMF_ConfigFindNextLabel</A>
<LI><A NAME="tex2html3088"
  HREF="node6.html#SECTION06093900000000000000">46.3.9 ESMF_ConfigGetAttribute</A>
<LI><A NAME="tex2html3089"
  HREF="node6.html#SECTION060931000000000000000">46.3.10 ESMF_ConfigGetAttribute</A>
<LI><A NAME="tex2html3090"
  HREF="node6.html#SECTION060931100000000000000">46.3.11 ESMF_ConfigGetChar</A>
<LI><A NAME="tex2html3091"
  HREF="node6.html#SECTION060931200000000000000">46.3.12 ESMF_ConfigGetDim</A>
<LI><A NAME="tex2html3092"
  HREF="node6.html#SECTION060931300000000000000">46.3.13 ESMF_ConfigGetLen</A>
<LI><A NAME="tex2html3093"
  HREF="node6.html#SECTION060931400000000000000">46.3.14 ESMF_ConfigIsCreated</A>
<LI><A NAME="tex2html3094"
  HREF="node6.html#SECTION060931500000000000000">46.3.15 ESMF_ConfigLoadFile</A>
<LI><A NAME="tex2html3095"
  HREF="node6.html#SECTION060931600000000000000">46.3.16 ESMF_ConfigNextLine</A>
<LI><A NAME="tex2html3096"
  HREF="node6.html#SECTION060931700000000000000">46.3.17 ESMF_ConfigPrint</A>
<LI><A NAME="tex2html3097"
  HREF="node6.html#SECTION060931800000000000000">46.3.18 ESMF_ConfigSetAttribute</A>
<LI><A NAME="tex2html3098"
  HREF="node6.html#SECTION060931900000000000000">46.3.19 ESMF_ConfigValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html3099"
  HREF="node6.html#SECTION060100000000000000000">47 Log Class</A>
<UL>
<LI><A NAME="tex2html3100"
  HREF="node6.html#SECTION060101000000000000000">47.1 Description</A>
<LI><A NAME="tex2html3101"
  HREF="node6.html#SECTION060102000000000000000">47.2 Constants</A>
<UL>
<LI><A NAME="tex2html3102"
  HREF="node6.html#SECTION060102100000000000000">47.2.1 ESMF_LOGERR</A>
<LI><A NAME="tex2html3103"
  HREF="node6.html#SECTION060102200000000000000">47.2.2 ESMF_LOGKIND</A>
<LI><A NAME="tex2html3104"
  HREF="node6.html#SECTION060102300000000000000">47.2.3 ESMF_LOGMSG</A>
</UL>
<LI><A NAME="tex2html3105"
  HREF="node6.html#SECTION060103000000000000000">47.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html3106"
  HREF="node6.html#SECTION060103100000000000000">47.3.1 Default Log</A>
<LI><A NAME="tex2html3107"
  HREF="node6.html#SECTION060103200000000000000">47.3.2 User created Log</A>
<LI><A NAME="tex2html3108"
  HREF="node6.html#SECTION060103300000000000000">47.3.3 Get and Set</A>
</UL>
<LI><A NAME="tex2html3109"
  HREF="node6.html#SECTION060104000000000000000">47.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html3110"
  HREF="node6.html#SECTION060105000000000000000">47.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html3111"
  HREF="node6.html#SECTION060106000000000000000">47.6 Object Model</A>
<LI><A NAME="tex2html3112"
  HREF="node6.html#SECTION060107000000000000000">47.7 Class API</A>
<UL>
<LI><A NAME="tex2html3113"
  HREF="node6.html#SECTION060107100000000000000">47.7.1 ESMF_LogAssignment(=)</A>
<LI><A NAME="tex2html3114"
  HREF="node6.html#SECTION060107200000000000000">47.7.2 ESMF_LogOperator(==)</A>
<LI><A NAME="tex2html3115"
  HREF="node6.html#SECTION060107300000000000000">47.7.3 ESMF_LogOperator(/=)</A>
<LI><A NAME="tex2html3116"
  HREF="node6.html#SECTION060107400000000000000">47.7.4 ESMF_LogClose</A>
<LI><A NAME="tex2html3117"
  HREF="node6.html#SECTION060107500000000000000">47.7.5 ESMF_LogFlush</A>
<LI><A NAME="tex2html3118"
  HREF="node6.html#SECTION060107600000000000000">47.7.6 ESMF_LogFoundAllocError</A>
<LI><A NAME="tex2html3119"
  HREF="node6.html#SECTION060107700000000000000">47.7.7 ESMF_LogFoundDeallocError</A>
<LI><A NAME="tex2html3120"
  HREF="node6.html#SECTION060107800000000000000">47.7.8 ESMF_LogFoundError</A>
<LI><A NAME="tex2html3121"
  HREF="node6.html#SECTION060107900000000000000">47.7.9 ESMF_LogFoundNetCDFError</A>
<LI><A NAME="tex2html3122"
  HREF="node6.html#SECTION0601071000000000000000">47.7.10 ESMF_LogGet</A>
<LI><A NAME="tex2html3123"
  HREF="node6.html#SECTION0601071100000000000000">47.7.11 ESMF_LogOpen</A>
<LI><A NAME="tex2html3124"
  HREF="node6.html#SECTION0601071200000000000000">47.7.12 ESMF_LogOpen</A>
<LI><A NAME="tex2html3125"
  HREF="node6.html#SECTION0601071300000000000000">47.7.13 ESMF_LogSet</A>
<LI><A NAME="tex2html3126"
  HREF="node6.html#SECTION0601071400000000000000">47.7.14 ESMF_LogSetError</A>
<LI><A NAME="tex2html3127"
  HREF="node6.html#SECTION0601071500000000000000">47.7.15 ESMF_LogWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html3128"
  HREF="node6.html#SECTION060110000000000000000">48 DELayout Class</A>
<UL>
<LI><A NAME="tex2html3129"
  HREF="node6.html#SECTION060111000000000000000">48.1 Description</A>
<LI><A NAME="tex2html3130"
  HREF="node6.html#SECTION060112000000000000000">48.2 Constants</A>
<UL>
<LI><A NAME="tex2html3131"
  HREF="node6.html#SECTION060112100000000000000">48.2.1 ESMF_PIN</A>
<LI><A NAME="tex2html3132"
  HREF="node6.html#SECTION060112200000000000000">48.2.2 ESMF_SERVICEREPLY</A>
</UL>
<LI><A NAME="tex2html3133"
  HREF="node6.html#SECTION060113000000000000000">48.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html3134"
  HREF="node6.html#SECTION060113100000000000000">48.3.1 Default DELayout</A>
<LI><A NAME="tex2html3135"
  HREF="node6.html#SECTION060113200000000000000">48.3.2 DELayout with specified number of DEs</A>
<LI><A NAME="tex2html3136"
  HREF="node6.html#SECTION060113300000000000000">48.3.3 DELayout with computational and communication weights</A>
<LI><A NAME="tex2html3137"
  HREF="node6.html#SECTION060113400000000000000">48.3.4 DELayout from petMap</A>
<LI><A NAME="tex2html3138"
  HREF="node6.html#SECTION060113500000000000000">48.3.5 DELayout from petMap with multiple DEs per PET</A>
<LI><A NAME="tex2html3139"
  HREF="node6.html#SECTION060113600000000000000">48.3.6 Working with a DELayout - simple 1-to-1 DE-to-PET mapping</A>
<LI><A NAME="tex2html3140"
  HREF="node6.html#SECTION060113700000000000000">48.3.7 Working with a DELayout - general DE-to-PET mapping</A>
<LI><A NAME="tex2html3141"
  HREF="node6.html#SECTION060113800000000000000">48.3.8 Work queue dynamic load balancing</A>
</UL>
<LI><A NAME="tex2html3142"
  HREF="node6.html#SECTION060114000000000000000">48.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html3143"
  HREF="node6.html#SECTION060115000000000000000">48.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html3144"
  HREF="node6.html#SECTION060116000000000000000">48.6 Class API</A>
<UL>
<LI><A NAME="tex2html3145"
  HREF="node6.html#SECTION060116100000000000000">48.6.1 ESMF_DELayoutAssignment(=)</A>
<LI><A NAME="tex2html3146"
  HREF="node6.html#SECTION060116200000000000000">48.6.2 ESMF_DELayoutOperator(==)</A>
<LI><A NAME="tex2html3147"
  HREF="node6.html#SECTION060116300000000000000">48.6.3 ESMF_DELayoutOperator(/=)</A>
<LI><A NAME="tex2html3148"
  HREF="node6.html#SECTION060116400000000000000">48.6.4 ESMF_DELayoutCreate</A>
<LI><A NAME="tex2html3149"
  HREF="node6.html#SECTION060116500000000000000">48.6.5 ESMF_DELayoutCreate</A>
<LI><A NAME="tex2html3150"
  HREF="node6.html#SECTION060116600000000000000">48.6.6 ESMF_DELayoutDestroy</A>
<LI><A NAME="tex2html3151"
  HREF="node6.html#SECTION060116700000000000000">48.6.7 ESMF_DELayoutGet</A>
<LI><A NAME="tex2html3152"
  HREF="node6.html#SECTION060116800000000000000">48.6.8 ESMF_DELayoutIsCreated</A>
<LI><A NAME="tex2html3153"
  HREF="node6.html#SECTION060116900000000000000">48.6.9 ESMF_DELayoutPrint</A>
<LI><A NAME="tex2html3154"
  HREF="node6.html#SECTION0601161000000000000000">48.6.10 ESMF_DELayoutServiceComplete</A>
<LI><A NAME="tex2html3155"
  HREF="node6.html#SECTION0601161100000000000000">48.6.11 ESMF_DELayoutServiceOffer</A>
<LI><A NAME="tex2html3156"
  HREF="node6.html#SECTION0601161200000000000000">48.6.12 ESMF_DELayoutValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html3157"
  HREF="node6.html#SECTION060120000000000000000">49 VM Class</A>
<UL>
<LI><A NAME="tex2html3158"
  HREF="node6.html#SECTION060121000000000000000">49.1 Description</A>
<LI><A NAME="tex2html3159"
  HREF="node6.html#SECTION060122000000000000000">49.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html3160"
  HREF="node6.html#SECTION060122100000000000000">49.2.1 Global VM</A>
<LI><A NAME="tex2html3161"
  HREF="node6.html#SECTION060122200000000000000">49.2.2 Getting the MPI Communicator from an VM object</A>
<LI><A NAME="tex2html3162"
  HREF="node6.html#SECTION060122300000000000000">49.2.3 Nesting ESMF inside a user MPI application</A>
<LI><A NAME="tex2html3163"
  HREF="node6.html#SECTION060122400000000000000">49.2.4 Nesting ESMF inside a user MPI application on a subset of MPI ranks</A>
<LI><A NAME="tex2html3164"
  HREF="node6.html#SECTION060122500000000000000">49.2.5 Multiple concurrent instances of ESMF under separate MPI communicators</A>
<LI><A NAME="tex2html3165"
  HREF="node6.html#SECTION060122600000000000000">49.2.6 VM and Components</A>
<LI><A NAME="tex2html3166"
  HREF="node6.html#SECTION060122700000000000000">49.2.7 Communication - Send and Recv</A>
<LI><A NAME="tex2html3167"
  HREF="node6.html#SECTION060122800000000000000">49.2.8 Communication - Scatter and Gather</A>
<LI><A NAME="tex2html3168"
  HREF="node6.html#SECTION060122900000000000000">49.2.9 Communication - AllReduce and AllFullReduce</A>
<LI><A NAME="tex2html3169"
  HREF="node6.html#SECTION0601221000000000000000">49.2.10 Using VM communication methods with data of rank greater than one</A>
</UL>
<LI><A NAME="tex2html3170"
  HREF="node6.html#SECTION060123000000000000000">49.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html3171"
  HREF="node6.html#SECTION060124000000000000000">49.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html3172"
  HREF="node6.html#SECTION060125000000000000000">49.5 Class API</A>
<UL>
<LI><A NAME="tex2html3173"
  HREF="node6.html#SECTION060125100000000000000">49.5.1 ESMF_VMAssignment(=)</A>
<LI><A NAME="tex2html3174"
  HREF="node6.html#SECTION060125200000000000000">49.5.2 ESMF_VMOperator(==)</A>
<LI><A NAME="tex2html3175"
  HREF="node6.html#SECTION060125300000000000000">49.5.3 ESMF_VMOperator(/=)</A>
<LI><A NAME="tex2html3176"
  HREF="node6.html#SECTION060125400000000000000">49.5.4 ESMF_VMAllFullReduce</A>
<LI><A NAME="tex2html3177"
  HREF="node6.html#SECTION060125500000000000000">49.5.5 ESMF_VMAllGather</A>
<LI><A NAME="tex2html3178"
  HREF="node6.html#SECTION060125600000000000000">49.5.6 ESMF_VMAllGatherV</A>
<LI><A NAME="tex2html3179"
  HREF="node6.html#SECTION060125700000000000000">49.5.7 ESMF_VMAllReduce</A>
<LI><A NAME="tex2html3180"
  HREF="node6.html#SECTION060125800000000000000">49.5.8 ESMF_VMAllToAll</A>
<LI><A NAME="tex2html3181"
  HREF="node6.html#SECTION060125900000000000000">49.5.9 ESMF_VMAllToAllV</A>
<LI><A NAME="tex2html3182"
  HREF="node6.html#SECTION0601251000000000000000">49.5.10 ESMF_VMBarrier</A>
<LI><A NAME="tex2html3183"
  HREF="node6.html#SECTION0601251100000000000000">49.5.11 ESMF_VMBroadcast</A>
<LI><A NAME="tex2html3184"
  HREF="node6.html#SECTION0601251200000000000000">49.5.12 ESMF_VMCommWait</A>
<LI><A NAME="tex2html3185"
  HREF="node6.html#SECTION0601251300000000000000">49.5.13 ESMF_VMCommWaitAll</A>
<LI><A NAME="tex2html3186"
  HREF="node6.html#SECTION0601251400000000000000">49.5.14 ESMF_VMGather</A>
<LI><A NAME="tex2html3187"
  HREF="node6.html#SECTION0601251500000000000000">49.5.15 ESMF_VMGatherV</A>
<LI><A NAME="tex2html3188"
  HREF="node6.html#SECTION0601251600000000000000">49.5.16 ESMF_VMGet</A>
<LI><A NAME="tex2html3189"
  HREF="node6.html#SECTION0601251700000000000000">49.5.17 ESMF_VMGet</A>
<LI><A NAME="tex2html3190"
  HREF="node6.html#SECTION0601251800000000000000">49.5.18 ESMF_VMGetGlobal</A>
<LI><A NAME="tex2html3191"
  HREF="node6.html#SECTION0601251900000000000000">49.5.19 ESMF_VMGetCurrent</A>
<LI><A NAME="tex2html3192"
  HREF="node6.html#SECTION0601252000000000000000">49.5.20 ESMF_VMIsCreated</A>
<LI><A NAME="tex2html3193"
  HREF="node6.html#SECTION0601252100000000000000">49.5.21 ESMF_VMPrint</A>
<LI><A NAME="tex2html3194"
  HREF="node6.html#SECTION0601252200000000000000">49.5.22 ESMF_VMRecv</A>
<LI><A NAME="tex2html3195"
  HREF="node6.html#SECTION0601252300000000000000">49.5.23 ESMF_VMReduce</A>
<LI><A NAME="tex2html3196"
  HREF="node6.html#SECTION0601252400000000000000">49.5.24 ESMF_VMScatter</A>
<LI><A NAME="tex2html3197"
  HREF="node6.html#SECTION0601252500000000000000">49.5.25 ESMF_VMScatterV</A>
<LI><A NAME="tex2html3198"
  HREF="node6.html#SECTION0601252600000000000000">49.5.26 ESMF_VMSend</A>
<LI><A NAME="tex2html3199"
  HREF="node6.html#SECTION0601252700000000000000">49.5.27 ESMF_VMSendRecv</A>
<LI><A NAME="tex2html3200"
  HREF="node6.html#SECTION0601252800000000000000">49.5.28 ESMF_VMValidate</A>
<LI><A NAME="tex2html3201"
  HREF="node6.html#SECTION0601252900000000000000">49.5.29 ESMF_VMWtime</A>
<LI><A NAME="tex2html3202"
  HREF="node6.html#SECTION0601253000000000000000">49.5.30 ESMF_VMWtimeDelay</A>
<LI><A NAME="tex2html3203"
  HREF="node6.html#SECTION0601253100000000000000">49.5.31 ESMF_VMWtimePrec</A>
</UL>
</UL>
<LI><A NAME="tex2html3204"
  HREF="node6.html#SECTION060130000000000000000">50 Profiling and Tracing</A>
<UL>
<LI><A NAME="tex2html3205"
  HREF="node6.html#SECTION060131000000000000000">50.1 Description</A>
<UL>
<LI><A NAME="tex2html3206"
  HREF="node6.html#SECTION060131100000000000000">50.1.1 Profiling</A>
<LI><A NAME="tex2html3207"
  HREF="node6.html#SECTION060131200000000000000">50.1.2 Tracing</A>
</UL>
<LI><A NAME="tex2html3208"
  HREF="node6.html#SECTION060132000000000000000">50.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html3209"
  HREF="node6.html#SECTION060132100000000000000">50.2.1 Output a Timing Profile to Text</A>
<LI><A NAME="tex2html3210"
  HREF="node6.html#SECTION060132200000000000000">50.2.2 Summarize Timings across Multiple PETs</A>
<LI><A NAME="tex2html3211"
  HREF="node6.html#SECTION060132300000000000000">50.2.3 Limit the Set of Profiled PETs</A>
<LI><A NAME="tex2html3212"
  HREF="node6.html#SECTION060132400000000000000">50.2.4 Include MPI Communication in the Profile</A>
<LI><A NAME="tex2html3213"
  HREF="node6.html#SECTION060132500000000000000">50.2.5 Output a Detailed Trace for Analysis</A>
<LI><A NAME="tex2html3214"
  HREF="node6.html#SECTION060132600000000000000">50.2.6 Set the Clock used for Profiling/Tracing</A>
<LI><A NAME="tex2html3215"
  HREF="node6.html#SECTION060132700000000000000">50.2.7 Tracing a simple ESMF application</A>
<LI><A NAME="tex2html3216"
  HREF="node6.html#SECTION060132800000000000000">50.2.8 Profiling/Tracing User-defined Code Regions</A>
</UL>
<LI><A NAME="tex2html3217"
  HREF="node6.html#SECTION060133000000000000000">50.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html3218"
  HREF="node6.html#SECTION060134000000000000000">50.4 Class API</A>
<UL>
<LI><A NAME="tex2html3219"
  HREF="node6.html#SECTION060134100000000000000">50.4.1 ESMF_TraceRegionEnter</A>
<LI><A NAME="tex2html3220"
  HREF="node6.html#SECTION060134200000000000000">50.4.2 ESMF_TraceRegionExit</A>
</UL>
</UL>
<LI><A NAME="tex2html3221"
  HREF="node6.html#SECTION060140000000000000000">51 Fortran I/O and System Utilities</A>
<UL>
<LI><A NAME="tex2html3222"
  HREF="node6.html#SECTION060141000000000000000">51.1 Description</A>
<LI><A NAME="tex2html3223"
  HREF="node6.html#SECTION060142000000000000000">51.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html3224"
  HREF="node6.html#SECTION060142100000000000000">51.2.1 Fortran unit number management</A>
<LI><A NAME="tex2html3225"
  HREF="node6.html#SECTION060142200000000000000">51.2.2 Flushing output</A>
</UL>
<LI><A NAME="tex2html3226"
  HREF="node6.html#SECTION060143000000000000000">51.3 Design and Implementation Notes</A>
<UL>
<LI><A NAME="tex2html3227"
  HREF="node6.html#SECTION060143100000000000000">51.3.1 Fortran unit number management</A>
<LI><A NAME="tex2html3228"
  HREF="node6.html#SECTION060143200000000000000">51.3.2 Flushing output</A>
<LI><A NAME="tex2html3229"
  HREF="node6.html#SECTION060143300000000000000">51.3.3 Sorting algorithms</A>
</UL>
<LI><A NAME="tex2html3230"
  HREF="node6.html#SECTION060144000000000000000">51.4 Utility API</A>
<UL>
<LI><A NAME="tex2html3231"
  HREF="node6.html#SECTION060144100000000000000">51.4.1 ESMF_UtilGetArg</A>
<LI><A NAME="tex2html3232"
  HREF="node6.html#SECTION060144200000000000000">51.4.2 ESMF_UtilGetArgC</A>
<LI><A NAME="tex2html3233"
  HREF="node6.html#SECTION060144300000000000000">51.4.3 ESMF_UtilGetArgIndex</A>
<LI><A NAME="tex2html3234"
  HREF="node6.html#SECTION060144400000000000000">51.4.4 ESMF_UtilIOGetCWD</A>
<LI><A NAME="tex2html3235"
  HREF="node6.html#SECTION060144500000000000000">51.4.5 ESMF_UtilIOMkDir</A>
<LI><A NAME="tex2html3236"
  HREF="node6.html#SECTION060144600000000000000">51.4.6 ESMF_UtilIORmDir</A>
<LI><A NAME="tex2html3237"
  HREF="node6.html#SECTION060144700000000000000">51.4.7 ESMF_UtilString2Double</A>
<LI><A NAME="tex2html3238"
  HREF="node6.html#SECTION060144800000000000000">51.4.8 ESMF_UtilString2Int</A>
<LI><A NAME="tex2html3239"
  HREF="node6.html#SECTION060144900000000000000">51.4.9 ESMF_UtilString2Real</A>
<LI><A NAME="tex2html3240"
  HREF="node6.html#SECTION0601441000000000000000">51.4.10 ESMF_UtilStringInt2String</A>
<LI><A NAME="tex2html3241"
  HREF="node6.html#SECTION0601441100000000000000">51.4.11 ESMF_UtilStringLowerCase</A>
<LI><A NAME="tex2html3242"
  HREF="node6.html#SECTION0601441200000000000000">51.4.12 ESMF_UtilStringUpperCase</A>
<LI><A NAME="tex2html3243"
  HREF="node6.html#SECTION0601441300000000000000">51.4.13 ESMF_UtilIOUnitFlush</A>
<LI><A NAME="tex2html3244"
  HREF="node6.html#SECTION0601441400000000000000">51.4.14 ESMF_UtilIOUnitGet</A>
<LI><A NAME="tex2html3245"
  HREF="node6.html#SECTION0601441500000000000000">51.4.15 ESMF_UtilSort</A>
</UL></UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION06000000000000000000">
5 Infrastructure: Utilities</A>
</H1>


<P>

<H1><A NAME="SECTION06010000000000000000">
38 Overview of Infrastructure Utility Classes</A>
</H1>

<P>
The ESMF utilities are a set of tools for quickly assembling modeling applications.

<P>
The ESMF Attribute class enables models to be self-describing via metadata, which are instances of Attribute name-value pairs.

<P>
The Time Management Library provides utilities for time and time interval representation and calculation, and higher-level utilities that control model time stepping, via clocks, as well as alarming.

<P>
The ESMF Config class provides configuration management based on NASA DAO's Inpak package, a collection of methods for accessing files containing input parameters stored in an ASCII format.

<P>
The ESMF LogErr class consists of a variety of methods for writing error, warning, and informational messages to log files. A default Log is created during ESMF initialization. Other Logs can be created later in the code by the user.

<P>
The DELayout class provides a layer of abstraction on top of the Virtual Machine (VM) layer. DELayout does this by introducing DEs (Decomposition Elements) as logical resource units. The DELayout object keeps track of the relationship between its DEs and the resources of the associated VM object. A DELayout can be shaped by the user at creation time to best match the computational problem or other design criteria.

<P>
The ESMF VM (Virtual Machine) class is a generic representation of hardware and system software resources. There is exactly one VM object per ESMF Component, providing the execution environment for the Component code. The VM class handles all resource management tasks for the Component class and provides a description of the underlying configuration of the compute resources used by a Component.  In addition to resource description and management, the VM class offers the lowest level of ESMF communication methods.

<P>
The ESMF Fortran I/O utilities provide portable methods to access capabilities which are often implemented in different ways amongst different environments. Currently, two utility methods are implemented: one to find an unopened unit number, and one to flush an I/O buffer.

<H1><A NAME="SECTION06020000000000000000">
39 Attribute Class</A>
</H1>

<H2><A NAME="SECTION06021000000000000000">
39.1 Description</A>
</H2>

<P>
The ESMF Attribute class is a metadata utility that supports emerging standards 
in a flexible way.  The Attribute class is useful for documenting data 
provenance and encourages models to be more self describing.  Attributes can 
also be used to automate some aspects of model execution and coupling.

<P>
Metadata, which is data about data, is broken down into 
name-value pairs by the Attribute class.  Attributes can be attached at any 
level of the ESMF object hierarchy, and in some cases the Attributes of 
different ESMF objects can be linked together to form 
a corresponding Attribute hierarchy.  Attribute hierarchies are linked up
automatically for the most part, with the exception of links between Components 
and between a Component and a State.  Attribute hierarchies can also be 
unlinked, copied, and moved around as needed.

<P>
ESMF Attribute packages 
are used to aggregate, store, and output model metadata.  They can be 
nested inside each other to make larger organized packages, distributed across 
processors and updated at runtime, and expanded to suit specific needs.  The
ESMF-supplied  
Attribute packages are designed around accepted metadata conventions, such as: 
climate and forecast (CF) [<A
 HREF="node8.html#ref:cf">11</A>], ISO standards [<A
 HREF="node8.html#ref:iso">2</A>], and the METAFOR Common Information Model (CIM) [<A
 HREF="node8.html#ref:cim">3</A>] [<A
 HREF="node8.html#ref:esdoccim">8</A>].

<P>
Most of the ESMF deep objects can host Attributes, and   
every object that can hold individual Attributes can also hold
Attribute packages.  Attribute hierarchies are supported for a majority of
the Attribute bearing classes.  
More information on the various Attribute 
capabilities, and the classes for which they are supported appear in the
following sections.

<P>
Reading Attribute XML files requires the Xerces C++ library, v3.1.0 
or better.  For more details, see the "ESMF Users Guide", "Building and 
Installing the ESMF, Third Party Libraries, Xerces".  Writing Attribute XML 
files is performed with the standard C++ output file stream facility.

<P>

<H3><A NAME="SECTION06021100000000000000">
39.1.1 Schemas and Controlled Vocabularies</A>
</H3>

<P>
There are two pieces to the information stored in Attributes.  One piece
is the property name and type, and its relation to other properties; this
is the schema.  The other piece is the range of values that are valid for
a particular property; this is the controlled vocabulary.  For many
information models, including the Common Information Model (CIM), these two
pieces are managed and versioned separately.

<P>
ESMF implements the appropriate schema internally; it translates the Attributes
as specified in the Attribute packages into the correct format based on the
convention and purpose as specified in arguments to most Attribute functions.
The controlled vocabularies, or Attribute values, however, are not controlled
or validated within ESMF.

<P>

<H3><A NAME="SECTION06021200000000000000">
39.1.2 The Common Information Model (CIM)</A>
</H3>

<P>
The CIM is a formal model of the climate modeling process developed by
the European Union's <A NAME="tex2html62"
  HREF="http://metaforclimate.eu/">METAFOR</A>
project.  The <A NAME="tex2html63"
  HREF="http://earthsystemcog.org/projects/es-doc-models/">Earth System - Documentation (ES-DOC)</A>
project
is an evolution of the METAFOR project, and they provide a detailed
description of the CIM <A NAME="tex2html64"
  HREF="http://earthsystemcog.org/projects/es-doc-models/cim">here</A>.

<P>
ESMF is currently implementing only a subset of version 1.5 of the CIM, though this representation is expected to grow.

<P>
<B>Mapping Attributes to the CIM</B>

<P>
The ESMF Attribute packages provide a structure for the Attributes that
are useful for climate modelers.  When the <TT>ESMF_AttributeWrite()</TT>
function is
called with "CIM" XML specified as the target, ESMF translates these package
structures into a format defined by the CIM schema.  The package descriptions
in the following sections provide a mapping from the ESMF Attribute name
to the CIM schema field.

<P>
For example, in the CIM Main Attribute Package, the Attribute named
"LongName" is mapped to the CIM schema field,
"software:SoftwareComponent:longName":

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><B>Controlled Vocabulary</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=213><B>CIM Schema Field <BR>(&lt;CIM section&gt;:&lt;Entity&gt;:&lt;Field&gt;)</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><TT>LongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>A version of the component name with all acronyms spelled out.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=213>software:SoftwareComponent:longName</TD>
</TR>
</TABLE>
<BR>
<P>
There are 3 parts to this mapping:

<P>

<UL>
<LI><B>&lt;CIM section&gt;</B> = "software"
</LI>
<LI><B>&lt;Entity&gt;</B> = "SoftwareComponent"
</LI>
<LI><B>&lt;Field&gt;</B> = "longName"
</LI>
</UL>

<P>
The CIM section refers to the categories, or subsections, of the CIM
mentioned above.  In this example, the CIM section is "software".  To find
this section in the CIM schema repository, go to the
<A NAME="tex2html65"
  HREF="http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5/">CIM repository</A>
and then select the "software" drop down (see Figure <A HREF="#fig:CIMRepository">33</A> ).

<P>

<DIV ALIGN="CENTER"><A NAME="fig:CIMRepository"></A><A NAME="71733"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 33:</STRONG>
The software section of the CIM repository</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><IMG
 WIDTH="725" HEIGHT="349" ALIGN="BOTTOM" BORDER="0"
 SRC="img191.png"
 ALT="\includegraphics[width=160mm]{CIMRepository}">
</DIV></TD></TR>
</TABLE>
</DIV>

<P>
You can view the schema graphically in a UML diagram by selecting the
software.png file and then visually search the picture for the
SoftwareComponent entity.
However, this view does not provide field details, such as type and
description.  Alternatively, you can select the software.xsd file, and
then search the XML for the entity, "SoftwareComponent," and the field,
"longName," which will provide the details for this field (see Figure <A HREF="#fig:LongNameXSD">34</A> ).

<P>

<DIV ALIGN="CENTER"><A NAME="fig:LongNameXSD"></A><A NAME="71739"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 34:</STRONG>
The longName Field in the CIM software XSD file</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><IMG
 WIDTH="725" HEIGHT="349" ALIGN="BOTTOM" BORDER="0"
 SRC="img192.png"
 ALT="\includegraphics[width=160mm]{LongNameXSD}">
</DIV></TD></TR>
</TABLE>
</DIV>

<P>
As the ES-DOC team continues its work, more tools will be provided to support
CIM implementations.  Currently, a more user-friendly way to view the CIM
schema is available through the ``CONCIM'' sections on <A NAME="tex2html66"
  HREF="https://www.earthsystemcog.org/projects/es-doc-models/cim_versions">this page</A>.

<P>

<H3><A NAME="SECTION06021300000000000000">
39.1.3 The ESMF approach to Attributes</A>
</H3>

<P>
ESMF's approach to Attributes can be summarized as follows:

<P>

<UL>
<LI>Implement community standards where they exist.
</LI>
<LI>Associate Attributes with the ESMF object they describe. Currently, the following ESMF objects can have Attributes:
  
<UL>
<LI>CplComp
</LI>
<LI>GridComp
</LI>
<LI>State
</LI>
<LI>FieldBundle
</LI>
<LI>Field
</LI>
<LI>ArrayBundle
</LI>
<LI>Array
</LI>
<LI>Grid
</LI>
<LI>DistGrid
     
</LI>
</UL>
</LI>
<LI>Establish pre-defined Attribute packages (see Section <A HREF="#sec:AttPacks">39.2</A>) to make Attribute creation easier for the user.
</LI>
<LI>Allow for user-defined custom Attribute packages (see Section <A HREF="#sec:CustomAttPacks">39.2.7</A>).
</LI>
<LI>Enable the nesting of Attribute packages (see Section <A HREF="#sec:AttPackNesting">39.3</A>) including Custom packages.
</LI>
<LI>Enable complex Attribute hierarchies (see Section <A HREF="#sec:AttHier">39.1.4</A>.
</LI>
<LI>Export Attributes in more than one format (see Section <A HREF="#sec:AttributeExports">39.4</A>).
</LI>
<LI>Ensure that all Attributes are consistent across the entire virtual machine of the object to which they are attached.
</LI>
</UL>

<P>

<H3><A NAME="SECTION06021400000000000000"></A>
<A NAME="sec:AttHier"></A>
<BR>
39.1.4 Attribute hierarchies
</H3>

<P>
Of the ESMF objects with Attributes, only some can link their Attributes together in an Attribute hierarchy.  These objects are:

<P>

<UL>
<LI>CplComp
</LI>
<LI>GridComp
</LI>
<LI>State
</LI>
<LI>FieldBundle
</LI>
<LI>Field
</LI>
<LI>ArrayBundle
</LI>
<LI>Array
</LI>
</UL>

<P>
Every ESMF deep object is given a <TT>root</TT> Attribute on creation.
These <TT>root</TT> Attributes serve as the attachment point for all metadata that 
is stored on a particular ESMF object, including all Attributes and
Attribute packages.  The <TT>root</TT> Attributes can also be connected together via 
the <TT>ESMF_AttributeLink()</TT> functionality.  This happens automatically in most 
cases, such as when a Field is added to a FieldBundle, and results
in the formation of an Attribute hierarchy which mirrors the structure 
of the underlying object hierarchy.  

<P>
When two Attribute hierarchies are linked together 
the objects are given read-only access to each other's Attributes.
To ensure consistency across a distributed system, 
there can only ever be one set of Attributes associated with each ESMF object.  
This implies that a copy operation on an ESMF object Attribute hierarchy <I>can</I> 
use a value copy for all Attributes which are owned by the object being copied, 
but <I>must</I> use a reference copy for all Attributes which the object can 
access (through links) but does NOT own. See section <A HREF="#sec:Att:Copy">39.9.6</A> for more
details on this concept.

<P>
The most common use for this hierarchy capability is for linking the Attributes 
of a Field to the FieldBundle which holds it, which is then linked to the 
State that is used to transport all of the data for a Component.  All of 
these links, with the exception of the link between the Component and the 
State, are automatically handled by ESMF. Additionally, the State will 
automatically set a <TT>VariableIntent</TT> Attribute for Field when that Field 
is added to the State.  <TT>VariableIntent</TT> will be set to either 
<TT>Export</TT> or <TT>Import</TT>.

<H2><A NAME="SECTION06022000000000000000">
39.2 Attribute Packages</A>
</H2>

<P>
<A NAME="sec:AttPacks"></A>
<P>
At this time, all ESMF objects which are enabled to contain Attributes can also contain Attribute packages, which are groupings of individual Attributes.  Every Attribute package is specified by a unique set of identifiers.  These are called the <B>convention</B> and <B>purpose</B> of the Attribute package, such as "CF" and "General" (see below).  These are used to validate ESMF Attribute packages against existing metadata conventions.  The <B>attPackInstanceName</B> can be used to differentiate between Attributes of the same name within a package. 

<P>
The user can choose to use an ESMF pre-defined Attribute package, specify their own Attribute package, or add customized Attributes to any of the ESMF pre-defined Attribute packages. Currently, the creation and setting of Attribute packages is quite involved, but future development with I/O will allow for a more automated approach to populating Attribute packages from a file.  This is already possible via <TT>ESMF_AttributeRead()</TT> for the ESMF/CF Attribute packages supplied by ESMF, as well as for custom individual Attributes not in a package.

<P>
The standard Attribute packages supplied by ESMF exist for the following ESMF objects:

<P>

<UL>
<LI>CplComp
</LI>
<LI>GridComp
</LI>
<LI>State
</LI>
<LI>Field
</LI>
<LI>Array
</LI>
<LI>Grid
</LI>
</UL>

<P>
The packages described in this section are grouped by the ESMF object they apply to. The creation of custom attributes and custom attribute packages is also possible and is discussed in Section <A HREF="#sec:CustomAttPacks">39.2.7</A>. In some cases it is possible to nest custom packages on top of ESMF packages. Attribute package nesting is described separately in Section <A HREF="#sec:AttPackNesting">39.3</A>.

<P>
Some Attributes come with a controlled vocabulary. A controlled vocabulary is a list of options that can be selected as the value of the attribute. The controlled vocabularies listed in this documentation represent those chosen by the community. They are not exhaustive and users may set these Attributes to a different value if they so choose. The primary consequence of doing so is that the resulting output may not be recognized by any of the online tools being developed with respect to this controlled vocabulary.

<P>

<H3><A NAME="SECTION06022100000000000000"></A>
<A NAME="ComponentAttributePackages"></A>
<BR>
39.2.1 Component Attribute packages
</H3>

<P>
There are many attributes that are used to describe components. There are currently 4 predefined component-level Attribute packages, with sub-packages defined for the 2nd:

<P>

<OL>
<LI>Earth System Modeling Framework (ESMF) General
</LI>
<LI>Common Information Model (CIM) Main
    
<OL>
<LI>Common Information Model (CIM) Platform
</LI>
<LI>International Organization for Standardization (ISO) Responsible Party
</LI>
<LI>International Organization for Standardization (ISO) Citation
    
</LI>
</OL>
</LI>
<LI>Common Information Model (CIM) Scientific Properties
</LI>
<LI>Common Information Model (CIM) Component Properties
</LI>
</OL>

<P>
<BR>
<BR>

<P>
<B>1. Earth System Modeling Framework (ESMF) General Attribute Package</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "ESMF"
</LI>
<LI><TT>purpose</TT> = "General"
    
</LI>
</UL>
</LI>
<LI>Output Options:
    
<UL>
<LI>Simple XML
    
</LI>
</UL>
</LI>
<LI>Description: This package contains several Attributes used to describe model components within the Earth System Modeling Framework (ESMF) ontology.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Agency</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An administrative unit of government.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>DoD, DOE, DOI, NASA, NOAA, NSF</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Author</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The person who created the content of a book, article, or other source.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>CodingLanguage</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The computer language in which a unit of software is written.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>C, C++, F77, F90, Java</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ComponentLongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of a model, model component, simulation, experiment, or dataset with all acronyms spelled out.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ComponentShortName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A version of the component name that contains acronyms.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Discipline</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A subject, theme, category, or general area of interest.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>Aerosol, Fisheries, Climate, Carbon Cycle, Hydrology, Land, Ocean, Polar, Sediment, Storm Surge, Turbulence, Weather, Wave, Weather Prediction</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Institution</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An organization associated with a model component, simulation, or dataset.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ModelComponentFramework</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The software package or mechanism used to transfer and transform data between model components.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>CCA, ESMF, Flume, FMS, OASIS, SWMF</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>PhysicalDomain</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A description of the geographic range being simulated.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>Atmosphere, Earth System, Ice, Lake, Land Ocean, River</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Version</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A specific form or variation of an artifact, i.e. a unit of software or metadata.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>
<B>2. Common Information Model (CIM) Main Attribute Package</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "CIM 1.5"
</LI>
<LI><TT>purpose</TT> = "ModelComp"
    
</LI>
</UL>
</LI>
<LI>CIM Version: CIM 1.5
</LI>
<LI>CIM URL: <A NAME="tex2html70"
  HREF="http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5/">http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5/</A>
</LI>
<LI>Includes:
    
<UL>
<LI>CIM Platform
</LI>
<LI>ISO Responsible Party (1 or more - user specifiable)
</LI>
<LI>ISO Citation (1 or more - user specifiable)
    
</LI>
</UL>
</LI>
<LI>Output Options:
    
<UL>
<LI>CIM XML
    
</LI>
</UL>
</LI>
<LI>Description: The CIM Main Package contains several standalone properties used to describe components. It also serves as the anchor to which other CIM packages are nested. Presently, these additional CIM packages (described further below) can only be created if the CIM Main Package is created. In the future, these packages will be decoupled, so that users may select subsections of the CIM to create and use. This package nests three of the packages below within it; this is described in Section <A HREF="#sec:AttPackNesting">39.3</A>.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><B>Controlled Vocabulary</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><B>CIM Schema Field (&lt;CIM section&gt;:&lt;Entity&gt;:&lt;Field&gt;)</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>Description</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>A multi-line description of the component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:SoftwareComponent:description</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>LongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>A version of the component name with all acronyms spelled out.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:SoftwareComponent:longName</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>MetadataVersion***</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The version number of the simulation metadata.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:modelComponent:metadataVersion</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ModelType*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>A short string describing the discipline of a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>Advection, Aerosol3D-Sources etc.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:ModelComponent:type</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>PreviousVersion**</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Name of the previous version of a model or model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Reference:name</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>PreviousVersionDescription**</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>A short note about the previous version of the model or model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Relationship:description</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ReleaseDate</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The date a model component was issued.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:SoftwareComponent:releaseDate</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ShortName*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>A version of the component name that contains acronyms.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:SoftwareComponent:shortName</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>SimulationDuration</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The length of time a simulation runs.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>activity:SimulationRun:dateRange</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>SimulationEndDate</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The date in simulated time of the end of a model simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>activity:SimulationRun:dateRange</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>SimulationEnsembleID</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The reference name or number of the ensemble to which a simulation belongs.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>activity:EnsembleMember:ensembleMemberID</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>SimulationLongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The name of the simulation with any acronyms spelled out.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>activity:NumericalActivity:longName</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>SimulationNumberOfProcessing Elements</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The number of PEs used in the simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:Parallelization:processes</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>SimulationProjectName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>A campaign, such as a model intercomparison project, that may involve multiple groups and experiments.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>activity:Activity:project</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>SimulationRationale</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The reason for performing a simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>activity:Activity:rationale</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>SimulationShortName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The name of the simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>activity:NumericalActivity:shortName</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>SimulationStartDate*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The date in simulated time of the start of a model simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>activity:SimulationRun:dateRange</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>URL</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>A URL associated with a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:CI_OnlineResource:linkage</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>Version</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Version number of the component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>appended to software:SoftwareComponent:shortName</TD>
</TR>
</TABLE>
 * Attribute required to be set to produce valid CIM XML output. 
<BR> ** If PreviousVersionDescription is set, PreviousVersion must also be set, to produce valid CIM XML output. 
<BR> *** If not set, defaults to 1.0

<P>
<BR>
<BR>

<P>
<B>2.1. CIM Platform Attribute Package</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "CIM 1.5"
</LI>
<LI><TT>purpose</TT> = "Platform"
    
</LI>
</UL>
</LI>
<LI>CIM Version: CIM 1.5
</LI>
<LI>CIM URL: <A NAME="tex2html71"
  HREF="http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5/">http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5/</A>
</LI>
<LI>Output Options:
    
<UL>
<LI>CIM XML
    
</LI>
</UL>
</LI>
<LI>Description: This package describes the platform a particular simulation is run on. It must be created in conjunction with the CIM Main Package (see above). This package is nested within the CIM Main Package (above); see the description in Section <A HREF="#sec:AttPackNesting">39.3</A>.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><B>Controlled Vocabulary</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><B>CIM Schema Field <BR>(&lt;CIM section&gt;:&lt;Entity&gt;:&lt;Field&gt;)</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>CompilerName**</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71>The brand of the software that takes source code and turns it into an executable.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Absoft, Default, Intel, Lahey, NAG, Pathscale, PGI, PGIGCC, XLF, XLFGCC</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Compiler:compilerName</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>CompilerVersion**</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71>The specific configuration value of the software used to take source code and turn it into executable code.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Compiler:compilerVersion</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineCoresPerProcessor</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71>The number of sub-divided elements or mini-chips on a computer chip.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Machine:machineCoresPerProcessor</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineDescription</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71>A short note about the machine.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Machine:machineDescription</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineInterconnectType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71>The technology used to associate each node in a supercomputer with every other node.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Cray Interconnect, Fat Tree, Gigabit Ethernet, Infiniband, Mixed, Myrinet, Numalink, Quadrics, SP Switch</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Machine:machineInterconnect</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineMaximumProcessors</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71>The highest number of computer chips on a computer system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Machine:machineMaximumProcessors</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineName*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71>The name given to a computer by its system administrators. This is not the brand name of the system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Machine:machineName</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineOperatingSystem</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71>The software that is responsible for the management and coordination of activities and the sharing of resources of a computer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Aix, Darwin, Irix64, Linux, SUNOS, Unicos</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Machine:machineOperatingSystem</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineProcessorType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71>The type of computer chip used in a particular computer platform.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Altix, AMD x86-64, Bluegene, G4, G5, Intel EM64T, Intel IA-64, Itanium, NEC, Opteron, Origin3800, Pentium 3, Pentium 4, SP, SPARC, X1, Xeon, XT3-4, ZX6000</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Machine:machineProcessorType</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineSystem</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71>The type of computer system (e.g. vector, parallel, cluster, etc.).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Beowulf, Parallel, Vector</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Machine:machineSystem</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineVendor</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=71>The brand name of a computer system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ACS, Action, Appro International, Bull SA, Cray Inc, Dalco AG Switzerland, Dawning, Dell, Fujitsu, Hitachi, HP, IBM, Intel, Koi Computers, Lenovo, Mac, NEC, NEC SUN, NUDT, PC, Pyramid Computer, Raytheon-Aspen Systems, Self Made, SGI, Sun Microsystems, T-platforms</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:Machine:machineVendor</TD>
</TR>
</TABLE>
* Attribute required to be set to produce valid CIM XML output. 
<BR>** Both CompilerName and CompilerVersion are required to be set, or else neither one, to produce valid CIM XML output; setting one without the other will produce invalid CIM XML output.

<P>
<BR>
<BR>

<P>
<B>2.2. ISO Responsible Party Attribute Package</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "ISO 19115"
</LI>
<LI><TT>purpose</TT> = "RespParty"
    
</LI>
</UL>
</LI>
<LI>Output Options:
    
<UL>
<LI>CIM XML
    
</LI>
</UL>
</LI>
<LI>Description: This package is used to describe contacts, authors, institutions, and funding agencies. This package is nested, with one or more user-specifiable instances, within the CIM Main Package(above); see the description in Section <A HREF="#sec:AttPackNesting">39.3</A>.
</LI>
<LI>Usage: The Responsible Party package is unique in that the user should first select the type of Responsible Party they wish to define. This is done via the ResponsiblePartyRole attribute within the package. Then the package's main value is set using the Name attribute.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><B>Controlled Vocabulary</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><B>CIM Schema Field (&lt;CIM section&gt;:&lt;Entity&gt;:&lt;Field&gt;)</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>Abbreviation</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>The abbreviation of an individual or organization associated with a model component or simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:ResponsibleParty:abbreviation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>EmailAddress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>The email address that others can use to ask questions about a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:CI_Address:electronicMailAddress</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>Name</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>The name of an author, contact, funder, centre, or principal investigator.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:CI_ResponsibleParty:individualName, shared:CI_ResponsibleParty:organisationName, shared:CI_ResponsibleParty:positionName (depending on NameType value)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>NameType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>The type of entity that Name references.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Individual, Organization, Position</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>Not part of CIM; used to determine which CIM field to use for Name</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>PhysicalAddress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>The address of the person designated to provide information about a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:CI_Address:deliveryPoint</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>ResponsiblePartyRole*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>A flag to define the role of the Responsible Party.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Author, PI, Contact, Center, Funder</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:CI_ResponsibleParty:role</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><TT>URL</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>A URL of an individual or organization.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:CI_OnlineResource:linkage</TD>
</TR>
</TABLE>
* Attribute required to be set, when any other attributes in this package are set, to produce valid CIM XML output. It is valid to set none of the attributes in this package. In that case, no corresponding CIM XML output will appear for that Responsible Party package instance, although there may be other populated instances, which, because they have attributes set, will appear in the output.

<P>
<B>2.3. ISO Citation Attribute Package</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "ISO 19115"
</LI>
<LI><TT>purpose</TT> = "Citation"
    
</LI>
</UL>
</LI>
<LI>Output Options:
    
<UL>
<LI>CIM XML
    
</LI>
</UL>
</LI>
<LI>Description: This package is used to describe references. Examples include a URL or a scientific reference.  This package is nested, with one or more user-specifiable instances, within the CIM Main Package (above); see the description in Section <A HREF="#sec:AttPackNesting">39.3</A>.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><B>Controlled Vocabulary</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><B>CIM Schema Field (&lt;CIM section&gt;:&lt;Entity&gt;:&lt;Field&gt;)</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>Date*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>The date of the citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:CI_Citation:Date</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>DOI</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>The assigned Digital Object Identifier (DOI) of the citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:CI_Citation:otherCitationDetails</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>LongTitle</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>The text of the citation or pointer (e.g. URL) that further describes a model component or simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:CI_Citation:collectiveTitle</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>PresentationForm</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>A description of the type of citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>documentDigital, documentHardcopy, imageDigital, imageHardcopy, mapDigital, mapHardcopy, modelDigital, modelHardcopy, profileDigital, profileHardcopy, tableDigital, tableHardcopy, videoDigital, videoHardcopy</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:CI_Citation:presentationForm</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>ShortTitle*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>An abbreviation for the citation.  This could be the short scientific citation (e.g. Murphy, 2009) or the title of a web page.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>shared:CI_Citation:title</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>URL</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Website associated with the citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>appended to shared:CI_Citation:collectiveTitle</TD>
</TR>
</TABLE>
* Attribute required to be set, when any other attributes in this package are set, to produce valid CIM XML output. It is valid to set none of the attributes in this package. In that case, no corresponding CIM XML output will appear for that Citation package instance, although there may be other populated instances, which, because they have attributes set, will appear in the output.

<P>
<BR>
<BR>

<P>
<B>3. Common Information Model (CIM) Scientific Properties Package</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "CIM 1.5"
</LI>
<LI><TT>purpose</TT> = "SciProp"
    
</LI>
</UL>
</LI>
<LI>CIM Version: CIM 1.5
</LI>
<LI>CIM URL: <A NAME="tex2html72"
  HREF="http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5/">http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5/</A>
</LI>
<LI>CV Version: 1.3
</LI>
<LI>CV URL: <A NAME="tex2html73"
  HREF="http://metaforclimate.eu/trac/browser/cmip5q/tags/version-1.3/trunk/cmip5q/cmip5q/data/mindmaps">http://metaforclimate.eu/trac/browser/cmip5q/tags/version-1.3/trunk/cmip5q/cmip5q/data/mindmaps</A>
</LI>
<LI>Output Options:
    
<UL>
<LI>CIM XML
    
</LI>
</UL>
</LI>
<LI>Description: This package is used to describe the scientific properties of a component.  The names and values of these properties are part of controlled vocabularies; the recommended version of the controlled vocabulary in the timeframe of this ESMF release is located in a set of mindmap files, located <A NAME="tex2html74"
  HREF="http://metaforclimate.eu/trac/browser/cmip5q/tags/version-1.3/trunk/cmip5q/cmip5q/data/mindmaps">here</A>.  This is the controlled vocabulary that was used for the <A NAME="tex2html75"
  HREF="http://q.cmip5.ceda.ac.uk/">5th Coupled Model Intercomparison Project</A>.  One or more values can be set (via an array) for a property name.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><B>Controlled Vocabulary</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><B>CIM Schema Field (&lt;CIM section&gt;:&lt;Entity&gt;:&lt;Field&gt;)</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>&lt;Scientific property name&gt;</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>&lt;METAFOR definition&gt;.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><A NAME="tex2html67"
  HREF="http://metaforclimate.eu/trac/browser/cmip5q/tags/version-1.3/trunk/cmip5q/cmip5q/data/mindmaps">METAFOR</A>
<A NAME="tex2html68"
  HREF="http://metaforclimate.eu/trac/browser/cmip5q/tags/version-1.3/trunk/cmip5q/cmip5q/data/mindmaps">mindmap</A>
<A NAME="tex2html69"
  HREF="http://metaforclimate.eu/trac/browser/cmip5q/tags/version-1.3/trunk/cmip5q/cmip5q/data/mindmaps">files</A>.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:SoftwareComponent: scientificProperties</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>
<B>4. Common Information Model (CIM) Component Properties Package</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "CIM 1.5"
</LI>
<LI><TT>purpose</TT> = "CompProp"
    
</LI>
</UL>
</LI>
<LI>CIM Version: CIM 1.5
</LI>
<LI>CIM URL: <A NAME="tex2html76"
  HREF="http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5/">http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5/</A>
</LI>
<LI>Output Options:
    
<UL>
<LI>CIM XML
    
</LI>
</UL>
</LI>
<LI>Description: This package is used to specify any number of custom, user-defined attributes of a component and have them output in valid CIM XML format.  This differs from the scientific properties package above in that the names and values are custom, not part of any controlled vocabulary.  It also differs from a custom attribute package (see Section <A HREF="#sec:CustomAttPacks">39.2.7</A>) in that this package has a standard convention and purpose, which is used to control the output of the user-defined attributes in standard CIM XML format.  One or more values can be set (via an array) for an attribute name.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><B>Controlled Vocabulary</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><B>CIM Schema Field (&lt;CIM section&gt;:&lt;Entity&gt;:&lt;Field&gt;)</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>&lt;User-defined name&gt;</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>&lt;User-defined definition&gt;.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:SoftwareComponent: componentProperties</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022200000000000000"></A>
<A NAME="StateAttributePackages"></A>
<BR>
39.2.2 State Attribute packages
</H3>

<P>
There is currently only 1 predefined State-level Attribute package:

<P>

<OL>
<LI>ESMF General
</LI>
</OL>

<P>
<BR>
<BR>
<B>1. ESMF General State Attribute Package</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "ESMF"
</LI>
<LI><TT>purpose</TT> = "General"
    
</LI>
</UL>
</LI>
<LI>Output Options:
    
<UL>
<LI>Tab-delimited
</LI>
<LI>Simple XML
    
</LI>
</UL>
</LI>
<LI>Description: This package is used to define whether an ESMF State object is an Import State or Export State.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name </B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Intent</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An indication of whether a state is imported into or exported from a particular model component. This refers to coupling, and not history output.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Export,Import</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022300000000000000"></A>
<A NAME="FieldAttributePackages"></A>
<BR>
39.2.3 Field Attribute packages
</H3>

<P>
Several standards exist to describe fields. There are currently 4 predefined Field-level Attribute packages:

<P>

<OL>
<LI>Common Information Model (CIM) Inputs
</LI>
<LI>Earth System Modeling Framework (ESMF) General
</LI>
<LI>Climate Forecast (CF) Convention Extended
</LI>
<LI>Climate Forecast (CF) Convention General
</LI>
</OL>

<P>
<BR>
<BR>

<P>
<B>1. Common Information Model (CIM) Inputs</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "CIM 1.5"
</LI>
<LI><TT>purpose</TT> = "Inputs"
    
</LI>
</UL>
</LI>
<LI>CIM Version: CIM 1.5
</LI>
<LI>CIM URL: <A NAME="tex2html77"
  HREF="http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5/">http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5/</A>
</LI>
<LI>Includes:
    
<UL>
<LI>ESMF General
</LI>
<LI>CF Extended
</LI>
<LI>CF General
    
</LI>
</UL>
</LI>
<LI>Output Options:
    
<UL>
<LI>CIM XML
    
</LI>
</UL>
</LI>
<LI>Description: This package is used to describe a simulation and the input (initial and boundary) conditions used in that simulation. It is also used to describe any ancillary data sets that contain input condition variables. This package should not be used to describe the variables in an unconfigured model component. A pre-defined Attribute package for that case will be implemented in a future release of ESMF.  This package nests the ESMF General, CF Extended, and CF General Field packages (below) within it; this is described in Section <A HREF="#sec:AttPackNesting">39.3</A>.  The attribute values within these ESMF and CF nested packages currently appear in the Component Properties section of the CIM output file.  A separate Component Properties package may be developed for this purpose in a future ESMF release.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><B>Controlled Vocabulary</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184><B>CIM Schema Field (&lt;CIM section&gt;:&lt;Entity&gt;:&lt;Field&gt;)</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>CouplingPurpose*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The form of the input condition (e.g. initial condition or boundary condition).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Ancillary, Boundary, Initial</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:Coupling:purpose</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>CouplingSource*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The component the input condition is coming from.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:Coupling:couplingSource</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>CouplingTarget*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The component the input condition is going to.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:Coupling:couplingTarget</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>Description</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>A multi-line description of the input.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:Coupling:description</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>Frequency</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The frequency (e.g. 2 months or 5 days) that a field from one component is input to another.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>n Seconds, n Minutes, n Hours, n Days, n Months, n Years, n Decades, n Centuries</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:Timing:rate</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>SpatialRegriddingMethod</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Method used to interpolate a field from one grid (source grid) to another (target grid).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Linear, Near-Neighbor, Cubic, Conservative-First-Order, Conservative-Second-Order, Conservative, Non-Conservative</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:SpatialRegridding: spatialRegriddingStandardMethod</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>SpatialRegriddingDimension</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Dimension of the regridding method.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>1D, 2D, 3D</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:SpatialRegridding: spatialRegriddingDimension</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>Technique</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>The software package or mechanism used to transfer and transform data between model components.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CCSM Flux Coupler, ESMF, Files, FMS, MCT, OASIS3, Shared</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=156><TT>TimeTransformationType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Temporal transformation performed on the input field before or after regridding onto the target grid.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Exact, None, Time Accumulation, Time Average, Time Interpolation</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=184>software:TimeTransformation:mappingType</TD>
</TR>
</TABLE>
* Attribute required to be set, when any other attributes in this package are set, to produce valid CIM XML output. It is valid to set none of the attributes in this package. In that case, no corresponding CIM XML output will appear for that Inputs package.

<P>
<BR>
<BR>

<P>
<B>2. Earth System Modeling Framework (ESMF) Field</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "ESMF"
</LI>
<LI><TT>purpose</TT> = "General"
    
</LI>
</UL>
</LI>
<LI>Includes:
    
<UL>
<LI>CF Extended
</LI>
<LI>CF General
    
</LI>
</UL>
</LI>
<LI>Output Options:
    
<UL>
<LI>Tab-delimited
</LI>
<LI>Simple XML
</LI>
<LI>CIM XML (when part of the CIM Inputs package)
    
</LI>
</UL>
</LI>
<LI>Description: This package nests the CF Extended and CF General packages (below) within it; this is described in Section <A HREF="#sec:AttPackNesting">39.3</A>.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name </B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Intent</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An indication of whether a variable is exported or imported. This refers to coupling and not history output.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>Export,Import</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>
<B>3. Climate Forecast (CF) Convention Extended</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "CF"
</LI>
<LI><TT>purpose</TT> = "Extended"
    
</LI>
</UL>
</LI>
<LI>Includes:
    
<UL>
<LI>CF General
    
</LI>
</UL>
</LI>
<LI>Output Options:
    
<UL>
<LI>Tab-delimited
</LI>
<LI>Simple XML
</LI>
<LI>CIM XML (when part of the CIM Inputs package)
    
</LI>
</UL>
</LI>
<LI>Description: The CF standard for fields contains an optional standard_name Attribute. Standard names are controlled vocabularies and not every variable in the earth system sciences contains a standard name. Because of this, ESMF implemented this optional Attribute in its own package. This package nests the CF General package (below) within it; this is described in Section <A HREF="#sec:AttPackNesting">39.3</A>.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name </B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>StandardName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The approved CF standard name for a variable if it exists.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>
<B>4. Climate Forecast (CF) Convention General</B>

<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "CF"
</LI>
<LI><TT>purpose</TT> = "General"
    
</LI>
</UL>
</LI>
<LI>Output Options:
    
<UL>
<LI>Tab-delimited
</LI>
<LI>Simple XML
</LI>
<LI>CIM XML (when part of the CIM Inputs package)
    
</LI>
</UL>
</LI>
<LI>Description: The climate and forecast (CF) convention contains metadata that is designed to promote the processing and sharing of files created with the NetCDF API. The CF conventions are increasingly gaining acceptance and have been adopted by a number of projects and groups as a primary standard. The conventions define metadata that provide a definitive description of what the data in each variable represents, and the spatial and temporal properties of the data. This enables users of data from different sources to decide which quantities are comparable, and facilitates building applications with powerful extraction, regridding, and display capabilities. The ESMF CF Attribute package contains the three mandatory Attributes required to describe fields.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name </B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>LongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An ad-hoc long descriptive name which may, for example, be used for labeling plots</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ShortName*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The short_name is technically not part of the CF standard but is commonly the name of the variable on the output file and so is
 distinct from the long_name</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Units</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The value of the units attribute is a string that can be recognized by UNIDATA's Udunits package</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
</TABLE>
<BR>* Attribute required to be set, if any attributes are set within this package, the CF/Extended, or ESMF/General package, to produce valid CIM XML output. It is valid to set none of the attributes in this package, the CF/Extended, or ESMF/General package, in which case no field CIM output will be produced. 
<BR>
<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022400000000000000"></A>
<A NAME="ArrayAttributePackages"></A>
<BR>
39.2.4 Array Attribute packages
</H3>

<P>
At this time the Array packages are the same as the Field packages.

<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022500000000000000"></A>
<A NAME="GridAttributePackages"></A>
<BR>
39.2.5 Grid Attribute packages
</H3>

<P>
There are 2 grid attribute packages in ESMF.

<P>

<OL>
<LI>CIM 1.5.1 grids
</LI>
<LI>ESMF Grid
</LI>
</OL>

<P>
<BR>
<BR>

<P>
<B>1. grids</B>

<P>
<A NAME="CIMGridAttributePackage"></A>
<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "CIM 1.5.1"
</LI>
<LI><TT>purpose</TT> = "grids"
    
</LI>
</UL>
</LI>
<LI>CIM Version: CIM 1.5.1
</LI>
<LI>CIM Schema URL: <A NAME="tex2html78"
  HREF="http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5.1/">http://metaforclimate.eu/trac/browser/CIM/tags/version-1.5.1/</A>
</LI>
<LI>Output Options:
    
<UL>
<LI>Simple XML
</LI>
<LI>This package can be used to create a CIM 1.5.1 compliant grids XML file.
    
</LI>
</UL>
</LI>
<LI>Description: This package contains the the information necessary to create a CIM 1.5.1 compliant grids XML file.  The Attributes in this package are populated entirely by internal ESMF Grid information, no user intervention beyond the addition of the package is needed to create this package.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>id</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A unique name used to identify this Grid, this is taken from the internal name of the Grid object</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>isLeaf</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A boolean value used to describe whether there are any nested mosaics inside of this mosaic</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>true, false</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>gridType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A text description of the the type of the grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>cubed_sphere, displaced_pole, icosahedral_geodesic, reduced_gaussian, regular_lat_lon, spectral_gaussian, tripolar, yin_yang, composite, other</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>numTiles</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of tiles in this Grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>shortName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A short name to identify this Grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>longName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A long name describing this Grid in detail</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>gridTile</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The specific number for this tile of the Grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>discretizationType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The type of discretization that is used in this Grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>logically_rectangular, structured_rectangular, unstructured_rectangular, pixel_based_catchment, unstructured_polygonal, spherical_harmonics, other</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>geometryType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The type of geometry that best describes this Grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>ellipsoid, plane, sphere</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>numDims</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of dimensions in this Grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>xcoords</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The x (or longitude) coordinates of this Grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ycoords</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The y (or latitude) coordinates of the Grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>
<B>2. ESMF Grid</B>

<P>
<A NAME="ESMFGridAttributePackage"></A>
<P>

<UL>
<LI>Specify with:
    
<UL>
<LI><TT>convention</TT> = "ESMF"
</LI>
<LI><TT>purpose</TT> = "General"
    
</LI>
</UL>
</LI>
<LI>Description: This package is used by ESMF to track internal ESMF Grid information.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>RegDecompX</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of DEs in X a particular grid is decomposed into.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>RegDecompY</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of DEs in Y a particular grid is decomposed into.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>N/A</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022600000000000000">
39.2.6 Table of available Attributes</A>
</H3>

<P>
The following is an alphabetical list of all the attributes implemented in ESMF, their definitions, and which packages they are contained within.

<P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43><B>Attribute Package</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Agency</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An administrative unit of government.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ESMF Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CodingLanguage</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The computer language in which a unit of software is written.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ESMF Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CompilerName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The brand of the software that takes source code and turns it into an executable.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CompilerVersion</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The specific configuration value of the software used to take source code and turn it into executable code.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CouplingPurpose</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The form of the input condition (e.g. initial condition or boundary condition).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CouplingSource</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The component the input condition is coming from.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CouplingTarget</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The component the input condition is going to.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Description</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A multi-line description of a component or input.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main, CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Date</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The date of the citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>DOI</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The assigned Digital Object Identifier (DOI) of the citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>EmailAddress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The email address that others can use to ask questions about a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ISO Responsible Party</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Frequency</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The frequency (e.g. months, days) that a field from one component is input to another.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>FullName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of a model, model component, simulation, experiment, or dataset with all acronyms spelled out.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ESMF Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Institution</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An organization associated with a model component, simulation, or dataset.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ESMF Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Intent</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An indication of whether a field or state is imported into or exported from a particular model component. This refers to coupling, and not history output.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ESMF State, ESMF Field</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>LongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of an object with all acronyms spelled out. For fields, it is an ad-hoc long descriptive name which may, for example, be used for labeling plots.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main, CF General</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>LongTitle</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The text of the citation or pointer (e.g. URL) that further describes a model component or simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineCoresPerProcessor</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of sub-divided elements or mini-chips on a computer chip.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineDescription</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A short note about the machine.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineInterconnectType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The technology used to associate each node in a supercomputer with every other node.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineMaximumProcessors</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The highest number of computer chips on a computer system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name given to a computer by its system administrators. This is not the brand name of the system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineOperatingSystem</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The software that is responsible for the management and coordination of activities and the sharing of resources of a computer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineProcessorType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The type of computer chip used in a particular computer platform.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineSystem</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The type of computer system (e.g. vector, parallel, cluster, etc.).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineVendor</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The brand name of a computer system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MetadataVersion</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The version number of the simulation metadata.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ModelComponentFramework</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The software package or mechanism used to transfer and transform data between model components.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ESMF Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ModelType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A short string describing the discipline of a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Name</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of an author, contact, funder, centre, or principal investigator.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ISO Responsible Party</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>NameType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The type of entity that Name references.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ISO Responsible Party</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PhysicalAddress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The address of the person designated to provide information about a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ISO Responsible Party</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PhysicalDomain</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A description of the geographic range being simulated.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ESMF Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PresentationForm</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A description of the type of citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PreviousVersion</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Name of the previous version of a model or model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PreviousVersionDescription</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A short note about the previous version of the model or model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ReleaseDate</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The year a model component was issued.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>RegDecompX</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of DEs in X a particular grid is decomposed into.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ESMF Grid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>RegDecompY</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of DEs in Y a particular grid is decomposed into.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ESMF Grid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ResponsiblePartyRole</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A flag to define the role of the Responsible Party.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ISO Responsible Party</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ShortName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>For component: a version of the component name that contains acronyms.  For field:  The short_name is technically not part of the CF standard but is commonly the name of the variable on the output file and so is distinct from the long_name.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main, CF General</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ShortTitle</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An abbreviation for the citation.  This could be the short scientific citation (e.g. Murphy, 2009) or the title of a web page.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationDuration</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The length of time a simulation runs.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationEndDate</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The date in simulated time of the end of a model simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationEnsembleID</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The reference name or number of the ensemble to which a simulation belongs.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationLongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of the simulation with any acronyms spelled out.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationNumberOfProcessingElements</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of PEs used in the simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationProjectName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A campaign, such as a model intercomparison project, that may involve multiple groups and experiments.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationRationale</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The reason for performing a simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationStartDate</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The date in simulated time of the start of a model simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationShortName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of the simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SpatialRegriddingMethod</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Method used to interpolate a field from one grid (source grid) to another (target grid).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SpatialRegriddingDimension</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Dimension of the regridding method.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>StandardName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The approved CF standard name for a variable if it exists.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CF Extended</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>TimeTransformationType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Temporal transformation performed on the input field before or after regridding onto the target grid.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Technique</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The software package or mechanism used to transfer and transform data between model components.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>URL</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>URL of the object being described. Exists in multple packages.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main, ISO Responsible Party, ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Units</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The value of the units attribute is a string that can be recognized by UNIDATA's Udunits package.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CF General</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Version</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A specific form or variation of an artifact i.e. a unit of software or metadata.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=43>CIM Main, ESMF Basic Component</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022700000000000000"></A>
<A NAME="sec:CustomAttPacks"></A>
<BR>
39.2.7 Custom Attribute packages
</H3>

<P>
ESMF allows for the creation of custom attribute packages, each of which has a user-defined convention and purpose, as well as a set of user-defined attributes. This can be done to augment one of the pre-defined packages (via package nesting <A HREF="#sec:AttPackNesting">39.3</A>) or to create a suite of attributes unique to the user. A custom attribute package currently outputs only in simple XML format, when used as a stand-alone package (not when used to augment a pre-defined package).  Examples of how to create such custom packages are contained in Sections <A HREF="#ex:AttributePackageEx">39.7.2</A> and <A HREF="#ex:AttributeCustPackEx">39.7.3</A>.

<H2><A NAME="SECTION06023000000000000000">
39.3 Attribute Packages Nesting</A>
</H2>

<P>
<A NAME="sec:AttPackNesting"></A>
<P>
Nesting is a way of creating larger Attribute packages out of smaller ones and allows users to add the attributes they want to an existing package. It is very useful when combining a custom package with a pre-defined package. One or more child Attribute packages can be nested within a parent package, and this can be repeated multiple times, allowing a full Attribute tree (hierarchical) structure to be created.  Breaking Attributes up into smaller packages that are then nested also allows for the construction of complex attribute trees where certain structures repeat themselves, allowing for Attribute package reusability.

<P>
Several of the ESMF pre-defined packages, when added to an ESMF object, are created with nested packages:

<P>
CIM Main - Component package - is a nest with three child packages:

<OL>
<LI>CIM Platform
</LI>
<LI>CIM Responsible Party (one or more - user specifiable)
</LI>
<LI>CIM Citation (one or more - user specifiable)
</LI>
</OL>

<P>
CIM Inputs - Field package - is a nest with one child package:

<OL>
<LI>ESMF General (with CF Extended and CF General packages nested within it)
</LI>
</OL>

<P>
ESMF General - Field package - is a nest with one child package:

<OL>
<LI>CF Extended (with a CF General package nested within it)
</LI>
</OL>

<P>
CF Extended - Field package - is a nest with one child package:

<OL>
<LI>CF General
</LI>
</OL>

<H2><A NAME="SECTION06024000000000000000">
39.4 Export Formats</A>
</H2>

<P>
<A NAME="sec:AttributeExports"></A>
<P>
The <TT>ESMF_AttributeWrite()</TT> interface is used to write the contents of an Attribute package to a file.  This routine can be called on any ESMF object that is capable of holding Attribute packages.  It can also write out all Attributes in Attribute packages with the same convention and purpose throughout an entire ESMF object hierarchy. 

<P>
There are three primary ways of exporting Attributes:

<OL>
<LI>Tab-delimited ASCII
</LI>
<LI>Simple XML 
</LI>
<LI>CIM XML
</LI>
</OL>

<P>
The flag that is used in the <TT>ESMF_AttributeWrite()</TT> interface to determine which format for writing the Attribute packages is called the <TT>ESMF_AttWriteFlag</TT>, with values as described below.  The resulting file will be placed in the execution directory after it is written and closed.

<P>

<H3><A NAME="SECTION06024100000000000000">
39.4.1 Tab-delimited ASCII</A>
</H3>

<P>
When <TT>ESMF_AttWriteFlag</TT> is set to <TT>ESMF_ATTWRITE_TAB</TT> (the default), a tab-delimited ascii file containing name-value pairs of attributes in the packages will be written.  The file will be named for the name of the ESMF object from which <TT>ESMF_AttributeWrite()</TT> is called. The suffix will be .stdout.

<P>

<H3><A NAME="SECTION06024200000000000000">
39.4.2 Simple XML</A>
</H3>

<P>
When <TT>ESMF_AttWriteFlag</TT> is set to <TT>ESMF_ATTWRITE_XML</TT>, an XML file containing name-value pairs of attributes in the packages will be written.  The file will be named for the name of the ESMF object from which <TT>ESMF_AttributeWrite()</TT> is called. The suffix will be .xml.

<P>

<H3><A NAME="SECTION06024300000000000000">
39.4.3 CIM XML</A>
</H3>

<P>
When the ESMF object from which <TT>ESMF_AttributeWrite()</TT> is called is a Component, and the Attribute package convention="CIM1.5", and the purpose="ModelComp", and <TT>ESMF_AttWriteFlag</TT> is set to <TT>ESMF_ATTWRITE_XML</TT>, an XML file conforming to the CIM standard will be written.  The file will contain Attributes from the entire Component tree and their contained Fields.  The file will be named for the name of the ESMF Component object from which <TT>ESMF_AttributeWrite()</TT> is called, and the suffix will be .xml.

<P>
There is a deviation from the standard CIM in the ESMF code: if the top-level object is not a component, or the proper convention ("CIM 1.5") or purpose ("ModelComp") are not used, then the simple XML logic will be followed, and elements such as, "variable_set" and "variable" may be found in the exported XML.

<P>

<H3><A NAME="SECTION06024400000000000000">
39.4.4 CIM 1.5.1 grids XML</A>
</H3>

<P>
** This is a prototype capability.

<P>
When the ESMF object from which <TT>ESMF_AttributeWrite()</TT> is called is a Grid (or 
it contains a Grid), and the Attribute package convention="CIM 1.5.1", and the 
purpose="grids", and <TT>ESMF_AttWriteFlag</TT> is set to <TT>ESMF_ATTWRITE_XML</TT>, an XML file conforming to the CIM 1.5.1 grids standard will be written.  The file will be named for the name of the ESMF Component object from which <TT>ESMF_AttributeWrite()</TT> is called, and the suffix will be .xml.  This file is written by pulling internal information out of the Grid object.  It is 
currently functional for one- and two-dimensional Grids.

<H2><A NAME="SECTION06025000000000000000">
39.5 Accessing object information through Attribute</A>
</H2>

<P>
<A NAME="sec:InternalInfo"></A>
<P>
Internal ESMF class information can be retrieved through the Attribute 
class with the <TT>ESMF_AttributeGet()</TT> interface.  The Grid class is
the prototype for this capability.  Internal information is retrieved by 
specifying the name in <TT>ESMF_AttributeGet()</TT> as the keyword of the 
desired argument from one of the <TT>ESMF_GridGet()</TT>interfaces.  
The `value' of the Attribute must be of the corresponding type
that is required to retrieve the desired piece of information.  There are 
a few pieces of information that cannot be retrieved from the Grid
through the Attribute interface at this time, see Tables 
<A HREF="#AttributeInternalInfo-Get">14</A> - <A HREF="#AttributeInternalInfo-Item">16</A> to
determine what is currently available.

<P>
The name of an Attribute that represents internal class information must have 
`ESMF:' prepended.  This is to indicate that the information should be retrieved
directly from class methods.  The input arguments must not have the `ESMF:'
string prepended, and they should be specified as a character string with the name
and value separated by an equal sign.  For example, the <TT>localDe=0</TT> would be 
specified like this: <TT>`localDe=0'</TT>.

<P>
Note: Attribute access to internal class information does not
have the normal Attribute restriction that the values of the Attributes must be
consistent across the current VM.

<P>
There is an example of how to use this capability in Section 
<A HREF="#ex:AttributeInternalInfoEx">39.7.5</A>.

<P>
The name, type, input arguments and original Grid interface for each of the 
pieces of internal Grid information that can be retrieved through the Attribute 
class are listed in Tables <A HREF="#AttributeInternalInfo-Get">14</A> - 
<A HREF="#AttributeInternalInfo-Item">16</A>.  
The name of the Attribute is specified by the character strings in the first 
column, and the type of the output is specified in the second column.
The third column specifies which input information is required (or optional) 
to retrieve the information and the fourth column gives a link to a detailed
description of the input arguments.

<P>
Note: The following pieces of Grid information cannot be retrieved with this 
method: distgrid, coordDimMap, arbIndexList, and coord.

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
  
  <A NAME="73315"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 14:</STRONG>
This table shows general Grid information that can be retrieved with character string inputs to the <TT>ESMF_AttributeGet()</TT> interface</CAPTION>
<TR><TD ALIGN="LEFT"><B>Name</B></TD>
<TD ALIGN="LEFT"><B>Type</B></TD>
<TD ALIGN="LEFT"><B>Input arguments</B></TD>
<TD ALIGN="LEFT"><B>Original Interface</B></TD>
</TR>
<TR><TD ALIGN="LEFT">arbDim</TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">arbDimCount</TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">arbIndexCount</TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT">localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetPLocalDe"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">computationalCount</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">staggerloc, localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetPLocalDePSloc"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">computationalLBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">staggerloc, localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetPLocalDePSloc"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">computationalUBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">staggerloc, localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetPLocalDePSloc"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">coordDimCount</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">coordTypeKind</TD>
<TD ALIGN="LEFT"><TT>ESMF_TypeKind_Flag</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">dimCount</TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">distgridToGridMap</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">exclusiveCount</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">staggerloc, localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetPLocalDePSloc"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">exclusiveLBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">staggerloc, localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetPLocalDePSloc"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">exclusiveUBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">staggerloc, localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetPLocalDePSloc"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">gridEdgeLWidth</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">gridEdgeUWidth</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">gridAlign</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">indexflag</TD>
<TD ALIGN="LEFT"><TT>ESMF_Index_Flag</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">isLBound</TD>
<TD ALIGN="LEFT"><TT>logical</TT></TD>
<TD ALIGN="LEFT">localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetPLocalDe"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">isUBound</TD>
<TD ALIGN="LEFT"><TT>logical</TT></TD>
<TD ALIGN="LEFT">localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetPLocalDe"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">localDECount</TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">maxIndex</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">tile, staggerloc</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetPSlocPTile"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">minIndex</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">tile, staggerloc</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetPSlocPTile"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">name</TD>
<TD ALIGN="LEFT"><TT>character</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">rank</TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">staggerlocCount</TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">status</TD>
<TD ALIGN="LEFT"><TT>ESMF_GridStatus_Flag</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">tileCount</TD>
<TD ALIGN="LEFT"><TT>integer</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGet"><TT>ESMF_GridGet()</TT></A></TD>
</TR>
</TABLE>
  <A NAME="AttributeInternalInfo-Get"></A>
</DIV>
<BR>

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
  
  <A NAME="73316"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 15:</STRONG>
This table shows Grid coordinate information that can be retrieved with character string inputs to the <TT>ESMF_AttributeGet()</TT> interface</CAPTION>
<TR><TD ALIGN="LEFT"><B>Name</B></TD>
<TD ALIGN="LEFT"><B>Type</B></TD>
<TD ALIGN="LEFT"><B>Input arguments</B></TD>
<TD ALIGN="LEFT"><B>Original Interface</B></TD>
</TR>
<TR><TD ALIGN="LEFT">farrayPtr</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">coordDim, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetCoord"><TT>ESMF_GridGetCoord()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">computationalCount</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">coordDim, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetCoord"><TT>ESMF_GridGetCoord()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">computationalLBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">coordDim, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetCoord"><TT>ESMF_GridGetCoord()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">computationalUBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">coordDim, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetCoord"><TT>ESMF_GridGetCoord()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">exclusiveCount</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">coordDim, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetCoord"><TT>ESMF_GridGetCoord()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">exclusiveLBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">coordDim, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetCoord"><TT>ESMF_GridGetCoord()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">exclusiveUBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">coordDim, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetCoord"><TT>ESMF_GridGetCoord()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">totalCount</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">coordDim, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetCoord"><TT>ESMF_GridGetCoord()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">totalLBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">coordDim, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetCoord"><TT>ESMF_GridGetCoord()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">totalUBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">coordDim, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetCoord"><TT>ESMF_GridGetCoord()</TT></A></TD>
</TR>
</TABLE>
  <A NAME="AttributeInternalInfo-Coord"></A>
</DIV>
<BR>

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
  
  <A NAME="73317"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 16:</STRONG>
This table shows Grid item information that can be retrieved with character string inputs to the <TT>ESMF_AttributeGet()</TT> interface</CAPTION>
<TR><TD ALIGN="LEFT"><B>Name</B></TD>
<TD ALIGN="LEFT"><B>Type</B></TD>
<TD ALIGN="LEFT"><B>Input arguments</B></TD>
<TD ALIGN="LEFT"><B>Original Interface</B></TD>
</TR>
<TR><TD ALIGN="LEFT">computationalCount</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">itemflag, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetItem"><TT>ESMF_GridGetItem()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">computationalLBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">itemflag, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetItem"><TT>ESMF_GridGetItem()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">computationalUBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">itemflag, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetItem"><TT>ESMF_GridGetItem()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">exclusiveCount</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">itemflag, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetItem"><TT>ESMF_GridGetItem()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">exclusiveLBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">itemflag, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetItem"><TT>ESMF_GridGetItem()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">exclusiveUBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">itemflag, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetItem"><TT>ESMF_GridGetItem()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">totalCount</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">itemflag, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetItem"><TT>ESMF_GridGetItem()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">totalLBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">itemflag, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetItem"><TT>ESMF_GridGetItem()</TT></A></TD>
</TR>
<TR><TD ALIGN="LEFT">totalUBound</TD>
<TD ALIGN="LEFT"><TT>integer(:)</TT></TD>
<TD ALIGN="LEFT">itemflag, (optional) staggerloc, (optional) localDe</TD>
<TD ALIGN="LEFT"><A HREF="node5.html#API:GridGetItem"><TT>ESMF_GridGetItem()</TT></A></TD>
</TR>
</TABLE>
  <A NAME="AttributeInternalInfo-Item"></A>
</DIV>
<BR>

<P>
<BR>
<BR>

<H2><A NAME="SECTION06026000000000000000">
39.6 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION06026100000000000000"></A>
<A NAME="const:attcopy"></A>
<BR>
39.6.1 ESMF_ATTCOPY
</H3>
<I>DESCRIPTION:
<BR></I>
Indicates which type of copy behavior is used when copying ESMF Attribute objects.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_AttCopy_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ATTCOPY_REFERENCE</STRONG></DT>
<DD>The destination Attribute hierarchy becomes a reference copy of
    the Attribute hierarchy of the source object. Any further changes to one
    will also be reflected in the other.
  
</DD>
<DT><STRONG>ESMF_ATTCOPY_VALUE</STRONG></DT>
<DD>All of the Attributes and Attribute packages of the source object will be
    copied by value to the destination object. None of the Attribute links to
    the Attribute hierarchies of other objects are copied to the
    destination object.
  
</DD>
<DT><STRONG>ESMF_ATTCOPY_HYBRID</STRONG></DT>
<DD>All of the Attributes and Attribute packages of the source object will be
    copied by value to the destination object. The Attribute links to the
    Attribute hierarchies of other objects are copied by reference.
</DD>
</DL>

<P>

<H3><A NAME="SECTION06026200000000000000"></A>
<A NAME="const:attgetcount"></A>
<BR>
39.6.2 ESMF_ATTGETCOUNT
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Indicates which type of Attribute object count to return.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_AttGetCountFlag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ATTGETCOUNT_ATTRIBUTE</STRONG></DT>
<DD>This option will allow the routine to return the number of single Attributes.
	
</DD>
<DT><STRONG>ESMF_ATTGETCOUNT_ATTPACK</STRONG></DT>
<DD>This option will allow the routine to return the number of Attribute packages.
	
</DD>
<DT><STRONG>ESMF_ATTGETCOUNT_ATTLINK</STRONG></DT>
<DD>This option will allow the routine to return the number of Attribute links.
	
</DD>
<DT><STRONG>ESMF_ATTGETCOUNT_TOTAL</STRONG></DT>
<DD>This option will allow the routine to return the total number of Attributes.
</DD>
</DL>

<P>

<H3><A NAME="SECTION06026300000000000000"></A>
<A NAME="const:attwrite"></A>
<BR>
39.6.3 ESMF_ATTWRITE
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Indicates which file format to use in the write operation.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_AttWriteFlag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ATTWRITE_XML</STRONG></DT>
<DD>This option will allow the routine to write in xml format.
	
</DD>
<DT><STRONG>ESMF_ATTWRITE_TAB</STRONG></DT>
<DD>This option will allow the routine to write in tab-delimited format.
</DD>
</DL>

<H2><A NAME="SECTION06027000000000000000">
39.7 Use and Examples</A>
</H2>

<P>
This section describes the use of the Attribute class.  There are eight 
examples that follow, which outline the use of Attributes at three increasing 
levels of difficulty.  The first example covers basic Attribute manipulations 
on the gridded Component.  The second example covers the Attribute package 
capabilities, including Attribute package nesting and Attribute hierarchy 
linking.  The third example covers Attribute management in a distributed 
environment and the I/O utilities.  These examples will be best understood if 
followed in an ascending order from basic to advanced.  The fourth example 
shows how to use the CIM Attribute packages.  The last four examples cover 
setting of Attribute packages and custom Attributes from an XML file.

<P>

<P>

<P>

<H3><A NAME="SECTION06027100000000000000"></A> <A NAME="ex:AttributeEx"></A>
<BR>
39.7.1 Basic Attribute usage
</H3>

<P>
This example illustrates the most basic usage of the Attribute class.  
   This demonstration of Attribute manipulation is limited to the gridded 
   Component, but the same principles apply to the coupler Component, State, 
   Grid, FieldBundle, Field, ArrayBundle and Array.  The
   functionality that is demonstrated includes setting and getting Attributes, 
   working with Attributes with different types and lists, removing Attributes,
   and getting default Attributes.  Various other uses of 
   <TT>ESMF_AttributeGet()</TT> is covered in detail in the last section.  The
   first thing we must do is declare variables and initialize ESMF. 

<P>
<PRE>
      ! Use ESMF framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! Local variables  
      integer                 :: rc, finalrc, petCount, localPet, &amp;
                                 itemCount, count, result
      type(ESMF_VM)           :: vm
      type(ESMF_GridComp)     :: gridcomp
      character(ESMF_MAXSTR)  :: name
      type(ESMF_TypeKind_Flag)     :: tk

      integer(ESMF_KIND_I4)                :: inI4
      integer(ESMF_KIND_I4), dimension(3)  :: inI4l
      integer(ESMF_KIND_I8)                :: inI8
      integer(ESMF_KIND_I8), dimension(3)  :: inI8l
      real(ESMF_KIND_R4)                   :: inR4
      real(ESMF_KIND_R4), dimension(3)     :: inR4l
      real(ESMF_KIND_R8)                   :: inR8
      real(ESMF_KIND_R8), dimension(3)     :: inR8l
      character(ESMF_MAXSTR)               :: inChar
      character(ESMF_MAXSTR), dimension(3) :: inCharl, &amp;
                                           defaultCharl, dfltoutCharl
      character(ESMF_MAXSTR), dimension(8) :: outCharl
      logical                              :: inLog
      logical, dimension(3)                :: inLogl, value
      character(ESMF_MAXSTR)               :: testname
      character(ESMF_MAXSTR)               :: failMsg
</PRE>

<P>
<PRE>
      
      ! initialize ESMF
      finalrc = ESMF_SUCCESS
      call ESMF_Initialize(vm=vm, defaultlogfilename="AttributeEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      
      ! get the vm
      call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=rc)
</PRE>

<P>
We will construct the gridded Component which will be responsible for all
      of the Attributes we will be manipulating. 

<P>
<PRE>
      if (petCount&lt;4) then
        gridcomp = ESMF_GridCompCreate(name="gridcomp", &amp;
          petList=(/0/), rc=rc)
      else 
        gridcomp = ESMF_GridCompCreate(name="gridcomp", &amp;
          petList=(/0,1,2,3/), rc=rc)
      endif
</PRE>

<P>
We can set Attributes using the <TT>ESMF_AttributeSet()</TT> command.  
       Attributes can be any of several different types, all of which are 
       demonstrated here. 

<P>
<PRE>
      inI4 = 4
      inI4l = (/1,2,3/)
      inI8 = 4
      inI8l = (/1,2,3/)
      inR4 = 4
      inR4l = (/1,2,3/)
      inR8 = 4
      inR8l = (/1,2,3/)
      inChar = "Character string 4"
      inCharl = (/ "Character string 1", &amp;
                   "Character string 2", &amp;
                   "Character string 3" /)
      inLog = .true.
      inLogl = (/.true., .false., .true. /)
      
      call ESMF_AttributeSet(gridcomp, name="ESMF_I4name", value=inI4, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, name="ESMF_I4namelist", &amp;
        valueList=inI4l, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, name="ESMF_I8name", value=inI8,  rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, name="ESMF_I8namelist", &amp;
        valueList=inI8l, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, name="ESMF_R4name", value=inR4, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, name="ESMF_R4namelist", &amp;
        valueList=inR4l, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, name="ESMF_R8name", value=inR8, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, name="ESMF_R8namelist", &amp;
        valueList=inR8l, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, name="Character_name", &amp;
        value=inChar, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, name="Character_namelist", &amp;
        valueList=inCharl, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, name="Logical_name", value=inLog, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, name="Logical_namelist", &amp;
        valueList=inLogl, rc=rc)
</PRE>

<P>
We can retrieve Attributes by issuing the <TT>ESMF_AttributeGet()</TT> 
       command.  This command can also be used with an optional default 
       value (or value list) so that if the Attribute is not found a value is 
       returned without an error code.  Removal of Attributes is also 
       possible, and is demonstrated here as well.  One of the Attributes
       previously created will be retrieved, then removed, then 
       retrieved again using a default return value.  In order to use the 
       default return value capabilites, we must first set up a default parameter. 

<P>
<PRE>
      defaultCharl = (/ "Character string 4", &amp;
                        "Character string 5", &amp;
                        "Character string 6" /)
      
      itemCount=3
      call ESMF_AttributeGet(gridcomp, name="Character_namelist", &amp;
        valueList=outCharl(1:5), itemCount=itemCount, rc=rc)
</PRE>

<P>
<PRE>
                    
      call ESMF_AttributeRemove(gridcomp, name="Character_namelist", rc=rc)
</PRE>

<P>
<PRE>
      
      call ESMF_AttributeGet(gridcomp, name="Character_namelist", &amp;
        valueList=dfltoutCharl, defaultvalueList=defaultCharl,rc=rc)
</PRE>

<P>
There are more overloaded instances of <TT>ESMF_AttributeGet()</TT> 
      which allow the retrieval of Attribute information by name or index 
      number, or a query for the count of the Attributes on a certain object.  
      These capabilities are demonstrated here by first retrieving the name of
      an Attribute using the index number, keep in mind that these index
      numbers start from 1.  Then the name that is retrieved
      is used to get other information about the Attribute, such as the
      typekind, and the number of items in the value of the Attribute.
      This information is then used to actually retrieve the Attribute value.
      Then the count of the number of Attributes on the object will be retrieved. 

<P>
<PRE>
      call ESMF_AttributeGet(gridcomp, attributeIndex=11 , name=name, rc=rc)
</PRE>

<P>
<PRE>
      
      call ESMF_AttributeGet(gridcomp, name=name, typekind=tk, &amp;
        itemCount=itemCount, rc=rc)
</PRE>

<P>
<PRE>
      
      if (tk==ESMF_TYPEKIND_Logical .AND. itemCount==3) then
        call ESMF_AttributeGet(gridcomp, name=name, valueList=value, rc=rc)
</PRE>

<P>
<PRE>
      endif
      
      call ESMF_AttributeGet(gridcomp, count=count, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION06027200000000000000"></A> <A NAME="ex:AttributePackageEx"></A>
<BR>
39.7.2 Attribute packages
</H3>

<P>
This example is slightly more complex than the example presented in section
   <A HREF="#ex:AttributeEx">39.7.1</A> and illustrates the use of the Attribute class to
   create Attribute hierarchies using Attribute packages.  A gridded Component
   is used in conjunction with two States, a FieldBundle, and various realistic
   Fields to create an Attribute hierarchy and copy it from one State to another.
   Attribute packages are created on the Component and Fields, and the
   standard Attributes in each package are used in the Attribute hierarchy.
   The Attribute package nesting capability is demonstrated by nesting the standard
   ESMF supplied packages for the Fields inside a user specified Attribute package
   with a customized convention. 

<P>
We must construct the ESMF objects that will be responsible for the
      Attributes we will be manipulating.  These objects include the
      gridded Component, two States, a FieldBundle, and 10 Fields.  In this trivial
      example we are constructing empty Fields with no underlying Grid. 

<P>
<PRE>
      if (petCount&lt;4) then
        gridcomp = ESMF_GridCompCreate(name="gridded_comp_ex2", &amp;
          petList=(/0/), rc=rc)
      else
        gridcomp = ESMF_GridCompCreate(name="gridded_comp_ex2", &amp;
          petList=(/0,1,2,3/), rc=rc)
      endif
</PRE>

<P>
<PRE>
      importState = ESMF_StateCreate(name="importState",  &amp;
                             stateintent=ESMF_STATEINTENT_IMPORT, rc=rc)
</PRE>

<P>
<PRE>
      exportState = ESMF_StateCreate(name="exportState",  &amp;
                             stateintent=ESMF_STATEINTENT_EXPORT, rc=rc)
</PRE>

<P>
<PRE>
      DPEDT = ESMF_FieldEmptyCreate(name='DPEDT', rc=rc)
</PRE>

<P>
<PRE>
      DTDT = ESMF_FieldEmptyCreate(name='DTDT', rc=rc)
</PRE>

<P>
<PRE>
      DUDT = ESMF_FieldEmptyCreate(name='DUDT', rc=rc)
</PRE>

<P>
<PRE>
      DVDT = ESMF_FieldEmptyCreate(name='DVDT', rc=rc)
</PRE>

<P>
<PRE>
      PHIS = ESMF_FieldEmptyCreate(name='PHIS', rc=rc)
</PRE>

<P>
<PRE>
      QTR = ESMF_FieldEmptyCreate(name='QTR', rc=rc)
</PRE>

<P>
<PRE>
      CNV = ESMF_FieldEmptyCreate(name='CNV', rc=rc)
</PRE>

<P>
<PRE>
      CONVCPT = ESMF_FieldEmptyCreate(name='CONVCPT', rc=rc)
</PRE>

<P>
<PRE>
      CONVKE = ESMF_FieldEmptyCreate(name='CONVKE', rc=rc)
</PRE>

<P>
<PRE>
      CONVPHI = ESMF_FieldEmptyCreate(name='CONVPHI', rc=rc)
</PRE>

<P>
<PRE>
      fbundle = ESMF_FieldBundleCreate(name="fbundle", rc=rc)
</PRE>

<P>
Now we can add Attribute packages to all of the appropriate objects.
      We will use the ESMF supplied Attribute packages for the Fields and
      the Component.  On the Fields, we will first use
      <TT>ESMF_AttributeAdd()</TT> to create standard Attribute packages, then
      we will nest customized Attribute packages around the ESMF standard
      Attribute packages.  In this simple example the purpose for the Attribute packages will
      be specified as "General" in all cases. 

<P>
<PRE>
      convESMF = 'ESMF'
      convCC = 'CustomConvention'
      purpGen = 'General'

      attrList(1) = 'Coordinates'
      attrList(2) = 'Mask'

      ! DPEDT
      call ESMF_AttributeAdd(DPEDT, convention=convESMF, purpose=purpGen, &amp;
        rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeAdd(DPEDT, convention=convCC, purpose=purpGen,   &amp;
        attrList=attrList, nestConvention=convESMF, nestPurpose=purpGen,  &amp;
        rc=rc)
</PRE>

<P>
... and so on for the other 9 Fields.

<P>
The standard Attribute package currently supplied by ESMF for
       Field contains 6 Attributes, 2 of which are set automatically.
       The remaining 4 Attributes in the standard Field Attribute
       package must be set manually by the user.   We must also
       set the Attributes of our own custom Attribute package, which
       is built around the ESMF standard Attribute package. 

<P>
<PRE>
      name1 = 'ShortName'
      name2 = 'StandardName'
      name3 = 'LongName'
      name4 = 'Units'

      ! DPEDT
      value1 = 'DPEDT'
      value2 = 'tendency_of_air_pressure'
      value3 = 'Edge pressure tendency'
      value4 = 'Pa s-1'
      ! Custom Attributes

      ! retrieve Attribute package
      call ESMF_AttributeGetAttPack(DPEDT, convCC, purpGen, &amp;
        attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(DPEDT, name='Coordinates', value='latlon', &amp;
        convention=convCC, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(DPEDT, name='Mask', value='yes', &amp;
        convention=convCC, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
      ! ESMF Attributes

      ! retrieve Attribute package
      call ESMF_AttributeGetAttPack(DPEDT, convESMF, purpGen, &amp;
        attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(DPEDT, name2, value2, &amp;
        convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(DPEDT, name3, value3, &amp;
        convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(DPEDT, name4, value4, &amp;
        convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
... and so on for the other 9 Fields.

<P>
The standard Attribute package currently supplied by ESMF for
       Component contains 10 Attributes.  These Attributes conform to both
       the ESG and CF conventions, and must be set manually. 

<P>
<PRE>
    ! retrieve Attribute package
    call ESMF_AttributeGetAttPack(gridcomp, convESMF, purpGen, attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'Agency', 'NASA', &amp;
      convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'Author', 'Max Suarez', &amp;
      convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'CodingLanguage', &amp;
      'Fortran 90', convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'Discipline', &amp;
      'Atmosphere', convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'ComponentLongName', &amp;
    'Goddard Earth Observing System Version 5 Finite Volume Dynamical Core', &amp;
        convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'ModelComponentFramework', &amp;
      'ESMF', convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'ComponentShortName', &amp;
      'GEOS-5 FV dynamical core', &amp;
      convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'PhysicalDomain', &amp;
      'Earth system', convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'Version', &amp;
      'GEOSagcm-EROS-beta7p12', convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
Adding the Fields to the FieldBundle will automatically ``link" the
       Attribute hierarchies.  The same type of link will be generated
       when adding a FieldBundle to a State. 

<P>
<PRE>
      call ESMF_FieldBundleAdd(fbundle, (/DPEDT/), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_FieldBundleAdd(fbundle, (/DTDT/), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_FieldBundleAdd(fbundle, (/DUDT/), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_FieldBundleAdd(fbundle, (/DVDT/), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_FieldBundleAdd(fbundle, (/PHIS/), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_FieldBundleAdd(fbundle, (/QTR/), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_FieldBundleAdd(fbundle, (/CNV/), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_FieldBundleAdd(fbundle, (/CONVCPT/), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_FieldBundleAdd(fbundle, (/CONVKE/), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_FieldBundleAdd(fbundle, (/CONVPHI/), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_StateAdd(exportState, fieldbundleList=(/fbundle/), rc=rc)
</PRE>

<P>
The link between a State and the Component of interest must be
       set manually. 

<P>
<PRE>
      call ESMF_AttributeLink(gridcomp, exportState, rc=rc)
</PRE>

<P>
There are currently two different formats available for writing
       the contents of the Attribute packages in an Attribute hierarchy.
       There is an XML formatted write, which generates an .xml file in the
       execution directory with the contents of the write.  There is also
       a tab-delimited write which writes to standard out, a file generated
       in the execution directory with the extension .stdout.  Either of
       the <TT>ESMF_AttributeWrite()</TT> formats can be called on any of the objects which
       are capable of manipulating Attributes, but only from objects in an
       Attribute hierarchy which contain ESMF standard Attribute packages can it be confirmed that any
       relevant information be written.  The <TT>ESMF_AttributeWrite()</TT>
       capability is only functional for single-item Attributes at this point, it
       will be more robust in future releases.  A flag is used to
       specify which format to write, the default is tab-delimited. 

<P>
<PRE>
      call ESMF_AttributeWrite(gridcomp,convESMF,purpGen, &amp;
        attwriteflag=ESMF_ATTWRITE_XML,rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeWrite(gridcomp,convESMF,purpGen,rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION06027300000000000000"></A>  <A NAME="ex:AttributeCustPackEx"></A>
<BR>
39.7.3 Custom Attribute package
</H3>

<P>
This example illustrates how to create a user-defined, custom Attribute 
   package.  The package is created on a gridded Component with three custom
   Attributes. 

<P>
We must construct the ESMF gridded Component object that will be 
      responsible for the custom Attribute package we will be manipulating. 

<P>
<PRE>
      if (petCount&lt;4) then
        gridcomp = ESMF_GridCompCreate(name="gridded_comp_ex3", &amp;
          petList=(/0/), rc=rc)
      else 
        gridcomp = ESMF_GridCompCreate(name="gridded_comp_ex3", &amp;
          petList=(/0,1,2,3/), rc=rc)
      endif
</PRE>

<P>
Now we can add a custom Attribute package to the gridded Component object. 

<P>
<PRE>
      customConv = 'CustomConvention'
      customPurp = 'CustomPurpose'

      customAttrList(1) = 'CustomAttrName1'
      customAttrList(2) = 'CustomAttrName2'
      customAttrList(3) = 'CustomAttrName3'

      call ESMF_AttributeAdd(gridcomp, convention=customConv, &amp;
        purpose=customPurp, attrList=customAttrList, rc=rc)
</PRE>

<P>
<PRE>
</PRE>

<P>
We must set the Attribute values of our custom Attribute package. 

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'CustomAttrName1', 'CustomAttrValue1', &amp;
      convention=customConv, purpose=customPurp, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'CustomAttrName2', 'CustomAttrValue2', &amp;
      convention=customConv, purpose=customPurp, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'CustomAttrName3', 'CustomAttrValue3', &amp;
      convention=customConv, purpose=customPurp, rc=rc)
</PRE>

<P>
Write out the contents of our custom Attribute package to an XML file,
       which is generated with a .xml file extension in the execution directory.  

<P>
<PRE>
      call ESMF_AttributeWrite(gridcomp,customConv,customPurp, &amp;
        attwriteflag=ESMF_ATTWRITE_XML,rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION06027400000000000000">
39.7.4 Updating Attributes in a distributed environment</A>
</H3>

<P>
This advanced example illustrates the proper methods of Attribute manipulation
   in a distributed environment to ensure consistency of metadata across the VM.
   This example is much more complicated than the previous two because we will
   be following the flow of control of a typical model run with two gridded Components
   and one coupling Component.  We will start out in the application driver, declaring
   Components, States, and the routines used to initialize, run and finalize the user's
   model Components.  Then we will follow the control flow into the actual Component level
   through initialize, run, and finalize examining how Attributes are used to organize the
   metadata.

<P>
This example follows a simple user model with two gridded Components and one coupling Component.
   The initialize routines are used to set up the application data and the run
   routines are used to manipulate the data.  Accordingly, most of the Attribute manipulation
   will take place in the initialize phase of each of the three Components.  The two gridded
   Components will be running on exclusive pieces of the VM and the coupler Component will
   encompass the entire VM so that it can handle the Attribute communications.

<P>
The control flow of this
   example will start in the application driver, after which it will complete three cycles
   through the three Components.  The first cycle will be through the initialize routines,
   from the first gridded Component to the second gridded Component to the coupler Component.  The
   second cycle will go through the run routines, from the first gridded Component to the
   coupler Component to the second Gridded component.  The third cycle will be through the
   finalize routines in the same order as the first cycle.

<P>
In the application driver, we must now construct some ESMF objects,
   such as the gridded Components, the coupler Component, and the States.  This
   is also where it is determined which subsets of the PETs of the VM the
   Components will be using to run their initialize, run, and finalize routines. 

<P>
<PRE>
        gridcomp1 = ESMF_GridCompCreate(name="gridcomp1", &amp;
          petList=(/0,1/), rc=rc)
</PRE>

<P>
<PRE>
        gridcomp2 = ESMF_GridCompCreate(name="gridcomp2", &amp;
          petList=(/2,3/), rc=rc)
</PRE>

<P>
<PRE>
        cplcomp = ESMF_CplCompCreate(name="cplcomp", &amp;
          petList=(/0,1,2,3/), rc=rc)
</PRE>

<P>
<PRE>
      endif

        c1exp = ESMF_StateCreate(name="Comp1 exportState", &amp;
                               stateintent=ESMF_STATEINTENT_EXPORT, rc=rc)
</PRE>

<P>
Before the individual components are initialized, run, and finalized Attributes should be set at the
   Component level.  Here we are going to use the ESG Attribute package on
   the first gridded Component.  The Attribute package is added, and then
   each of the Attributes is set.  The Attribute hierarchy of the Component
   is then linked to the Attribute hierarchy of the export State in a
   manual fashion. 

<P>
<PRE>
      convESMF = 'ESMF'
      purpGen = 'General'
      call ESMF_AttributeAdd(gridcomp1, &amp;
        convention=convESMF, purpose=purpGen, attpack=attpack, &amp;
        rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp1, 'Agency', 'NASA', attpack, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp1, 'Author', 'Max Suarez', &amp;
      convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp1, 'CodingLanguage', &amp;
      'Fortran 90', convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp1, 'Discipline', &amp;
      'Atmosphere', convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp1, 'ComponentLongName', &amp;
   'Goddard Earth Observing System Version 5 Finite Volume Dynamical Core', &amp;
        convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp1, 'ModelComponentFramework', &amp;
      'ESMF', &amp;
      convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp1, 'ComponentShortName', &amp;
      'GEOS-5 FV dynamical core', convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp1, 'PhysicalDomain', &amp;
      'Earth system', convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp1, 'Version', &amp;
      'GEOSagcm-EROS-beta7p12', convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeLink(gridcomp1, c1exp, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeLinkRemove(gridcomp1, c1exp, rc=rc)
</PRE>

<P>
Now the individual Components will be run.  First we will initialize the two
   gridded Components, then we will initialize the coupler Component.
   During each of these Component initialize routines Attribute
   packages will be added, and the Attributes set.  The Attribute
   hierarchies will also be linked (unlinking also demonstrated).  As the
   gridded Components will be running on exclusive portions of the VM, the
   Attributes will need to be made available across the VM using an
   <TT>ESMF_StateReconcile()</TT> call in the coupler Component.  The majority of
   the work with Attributes will take place in this portion of the model run, as
   metadata rarely needs to be changed during run time.

<P>
What
   follows are the calls from the driver code that run the initialize, run, and finalize routines
   for each of the Components.  After these calls we will step through the first
   cycle as explained in the introduction, through the initialize routines of
   gridded Component 1 to gridded Component 2 to the coupler Component. 

<P>
<PRE>
      call ESMF_GridCompInitialize(gridcomp1, exportState=c1exp, rc=rc)
      call ESMF_GridCompInitialize(gridcomp2, importState=c2imp, rc=rc)
      call ESMF_CplCompInitialize(cplcomp, importState=c1exp, &amp;
        exportState=c2imp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompRun(gridcomp1, exportState=c1exp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_CplCompRun(cplcomp, importState=c1exp, &amp;
        exportState=c2imp, userRc=urc, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompRun(gridcomp2, importState=c2imp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompFinalize(gridcomp1, exportState=c1exp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompFinalize(gridcomp2, importState=c2imp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_CplCompFinalize(cplcomp, importState=c1exp, &amp;
        exportState=c2imp, rc=rc)
</PRE>

<P>


<P>

<P>

<P>
In the first gridded Component initialize routine we need to create some
   Attribute packages and set all of the Attributes.  These Attributes will
   be attached to realistic Fields, containing a Grid, which are contained in a
   FieldBundle.  The first thing to do is declare variables and make the Grid. 

<P>
<PRE>
        type(ESMF_AttPack)       :: attpack
    type(ESMF_VM)            :: vm
    integer                  :: petCount, status, myPet
    character(ESMF_MAXSTR)   :: name1,name2,name3,name4,value1,value2, &amp;
                                value3,value4,convESMF,purpGen,convCC
    type(ESMF_ArraySpec)     :: arrayspec
    type(ESMF_Grid)          :: grid
    type(ESMF_Field)         :: DPEDT,DTDT,DUDT,DVDT,PHIS,QTR,CNV,CONVCPT, &amp;
                                CONVKE,CONVPHI
    type(ESMF_FieldBundle)   :: fieldbundle
    character(ESMF_MAXSTR),dimension(2)   :: attrList

    rc = ESMF_SUCCESS

    call ESMF_GridCompGet(comp, vm=vm, rc=status)
    call ESMF_VMGet(vm, petCount=petCount, localPet=myPet, rc=status)

    call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, &amp;
           rc=rc)
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/100,150/), &amp;
      regDecomp=(/1,petCount/), &amp;
      gridEdgeLWidth=(/0,0/), gridEdgeUWidth=(/0,0/), &amp;
      indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
At this point the Fields will need to have Attribute packages attached to them, and the
   Attributes will be set with appropriate values. 

<P>
<PRE>
    convCC = 'CustomConvention'
    convESMF = 'ESMF'
    purpGen = 'General'
    name1 = 'ShortName'
    name2 = 'StandardName'
    name3 = 'LongName'
    name4 = 'Units'

    value1 = 'DPEDT'
    value2 = 'tendency_of_air_pressure'
    value3 = 'Edge pressure tendency'
    value4 = 'Pa s-1'

    DPEDT = ESMF_FieldCreate(grid, arrayspec=arrayspec, &amp;
              staggerloc=ESMF_STAGGERLOC_CENTER, rc=status)
    call ESMF_AttributeAdd(DPEDT, convention=convESMF, purpose=purpGen, &amp;
      attpack=attpack, rc=status)
    call ESMF_AttributeSet(DPEDT, name=name1, value=value1, &amp;
      attpack=attpack, rc=status)
    call ESMF_AttributeSet(DPEDT, name=name2, value=value2, &amp;
      attpack=attpack, rc=status)
    call ESMF_AttributeSet(DPEDT, name=name3, value=value3, &amp;
      attpack=attpack, rc=status)
    call ESMF_AttributeSet(DPEDT, name=name4, value=value4, &amp;
      attpack=attpack, rc=status)
</PRE>

<P>
... and so on for the other 9 Fields.

<P>
Now the Fields will be added to the FieldBundle, at which point the Attribute
   hierarchies of the Fields will also be attached to the Attribute hierarchy of
   the FieldBundle.  After that, the FieldBundle will be attached to the export
   State, again at which time the Attribute hierarchy of the FieldBundle will be
   attached to the Attribute hierarchy of the export State. 

<P>
<PRE>
    fieldbundle = ESMF_FieldBundleCreate(name="fieldbundle", rc=status)
    call ESMF_FieldBundleSet(fieldbundle, grid=grid, rc=status)

    call ESMF_FieldBundleAdd(fieldbundle, (/DPEDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/DTDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/DUDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/DVDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/PHIS/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/QTR/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CNV/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CONVCPT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CONVKE/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CONVPHI/), rc=status)

    call ESMF_StateAdd(exportState, fieldbundleList=(/fieldbundle/), rc=status)
</PRE>

<P>
At this point, the driver of the model run will transfer control to the
   initialize phase of the second gridded Component. 

<P>
In the second gridded Component initialize routine we don't have
   anything to do.  The data that was created in the initialize routine
   of the first gridded Component will be passed to this Component through
   the coupler Component.  The data will not be used in this Component
   until the run phase of the model.  So now the application driver transfers
   control to the initialize phase of the coupler Component. 

<P>
In the coupler Component initialize routine all that is required
   is to ensure consistent data across the VM.  The data created
   in the first gridded Component on one set of the PETs in the VM is
   intended to be read and manipulated by the second gridded Component
   which runs on an exclusive set of the PETs of the VM for this
   application.  We need to first make that data consistent across the
   entire VM with the <TT>ESMF_StateReconcile()</TT> call.
   This State level call handles both the data - Fields and FieldBundles,
   and the metadata - Attribute and Attribute packages.  There is a flag in
   this call to allow the user to specify whether they want
   the metadata to be reconciled or not. 

<P>
<PRE>
    type(ESMF_VM)         :: vm

    rc = ESMF_SUCCESS

    call ESMF_CplCompGet(comp, vm=vm, rc=rc)
    call ESMF_StateReconcile(importState, vm=vm, &amp;
               attreconflag=ESMF_ATTRECONCILE_ON, rc=rc)
    call ESMF_StateReconcile(exportState, vm=vm, &amp;
               attreconflag=ESMF_ATTRECONCILE_ON, rc=rc)
</PRE>

<P>
At this point, the driver of the model run will transfer control to the
   run phase of the first gridded Component. 

<P>
In the run phase of the first gridded Component is typically where the
   data contained in the Fields is manipulated.  For this simple example
   we will do no actual data manipulation because all we are interested in
   at this point is the metadata.  What we will do is add a nested Attribute
   package inside the currently existing Attribute package on each Field.  We
   will also change the value of one of the Attributes in the original Attribute
   package, and remove another of the Attributes from the original Attribute
   package on each of the Fields.  The first thing is to declare variables and
   get the Component, VM, State, and FieldBundle. 

<P>
<PRE>
        type(ESMF_AttPack)          :: attpack, attpackGen
    type(ESMF_VM)               :: vm
    integer                     :: petCount, status, myPet, k
    character(ESMF_MAXSTR)      :: name2,value2,convESMF,purpGen,purp2,name3
    character(ESMF_MAXSTR),dimension(2) :: attrList
    type(ESMF_Field)            :: field(10)
    type(ESMF_FieldBundle)      :: fieldbundle
    type(ESMF_Grid)             :: grid

    rc = ESMF_SUCCESS

    convESMF = 'ESMF'
    purpGen = 'General'
    name2 = 'StandardName'
    value2 = 'default_standard_name'
    name3 = 'LongName'

    purp2 = 'Extended'
    attrList(1) = 'Coordinates'
    attrList(2) = 'Mask'

    call ESMF_GridCompGet(comp, vm=vm, rc=status)
    call ESMF_VMGet(vm, petCount=petCount, localPet=myPet, rc=status)

    call ESMF_StateGet(exportState, "fieldbundle", fieldbundle, rc=rc)
    if (rc .ne. ESMF_SUCCESS) return
    call ESMF_FieldBundleGet(fieldbundle, grid=grid, rc=rc)
    if (rc .ne. ESMF_SUCCESS) return
</PRE>

<P>
At this point we will extract each of the Fields in the FieldBundle in turn
   and change the value of one Attribute in the original Attribute package,
   add a nested Attribute package, and delete one other of the Attributes in the
   original Attribute package.  These three changes represent, respectively, a
   value change and two structural changes to the Attribute hierarchy during
   run time, which must be reconciled across the VM before the second gridded
   Component can be allowed to further manipulate the Attribute hierarchy. 

<P>
<PRE>
    call ESMF_FieldBundleGet(fieldbundle, fieldList=field, rc=rc)
    if (rc .ne. ESMF_SUCCESS) return
    do k = 1, 10
        call ESMF_AttributeGetAttPack(field(k), convESMF, purpGen, &amp;
          attpack=attpackGen, rc=rc)
        if (rc .ne. ESMF_SUCCESS) return
        call ESMF_AttributeSet(field(k), name=name2, value=value2, &amp;
          attpack=attpackGen, rc=status)
        if (rc .ne. ESMF_SUCCESS) return
        call ESMF_AttributeAdd(field(k), attrList=attrList, &amp;
          convention=convESMF, purpose=purp2, &amp;
          nestConvention=convESMF, nestPurpose=purpGen, &amp;
          attpack=attpack, rc=rc)
        if (rc .ne. ESMF_SUCCESS) return
        call ESMF_AttributeSet(field(k), name='Coordinates', value='Latlon', &amp;
          attpack=attpack, rc=rc)
        if (rc .ne. ESMF_SUCCESS) return
        call ESMF_AttributeSet(field(k), name='Mask', value='Yes', &amp;
          attpack=attpack, rc=rc)
        if (rc .ne. ESMF_SUCCESS) return
        call ESMF_AttributeRemove(field(k), name=name3, &amp;
          attpack=attpackGen, rc=status)
        if (rc .ne. ESMF_SUCCESS) return
    enddo
</PRE>

<P>
At this point, the driver of the model run will transfer control to the
   run phase of the coupler Component. 

<P>
In the run phase of the coupler Component we must now ensure that the
   entire VM again has a consistent view of the Attribute hierarchy.  This
   is different from the communication done in the initialize phase of the
   model run because the only structural change that has occurred is in the
   Attribute hierarchy.  Therefore an <TT>ESMF_AttributeUpdate()</TT> call can
   be used at this point to reconcile these changes.  It should be noted that
   the <TT>ESMF_AttributeUpdate()</TT> call will reconcile value changes to the
   Attribute hierarchy as well as structural changes.

<P>
The first thing to do is to retrieve the Component, VM, and States.  Then
   <TT>ESMF_AttributeUpdate()</TT> will be called on the import State to accomplish
   a VM wide communication.  Afterwards, the Attribute hierarchy can be transferred,
   in a local sense, from the import State to the export State using an
   <TT>ESMF_AttributeCopy()</TT> call. 

<P>
<PRE>
    type(ESMF_VM)               :: vm
    integer                     :: myPet

    integer, dimension(2)       :: rootList

    rc = ESMF_SUCCESS

    call ESMF_CplCompGet(comp, vm=vm, rc=rc)

    call ESMF_VMGet(vm, localPet=myPet, rc=rc)

    call ESMF_StateGet(importState, rc=rc)
    call ESMF_StateGet(exportState, rc=rc)

    rootList = (/0,1/)
    call ESMF_AttributeUpdate(importState, vm, rootList=rootList, rc=rc)

    call ESMF_AttributeCopy(importState, exportState, &amp;
      attcopy=ESMF_ATTCOPY_REFERENCE, rc=rc)
</PRE>

<P>
At this point the entire VM has a consistent view of the Attribute hierarchy
   that was recently modified during <I>run time</I> in the first gridded component
   and the driver of the model run will transfer control to the
   run phase of the second gridded Component. 

<P>
In the run phase of the second gridded Component is normally where
   a user model would again manipulate the data it was given.  In this
   simple example we are only dealing with the metadata, which has already
   been ensured for consistency across the VM, including the exclusive
   piece of which is being used in this Component.  Therefore we are free
   to use the metadata as we wish, considering only that any changes we
   make to it during run time will have to first be reconciled before other
   parts of the VM can use them.  However, this is not our concern at this
   point because we will now explore the capabilities of <TT>ESMF_AttributeWrite()</TT>.

<P>
First we will get the Component and VM.  Then we will write out the
   Attribute hierarchy to an .xml file,
   after which we will write out the Attribute hierarchy to a more reader
   friendly tab-delimited format.  Both of these write calls will output their
   respective data into files in the execution directory, in either a .xml
   or .stdout file. 

<P>
<PRE>
    type(ESMF_VM)               :: vm
    integer                     :: petCount, status, myPet
    character(ESMF_MAXSTR)      :: convESMF,purpGen

    rc = ESMF_SUCCESS

    call ESMF_GridCompGet(comp, vm=vm, rc=status)
    if (status .ne. ESMF_SUCCESS) return
    call ESMF_VMGet(vm, petCount=petCount, localPet=myPet, rc=status)
    if (status .ne. ESMF_SUCCESS) return

    convESMF = 'ESMF'
    purpGen = 'General'

    if (myPet .eq. 2) then
      call ESMF_AttributeWrite(importState,convESMF,purpGen, &amp;
        attwriteflag=ESMF_ATTWRITE_XML, rc=rc)
      call ESMF_AttributeWrite(importState,convESMF,purpGen,rc=rc)
      if (rc .ne. ESMF_SUCCESS) return
    endif
</PRE>

<P>
At this point the driver of the model run would normally transfer control
   to the finalize phase of the first gridded Component.  However, there is
   not much of interest as far as metadata is concerned in this portion
   of the model run.  So with that we will conclude this example.


<P>

<P>

<P>

<H3><A NAME="SECTION06027500000000000000"></A> 
   <A NAME="ex:AttributeInternalInfoEx"></A>
<BR>
39.7.5 Accessing object information through Attribute
</H3>

<P>
This example demonstrates the ability to access object information through
   the Attribute class.  This capability is enabled only in the Grid class
   at this point.  Internal Grid information is retrieved through the 
   ESMF_AttributeGet() interface by specifying the name as a character
   string holding the keyword of the desired piece of Grid information.
   Information that requires input arguments is retrieved by
   specifying the input argument in a character array.

<P>
Some examples of this capability are given in this section.  The first
   shows how to get the name of a Grid, and the second shows how
   to get a more complex parameter which requires inputs.  First, we must
   initialize ESMF, declare some variables, and create a Grid: 

<P>
<PRE>
      ! Use ESMF framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! Local variables  
      integer                 :: rc, finalrc, petCount, localPet, result
      type(ESMF_VM)           :: vm
      type(ESMF_Grid)         :: grid
      type(ESMF_DistGrid)     :: distgrid
      character(ESMF_MAXSTR)  :: name
      character(ESMF_MAXSTR),dimension(3) :: inputList 
      integer(ESMF_KIND_I4)  :: exclusiveLBound(2), exclusiveUBound(2)
      integer(ESMF_KIND_I4)  :: exclusiveCount(2)

      character(ESMF_MAXSTR)               :: testname
      character(ESMF_MAXSTR)               :: failMsg
</PRE>

<P>
<PRE>
      ! initialize ESMF
      finalrc = ESMF_SUCCESS
      call ESMF_Initialize(vm=vm, &amp;
                defaultlogfilename="AttributeInternalInfoEx.Log", &amp;
                logkindflag=ESMF_LOGKIND_MULTI, rc=rc)

      distgrid=ESMF_DistGridCreate(minIndex=(/1,1/),maxIndex=(/10,10/), rc=rc)
</PRE>

<P>
<PRE>
      grid=ESMF_GridCreate(distgrid=distgrid, &amp;
                       coordTypeKind=ESMF_TYPEKIND_I4, &amp;
                       name="AttributeTestGrid", rc=rc)
</PRE>

<P>
This first call shows how to retrieve the name of a Grid.  The 
    return value is a character string in this case, which must be
    provided as the argument to 'value'.  The 'name' of the Attribute
    is specified as a character string whose value is the keyword of the piece
    of Grid information to retrieve preceded by a special tag.
    This tag, 'ESMF:', tells the ESMF_AttributeGet() routine that it
    should be looking for class information, rather than an Attribute
    that was previously created with the ESMF_AttributeSet() call. 

<P>
<PRE>
  call ESMF_AttributeGet(grid, name="ESMF:name", value=name, rc=rc)
</PRE>

<P>
This second call demonstrates how to retrieve the exclusiveCount from
    a Grid.  As before, the 'name' of the Attribute is specified as the
    keyword of the information to retrieve, preceded by the 'ESMF:' tag.
    The value is an integer array, which must be allocated to a sufficient
    size to hold all of the requested information.  The exclusiveCount of
    a Grid requires three pieces of input information: localDe, itemflag, and
    staggerloc.  These are specified in an array of character strings.  The
    name of the input parameter is separated from the value by a ':'. 

<P>
<PRE>
  inputList(:) = ''
  inputList(1) = 'localDe:0'
  inputList(2) = 'itemflag:ESMF_GRIDITEM_MASK'
  inputList(3) = 'staggerloc:ESMF_STAGGERLOC_CENTER'
  call ESMF_AttributeGet(grid, name="ESMF:exclusiveCount", &amp;
                         valueList=exclusiveCount, inputList=inputList, rc=rc)
</PRE>

<P>
That all there is to it!  Now we just have to Finalize ESMF: 

<P>
<PRE>
    call ESMF_Finalize(rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION06027600000000000000"></A>
   <A NAME="sec:attribute:usage:cimAttPack"></A>
<BR>
39.7.6 CIM Attribute packages
</H3>

<P>
This example illustrates the use of the Metafor CIM Attribute packages,
   supplied by ESMF, to create an Attribute hierarchy on an ESMF object tree.
   Gridded, coupler and science Components are used together with a State
   and a realistic Field
   to create a simple ESMF object tree.  CIM Attributes packages are created
   on the Components and Field, and then the individual Attributes within the
   packages are populated with values.  Finally, all the Attributes are written
   to a CIM-formatted XML file.  For a more comprehensive example, see the
   ESMF_AttributeCIM system test.

<P>
<PRE>
      ! Use ESMF framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! Local variables
      integer                 :: rc, finalrc, petCount, localPet, result
          type(ESMF_AttPack)      :: attpack
      type(ESMF_VM)           :: vm
      type(ESMF_Field)        :: ozone
      type(ESMF_State)        :: exportState
      type(ESMF_CplComp)      :: cplcomp
      type(ESMF_GridComp)     :: gridcomp
      type(ESMF_SciComp)      :: scicomp
      character(ESMF_MAXSTR)  :: convCIM, purpComp, purpProp, purpSci
      character(ESMF_MAXSTR)  :: purpField, purpPlatform
      character(ESMF_MAXSTR)  :: convISO, purpRP, purpCitation
      character(ESMF_MAXSTR), dimension(2)  :: compPropAtt
      character(ESMF_MAXSTR), dimension(2)  :: rad_sciPropAtt
      character(ESMF_MAXSTR)  :: testname
      character(ESMF_MAXSTR)  :: failMsg
</PRE>

<P>
<PRE>
      ! initialize ESMF
      finalrc = ESMF_SUCCESS
      call ESMF_Initialize(vm=vm, defaultlogfilename="AttributeCIMEx.Log", &amp;
        logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

      ! get the vm
      call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Create the ESMF objects that will hold the CIM Attributes.
      These objects include all three Component types (coupler, gridded,
      and science Components) as well as a State, and a Field.
      In this example we are constructing empty Fields without an
      underlying Grid.

<P>
<PRE>
      ! Create top-level Coupler Component
      cplcomp = ESMF_CplCompCreate(name="coupler_component", &amp;
        petList=(/0/), rc=rc)
</PRE>

<P>
<PRE>
      ! Create Gridded Component as a child of the Coupler Component
      gridcomp = ESMF_GridCompCreate(name="gridded_component", &amp;
        petList=(/0/), rc=rc)

      call ESMF_AttributeLink(cplcomp, gridcomp, rc=rc)
</PRE>

<P>
<PRE>
      ! Create Science Component as a child of the Gridded Component
      scicomp = ESMF_SciCompCreate(name="science_component", rc=rc)

      call ESMF_AttributeLink(gridcomp, scicomp, rc=rc)
</PRE>

<P>
<PRE>
      ! Create State
      exportState = ESMF_StateCreate(name="exportState",  &amp;
        stateintent=ESMF_STATEINTENT_EXPORT, rc=rc)
</PRE>

<P>
<PRE>
      ! Create Field
      ozone = ESMF_FieldEmptyCreate(name='ozone', rc=rc)
</PRE>

<P>
<PRE>
      convCIM = 'CIM 1.5'
      purpComp = 'ModelComp'
      purpProp = 'CompProp'
      purpSci = 'SciProp'
      purpField = 'Inputs'
      purpPlatform = 'Platform'

      convISO = 'ISO 19115'
      purpRP = 'RespParty'
      purpCitation = 'Citation'
</PRE>

<P>
Add CIM Component package and Attributes to the Coupler Component.

<P>
<PRE>
      call ESMF_AttributeAdd(cplcomp,  &amp;
                             convention=convCIM, purpose=purpComp, rc=rc)

      call ESMF_AttributeSet(cplcomp, "ShortName", "Driver", &amp;
                             convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(cplcomp, "LongName", &amp;
                             "Model Driver", &amp;
                             convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(cplcomp, "ModelType", &amp;
                             "climate", &amp;
                             convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      ! Simulation run attributes
      call ESMF_AttributeSet(cplcomp, 'SimulationShortName', &amp;
                                      'SMS.f09_g16.X.hector', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)

      call ESMF_AttributeSet(cplcomp, 'SimulationLongName', &amp;
        'EarthSys - Earth System Modeling Framework Earth System Model 1.0', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)

      call ESMF_AttributeSet(cplcomp, 'SimulationRationale', &amp;
  'EarthSys-ESMF simulation run in respect to CMIP5 core experiment 1.1 ()', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)

      call ESMF_AttributeSet(cplcomp, 'SimulationStartDate', &amp;
                                       '1960-01-01T00:00:00Z', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)

      call ESMF_AttributeSet(cplcomp, 'SimulationDuration', 'P10Y', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)

      call ESMF_AttributeSet(cplcomp, &amp;
         'SimulationNumberOfProcessingElements', '16', &amp;
          convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeGetAttPack(cplcomp, convCIM, purpPlatform, &amp;
        attpack=attpack, rc=rc)

      call ESMF_AttributeSet(cplcomp, 'MachineName', 'HECToR', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
</PRE>

<P>
Now add CIM Attribute packages and Attributes to the Gridded Component
      and Field.  Also, add a CIM Component Properties package, to contain
      two custom attributes.

<P>
<PRE>
      ! Add CIM Attribute package to the gridded Component
      call ESMF_AttributeAdd(gridcomp, convention=convCIM, &amp;
        purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      ! Specify the gridded Component to have a Component Properties
      ! package with two custom attributes, with user-specified names
      compPropAtt(1) = 'SimulationType'
      compPropAtt(2) = 'SimulationURL'
      call ESMF_AttributeAdd(gridcomp, convention=convCIM, purpose=purpProp, &amp;
        attrList=compPropAtt, rc=rc)
</PRE>

<P>
<PRE>
      ! Add CIM Attribute package to the Field
      call ESMF_AttributeAdd(ozone, convention=convCIM, purpose=purpField, &amp;
        rc=rc)
</PRE>

<P>
The standard Attribute package supplied by ESMF for a CIM Component
       contains several Attributes, grouped into sub-packages.  These
       Attributes conform to the CIM convention as defined by Metafor and
       their values are set individually.

<P>
<PRE>
      !
      ! Top-level model component attributes, set on gridded component
      !
      call ESMF_AttributeSet(gridcomp, 'ShortName', 'EarthSys_Atmos', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'LongName', &amp;
        'Earth System High Resolution Global Atmosphere Model', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'Description', &amp;
        'EarthSys brings together expertise from the global ' // &amp;
        'community in a concerted effort to develop coupled ' // &amp;
        'climate models with increased horizontal resolutions.  ' // &amp;
        'Increasing the horizontal resolution of coupled climate ' // &amp;
        'models will allow us to capture climate processes and ' // &amp;
        'weather systems in much greater detail.', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'Version', '2.0', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'ReleaseDate', '2009-01-01T00:00:00Z', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'ModelType', 'aerosol', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'URL', &amp;
        'www.earthsys.org', convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'MetadataVersion', '1.1', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      ! Document genealogy
      call ESMF_AttributeSet(gridcomp, 'PreviousVersion', &amp;
                                       'EarthSys1 Atmosphere', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'PreviousVersionDescription', &amp;
       'Horizontal resolution increased to 1.20 x 0.80 degrees; ' // &amp;
       'Timestep reduced from 30 minutes to 15 minutes.', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeGetAttPack(gridcomp, convCIM, purpPlatform, &amp;
        attpack=attpack, rc=rc)

      ! Platform description attributes
      call ESMF_AttributeSet(gridcomp, 'CompilerName', 'Pathscale', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'CompilerVersion', '3.0', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'MachineName', 'HECToR', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'MachineDescription', &amp;
        'HECToR (Phase 2a) is currently an integrated system known ' // &amp;
        'as Rainier, which includes a scalar MPP XT4 system, a vector ' // &amp;
        'system known as BlackWidow, and storage systems.', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'MachineSystem', 'Parallel', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineOperatingSystem', 'Unicos', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineVendor', 'Cray Inc', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineInterconnectType', &amp;
                                       'Cray Interconnect', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'MachineMaximumProcessors', '22656', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'MachineCoresPerProcessor', '4', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'MachineProcessorType', 'AMD X86_64', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeGetAttPack(gridcomp, convCIM, purpProp, &amp;
         attpack=attpack, rc=rc)

      ! Component Properties: custom attributes
      call ESMF_AttributeSet(gridcomp, 'SimulationType', 'branch', &amp;
        convention=convCIM, purpose=purpProp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'SimulationURL', &amp;
                                       'http://earthsys.org/simulations', &amp;
        convention=convCIM, purpose=purpProp, rc=rc)
</PRE>

<P>
Set the attribute values of the Responsible Party sub-package, created
      above for the gridded Component in the ESMF_AttributeAdd(gridcomp, ...)
      call.

<P>
<PRE>
      call ESMF_AttributeGetAttPack(gridcomp, convISO, purpRP, &amp;
        attpack=attpack, rc=rc)

      ! Responsible party attributes (for Principal Investigator)
      call ESMF_AttributeSet(gridcomp, 'Name', 'John Doe', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'Abbreviation', 'JD', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'PhysicalAddress', &amp;
          'Department of Meteorology, University of ABC', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'EmailAddress', &amp;
                                       'john.doe@earthsys.org', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'ResponsiblePartyRole', 'PI', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'URL', 'www.earthsys.org', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
</PRE>

<P>
Set the attribute values of the Citation sub-package, created above
      for the gridded Component in the ESMF_AttributeAdd(gridcomp, ...) call.

<P>
<PRE>
      call ESMF_AttributeGetAttPack(gridcomp, convISO, purpCitation, &amp;
        attpack=attpack, rc=rc)

      ! Citation attributes
      call ESMF_AttributeSet(gridcomp, 'ShortTitle', 'Doe_2009', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'LongTitle', &amp;
       'Doe, J.A.; Norton, A.B.; ' // &amp;
       'Clark, G.H.; Davies, I.J.. 2009 EarthSys: ' // &amp;
       'The Earth System High Resolution Global Atmosphere Model - Model ' // &amp;
       'description and basic evaluation. Journal of Climate, 15 (2). ' // &amp;
       '1261-1296.', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'Date', '2010-03-15', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'PresentationForm', 'Online Refereed', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'DOI', 'doi:17.1035/2009JCLI4508.1', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(gridcomp, 'URL', &amp;
                             'http://www.earthsys.org/publications', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
</PRE>

<P>
Add Component attributes to the Science Component and then add
       scientific properties to it.

<P>
<PRE>
      call ESMF_AttributeAdd(scicomp,  &amp;
                             convention=convCIM, purpose=purpComp, rc=rc)

      call ESMF_AttributeSet(scicomp, "ShortName", "AtmosRadiation", &amp;
                             convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(scicomp, "LongName", &amp;
                             "Atmosphere Radiation", &amp;
                             convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(scicomp, "ModelType", &amp;
                             "radiation", &amp;
                             convention=convCIM, purpose=purpComp, rc=rc)
</PRE>

<P>
<PRE>
      rad_sciPropAtt(1) = 'LongwaveSchemeType'
      rad_sciPropAtt(2) = 'LongwaveSchemeMethod'

      call ESMF_AttributeAdd(scicomp,  &amp;
                             convention=convCIM, purpose=purpSci, &amp;
                             attrList=rad_sciPropAtt, rc=rc)

      call ESMF_AttributeSet(scicomp, &amp;
                             'LongwaveSchemeType', &amp;
                             'wide-band model', &amp;
                             convention=convCIM, purpose=purpSci, rc=rc)
      call ESMF_AttributeSet(scicomp, &amp;
                             'LongwaveSchemeMethod', &amp;
                             'two-stream', &amp;
                             convention=convCIM, purpose=purpSci, rc=rc)
</PRE>

<P>
The standard Attribute package currently supplied by ESMF for
       CIM Fields contains a standard CF-Extended package nested within it.

<P>
<PRE>
      call ESMF_AttributeGetAttPack(ozone, convCIM, purpField, &amp;
        attpack=attpack, rc=rc)

      ! ozone CF-Extended Attributes
      call ESMF_AttributeSet(ozone, 'ShortName', 'Global_O3_mon', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'StandardName', 'ozone', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'LongName', 'ozone', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'Units', 'unknown', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
</PRE>

<P>
<PRE>
      ! ozone CIM Attributes
      call ESMF_AttributeSet(ozone, 'CouplingPurpose', 'Boundary', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(ozone, 'CouplingSource', 'EarthSys_Atmos', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(ozone, 'CouplingTarget', &amp;
       'EarthSys_AtmosDynCore', convention=convCIM, &amp;
        purpose=purpField, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(ozone, 'Description', &amp;
                                    'Global Ozone concentration ' // &amp;
                                    'monitoring in the atmosphere.', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(ozone, 'SpatialRegriddingMethod', &amp;
                                    'Conservative-First-Order', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(ozone, 'SpatialRegriddingDimension', '3D', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(ozone, 'Frequency', '15 Minutes', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(ozone, 'TimeTransformationType', &amp;
                                    'TimeInterpolation', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
</PRE>

<P>
Adding the Field to the State will automatically link the
       Attribute hierarchies from the State to the Field

<P>
<PRE>
      ! Add the Field directly to the State
      call ESMF_StateAdd(exportState, fieldList=(/ozone/), rc=rc)
</PRE>

<P>
The Attribute link between a Component and a State must be set manually.

<P>
<PRE>
      ! Link the State to the gridded Component
      call ESMF_AttributeLink(gridcomp, exportState, rc=rc)
</PRE>

<P>
Write the entire CIM Attribute hierarchy, beginning at the gridded
       Component (the top), to an XML file formatted to conform to CIM
       specifications.  The CIM output tree structure differs from the
       internal Attribute hierarchy in that it has all the attributes of
       the fields within its top-level &lt;modelComponent&gt; record.  The filename
       used, gridded_component.xml, is derived from the name of the gridded
       Component, given as an input argument in the ESMF_GridCompCreate()
       call above.  The file is written to the examples execution directory.

<P>
<PRE>
      call ESMF_AttributeWrite(cplcomp, convCIM, purpComp, &amp;
        attwriteflag=ESMF_ATTWRITE_XML,rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_StateDestroy(exportState, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_SciCompDestroy(scicomp, rc=rc)
      call ESMF_GridCompDestroy(gridcomp, rc=rc)
      call ESMF_CplCompDestroy(cplcomp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_Finalize(rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION06027700000000000000">
39.7.7 Read an XML file-based ESG Attribute package for a Gridded Component</A>
</H3>
   This example shows how to read an ESG Attribute Package for a Gridded
   Component from an XML file.  The XML file contains Attribute values filled-in
   by the user.  The standard ESG Component Attribute Package is supplied with
   ESMF and is defined in an XSD file, which is used to validate the XML file.
   See
   <DL>
<DT></DT>
<DD>ESMF_DIR/src/Superstructure/Component/etc/esmf_gridcomp.xml (Attribute Package values) and
   
</DD>
<DT></DT>
<DD>ESMF_DIR/src/Superstructure/Component/etc/esmf_comp.xsd (Attribute Package definition).
   
</DD>
</DL> 

<P>
<PRE>
      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! local variables
      type(ESMF_GridComp)    :: gridcomp
      type(ESMF_AttPack)   :: attpack
      character(ESMF_MAXSTR) :: attrvalue
      type(ESMF_VM)          :: vm
      integer                :: rc, petCount, localPet
</PRE>

<P>
<PRE>
      ! initialize ESMF
      call ESMF_Initialize(vm=vm, defaultlogfilename="AttReadGridCompEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      ! get the vm
      call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=rc)
</PRE>

<P>
<PRE>
      if (petCount&lt;4) then
        gridcomp = ESMF_GridCompCreate(name="gridcomp", &amp;
          petList=(/0/), rc=rc)
      else
        gridcomp = ESMF_GridCompCreate(name="gridcomp", &amp;
          petList=(/0,1,2,3/), rc=rc)
      endif
</PRE>

<P>
<PRE>
      ! Read an XML file to populate the ESG Attribute package of a GridComp.
      ! The file is validated against an internal, ESMF-supplied XSD file
      ! defining the standard ESG Component Attribute package (see file
      ! pathnames above).
      call ESMF_AttributeRead(comp=gridcomp, fileName="esmf_gridcomp.xml", &amp;
          rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "ComponentShortName" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='ComponentShortName', &amp;
                             value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "ComponentLongName" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='ComponentLongName', &amp;
                             value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "Agency" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='Agency', value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "Institution" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='Institution', value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "Version" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='Version', value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "Author" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='Author', value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "Discipline" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='Discipline', value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "PhysicalDomain" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='PhysicalDomain', &amp;
                             value=attrValue, convention='ESG', &amp;
                             purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "CodingLanguage" Attribute from a GridComp Test
      call ESMF_AttributeGet(gridcomp, name='CodingLanguage', &amp;
                             value=attrValue,  convention='ESG', &amp;
                             purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "ModelComponentFramework" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='ModelComponentFramework', &amp;
                             value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompDestroy(gridcomp, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION06027800000000000000">
39.7.8 Read an XML file-based CF Attribute package for a Field</A>
</H3>
   This example shows how to read a CF Attribute Package for a Field from an
   XML file.  The XML file contains Attribute values filled-in by the user.
   The standard CF Attribute Package is supplied with ESMF and is defined in
   an XSD file, which is used to validate the XML file.  See
   <DL>
<DT></DT>
<DD>ESMF_DIR/src/Infrastructure/Field/etc/esmf_field.xml (Attribute Package values) and
   
</DD>
<DT></DT>
<DD>ESMF_DIR/src/Infrastructure/Field/etc/esmf_field.xsd (Attribute Package definition).
   
</DD>
</DL> 

<P>
<PRE>
      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! local variables
      type(ESMF_Field)       :: field
      type(ESMF_AttPack)   :: attpack, attpack_extended
      character(ESMF_MAXSTR) :: attrvalue
      type(ESMF_VM)          :: vm
      integer                :: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF
      call ESMF_Initialize(vm=vm, defaultlogfilename="AttReadFieldEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      ! Create a field
      field = ESMF_FieldEmptyCreate(name="field", rc=rc)
</PRE>

<P>
<PRE>
      ! Read an XML file to populate the CF Attribute package of a Field.
      ! The file is validated against an internal, ESMF-supplied XSD file
      ! defining the standard CF Attribute package (see file pathnames above).
      call ESMF_AttributeRead(field=field, fileName="esmf_field.xml", rc=rc)
</PRE>

<P>
<PRE>
      ! Get CF "ShortName" Attribute from a Field
      call ESMF_AttributeGet(field, name='ShortName', value=attrValue, &amp;
                             convention='CF', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get CF "StandardName" Attribute from a Field
      call ESMF_AttributeGet(field, name='StandardName', &amp;
                             value=attrValue, &amp;
                             convention='CF', purpose='Extended', rc=rc)
</PRE>

<P>
<PRE>
      ! Get CF "LongName" Attribute from a Field
      call ESMF_AttributeGet(field, name='LongName', value=attrValue, &amp;
                             convention='CF', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get CF "Units" Attribute from a Field
      call ESMF_AttributeGet(field, name='Units', value=attrValue, &amp;
                             convention='CF', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_FieldDestroy(field, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION06027900000000000000">
39.7.9 Read and validate an XML file-based set of user-defined Attributes for a Coupler Component</A>
</H3>
   This example shows how to read and validate, from an XML and XSD file,
   respectively, a set of user-defined custom Attributes for a Coupler Component.
   See
   <DL>
<DT></DT>
<DD>ESMF_DIR/src/Superstructure/Component/etc/custom_cplcomp.xml (Attribute values) and 
   
</DD>
<DT></DT>
<DD>ESMF_DIR/src/Superstructure/Component/etc/custom_cplcomp.xsd (Attribute definitions)
   
</DD>
</DL> 

<P>
<PRE>
      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! local variables
      type(ESMF_CplComp)     :: cplcomp
      character(ESMF_MAXSTR) :: attrvalue
      type(ESMF_VM)          :: vm
      integer                :: rc, petCount, localPet
</PRE>

<P>
<PRE>
      ! initialize ESMF
      call ESMF_Initialize(vm=vm, &amp;
                    defaultlogfilename="AttReadCustCplCompEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      ! get the vm
      call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=rc)
</PRE>

<P>
<PRE>
      if (petCount&lt;4) then
        cplcomp = ESMF_CplCompCreate(name="cplcomp", &amp;
          petList=(/0/), rc=rc)
      else
        cplcomp = ESMF_CplCompCreate(name="cplcomp", &amp;
          petList=(/0,1,2,3/), rc=rc)
      endif
</PRE>

<P>
<PRE>
      ! Read an XML file to decorate a Coupler Component with custom,
      ! user-defined attributes, and validate them against a corresponding
      ! XSD schema file (see file pathnames above).
      call ESMF_AttributeRead(comp=cplcomp, fileName="custom_cplcomp.xml", &amp;
                              schemaFileName="custom_cplcomp.xsd", rc=rc)
</PRE>

<P>
<PRE>
      ! Get custom "MyAttribute1" from CplComp
      call ESMF_AttributeGet(cplcomp, name='MyAttribute1', value=attrValue, &amp;
           rc=rc)
</PRE>

<P>
<PRE>
      ! Get custom "MyAttribute2" from CplComp
      call ESMF_AttributeGet(cplcomp, name='MyAttribute2', value=attrValue, &amp;
           rc=rc)
</PRE>

<P>
<PRE>
      ! Get custom "MyAttribute3" from CplComp
      call ESMF_AttributeGet(cplcomp, name='MyAttribute3', value=attrValue, &amp;
           rc=rc)
</PRE>

<P>
<PRE>
      ! Get custom "MyAttribute4" from CplComp
      call ESMF_AttributeGet(cplcomp, name='MyAttribute4', value=attrValue, &amp;
           rc=rc)
</PRE>

<P>
<PRE>
      ! Get custom "MyAttribute5" from CplComp
      call ESMF_AttributeGet(cplcomp, name='MyAttribute5', value=attrValue, &amp;
           rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_CplCompDestroy(cplcomp, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION06028000000000000000">
39.8 Restrictions and Future Work</A>
</H2>

<P>

<H3><A NAME="SECTION06028100000000000000">
39.8.1 Attributes</A>
</H3>

<P>

<UL>
<LI>Case insensitive Attribute names, conventions, purposes, and values will be enabled in a future release.
</LI>
</UL>

<P>

<H3><A NAME="SECTION06028200000000000000">
39.8.2 Attribute packages</A>
</H3>

<P>

<UL>
<LI>A future capability may be to automatically create default object Attribute packages upon ESMF object creation, this is being prototyped with the CIM 1.5.1 grids package in the present release.
</LI>
<LI>The implementation of Grids is still in flux within the CIM.  In particular, this will affect the final appearance of the CIM 1.5.1 grids package in ESMF.
</LI>
<LI>A CIM Scientific Property Attribute Package will be added. For CMIP5, hundreds of Scientific Properties have been identified. All of these will be added to ESMF. 
</LI>
<LI>The Attribute packages ISO Responsible Party, ISO Citation, and CIM Platform can only be created automatically within a CIM Main component Attribute package.  In a future release, it will be possible to create these within other CIM Attribute packages as required, or as separate, standalone packages.
</LI>
</UL>

<P>

<H3><A NAME="SECTION06028300000000000000">
39.8.3 Attribute hierarchies</A>
</H3>

<P>

<UL>
<LI>The option of "deep" copies of an Attribute hierarchy will be added.
</LI>
</UL>

<P>

<H3><A NAME="SECTION06028400000000000000">
39.8.4 Attribute import and export</A>
</H3>

<UL>
<LI>The CIM XML output in this release validates against the official CIM v1.5 release.  CIM development is continuing, with further releases expected.  ESMF, in its future releases, will conform to these future CIM releases.
</LI>
<LI>CIM Attribute packages can only be output (to CIM XML); they may be inputtable (via XML) in a future release.
</LI>
</UL>

<H2><A NAME="SECTION06029000000000000000">
39.9 Design and Implementation Notes</A>
</H2>

<P>
This section covers Attribute memory deallocation, the use of <TT>ESMF_AttributeGet()</TT>, Attribute package nesting capabilities, issues with Attributes in a distributed environment, and reading/writing of Attributes via XML files.  Issues and procedures dealing with Attribute memory deallocation, using <TT>ESMF_AttributeGet()</TT> to retrieve Attribute lists, and nested Attribute package capabilities are discussed to help avoid misuse.  The limitations with Attributes in a distributed environment are also discussed, with an outline of the future work to be done in this area. 

<P>

<H3><A NAME="SECTION06029100000000000000">
39.9.1 Attribute memory deallocation</A>
</H3>

<P>
The Attribute class presents a somewhat different paradigm with respect to memory deallocation than other ESMF objects.  The <TT>ESMF_AttributeRemove()</TT> call can be issued to remove any Attribute from an ESMF object or an Attribute package on an ESMF object.  This call is also enabled to remove entire Attribute packages with one call, which would remove any nested Attribute packages as well.  The user is <B>not</B> required to remove all Attributes that are used in a model run.  The entire Attribute hierarchy will be removed automatically by ESMF, provided the ESMF objects which contain them are properly destroyed.  

<P>
The decision to remove either an Attribute or an Attribute package is made by calling <TT>ESMF_AttributeRemove()</TT> with the correct optional arguments.  If an Attribute which is not associated with any Attribute package should be removed, then the call must be issued without a convention or purpose argument.  If an Attribute in an Attribute package is to be removed, then the call should be issued with all three of name, convention, and purpose.  Finally, if an entire Attribute package is to be removed the call should be issued with a convention and purpose, but no Attribute name.

<P>

<H3><A NAME="SECTION06029200000000000000">
39.9.2 Using <TT>ESMF_AttributeGet()</TT> to retrieve Attribute lists</A>
</H3>

<P>
The behavior of the <TT>ESMF_AttributeGet()</TT> routine, when retrieving an Attribute containing a value list, follows a slightly different convention than other similar ESMF routines.  This routine requires the input of a Fortran array as a place to store the retrieved values of the Attribute list.  If the array that is given is longer that the list of Attribute values, the first part of the array will be filled, leaving the extra space untouched.  If, however, the array passed in is shorter than the number of Attribute values, the routine will exit with a return code which is not equal to <B>ESMF_SUCCESS</B>.  It is suggested that if it is required by the user to use a Fortran array that is longer than the number of Attribute values returned, only the indices of the array which the user desires to be filled with retrieved Attribute values should be passed into the routine.  

<P>
Similar behavior is exhibited with the <TT>defaultvalueList</TT> argument in the <TT>ESMF_AttributeGet()</TT> routine.  The difference here is that if the <TT>valueList</TT> is shorter than the <TT>defaultvalueList</TT> only the appropriate values will be filed in, and the routine will exit without error.  Likewise, if the <TT>valueList</TT> is longer than the <TT>defaultvalueList</TT> then the entire <TT>valueList</TT> will be populated with the beginning section of the <TT>defaultvalueList</TT> that is given.

<P>

<H3><A NAME="SECTION06029300000000000000">
39.9.3 Using Attribute package nesting capabilites</A>
</H3>

<P>
There is a recommended practice to organizing metadata conventions when using nested Attribute packages.  The most general Attribute packages should always be added first (innermost parts of the tree), followed by the more specific ones (encompassing tree branches).  For instance, when adding Attribute packages to a Field, it is recommended that the CF convention be added first, followed by the ESMF convention, followed by any additional customized Attribute packages.  

<P>
At this time there are several ESMF supplied Attribute packages, with a convention of ESMF and a purpose of General.  These Attribute packages are generated by calling <TT>ESMF_AttributeAdd()</TT> with the appropriate convention and purpose.  The ESMF standard Attribute packages can be customized by nesting a custom Attribute package around them.

<P>
Another consideration when using nested Attribute packages is to remember that when a nested Attribute package is removed every nested Attribute package below the point of removal will also be removed (like pruning a tree branch).  Thus, by removing the ESMF Attribute package on a Field, the CF Attribute package contained within it will also be removed.

<P>

<H3><A NAME="SECTION06029400000000000000"></A>
<A NAME="sec:Att:Dist"></A>
<BR>
39.9.4 Attributes in a distributed environment
</H3>

<P>
This section discusses the methods of building a consistent view of the metadata across the VM of a model run.  To better explain the ESMF capabilities for ensuring the integrity of Attributes in a distributed environment three types of changes to an Attribute hierarchy need to be specified, these are: 1. <B>link changes</B> are structural links created when two separate Attribute hierarchies are linked, 2. <B>structural changes</B> are changes which occur when Attributes or Attribute packages are added or removed within a single level of an Attribute hierarchy, and 3. <B>value changes</B> occur when the value portion of any single Attribute is modified.  These definitions will help to describe how <TT>ESMF_StateReconcile()</TT> and <TT>ESMF_AttributeUpdate()</TT> can be effectively used to ensure a consistent view of the metadata throughout a model run.

<P>
The <TT>ESMF_StateReconcile()</TT> call is used to create a consistent view of ESMF objects over the entire VM in the initialization phase of a model run.  All Attributes that are attached to an ESMF object contained in the State, i.e. an object that is being reconciled, can also be reconciled.  This is done by setting a flag in the <TT>ESMF_StateReconcile()</TT> call, see the State documentation for details.  This means that, at the conclusion of <TT>ESMF_StateReconcile()</TT> there is a one-to-one correspondence between Attribute hierarchies and the ESMF objects they represent.  This is the only place where link changes in an Attribute hierarchy can be resolved.

<P>
The <TT>ESMF_AttributeUpdate()</TT> call can be used any time during the run phase of a model to insure that either structural or value changes made to an Attribute hierarchy on a subset of the VM are consistently represented across the remainder of the VM.  At this time, link changes cannot be resolved by <TT>ESMF_AttributeUpdate()</TT> as this would represent a departure from the one-to-one correspondence between the Attribute hierarchy and the ESMF objects it represents.  This means that <TT>ESMF_AttributeUpdate()</TT> will only work if it is called after <TT>ESMF_StateReconcile()</TT> when link changes have been made.  

<P>
<TT>ESMF_AttributeUpdate()</TT> is similar to <TT>ESMF_StateReconcile()</TT> in that it must be called from a location that has a view of the entire VM across which to update the Attribute hierarchy, such as a coupler Component.  The main difference is that <TT>ESMF_AttributeUpdate()</TT> operates only on the underlying Attribute hierarchy of the given ESMF object.  The Attribute hierarchy may be updated as many times as necessary.  

<P>
The specification of a list of PETs that are to be used as the basis for the update is a key feature of this interface.  This allows a many-to-many communication, as well as the direct specification of which PETs are to be updated and which are to be used as the "real" values.  The information is basically transported from the Attributes on the PETs specified in the rootList to their counterparts on the PETs which are not specified in the rootList.  This means that care must be taken to ensure that the data on the PETs in the rootList is consistent.

<P>
Simultaneous changes or addition of the same Attributes in different order on both the source and destination PETs can result in inefficient and/or undefined behavior if the <TT>reconcile</TT> flag is not used. The <TT>reconcile</TT> flag will completely replace all Attributes on the destination PETs with those of the source PETs. The <TT>reconcile</TT> flag is a good way to ensure a consistent Attribute hierarchy when using <TT>ESMF_AttributeUpdate()</TT> for the first-pass metadata update in a situation where either <TT>ESMF_StateReconcile()</TT> is not available or some unusual state has arisen within the Attribute hierarchy.

<P>

<H3><A NAME="SECTION06029500000000000000">
39.9.5 Writing Attribute packages to file</A>
</H3>

<P>
The <TT>ESMF_AttributeWrite()</TT> interface is in limited form at the present time, as it can only be used reliably on the ESMF standard Attribute packages.  Chances are that it will perform as expected for most Attribute packages, but for now it is only guaranteed for the ESMF standard Attribute packages.  This routine is also not yet enabled to handle multi-valued Attributes.    One thing to remember when using this interface is that if you are writing an Attribute package that contains nested Attribute packages then all Attribute nested below the top level Attribute package will be written.

<P>

<H3><A NAME="SECTION06029600000000000000"></A>
<A NAME="sec:Att:Copy"></A>
<BR>
39.9.6 Copying Attribute hierarchies
</H3>

<P>
The <TT>ESMF_AttributeCopy()</TT> routine can be used to <I>locally</I> copy an Attribute hierarchy between Components, States, FieldBundles, Fields or Grids.  It is important to note that this is a local copy, and no inter-PET communication is carried out.  Another thing to note is that when this functionality is based on a reference copy any further changes made to some portions of the original Attribute hierarchy will also affect the new Attribute hierarchy.

<P>
The <TT>ESMF_AttCopy_Flag</TT> is used to specify which type of copy is desired. The default behavior is represented by <TT>ESMF_ATTCOPY_VALUE</TT> . This will copy by value (deep copy) only the first level of an Attribute hierarchy (i.e. Attributes and Attribute packages but none of the Attribute hierarchies that are linked by other objects). There is a reference copy represented by <TT>ESMF_ATTCOPY_REFERENCE</TT>, which is a strict shallow copy. Any changes to one Attribute hierarchy after the copy will also affect the other. A third type of copy can be done by setting the <TT>ESMF_AttCopy_Flag</TT> to <TT>ESMF_ATTCOPY_HYBRID</TT>. This is a hybrid approach of reference and value copies. Attributes and Attribute packates are copied by value, and links to Attribute hierarchies of other objects are copied by reference.

<P>

<H3><A NAME="SECTION06029700000000000000"></A>
<A NAME="Att:Xerces"></A>
<BR>
39.9.7 Reading and writing Attributes from XML files
</H3>

<P>
The Xerces C++ library, v3.1.0 or newer, is used to read XML files.
More specifically, the SAX2 API is currently used, although future releases may 
also use the DOM API.  The Xerces C++ website is 
http://xerces.apache.org/xerces-c/.  For more details, see the 
"ESMF Users Guide", "Building and Installing the ESMF, Third Party Libraries,
Xerces".  Also please see the section on Attribute I/O,&nbsp;<A HREF="node5.html#io:attributeio">37.2</A>.  
Writing Attribute XML files is performed with the standard C++ output file 
stream facility.

<P>

<H3><A NAME="SECTION06029800000000000000">
39.9.8 Attribute duplicates</A>
</H3>

<P>
The Attribute class has three different types of Attributes, they are: 1. regular Attributes, 2. Attribute packages, and 3. Attribute links.  Each of these types of Attributes have different behavior with respect to duplicates.

<P>
With regular Attributes a duplicate Attribute is replaced by the new value, sometimes resulting in a change in the type of the Attribute.  This behavior also applies to the individual Attributes inside an Attribute package.

<P>
The second type, Attribute packages (Attpacks), are groups of Attributes identified and organized by a "convention" and "purpose";  i.e. the name of an Attpack is just one of the three pieces of identifying information: 1. name, 2. convention, and 3. purpose.  If a duplicate Attpack is created (this is a common use case for some users) a fourth piece of identifying information is created by ESMF to separate the two Attpacks. The user can query for this fourth piece of identifying information, called an attPackInstanceName, either at the time of creation or later in the runtime.

<P>
The third type, Attribute links, are used to link the Attribute trees of two objects.  Duplicates of Attribute links are required for some of the operations within the ESMF containers, and therefore they are enabled.  However, because there is little demand for duplicate links on the user level, they cannot be deleted in any order other than the order in which they were added.

<H2><A NAME="SECTION060210000000000000000">
39.10 Object Model</A>
</H2>

<P>
Each Attribute contains a name-value pair in which the value can be any of several numeric, character, and logical types.  Each value type is implemented as a vector, and can hold one or several values.  The available ESMF Attribute value types include:

<P>
<A NAME="table:attTypes"></A>
<UL>
<LI><TT>ESMF_TYPEKIND_I4</TT>
</LI>
<LI><TT>ESMF_TYPEKIND_I8</TT>
</LI>
<LI><TT>ESMF_TYPEKIND_R4</TT>
</LI>
<LI><TT>ESMF_TYPEKIND_R8</TT>
</LI>
<LI><TT>ESMF_TYPEKIND_Logical</TT>
</LI>
<LI><TT>EMSF_TYPEKIND_Character</TT>
</LI>
</UL>

<P>
The other members of the Attribute class can be seen in Figure <A HREF="#fig:AttributeClassUML">35</A>  below, which shows a UML representation of the ESMF Attribute class.

<P>
In addition to a name, all Attributes within an Attribute package are identified by a convention, purpose, and the ESMF object type with which they are associated. These are additional strings that are initialized as empty until specified.

<P>
Also, all Attributes contain three vectors of pointers to other Attributes, which are empty until specified otherwise.  These vectors of Attribute pointers hold the Attributes, Attribute packages, and Attribute links.  This feature is what allows the Attribute class to self assemble complex structures for representing and organizing the metadata of an ESMF object hierarchy.

<P>
For a more detailed view of how Attribute packages and hierarchies are formed, see Figures <A HREF="#fig:AttributePackageUML">36</A> and <A HREF="#fig:AttributeHierarchyUML">37</A>, respectively.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:AttributeClassUML"></A><A NAME="75741"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 35:</STRONG>
The structure of the Attribute class</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><IMG
 WIDTH="305" HEIGHT="673" ALIGN="BOTTOM" BORDER="0"
 SRC="img193.png"
 ALT="\includegraphics{AttributeClassUML}">
</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:AttributePackageUML"></A><A NAME="75746"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 36:</STRONG>
The internal object organization for the representation of Attribute packages</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><IMG
 WIDTH="632" HEIGHT="690" ALIGN="BOTTOM" BORDER="0"
 SRC="img194.png"
 ALT="\includegraphics[width=5.5in,height=6in]{AttributePackageUML}">
</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:AttributeHierarchyUML"></A><A NAME="75751"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 37:</STRONG>
The internal object organization for the representation of Attribute hierarchies</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><IMG
 WIDTH="633" HEIGHT="690" ALIGN="BOTTOM" BORDER="0"
 SRC="img195.png"
 ALT="\includegraphics[width=5.5in,height=6in]{AttributeHierarchyUML}">
</DIV></TD></TR>
</TABLE>
</DIV>


<H2><A NAME="SECTION060211000000000000000">
39.11 Class API</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060211100000000000000">
39.11.1 ESMF_AttributeAdd - Add an ESMF standard Attribute package</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeAdd()
   subroutine ESMF_AttAddPackStd(&lt;object&gt;, convention, purpose, attpack, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: convention
   character (len = *), intent(in) :: purpose
   type(ESMF_AttPack), intent(inout), optional :: attpack
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add an ESMF standard Attribute package. See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A>
   for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the new Attribute package.
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the new Attribute package.
   
</DD>
<DT><STRONG>[attpack]</STRONG></DT>
<DD>An optional handle to the Attribute package that is to be created.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060211200000000000000">
39.11.2 ESMF_AttributeAdd - Add an ESMF standard Attribute package containing nested standard Attribute packages</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeAdd()
   subroutine ESMF_AttAddPackStdN(&lt;object&gt;, convention, purpose, &amp;
   nestConvention, nestPurpose, nestAttPackInstanceCountList, &amp;
   nestAttPackInstanceNameList, nestCount, &amp;
   nestAttPackInstanceNameCount, attpack, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: convention
   character (len = *), intent(in) :: purpose
   character (len = *), intent(in) :: nestConvention(:)
   character (len = *), intent(in) :: nestPurpose(:)
   integer, intent(in) :: nestAttPackInstanceCountList(:)
   character (len = *), intent(out) :: nestAttPackInstanceNameList(:)
   integer, intent(in), optional :: nestCount
   integer, intent(out), optional :: nestAttPackInstanceNameCount
   type(ESMF_AttPack), intent(inout), optional :: attpack
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add an ESMF standard Attribute package which contains a user-specified
   number of nested standard Attribute packages. ESMF generates and returns
   default instance names for the nested Attribute packages. These names
   can be used later to distinguish among multiple nested Attribute
   packages of the same type in calls to <TT>ESMF_AttributeGet()</TT>,
   <TT>ESMF_AttributeSet()</TT>, and <TT>ESMF_AttributeRemove()</TT>.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the new Attribute package.
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the new Attribute package.
   
</DD>
<DT><STRONG>nestConvention</STRONG></DT>
<DD>The convention(s) of the standard Attribute package(s) around
   which to nest the new Attribute package.
   
</DD>
<DT><STRONG>nestPurpose</STRONG></DT>
<DD>The purpose(s) of the standard Attribute package(s) around
   which to nest the new Attribute package.
   
</DD>
<DT><STRONG>nestAttPackInstanceCountList</STRONG></DT>
<DD>The desired number of nested Attribute package instances for each
   nested (nestConvention, nestPurpose) package type. Note: if only one
   of each nested package type is desired, then the
   <TT>ESMF_AttributeAdd()</TT> overloaded method
   <TT>ESMF_AttAddPackStd()</TT> should be used.
   
</DD>
<DT><STRONG>nestAttPackInstanceNameList</STRONG></DT>
<DD>The name(s) of the nested Attribute package instances, generated
   by ESMF, used to distinguish between multiple instances of the
   same convention and purpose.
   
</DD>
<DT><STRONG>[nestCount]</STRONG></DT>
<DD>The count of the number of nested Attribute package types to add to
   the new Attribute package.
   
</DD>
<DT><STRONG>[nestAttPackInstanceNameCount]</STRONG></DT>
<DD>The number of nested Attribute package instance names.
   
</DD>
<DT><STRONG>[attpack]</STRONG></DT>
<DD>An optional handle to the Attribute package that is to be created.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060211300000000000000">
39.11.3 ESMF_AttributeAdd - Add a custom Attribute package or modify an existing Attribute package</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeAdd()
   subroutine ESMF_AttAddPackCst(&lt;object&gt;, convention, purpose, &amp;
   attrList, count, redundant, attpack, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: convention
   character (len = *), intent(in) :: purpose
   character (len = *), intent(in) :: attrList(:)
   integer, intent(in), optional :: count
   logical, intent(in), optional :: redundant
   type(ESMF_AttPack), intent(inout), optional :: attpack
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a custom Attribute package to &lt;object&gt;, or add
   Attributes to an existing Attribute package. The <TT>redundant</TT> flag can
   be set to <TT>.true.</TT> to create redundant Attribute packages. Otherwise,
   Attributes will be added to an existing package. The <TT>attpack</TT> will be
   used instead of <TT>convention</TT> and <TT>purpose</TT> if both are present.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>attrList</STRONG></DT>
<DD>The list of Attribute names to specify the custom Attribute package.
   
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>The number of Attributes to add to the custom Attribute package.
   
</DD>
<DT><STRONG>[redundant]</STRONG></DT>
<DD>A flag to determine whether or not to create redundant Attribute
   packages. If an Attribute package already exists with the specified
   <TT>convention</TT> and <TT>purpose</TT> and <TT>redundant</TT> is set to
   <TT>.true.</TT> then a redundant Attribute package will be created.
   The default value is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[attpack]</STRONG></DT>
<DD>The handle to the Attribute package that was created.
   This can also be used as an input parameter to indicate the
   Attribute package to which additional Attributes should be added.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060211400000000000000">
39.11.4 ESMF_AttributeAdd - Add a custom Attribute package with nested Attribute packages</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeAdd()
   subroutine ESMF_AttAddPackCstN(&lt;object&gt;, convention, purpose, &amp;
   attrList, count, nestConvention, nestPurpose, nestCount, attpack, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: convention
   character (len = *), intent(in) :: purpose
   character (len = *), intent(in), optional :: attrList(:)
   integer, intent(in), optional :: count
   character (len = *), intent(in) :: nestConvention(:)
   character (len = *), intent(in) :: nestPurpose(:)
   integer, intent(in), optional :: nestCount
   type(ESMF_AttPack), intent(inout), optional :: attpack
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a custom Attribute package, with one or more nested Attribute
   packages, to &lt;object&gt;. Allows for building full multiple-child Attribute
   hierarchies (multi-child trees).
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attrList]</STRONG></DT>
<DD>The list of Attribute names to specify the custom Attribute package.
   
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>The number of Attributes to add to the custom Attribute package.
   
</DD>
<DT><STRONG>nestConvention</STRONG></DT>
<DD>The convention(s) of the Attribute package(s) around which to nest
   the new Attribute package.
   
</DD>
<DT><STRONG>nestPurpose</STRONG></DT>
<DD>The purpose(s) of the Attribute package(s) around which to nest the
   new Attribute package.
   
</DD>
<DT><STRONG>[nestCount]</STRONG></DT>
<DD>The number of nested Attribute packages to add to the custom
   Attribute package.
   
</DD>
<DT><STRONG>[attpack]</STRONG></DT>
<DD>An optional handle to the Attribute package that is to be created.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060211500000000000000">
39.11.5 ESMF_AttributeAdd - Add a custom Attribute package with a single nested Attribute package</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeAdd()
   subroutine ESMF_AttAddPackCstN1(&lt;object&gt;, convention, purpose, &amp;
   attrList, count, nestConvention, nestPurpose, attpack, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: convention
   character (len = *), intent(in) :: purpose
   character (len = *), intent(in), optional :: attrList(:)
   integer, intent(in), optional :: count
   character (len = *), intent(in) :: nestConvention
   character (len = *), intent(in) :: nestPurpose
   type(ESMF_AttPack), intent(inout), optional :: attpack
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a custom Attribute package, with a single nested Attribute
   package, to &lt;object&gt;. Allows for building single-child Attribute
   hierarchies (single-child trees).
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attrList]</STRONG></DT>
<DD>The list of Attribute names to specify the custom Attribute package.
   
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>The number of Attributes to add to the custom Attribute package.
   
</DD>
<DT><STRONG>nestConvention</STRONG></DT>
<DD>The convention of the Attribute package around which to nest
   the new Attribute package.
   
</DD>
<DT><STRONG>nestPurpose</STRONG></DT>
<DD>The purpose of the Attribute package around which to nest the
   new Attribute package.
   
</DD>
<DT><STRONG>[attpack]</STRONG></DT>
<DD>An optional handle to the Attribute package that is to be created.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060211600000000000000">
39.11.6 ESMF_AttributeCopy - Copy an Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeCopy()
   subroutine ESMF_AttributeCopy(&lt;object1&gt;, &lt;object2&gt;, attcopy, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object1&gt;, see below for supported values
   &lt;object2&gt;, see below for supported values
   type(ESMF_AttCopy_Flag),intent(in) optional :: attcopy
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Copy an Attribute hierarchy from &lt;object1&gt; to &lt;object2&gt;. The
   default behavior is to ignore (instead of replace) values on
   pre-existing Attributes.

<P>
Supported values for &lt;object1&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp1
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp1
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp1
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field1
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle1
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid1
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
Supported values for &lt;object2&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field2
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle2
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid2
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
NOTE: Copies between different ESMF object types are not possible at this time.

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object1&gt;</STRONG></DT>
<DD>An <TT>Attribute</TT>-bearing ESMF object.
   
</DD>
<DT><STRONG>&lt;object2&gt;</STRONG></DT>
<DD>An <TT>Attribute</TT>-bearing ESMF object.
   
</DD>
<DT><STRONG>[attcopy]</STRONG></DT>
<DD>A flag to determine if the copy is to be by reference, value,
   or hybrid. This flag is documented in section <A HREF="#const:attcopy">39.6.1</A>.
   The default is to copy by value.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060211700000000000000">
39.11.7 ESMF_AttributeGet - Get an Attribute from an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeGet(&lt;object&gt;, name, attpack, &lt;value&gt; &amp;
   &lt;defaultvalue&gt;, attnestflag, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   type(ESMF_AttPack), intent(inout) :: attpack
   &lt;value&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   &lt;defaultvalue&gt;, see below for supported values
   type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return an Attribute <TT>value</TT> from the &lt;object&gt;, or from an Attribute
   package on the &lt;object&gt;, specified by <TT>attpack</TT>. Internal information can also
   be retrieved from Grid objects by prepending 'ESMF:' to the name of the
   piece of information that is requested. See
   Section&nbsp;<A HREF="#sec:InternalInfo">39.5</A> for more information
   on which pieces of Grid data can be retrieved through this interface.
   A <TT>defaultvalue</TT> argument
   may be given if a return code is not desired when the Attribute is not
   found. See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute
   packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(in) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
Supported values for &lt;value&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out) :: value
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(out) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(out) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(out) :: value
   
</DD>
<DT></DT>
<DD>logical, intent(out) :: value
   
</DD>
<DT></DT>
<DD>character (len = *), intent(out) :: value
   
</DD>
</DL>

<P>
Supported values for &lt;defaultvalue&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>logical, intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in), optional :: defaultvalue
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to retrieve.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>&lt;value&gt;</STRONG></DT>
<DD>The value of the named Attribute.
   
</DD>
<DT><STRONG>[&lt;defaultvalue&gt;]</STRONG></DT>
<DD>The default value of the named Attribute.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060211800000000000000">
39.11.8 ESMF_AttributeGet - Get an Attribute pointing to internal class information from an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeGet(&lt;object&gt;, name, attpack, &lt;value&gt;, &amp;
   &lt;defaultvalue&gt;, inputList, attnestflag, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   type(ESMF_AttPack), intent(inout) :: attpack
   &lt;value&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   &lt;defaultvalue&gt;, see below for supported values
   character (len = *), intent(in), optional :: inputList(:)
   type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return an Attribute <TT>value</TT> from the &lt;object&gt;, or from an Attribute
   package on the &lt;object&gt;, specified by <TT>attpack</TT>. Internal class information can
   be retrieved by prepending 'ESMF:' to the name of the
   piece of information that is requested. See
   Section&nbsp;<A HREF="#sec:InternalInfo">39.5</A> for more information
   on this capability.
   A <TT>defaultvalue</TT> argument
   may be given if a return code is not desired when the Attribute is not
   found. See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute
   packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
</DL>

<P>
Supported values for &lt;value&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out) :: value
   
</DD>
<DT></DT>
<DD>character (len = *), intent(out) :: value
   
</DD>
</DL>

<P>
Supported values for &lt;defaultvalue&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in), optional :: defaultvalue
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to retrieve.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>The value of the named Attribute.
   
</DD>
<DT><STRONG>[&lt;defaultvalue argument&gt;]</STRONG></DT>
<DD>The default value of the named Attribute.
   
</DD>
<DT><STRONG>[inputList]</STRONG></DT>
<DD>A list of the input parameters required to retrieve internal info.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060211900000000000000">
39.11.9 ESMF_AttributeGet - Get an Attribute from an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeGet(&lt;object&gt;, name, attpack, &lt;valueList&gt;, &amp;
   &lt;defaultvalueList&gt;, attnestflag, itemCount, &amp;
   isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   type(ESMF_AttPack), intent(inout) :: attpack
   &lt;valueList&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   &lt;defaultvalueList&gt;, see below for supported values
   type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
   integer, intent(out), optional :: itemCount
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return an Attribute <TT>valueList</TT> from the &lt;object&gt;, or from an
   Attribute package on the &lt;object&gt;, specified by <TT>attpack</TT>. Internal
   information can also be retrieved from Grid objects by prepending 'ESMF:'
   to the name of the piece of information that is requested. See
   Section&nbsp;<A HREF="#sec:InternalInfo">39.5</A> for more information
   on which pieces of Grid data can be retrieved through this interface.
   A <TT>defaultvalueList</TT> list argument may be given if
   a return code is not desired when the Attribute is not found.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(in) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
Supported values for &lt;valueList&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>character (len = *), intent(out) :: valueList(:)
   
</DD>
</DL>

<P>
Supported values for &lt;defaultvalueList&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in), optional :: defaultvalueList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to retrieve.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>&lt;valueList&gt;</STRONG></DT>
<DD>The valueList of the named Attribute.
   
</DD>
<DT><STRONG>[&lt;defaultvalueList&gt;]</STRONG></DT>
<DD>The default value list of the named Attribute.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in a multi-valued Attribute.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602111000000000000000">
39.11.10 ESMF_AttributeGet - Get an Attribute pointing to internal class information from an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeGet(&lt;object&gt;, name, attpack, &lt;valueList&gt;, &amp;
   &lt;defaultvalueList&gt;, inputList, attnestflag, &amp;
   itemCount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   type(ESMF_AttPack), intent(inout) :: attpack
   &lt;valueList&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   &lt;defaultvalueList&gt;, see below for supported values
   character (len = *), intent(in), optional :: inputList(:)
   type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
   integer, intent(out), optional :: itemCount
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return an Attribute <TT>valueList</TT> from the &lt;object&gt;, or from an
   Attribute package on the &lt;object&gt;, specified by <TT>attpack</TT>. Internal class
   information can be retrieved by prepending 'ESMF:'
   to the name of the piece of information that is requested. See
   Section&nbsp;<A HREF="#sec:InternalInfo">39.5</A> for more information
   on this capability.
   A <TT>defaultvalueList</TT> list argument may be given if
   a return code is not desired when the Attribute is not found.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
</DL>

<P>
Supported values for &lt;valueList&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(out) :: valueList(:)
   
</DD>
</DL>

<P>
Supported values for &lt;defaultvalueList&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(in), optional :: defaultvalueList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to retrieve.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>&lt;valueList&gt;</STRONG></DT>
<DD>The valueList of the named Attribute.
   
</DD>
<DT><STRONG>[&lt;defaultvalueList&gt;]</STRONG></DT>
<DD>The default value list of the named Attribute.
   
</DD>
<DT><STRONG>[inputList]</STRONG></DT>
<DD>A list of the input parameters required to retrieve internal info.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in a multi-valued Attribute.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602111100000000000000">
39.11.11 ESMF_AttributeGet - Get an Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeGet(&lt;object&gt;, name, &lt;value&gt;, &lt;defaultvalue&gt;, &amp;
   convention, purpose, attPackInstanceName, attnestflag, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;value&gt;, see below for supported values
   &lt;defaultvalue&gt;, see below for supported values
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return an Attribute <TT>value</TT> from the &lt;object&gt;, or from an Attribute
   package on the &lt;object&gt;, specified by <TT>convention</TT>,
   <TT>purpose</TT>, and <TT>attPackInstanceName</TT>. Internal information can also
   be retrieved from Grid objects by prepending 'ESMF:' to the name of the
   piece of information that is requested. See
   Section&nbsp;<A HREF="#sec:InternalInfo">39.5</A> for more information
   on which pieces of Grid data can be retrieved through this interface.
   A <TT>defaultvalue</TT> argument
   may be given if a return code is not desired when the Attribute is not
   found. See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute
   packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(in) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
Supported values for &lt;value&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out) :: value
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(out) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(out) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(out) :: value
   
</DD>
<DT></DT>
<DD>logical, intent(out) :: value
   
</DD>
<DT></DT>
<DD>character (len = *), intent(out) :: value
   
</DD>
</DL>

<P>
Supported values for &lt;defaultvalue&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>logical, intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in), optional :: defaultvalue
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to retrieve.
   
</DD>
<DT><STRONG>&lt;value&gt;</STRONG></DT>
<DD>The value of the named Attribute.
   
</DD>
<DT><STRONG>[&lt;defaultvalue&gt;]</STRONG></DT>
<DD>The default value of the named Attribute.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602111200000000000000">
39.11.12 ESMF_AttributeGet - Get an Attribute pointing to internal class information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeGet(&lt;object&gt;, name, &lt;value&gt;, &lt;defaultvalue&gt;, &amp;
   inputList, convention, purpose, attPackInstanceName, attnestflag, &amp;
   isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;value&gt;, see below for supported values
   &lt;defaultvalue&gt;, see below for supported values
   character (len = *), intent(in), optional :: inputList(:)
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return an Attribute <TT>value</TT> from the &lt;object&gt;, or from an Attribute
   package on the &lt;object&gt;, specified by <TT>convention</TT>,
   <TT>purpose</TT>, and <TT>attPackInstanceName</TT>. Internal class information can
   be retrieved by prepending 'ESMF:' to the name of the
   piece of information that is requested. See
   Section&nbsp;<A HREF="#sec:InternalInfo">39.5</A> for more information
   on this capability.
   A <TT>defaultvalue</TT> argument
   may be given if a return code is not desired when the Attribute is not
   found. See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute
   packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
</DL>

<P>
Supported values for &lt;value&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out) :: value
   
</DD>
<DT></DT>
<DD>character (len = *), intent(out) :: value
   
</DD>
</DL>

<P>
Supported values for &lt;defaultvalue&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in), optional :: defaultvalue
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to retrieve.
   
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>The value of the named Attribute.
   
</DD>
<DT><STRONG>[&lt;defaultvalue argument&gt;]</STRONG></DT>
<DD>The default value of the named Attribute.
   
</DD>
<DT><STRONG>[inputList]</STRONG></DT>
<DD>A list of the input parameters required to retrieve internal info.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602111300000000000000">
39.11.13 ESMF_AttributeGet - Get an Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeGet(&lt;object&gt;, name, &lt;valueList&gt;, &amp;
   &lt;defaultvalueList&gt;, convention, purpose, attPackInstanceName, &amp;
   attnestflag, itemCount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;valueList&gt;, see below for supported values
   &lt;defaultvalueList&gt;, see below for supported values
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
   integer, intent(out), optional :: itemCount
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return an Attribute <TT>valueList</TT> from the &lt;object&gt;, or from an
   Attribute package on the &lt;object&gt;, specified by <TT>convention</TT>,
   <TT>purpose</TT>, and <TT>attPackInstanceName</TT>. Internal
   information can also be retrieved from Grid objects by prepending 'ESMF:'
   to the name of the piece of information that is requested. See
   Section&nbsp;<A HREF="#sec:InternalInfo">39.5</A> for more information
   on which pieces of Grid data can be retrieved through this interface.
   A <TT>defaultvalueList</TT> list argument may be given if
   a return code is not desired when the Attribute is not found.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(in) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
Supported values for &lt;valueList&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>character (len = *), intent(out) :: valueList(:)
   
</DD>
</DL>

<P>
Supported values for &lt;defaultvalueList&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in), optional :: defaultvalueList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to retrieve.
   
</DD>
<DT><STRONG>&lt;valueList&gt;</STRONG></DT>
<DD>The valueList of the named Attribute.
   
</DD>
<DT><STRONG>[&lt;defaultvalueList&gt;]</STRONG></DT>
<DD>The default value list of the named Attribute.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in a multi-valued Attribute.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602111400000000000000">
39.11.14 ESMF_AttributeGet - Get an Attribute pointing to internal class information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeGet(&lt;object&gt;, name, &lt;valueList&gt;, &amp;
   &lt;defaultvalueList&gt;, inputList, convention, purpose, attPackInstanceName, &amp;
   attnestflag, itemCount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;valueList&gt;, see below for supported values
   &lt;defaultvalueList&gt;, see below for supported values
   character (len = *), intent(in), optional :: inputList(:)
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   type(ESMF_AttNest_Flag),intent(in), optional :: attnestflag
   integer, intent(out), optional :: itemCount
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return an Attribute <TT>valueList</TT> from the &lt;object&gt;, or from an
   Attribute package on the &lt;object&gt;, specified by <TT>convention</TT>,
   <TT>purpose</TT>, and <TT>attPackInstanceName</TT>. Internal class
   information can be retrieved by prepending 'ESMF:'
   to the name of the piece of information that is requested. See
   Section&nbsp;<A HREF="#sec:InternalInfo">39.5</A> for more information
   on this capability.
   A <TT>defaultvalueList</TT> list argument may be given if
   a return code is not desired when the Attribute is not found.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
</DL>

<P>
Supported values for &lt;valueList&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(out) :: valueList(:)
   
</DD>
</DL>

<P>
Supported values for &lt;defaultvalueList&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(in), optional :: defaultvalueList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to retrieve.
   
</DD>
<DT><STRONG>&lt;valueList&gt;</STRONG></DT>
<DD>The valueList of the named Attribute.
   
</DD>
<DT><STRONG>[&lt;defaultvalueList&gt;]</STRONG></DT>
<DD>The default value list of the named Attribute.
   
</DD>
<DT><STRONG>[inputList]</STRONG></DT>
<DD>A list of the input parameters required to retrieve internal info.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in a multi-valued Attribute.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602111500000000000000">
39.11.15 ESMF_AttributeGet - Get the Attribute count from an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetCount(&lt;object&gt;, attpack, count, &amp;
   attcountflag, attnestflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   type(ESMF_AttPack), intent(inout) :: attpack
   integer, intent(out) :: count
   type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return the Attribute count for &lt;object&gt;.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(in) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>The number of all existing Attributes of the type designated in the
   <I>attcountflag</I>, not just Attribute that have been set.
   
</DD>
<DT><STRONG>[attcountflag]</STRONG></DT>
<DD>The flag to specify which attribute count to return, the
   default is ESMF_ATTGETCOUNT_ATTRIBUTE. This flag is documented
   in section <A HREF="#const:attgetcount">39.6.2</A>.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
EOP!--------------------------------------- 

<P>

<P>

<H3><A NAME="SECTION0602111600000000000000">
39.11.16 ESMF_AttributeGet - Get the Attribute count</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetCount(&lt;object&gt;, count, &amp;
   convention, purpose, attPackInstanceName, &amp;
   attcountflag, attnestflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   integer, intent(out) :: count
   character (len=*), intent(in), optional :: convention
   character (len=*), intent(in), optional :: purpose
   character (len=*), intent(in), optional :: attPackInstanceName
   type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return the Attribute count for &lt;object&gt;.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(in) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>The number of all existing Attributes of the type designated in the
   <I>attcountflag</I>, not just Attribute that have been set.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance.
   
</DD>
<DT><STRONG>[attcountflag]</STRONG></DT>
<DD>The flag to specify which attribute count to return, the
   default is ESMF_ATTGETCOUNT_ATTRIBUTE. This flag is documented
   in section <A HREF="#const:attgetcount">39.6.2</A>.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602111700000000000000">
39.11.17 ESMF_AttributeGet - Get Attribute info by name from an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetInfoByNamAP(&lt;object&gt;, name, attpack, &amp;
   attnestflag, typekind, itemCount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   type(ESMF_AttPack), intent(inout) :: attpack
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
   integer, intent(out), optional :: itemCount
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return information associated with an Attribute in an Attribute package,
   including <TT>typekind</TT> and <TT>itemCount</TT>.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(in) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to query.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the Attribute. This flag is documented in section
   <A HREF="node9.html#const:typekind">52.58</A>.
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in this Attribute.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602111800000000000000">
39.11.18 ESMF_AttributeGet - Get Attribute info by name</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetInfoByNam(&lt;object&gt;, name, &amp;
   convention, purpose, attPackInstanceName, &amp;
   attnestflag, typekind, itemCount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character (len=*), intent(in), optional :: convention
   character (len=*), intent(in), optional :: purpose
   character (len=*), intent(in), optional :: attPackInstanceName
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
   integer, intent(out), optional :: itemCount
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return information associated with the named Attribute,
   including <TT>typekind</TT> and <TT>itemCount</TT>.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(in) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to query.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the Attribute. This flag is documented in section
   <A HREF="node9.html#const:typekind">52.58</A>.
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in this Attribute.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602111900000000000000">
39.11.19 ESMF_AttributeGet - Get Attribute info by index number from an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetInfoByNum(&lt;object&gt;, attributeIndex, &amp;
   name, attpack, attnestflag, typekind, itemcount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   integer, intent(in) :: attributeIndex
   character (len = *), intent(out) :: name
   type(ESMF_AttPack), intent(inout) :: attpack
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
   integer, intent(out), optional :: itemCount
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns information associated with the indexed Attribute,
   including <TT>name</TT>, <TT>typekind</TT> and <TT>itemCount</TT>. Keep in
   mind that these indices start from 1, as expected in a Fortran API.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(in) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>attributeIndex</STRONG></DT>
<DD>The index number of the Attribute to query.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the Attribute. This flag is documented in section
   <A HREF="node9.html#const:typekind">52.58</A>.
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in this Attribute.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602112000000000000000">
39.11.20 ESMF_AttributeGet - Get Attribute info by index number</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetInfoByNum(&lt;object&gt;, attributeIndex, &amp;
   name, convention, purpose, attPackInstanceName, attnestflag, &amp;
   typekind, itemcount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   integer, intent(in) :: attributeIndex
   character (len = *), intent(out) :: name
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
   integer, intent(out), optional :: itemCount
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns information associated with the indexed Attribute,
   including <TT>name</TT>, <TT>typekind</TT> and <TT>itemCount</TT>. Keep in
   mind that these indices start from 1, as expected in a Fortran API.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(in) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>attributeIndex</STRONG></DT>
<DD>The index number of the Attribute to query.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when looking for this Attribute, the default
   is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in section
   <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the Attribute. This flag is documented in section
   <A HREF="node9.html#const:typekind">52.58</A>.
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in this Attribute.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602112100000000000000">
39.11.21 ESMF_AttributeGet - Get Attribute package instance names from an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetAPinstNamesAP(&lt;object&gt;, attpack, &amp;
   attPackInstanceNameList, attPackInstanceNameCount, &amp;
   attnestflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   type(ESMF_AttPack), intent(inout) :: attpack
   character (len = *), intent(out) :: attPackInstanceNameList(:)
   integer, intent(out) :: attPackInstanceNameCount
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get the Attribute package instance names of the ESMF_AttPack.
   Also get the number of such names.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>attPackInstanceNameList</STRONG></DT>
<DD>The name(s) of the Attribute package instances of the given
   convention and purpose.
   
</DD>
<DT><STRONG>attPackInstanceNameCount</STRONG></DT>
<DD>The number of Attribute package instance names.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when searching for this Attribute package,
   the default is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented
   in section <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602112200000000000000">
39.11.22 ESMF_AttributeGet - Get Attribute package instance names</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetAPinstNames(&lt;object&gt;, convention, purpose, &amp;
   attPackInstanceNameList, attPackInstanceNameCount, attnestflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in), :: convention
   character (len = *), intent(in), :: purpose
   character (len = *), intent(out) :: attPackInstanceNameList(:)
   integer, intent(out) :: attPackInstanceNameCount
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get the Attribute package instance names of the specified convention
   and purpose. Also get the number of such names.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the Attribute package instances.
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the Attribute package instances.
   
</DD>
<DT><STRONG>attPackInstanceNameList</STRONG></DT>
<DD>The name(s) of the Attribute package instances of the given
   convention and purpose.
   
</DD>
<DT><STRONG>attPackInstanceNameCount</STRONG></DT>
<DD>The number of Attribute package instance names.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when searching for this Attribute package,
   the default is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented
   in section <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602112300000000000000">
39.11.23 ESMF_AttributeGetAttPack - Get an ESMF Attribute package object and/or query for presence</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGetAttPack()
   subroutine ESMF_AttGetAttPack(&lt;object&gt;, convention, purpose, &amp;
   attPackInstanceName, attpack, attnestflag, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: convention
   character (len = *), intent(in) :: purpose
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character (len = *), intent(in), optional :: attPackInstanceName
   type(ESMF_AttPack), intent(inout), optional :: attpack
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get an ESMF Attribute package object. If there are redundant Attribute
   packages on this object then the <I>most recently created</I> one will be
   retrieved.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance.
   
</DD>
<DT><STRONG>[attpack]</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>A flag to determine whether to descend the
   Attribute hierarchy when searching for this Attribute package, the
   default is <TT>ESMF_ATTNEST_ON</TT>. This flag is documented in
   section <A HREF="node9.html#const:attnest">52.5</A>.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute package is present or not.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602112400000000000000">
39.11.24 ESMF_AttributeLink - Link a Component Attribute hierarchy to that of a Component or State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLink()
   subroutine ESMF_CompAttLink(&lt;object1&gt;, &lt;object2&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object1&gt;, see below for supported values
   &lt;object2&gt;, see below for supported values
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach a <TT>CplComp</TT>, <TT>GridComp</TT>, or <TT>SciComp</TT> Attribute
   hierarchy to the
   hierarchy of a <TT>CplComp</TT>, <TT>GridComp</TT>, <TT>SciComp</TT>, or
   <TT>State</TT>.

<P>
Supported values for the &lt;object1&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp1
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp1
   
</DD>
<DT></DT>
<DD>type(ESMF_SCiComp), intent(inout) :: comp1
   
</DD>
</DL>

<P>
Supported values for the &lt;object2&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object1&gt;</STRONG></DT>
<DD>The <I>parent</I> object in the Attribute hierarchy link.
   
</DD>
<DT><STRONG>&lt;object2&gt;</STRONG></DT>
<DD>The <I>child</I> object in the Attribute hierarchy link.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602112500000000000000">
39.11.25 ESMF_AttributeLink - Link a State Attribute hierarchy with the hierarchy of an Array, ArrayBundle, Field, FieldBundle, or State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLink()
   subroutine ESMF_StateAttLink(state, &lt;object&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(inout) :: state
   &lt;object&gt;, see below for supported values
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach a <TT>State</TT> Attribute hierarchy to the hierarchy of
   a <TT>Fieldbundle</TT>, <TT>Field</TT>, or another <TT>State</TT>.

<P>
Supported values for the &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> object.
   
</DD>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>The object with which to link hierarchies.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602112600000000000000">
39.11.26 ESMF_AttributeLink - Link a FieldBundle and Field Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLink()
   subroutine ESMF_FieldBundleAttLink(fieldbundle, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   type(ESMF_Field), intent(in) :: field
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach a <TT>FieldBundle</TT> Attribute hierarchy to the hierarchy of
   a <TT>Field</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
   
</DD>
<DT><STRONG>field</STRONG></DT>
<DD>An <TT>ESMF_Field</TT> object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602112700000000000000">
39.11.27 ESMF_AttributeLink - Link a Field and Grid Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLink()
   subroutine ESMF_FieldAttLink(field, grid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field
   type(ESMF_Grid), intent(in) :: grid
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach a <TT>Field</TT> Attribute hierarchy to the hierarchy of
   a <TT>Grid</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>An <TT>ESMF_Field</TT> object.
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>An <TT>ESMF_Grid</TT> object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602112800000000000000">
39.11.28 ESMF_AttributeLink - Link an ArrayBundle and Array Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLink()
   subroutine ESMF_ArrayBundleAttLink(arraybundle, array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   type(ESMF_Array), intent(in) :: array
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach an <TT>ArrayBundle</TT> Attribute hierarchy to the hierarchy of
   an <TT>Array</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD>An <TT>ESMF_ArrayBundle</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An <TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602112900000000000000">
39.11.29 ESMF_AttributeLinkRemove - Unlink a Component Attribute hierarchy from that of a Component or State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLinkRemove()
   subroutine ESMF_CompAttLinkRemove(&lt;object1&gt;, &lt;object2&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object1&gt;, see below for supported values
   &lt;object2&gt;, see below for supported values
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Unattach a <TT>CplComp</TT>, <TT>GridComp</TT>, or <TT>SciComp</TT> Attribute
   hierarchy from the hierarchy of a <TT>CplComp</TT>, <TT>GridComp</TT>,
   <TT>SciComp</TT>, or <TT>State</TT>.

<P>
Supported values for the &lt;object1&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp1
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp1
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp1
   
</DD>
</DL>

<P>
Supported values for the &lt;object2&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object1&gt;</STRONG></DT>
<DD>The <I>parent</I> object in the Attribute hierarchy link.
   
</DD>
<DT><STRONG>&lt;object2&gt;</STRONG></DT>
<DD>The <I>child</I> object in the Attribute hierarchy link.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602113000000000000000">
39.11.30 ESMF_AttributeLinkRemove - Unlink a State Attribute hierarchy from the hierarchy of an Array, ArrayBundle, Field, FieldBundle, or State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLinkRemove()
   subroutine ESMF_StateAttLinkRemove(state, &lt;object&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(inout) :: state
   &lt;object&gt;, see below for supported values
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Unattach a <TT>State</TT> Attribute hierarchy from the hierarchy of
   a <TT>Fieldbundle</TT>, <TT>Field</TT>, or another <TT>State</TT>.

<P>
Supported values for the &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> object.
   
</DD>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>The object with which to unlink hierarchies.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602113100000000000000">
39.11.31 ESMF_AttributeLinkRemove - Unlink a FieldBundle and Field Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLinkRemove()
   subroutine ESMF_FieldBundleAttLinkRemove(fieldbundle, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   type(ESMF_Field), intent(in) :: field
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Unattach a <TT>FieldBundle</TT> Attribute hierarchy from the hierarchy of
   a <TT>Field</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
   
</DD>
<DT><STRONG>field</STRONG></DT>
<DD>An <TT>ESMF_Field</TT> object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602113200000000000000">
39.11.32 ESMF_AttributeLinkRemove - Unlink a Field and Grid Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLinkRemove()
   subroutine ESMF_FieldAttLinkRemove(field, grid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field
   type(ESMF_Grid), intent(in) :: grid
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Unattach a <TT>Field</TT> Attribute hierarchy from the hierarchy of
   a <TT>Grid</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>An <TT>ESMF_Field</TT> object.
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>An <TT>ESMF_Grid</TT> object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602113300000000000000">
39.11.33 ESMF_AttributeLinkRemove - Unlink an ArrayBundle and Array Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLinkRemove()
   subroutine ESMF_ArrayBundleAttLinkRemove(arraybundle, array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   type(ESMF_Array), intent(in) :: array
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Unattach an <TT>ArrayBundle</TT> Attribute hierarchy from the hierarchy of
   an <TT>Array</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD>An <TT>ESMF_ArrayBundle</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An <TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602113400000000000000">
39.11.34 ESMF_AttributeRead - Read Attributes from an XML file</A>
</H3>

<P>
<A NAME="api:AttributeRead"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeRead(&lt;object&gt;, fileName, schemaFileName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in), optional :: fileName
   character (len = *), intent(in), optional :: schemaFileName
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Read Attributes for &lt;object&gt; from fileName, whose format is XML.
   schemaFileName format is XSD. If present, the schemaFileName is used to
   validate the contents of fileName. schemaFileName must be specified for
   a fileName containing custom, user-defined Attributes.

<P>
Requires the third-party Xerces C++ XML Parser library to be installed,
   v3.1.0 or newer. For more details, see the "ESMF Users Guide",
   "Building and Installing the ESMF, Third Party Libraries, Xerces" and
   the website
   <BR>
   "http://xerces.apache.org/xerces-c". Also please see the
   section on Attribute I/O,&nbsp;<A HREF="node5.html#io:attributeio">37.2</A>.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array ! not yet implemented
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arrayBundle ! not yet implemented
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: cplComp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: gridComp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: gridComp
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle ! not yet implemented
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distGrid ! not yet implemented
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>The <TT>ESMF</TT> object onto which the read Attributes will be placed.
   
</DD>
<DT><STRONG>[fileName]</STRONG></DT>
<DD>The name of the XML file to read.
   
</DD>
<DT><STRONG>[schemaFileName]</STRONG></DT>
<DD>The name of the XSD file to validate the contents of fileName.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602113500000000000000">
39.11.35 ESMF_AttributeRemove - Remove an Attribute or Attribute package using an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeRemove(&lt;object&gt;, name, &amp;
   attpack, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character (len = *), intent(in), optional :: name
   type(ESMF_AttPack), intent(inout) :: attpack
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Remove an Attribute, or Attribute package on &lt;object&gt;.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of the Attribute to remove.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
NOTE: An entire Attribute package can be removed by specifying
   <TT>attpack</TT> only, without <TT>name</TT>. By specifying
   <TT>attpack</TT> an Attribute will be removed
   from the corresponding Attribute package, if it exists. An
   Attribute can be removed directly from &lt;object&gt; by specifying
   <TT>name</TT>, without <TT>attpack</TT>.

<P>

<P>

<H3><A NAME="SECTION0602113600000000000000">
39.11.36 ESMF_AttributeRemove - Remove an Attribute or Attribute package</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeRemove(&lt;object&gt;, name, convention, purpose, &amp;
   attPackInstanceName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in), optional :: name
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Remove an Attribute, or Attribute package on &lt;object&gt;.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of the Attribute to remove.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
NOTE: An entire Attribute package can be removed by specifying
   <TT>convention</TT>, <TT>purpose</TT>, and <TT>attPackInstanceName</TT>
   only, without <TT>name</TT>. An
   Attribute can be removed directly from &lt;object&gt; by specifying
   <TT>name</TT>, without <TT>convention</TT>, <TT>purpose</TT>, and
   <TT>attPackInstanceName</TT>.

<P>

<P>

<H3><A NAME="SECTION0602113700000000000000">
39.11.37 ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeSet(&lt;object&gt;, name, &lt;value&gt;, attpack, &amp;
   rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;value&gt;, see below for supported values
   type(ESMF_AttPack), intent(inout) :: attpack
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach an Attribute to &lt;object&gt;, or set an Attribute in an
   Attribute package. The Attribute has a <TT>name</TT> and <TT>value</TT>,
   and, if in an Attribute package, a <TT>attpack</TT>.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
Supported values for the &lt;value&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in) :: value
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(in) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(in) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in) :: value
   
</DD>
<DT></DT>
<DD>logical, intent(in) :: value
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in) :: value
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to set.
   
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>The value of the Attribute to set.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602113800000000000000">
39.11.38 ESMF_AttributeSet - Set an Attribute to point to internal class information in an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeSet(&lt;object&gt;, name, &lt;value&gt;, attpack, &amp;
   inputList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;value&gt;, see below for supported values
   type(ESMF_AttPack), intent(inout) :: attpack
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character (len = *), intent(in), optional :: inputList(:)
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach an Attribute to &lt;object&gt;, or set an Attribute in an
   Attribute package. The Attribute has a <TT>name</TT> and <TT>value</TT>,
   and, if in an Attribute package, a <TT>attpack</TT>.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.
   The Attribute can
   also be set to be a pointer to internal class information. See Section
   <A HREF="#sec:InternalInfo">39.5</A> for a description of this capability.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
</DL>

<P>
Supported values for the &lt;value&gt; are:
   <DL>
<DT></DT>
<DD>character (len = *), intent(in), :: value
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to set.
   
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>The value of the Attribute to set.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>[inputList]</STRONG></DT>
<DD>A list of the input parameters required to set internal info.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602113900000000000000">
39.11.39 ESMF_AttributeSet - Set an Attribute in an ESMF_AttPack</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeSet(&lt;object&gt;, name, &lt;valueList&gt;, attpack, &amp;
   itemCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;valueList&gt;, see below for supported values
   type(ESMF_AttPack), intent(in) :: attpack
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: itemCount
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach an Attribute to &lt;object&gt;, or set an Attribute in an
   Attribute package. The Attribute has a <TT>name</TT> and a
   <TT>valueList</TT>, with an <TT>itemCount</TT>, and, if in an Attribute
   package, a <TT>attpack</TT>. See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a
   description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
Supported values for the &lt;valueList&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in) :: valueList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to set.
   
</DD>
<DT><STRONG>&lt;valueList argument&gt;</STRONG></DT>
<DD>The valueList of the Attribute to set.
   
</DD>
<DT><STRONG>attpack</STRONG></DT>
<DD>A handle to the Attribute package.
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in a multi-valued Attribute.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602114000000000000000">
39.11.40 ESMF_AttributeSet - Set an Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeSet(&lt;object&gt;, name, &lt;value&gt;, &amp;
   convention, purpose, attPackInstanceName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;value&gt;, see below for supported values
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach an Attribute to &lt;object&gt;, or set an Attribute in an
   Attribute package. The Attribute has a <TT>name</TT> and <TT>value</TT>,
   and, if in an Attribute package, <TT>convention</TT>, <TT>purpose</TT>, and
   <TT>attPackInstanceName</TT>.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
Supported values for the &lt;value&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in) :: value
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(in) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(in) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in) :: value
   
</DD>
<DT></DT>
<DD>logical, intent(in) :: value
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in) :: value
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to set.
   
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>The value of the Attribute to set.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance. (Not implemented yet)
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602114100000000000000">
39.11.41 ESMF_AttributeSet - Set an Attribute to point to internal class information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeSet(&lt;object&gt;, name, &lt;value&gt;, inputList,
   convention, purpose, attPackInstanceName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;value&gt;, see below for supported values
   character (len = *), intent(in), optional :: inputList(:)
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach an Attribute to &lt;object&gt;, or set an Attribute in an
   Attribute package. The Attribute has a <TT>name</TT> and <TT>value</TT>,
   and, if in an Attribute package, <TT>convention</TT>, <TT>purpose</TT>, and
   <TT>attPackInstanceName</TT>.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description of Attribute packages.
   The Attribute can
   also be set to be a pointer to internal class information. See Section
   <A HREF="#sec:InternalInfo">39.5</A> for a description of this capability.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
</DL>

<P>
Supported values for the &lt;value&gt; are:
   <DL>
<DT></DT>
<DD>character (len = *), intent(in), :: value
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to set.
   
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>The value of the Attribute to set.
   
</DD>
<DT><STRONG>[inputList]</STRONG></DT>
<DD>A list of the input parameters required to set internal info.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance. (Not implemented yet)
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602114200000000000000">
39.11.42 ESMF_AttributeSet - Set an Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeSet(&lt;object&gt;, name, &lt;valueList&gt;, &amp;
   convention, purpose, attPackInstanceName, itemCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;valueList&gt;, see below for supported values
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   integer, intent(in), optional :: itemCount
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach an Attribute to &lt;object&gt;, or set an Attribute in an
   Attribute package. The Attribute has a <TT>name</TT> and a
   <TT>valueList</TT>, with an <TT>itemCount</TT>, and, if in an Attribute
   package, <TT>convention</TT>, <TT>purpose</TT>, and <TT>attPackInstanceName</TT>.
   See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a
   description of Attribute packages.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
Supported values for the &lt;valueList&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in) :: valueList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to set.
   
</DD>
<DT><STRONG>&lt;valueList argument&gt;</STRONG></DT>
<DD>The valueList of the Attribute to set.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one
   of multiple Attribute package instances of the same convention
   and purpose, within a nest. If not specified, defaults to the
   first instance. (Not implemented yet)
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in a multi-valued Attribute.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602114300000000000000">
39.11.43 ESMF_AttributeUpdate - Update an Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeUpdate(&lt;object&gt;, vm, rootList, reconcile, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   type(ESMF_VM), intent(in) :: vm
   integer, intent(in) :: rootList(:)
   logical, intent(in), optional :: reconcile
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Update an Attribute hierarchy during runtime. The information from
   the PETs in the <TT>rootList</TT> is transferred to the PETs that are not
   in the <TT>rootList</TT>. Care should be taken to ensure that the
   information contained in the Attributes on the PETs in the <TT>rootList</TT>
   is consistent.
   If changes have been made to the underlying object hierarchy then either
   <TT>ESMF_StateReconcile()</TT> or the <TT>reconcile</TT> flag must be used to
   resolve them. The same applies if changes are made to both PETs and in
   the <TT>rootList</TT> and PETs outside of the <TT>rootList</TT>, or if the same
   changes are made in a different order.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>vm</STRONG></DT>
<DD>The virtual machine over which this Attribute hierarchy
   should be updated.
   
</DD>
<DT><STRONG>rootList</STRONG></DT>
<DD>The list of PETs that are to be used as the source of the update.
   
</DD>
<DT><STRONG>[reconcile]</STRONG></DT>
<DD>A logical flag used to indicate whether to use reconcile behavior 
   or normal update behavior. If <TT>reconcile</TT> is set to 
   <TT>.true.</TT> then the values of the root PETs will be sent to 
   the nonroot PETs without exception. Otherwise, an algorithm that 
   is optimized to use minimal memory will be used to update only 
   the modified parts of the Attribute hierarchy on the nonroot 
   PETs. The default value is <TT>.false.</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602114400000000000000">
39.11.44 ESMF_AttributeWrite - Write an Attribute package</A>
</H3>

<P>
<A NAME="api:AttributeWrite"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeWrite(&lt;object&gt;, convention, purpose, &amp;
   attwriteflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write the Attribute package for &lt;object&gt;. The Attribute package defines
   the convention, purpose, and object type of the associated Attributes. Either
   tab-delimited or xml format is achieved by using <TT>attwriteflag</TT>.
   Currently, only ESMF/ESG/CF Field Attribute packages can be written in
   tab-delimited format. See Section&nbsp;<A HREF="#sec:AttPacks">39.2</A> for a description
   of Attribute packages and their conventions, purposes, and object types.

<P>
This call is collective across the current VM.

<P>
Writing Attribute XML files is performed with the standard C++ output
   file stream facility.

<P>
Note: For an object type of <TT>ESMF_GridComp</TT>, convention='WaterML',
   purpose='TimeSeries', and
   <BR>
attwriteflag=ESMF_ATTWRITE_XML, an XML file
   conforming to a hydrologic standard called WaterML will be written. See
   the following for more information:

<P>
<DL>
<DT></DT>
<DD>"http://his.cuahsi.org/wofws.html"
   
</DD>
<DT></DT>
<DD>"http://www.earthsystemcurator.org/projects/waterml.shtml"
   
</DD>
</DL>

<P>
An ESMF Use Test Case is available which showcases an example of how
   to write a WaterML file; please see

<P>
<DL>
<DT></DT>
<DD>"http://esmf.cvs.sourceforge.net/viewvc/esmf/use_test_cases/ESMF_WaterML"
   
</DD>
<DT></DT>
<DD>"http://esmf.cvs.sourceforge.net/viewvc/esmf/use_test_cases/README"
   
</DD>
</DL>

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_SciComp), intent(in) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(in) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(in) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package.
   
</DD>
<DT><STRONG>[attwriteflag]</STRONG></DT>
<DD>The flag to specify which format is desired for the write, the
   default is ESMF_ATTWRITE_TAB. This flag is documented in
   section <A HREF="#const:attwrite">39.6.3</A>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<H1><A NAME="SECTION06030000000000000000">
40 Time Manager Utility</A>
</H1>
  
<P>
The ESMF Time Manager utility includes software for time and date 
representation and calculations, model time advancement, and the 
identification of unique and periodic events.  Since multi-component 
geophysical applications often require synchronization across
the time management schemes of the individual components, the 
Time Manager's standard calendars and consistent time representation 
promote component interoperability.
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Drift-free timekeeping through an integer-based internal time 
representation.  Both integers and reals can be specified at the interface.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>The ability to represent time as a rational fraction, to support 
exact timekeeping in applications that involve grid refinement.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for many calendar kinds, including user-customized calendars.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for both concurrent and sequential modes of component execution.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for varying and negative time steps.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION06031000000000000000">
40.1 Time Manager Classes</A>
</H2>
There are five ESMF classes that represent time concepts:

<UL>
<LI><B>Calendar</B>  A Calendar can be used to keep track of the 
date as an ESMF Gridded Component advances in time. Standard calendars 
(such as Gregorian and 360-day) and user-specified calendars are 
supported.  Calendars can be queried for quantities such as seconds 
per day, days per month, and days per year.  
</LI>
<LI><B>Time</B> A Time represents a time instant in a particular
calendar, such as November 28, 1964, at 7:31pm EST in the Gregorian 
calendar.  The Time class can be used 
to represent the start and stop time of a time integration.
</LI>
<LI><B>TimeInterval</B> TimeIntervals represent a period 
of time, such as 300 milliseconds.  Time steps can be represented 
using TimeIntervals.  
</LI>
<LI><B>Clock</B> Clocks collect the parameters and 
methods used for model time advancement into a convenient 
package.  A Clock can be queried for quantities such
as start time, stop time, current time, and time step.  Clock
methods include incrementing the current time, and determining
if it is time to stop.  
</LI>
<LI><B>Alarm</B> Alarms identify unique or periodic events
by ``ringing'' - returning a true value - at specified times.  
For example, an Alarm might be set to ring on the day of the 
year when leaves start falling from the trees in a climate model.
</LI>
</UL>

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="749" HEIGHT="215" ALIGN="BOTTOM" BORDER="0"
 SRC="img196.png"
 ALT="\includegraphics{TimeMgr_desc}">

</DIV>

<P>
In the remainder of this section, we briefly summarize the 
functionality that the Time Manager classes provide.  Detailed 
descriptions and usage examples precede the API listing for each 
class.

<P>

<H2><A NAME="SECTION06032000000000000000">
40.2 Calendar</A>
</H2>
An ESMF Calendar can be queried for seconds per day, days per month 
and days per year.  The flexible definition of Calendars allows them
to be defined for planetary bodies other than Earth.  The set of supported 
calendars includes:
<DL>
<DT><STRONG>Gregorian</STRONG></DT>
<DD>The standard Gregorian calendar.
</DD>
<DT><STRONG>no-leap</STRONG></DT>
<DD>The Gregorian calendar with no leap years.
</DD>
<DT><STRONG>Julian</STRONG></DT>
<DD>The standard Julian date calendar.
</DD>
<DT><STRONG>Julian Day</STRONG></DT>
<DD>The standard Julian days calendar.
</DD>
<DT><STRONG>Modified Julian Day</STRONG></DT>
<DD>The Modified Julian days calendar.
</DD>
<DT><STRONG>360-day</STRONG></DT>
<DD>A 30-day-per-month, 12-month-per-year calendar.
</DD>
<DT><STRONG>no calendar</STRONG></DT>
<DD>Tracks only elapsed model time in hours, minutes, seconds.
</DD>
</DL>
See Section&nbsp;<A HREF="#sec:Calendar">41.1</A> for more details on supported standard 
calendars, and how to create a customized ESMF Calendar.

<P>

<H2><A NAME="SECTION06033000000000000000">
40.3 Time Instants and TimeIntervals</A>
</H2>

<P>
<A NAME="subsec:Time_Instants_and_TimeIntervals"></A>TimeIntervals and Time instants (simply called Times) are the computational 
building blocks of the Time Manager utility.  TimeIntervals support operations
such as add, subtract, compare size, reset value, copy value, and subdivide
by a scalar.  Times, which are moments in time associated with specific
Calendars, can be incremented or decremented by TimeIntervals, compared to
determine which of two Times is later, differenced to obtain the TimeInterval
between two Times, copied, reset, and manipulated in other useful ways.
Times support a host of different queries, both for values of individual Time 
components such as year, month, day, and second, and for derived values such 
as day of year, middle of current month and Julian day.  It is also possible 
to retrieve the value of the hardware realtime clock in the form of a 
Time.  See Sections&nbsp;<A HREF="#sec:Time">42.1</A> and&nbsp;<A HREF="#sec:TimeInterval">43.1</A>, respectively,
for use and examples of Times and TimeIntervals.

<P>
Since climate modeling, numerical weather prediction and other 
Earth and space applications have widely varying time scales and require 
different sorts of calendars, Times and TimeIntervals must support 
a wide range of time specifiers, spanning nanoseconds to years.  The
interfaces to these time classes are defined so that the user can specify a time
using a combination of units selected from the list shown in 
Table&nbsp;<A HREF="#table:timeOpts">40.4</A>.  

<P>

<H2><A NAME="SECTION06034000000000000000">
40.4 Clocks and Alarms</A>
</H2>
Although it is possible to repeatedly step a Time forward by a 
TimeInterval using arithmetic on these basic types, it is useful to 
identify a higher-level concept to represent this function.  We refer to 
this capability as a Clock, and include in its required features the 
ability to store the start and stop times of 
a model run, to check when time advancement should cease, 
and to query the value of quantities such as the current time and the
time at the previous time step.  The Time Manager includes a class 
with methods that return a true value when a periodic or unique event 
has taken place; we refer to these as Alarms.  Applications may contain 
temporary or multiple Clocks and Alarms.  Sections&nbsp;<A HREF="#sec:Clock">44.1</A> and
<A HREF="#sec:Alarm">45.1</A> describe the use of Clocks and Alarms in detail.

<P>

<A NAME="table:timeOpts"></A>
<DIV ALIGN="CENTER">
</DIV>
<BR><P></P>
<DIV ALIGN="CENTER">

<A NAME="78502"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 17:</STRONG>
Specifiers for Times and TimeIntervals</CAPTION>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72>Unit</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Meaning</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;yy|yy_i8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Year.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>mm</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Month of the year.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>dd</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Day of the month.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;d|d_i8|d_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Julian or Modified Julian day.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;h|h_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Hour.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;m|m_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Minute.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;s|s_i8|s_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Second.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;ms|ms_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Millisecond.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;us|us_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Microsecond.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;ns|ns_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Nanosecond.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>O</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Time zone offset in integer number of hours and minutes.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;sN|sN_i8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Numerator for times of the form s <B><!-- MATH
 $+ 
\frac{{\rm sN}}{{\rm sD}}$
 -->
<IMG
 WIDTH="35" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img197.png"
 ALT="$ +
\frac{{\rm sN}}{{\rm sD}}$"></B>, where s is seconds and s, sN, and
sD are integers.  This format provides a mechanism for supporting
exact behavior.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;sD|sD_i8</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Denominator for times of the form s <B><!-- MATH
 $+ 
\frac{{\rm sN}}{{\rm sD}}$
 -->
<IMG
 WIDTH="35" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img197.png"
 ALT="$ +
\frac{{\rm sN}}{{\rm sD}}$"></B>, where s is seconds and s, sN, and
sD are integers.</TD>
</TR>
</TABLE>
</DIV>
<BR>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION06035000000000000000">
40.5 Design and Implementation Notes</A>
</H2>

<OL>
<LI><B>Base TimeIntervals and Times on the same integer representation.</B> 
It is useful to allow both TimeIntervals and Times to 
inherit from a single class, BaseTime.  In C++, this can be
implemented by using inheritance.  In Fortran, it can be implemented
by having the derived types TimeIntervals and Times
contain a derived type BaseTime.  In both cases, the 
BaseTime class can be made private and invisible to the user.

<P>
The result of this strategy is that Time Intervals and 
Times gain a consistent core representation of time as well a set
of basic methods.

<P>
The BaseTime class can be designed with a minimum number of elements
to represent any required time.  The design is based on the idea used
in the real-time POSIX 1003.1b-1993 standard.  That is, to represent
time simply as a pair of integers: one for seconds (whole) and one for
nanoseconds (fractional).  These can then be converted at the interface
level to any desired format.

<P>
For ESMF, this idea can be modified and extended, in order to handle the
requirements for a large time range (&gt; 200,000 years) and to exactly
represent any rational fraction, not just nanoseconds.  To handle the
large time range, a 64-bit or greater integer is used for whole seconds.
Any rational fractional second is expressed using two additional integers:
a numerator and a denominator.  Both the whole seconds and fractional
numerator are signed to handle negative time intervals and instants.
For arithmetic consistency both must carry the same sign (both positive
or both negative), except, of course, for zero values.  The fractional
seconds element (numerator) is bounded with respect to whole seconds. 
If the absolute value of the
numerator becomes greater than or equal to the denominator, whole
seconds are incremented or decremented accordingly and the numerator is
reset to the remainder.  Conversions are performed upon demand by
interface methods within the TimeInterval and
Time classes.  This is done because different applications require different
representations of time intervals and time instances.  Floating point values as well as integers can be specified for the various time units in the interfaces, see Table&nbsp;<A HREF="#table:timeOpts">40.4</A>.  Floating point values are represented internally as integer-based rational fractions.

<P>
The BaseTime class defines increment and decrement methods for basic
TimeInterval calculations between Time instants.  It is done here rather
than in the Calendar class because it can be done with simple 
second-based arithmetic that is calendar independent.  

<P>
Comparison methods can also be defined in the BaseTime class.  These
perform equality/inequality, less than, and greater than comparisons
between any two TimeIntervals or Times.  These methods capture
the common comparison logic between TimeIntervals and Times and
hence are defined here for sharing.

<P>
</LI>
<LI><B>The Time class depends on a calendar.</B> The Time class contains 
an internal Calendar class.  
Upon demand by a user, the results of an increment or decrement operation are 
converted to user units, which may be calendar-dependent, via methods 
obtained from their internal Calendar.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION06036000000000000000">
40.6 Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
Time Manager utility.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="749" HEIGHT="346" ALIGN="BOTTOM" BORDER="0"
 SRC="img198.png"
 ALT="\includegraphics{TimeMgr_obj}">   

</DIV>

<H1><A NAME="SECTION06040000000000000000">
41 Calendar Class</A>
</H1>

<H2><A NAME="SECTION06041000000000000000">
41.1 Description</A>
</H2>

<P>
<A NAME="sec:Calendar"></A>The Calendar class represents the standard calendars used in 
geophysical modeling:  Gregorian, Julian, Julian Day, Modified Julian Day, 
no-leap, 360-day, and no-calendar.  It also supports a user-customized 
calendar.  Brief descriptions are provided for each calendar below.  For more 
information on standard calendars, see&nbsp;[<A
 HREF="node8.html#Seidelman">25</A>] and&nbsp;[<A
 HREF="node8.html#Meyer1">21</A>].

<H2><A NAME="SECTION06042000000000000000">
41.2 Constants</A>
</H2>

<P>
<A NAME="subsec:Calendar_options"></A>
<P>

<H3><A NAME="SECTION06042100000000000000"></A>
<A NAME="const:calkindflag"></A>
<BR>
41.2.1 ESMF_CALKIND
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Supported calendar kinds.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_CalKind_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_CALKIND_360DAY</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
In the 360-day calendar, there are 12 months, each of which has 30 days.  
Like the no-leap calendar, this is a simple approximation to the Gregorian
calendar sometimes used by modelers.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_CUSTOM</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
The user can set calendar parameters in the generic calendar.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_GREGORIAN</STRONG></DT>
<DD><I>Valid range: 3/1/4801 BC to 10/29/292,277,019,914 </I>
<BR>
The Gregorian calendar is the calendar currently in use 
throughout Western countries.  Named after Pope Gregory XIII, it is a minor 
correction to the older Julian calendar. In the Gregorian calendar every
fourth year is a leap year in which February has 29 and not 28 days;
however, years divisible by 100 are not leap years unless they are also 
divisible  by 400.  As in the Julian calendar, days begin at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_JULIAN</STRONG></DT>
<DD><I>Valid range: 3/1/4713 BC to 4/24/292,271,018,333 </I> 
<BR>
The Julian calendar was introduced by Julius Caesar in 46 B.C., and 
reached its final form in 4 A.D.  The Julian calendar differs from the 
Gregorian only in the determination of leap years, lacking the correction 
for years divisible by 100 and 400 in the Gregorian calendar.  In the Julian 
calendar, any year is a leap year if divisible by 4.  Days are considered to 
begin at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_JULIANDAY</STRONG></DT>
<DD><I>Valid range:  +/- 1x10<IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img199.png"
 ALT="$^{14}$"></I> 
<BR>
Julian days simply enumerate the days and fraction of a day which 
have elapsed since the start of the Julian era, defined as beginning at noon 
on Monday, 1st January of year 4713 B.C. in the Julian calendar.  Julian days, 
unlike the dates in the Julian and Gregorian calendars, begin at noon.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_MODJULIANDAY</STRONG></DT>
<DD><I>Valid range:  +/- 1x10<IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img199.png"
 ALT="$^{14}$"></I>
<BR>
The Modified Julian Day (MJD) was introduced by space scientists in
 the late 1950's.  It is defined as an offset from the Julian Day (JD):

<P>
MJD = JD - 2400000.5

<P>
The half day is subtracted so that the day starts at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_NOCALENDAR</STRONG></DT>
<DD><I>Valid range: machine limits</I>
<BR>
The no-calendar option simply tracks the elapsed model time in seconds.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_NOLEAP</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
The no-leap calendar is the Gregorian calendar with no leap years - 
February is always assumed to have 28 days.  Modelers sometimes use this 
calendar as a simple, close approximation to the Gregorian calendar.

<P>
</DD>
</DL>

<H2><A NAME="SECTION06043000000000000000">
41.3 Use and Examples</A>
</H2>

<P>
In most multi-component Earth system applications, the timekeeping in 
each component 
must refer to the same standard calendar in order for the components 
to properly synchronize.  It therefore makes sense to create as few 
ESMF Calendars as possible, preferably one per application.
A typical strategy would be to create a single Calendar at the start
of an application, and use that Calendar in all subsequent calls that
accept a Calendar, such as <TT>ESMF_TimeSet</TT>.

<P>
The following example shows how to set up an ESMF Calendar.  

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_CalendarEx - Calendar creation examples
!
! !DESCRIPTION:
!
! This program shows examples of how to create different calendar kinds
!-----------------------------------------------------------------------------
#include "ESMF.h"

      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! instantiate calendars
      type(ESMF_Calendar) :: gregorianCalendar
      type(ESMF_Calendar) :: julianDayCalendar
      type(ESMF_Calendar) :: marsCalendar

      ! local variables for Get methods
      integer :: sols
      integer(ESMF_KIND_I8) :: dl
      type(ESMF_Time) :: time, marsTime
      type(ESMF_TimeInterval) :: marsTimeStep

      ! return code
      integer:: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultlogfilename="CalendarEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06043100000000000000">
41.3.1 Calendar creation</A>
</H3>

<P>
This example shows how to create three <TT>ESMF_Calendars</TT>. 

<P>
<PRE>
      ! create a Gregorian calendar
      gregorianCalendar = ESMF_CalendarCreate(ESMF_CALKIND_GREGORIAN, &amp;
                                              name="Gregorian", rc=rc)
</PRE>

<P>
<PRE>
      ! create a Julian Day calendar
      julianDayCalendar = ESMF_CalendarCreate(ESMF_CALKIND_JULIANDAY, &amp;
                                              name="JulianDay", rc=rc)
</PRE>

<P>
<PRE>
      ! create a Custom calendar for the planet Mars
      ! 1 Mars solar day = 24 hours, 39 minutes, 35 seconds = 88775 seconds
      ! 1 Mars solar year = 668.5921 Mars solar days = 668 5921/10000 sols/year
      ! http://www.giss.nasa.gov/research/briefs/allison_02
      ! http://www.giss.nasa.gov/tools/mars24/help/notes.html
      marsCalendar = ESMF_CalendarCreate(secondsPerDay=88775, &amp;
                                         daysPerYear=668, &amp;
                                         daysPerYearDn=5921, &amp;
                                         daysPerYearDd=10000, &amp;
                                         name="MarsCalendar", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06043200000000000000">
41.3.2 Calendar comparison</A>
</H3>

<P>
This example shows how to compare an <TT>ESMF_Calendar</TT> with a known
   calendar kind. 

<P>
<PRE>
      ! compare calendar kind against a known type
      if (gregorianCalendar == ESMF_CALKIND_GREGORIAN) then
        print *, "gregorianCalendar is of type ESMF_CALKIND_GREGORIAN."
      else
        print *, "gregorianCalendar is not of type ESMF_CALKIND_GREGORIAN."
      end if
</PRE>

<P>

<H3><A NAME="SECTION06043300000000000000">
41.3.3 Time conversion between Calendars</A>
</H3>

<P>
This example shows how to convert a time from one <TT>ESMF_Calendar</TT>
   to another. 

<P>
<PRE>
      call ESMF_TimeSet(time, yy=2004, mm=4, dd=17, &amp;
                        calendar=gregorianCalendar, rc=rc)
</PRE>

<P>
<PRE>
      ! switch time's calendar to perform conversion
      call ESMF_TimeSet(time, calendar=julianDayCalendar, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeGet(time, d_i8=dl, rc=rc)
      print *, "Gregorian date 2004/4/17 is ", dl, &amp;
               " days in the Julian Day calendar."
</PRE>

<P>

<H3><A NAME="SECTION06043400000000000000">
41.3.4 Add a time interval to a time on a Calendar</A>
</H3>

<P>
This example shows how to increment a time using a custom <TT>ESMF_Calendar</TT>. 

<P>
<PRE>
      ! Set a time to Mars solar year 3, sol 100
      call ESMF_TimeSet(marsTime, yy=3, d=100, &amp;
                        calendar=marsCalendar, rc=rc)
</PRE>

<P>
<PRE>
      ! Set a 1 solar year time step
      call ESMF_TimeIntervalSet(marsTimeStep, yy=1, rc=rc)
</PRE>

<P>
<PRE>
      ! Perform the increment
      marsTime = marsTime + marsTimeStep
</PRE>

<P>
<PRE>
      ! Get the result in sols (2774 = (3+1)*668.5921 + 100)
      call ESMF_TimeGet(marsTime, d=sols, rc=rc)
      print *, "For Mars, 3 solar years, 100 sols + 1 solar year = ", &amp;
                sols, "sols."
</PRE>

<P>

<H3><A NAME="SECTION06043500000000000000">
41.3.5 Calendar destruction</A>
</H3>

<P>
This example shows how to destroy three <TT>ESMF_Calendars</TT>. 

<P>
<PRE>
      call ESMF_CalendarDestroy(julianDayCalendar, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_CalendarDestroy(gregorianCalendar, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_CalendarDestroy(marsCalendar, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_CalendarEx
</PRE>

<P>


<H2><A NAME="SECTION06044000000000000000">
41.4 Restrictions and Future Work</A>
</H2>

<P>
<A NAME="subsec:Calendar_rest"></A>
<P>

<OL>
<LI><B>Months per year set to 12.</B> Due to the requirement of only Earth modeling, the number of months per year is hard-coded at 12.  However, for easy modification, this is implemented via a C preprocessor #define MONTHS_PER_YEAR in ESMCI_Calendar.h.

<P>
</LI>
<LI><B>Calendar date conversions.</B> Date conversions are currently defined between the Gregorian, Julian, Julian Day, and Modified Julian Day calendars. Further research and work would need to be done to determine conversion algorithms with and between the other calendars:  No Leap, 360 Day, and Custom.

<P>
</LI>
<LI><B>ESMF_CALKIND_CUSTOM.</B> Currently, there is no provision for a custom calendar to define a leap year rule, so <TT>ESMF_CalendarIsLeapYear()</TT> will always return <TT>.false.</TT> in this case.  However, the arguments <TT>daysPerYear</TT>, <TT>daysPerYearDn</TT>, and <TT>daysPerYearDd</TT> in <TT>ESMF_CalendarCreate()</TT> and <TT>ESMF_CalendarSet()</TT> can be used to set a fractional number of days per year, for example, 365.25 = 365 25/100.  Also, if further timekeeping precision is required, fractional and/or floating point <TT>secondsPerDay</TT> and <TT>secondsPerYear</TT> could be added to the interfaces <TT>ESMF_CalendarCreate()</TT>, <TT>ESMF_CalendarSet()</TT>, and <TT>ESMF_CalendarGet()</TT> and implemented.

<P>
</LI>
</OL>

<H2><A NAME="SECTION06045000000000000000">
41.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06045100000000000000">
41.5.1 ESMF_CalendarAssignment(=) - Assign a Calendar to another Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface assignment(=)
       calendar1 = calendar2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar) :: calendar1
       type(ESMF_Calendar) :: calendar2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign <TT>calendar1</TT> as an alias to the same <TT>ESMF_Calendar</TT> 
       object in memory as <TT>calendar2</TT>. If <TT>calendar2</TT> is invalid, then 
       <TT>calendar1</TT> will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar1</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object on the left hand side of the 
            assignment.
       
</DD>
<DT><STRONG>calendar2</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object on the right hand side of the 
            assignment.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045200000000000000">
41.5.2 ESMF_CalendarOperator(==) - Test if Calendar argument 1 is equal to Calendar argument 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (&lt;calendar argument 1&gt; == &lt;calendar argument 2&gt;) then ... endif
                                   OR
       result = (&lt;calendar argument 1&gt; == &lt;calendar argument 2&gt;)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       &lt;calendar argument 1&gt;, see below for supported values
       &lt;calendar argument 2&gt;, see below for supported values
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Calendar</TT> class.
       Compare an <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> with
       another calendar object or calendar kind for equality.  Return
       <TT>.true.</TT> if equal, <TT>.false.</TT> otherwise.  Comparison is based on
       calendar kind, which is a property of a calendar object.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and both are of  
       type <TT>ESMF_CALKIND_CUSTOM</TT>, then all the calendar's properties, 
       except name, are compared.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and either of them
       is not in the <TT>ESMF_INIT_CREATED</TT> status, an error will be logged.
       However, this does not affect the return value, which is <TT>.true.</TT> 
       when both arguments are in the <EM>same</EM> status, and <TT>.false.</TT>
       otherwise.

<P>
If one argument is an <TT>ESMF_Calendar</TT> object, and the other is an
       <TT>ESMF_CalKind_Flag</TT>, and the calendar object is not in the
       <TT>ESMF_INIT_CREATED</TT> status, an error will be logged and
       <TT>.false.</TT> will be returned.

<P>
Supported values for &lt;calendar argument 1&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar1
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag1
       
</DD>
</DL>
       Supported values for &lt;calendar argument 2&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar2
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag2
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>&lt;calendar argument 1&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            left hand side of the equality operation.
       
</DD>
<DT><STRONG>&lt;calendar argument 2&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            right hand side of the equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045300000000000000">
41.5.3 ESMF_CalendarOperator(/=) - Test if Calendar argument 1 is not equal to Calendar argument 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (&lt;calendar argument 1&gt; /= &lt;calendar argument 2&gt;) then ... endif
                                   OR
       result = (&lt;calendar argument 1&gt; /= &lt;calendar argument 2&gt;)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       &lt;calendar argument 1&gt;, see below for supported values
       &lt;calendar argument 2&gt;, see below for supported values
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Calendar</TT> class.
       Compare a <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> with
       another calendar object or calendar kind for inequality.  Return
       <TT>.true.</TT> if not equal, <TT>.false.</TT> otherwise.  Comparison is based
       on calendar kind, which is a property of a calendar object.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and both are of  
       type <TT>ESMF_CALKIND_CUSTOM</TT>, then all the calendar's properties,
       except name, are compared.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and either of them
       is not in the <TT>ESMF_INIT_CREATED</TT> status, an error will be logged.
       However, this does not affect the return value, which is <TT>.true.</TT> 
       when both arguments are <EM>not</EM> in the <EM>same</EM> status, and
       <TT>.false.</TT> otherwise.

<P>
If one argument is an <TT>ESMF_Calendar</TT> object, and the other is an
       <TT>ESMF_CalKind_Flag</TT>, and the calendar object is not in the
       <TT>ESMF_INIT_CREATED</TT> status, an error will be logged and
       <TT>.true.</TT> will be returned.

<P>
Supported values for &lt;calendar argument 1&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar1
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag1
       
</DD>
</DL>
       Supported values for &lt;calendar argument 2&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar2
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag2
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>&lt;calendar argument 1&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            left hand side of the non-equality operation.
       
</DD>
<DT><STRONG>&lt;calendar argument 2&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            right hand side of the non-equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045400000000000000">
41.5.4 ESMF_CalendarCreate - Create a new ESMF Calendar of built-in type</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarCreate()
       function ESMF_CalendarCreateBuiltIn(calkindflag, &amp;
         name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Calendar) :: ESMF_CalendarCreateBuiltIn
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates and sets a <TT>calendar</TT> to the given built-in
       <TT>ESMF_CalKind_Flag</TT>. 

<P>
The arguments are:
       <DL>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>The built-in <TT>ESMF_CalKind_Flag</TT>.  Valid values are:
              <BR>
              <TT>ESMF_CALKIND_360DAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_GREGORIAN</TT>,
              <BR>
              <TT>ESMF_CALKIND_JULIAN</TT>, 
              <BR>
              <TT>ESMF_CALKIND_JULIANDAY</TT>,
              <BR>
              <TT>ESMF_CALKIND_MODJULIANDAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_NOCALENDAR</TT>,
              <BR>
and <TT>ESMF_CALKIND_NOLEAP</TT>.
              <BR>
See Section&nbsp;<A HREF="#subsec:Calendar_options">41.2</A> for a description of each
            calendar kind.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created calendar.  If not specified, a
            default unique name will be generated: "CalendarNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045500000000000000">
41.5.5 ESMF_CalendarCreate - Create a copy of an ESMF Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarCreate()
       function ESMF_CalendarCreateCopy(calendar, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Calendar) :: ESMF_CalendarCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a complete (deep) copy of a given <TT>ESMF_Calendar</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> to copy.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045600000000000000">
41.5.6 ESMF_CalendarCreate - Create a new custom ESMF Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarCreate()
       function ESMF_CalendarCreateCustom(&amp;
         daysPerMonth, secondsPerDay, &amp;
         daysPerYear, daysPerYearDn, daysPerYearDd, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Calendar) :: ESMF_CalendarCreateCustom
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,               intent(in),  optional :: daysPerMonth(:)
       integer(ESMF_KIND_I4), intent(in),  optional :: secondsPerDay
       integer(ESMF_KIND_I4), intent(in),  optional :: daysPerYear
       integer(ESMF_KIND_I4), intent(in),  optional :: daysPerYearDn
       integer(ESMF_KIND_I4), intent(in),  optional :: daysPerYearDd
       character (len=*),     intent(in),  optional :: name
       integer,               intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a custom <TT>ESMF_Calendar</TT> and sets its properties.

<P>
The arguments are:
       <DL>
<DT><STRONG>[daysPerMonth]</STRONG></DT>
<DD>Integer array of days per month, for each month of the year.
            The number of months per year is variable and taken from the
            size of the array.  If unspecified, months per year = 0,
            with the days array undefined.
       
</DD>
<DT><STRONG>[secondsPerDay]</STRONG></DT>
<DD>Integer number of seconds per day.  Defaults to 0 if not 
            specified.
       
</DD>
<DT><STRONG>[daysPerYear]</STRONG></DT>
<DD>Integer number of days per year.  Use with daysPerYearDn and
            daysPerYearDd (see below) to specify a days-per-year calendar
            for any planetary body.  Default = 0.
       
</DD>
<DT><STRONG>[daysPerYearDn]</STRONG></DT>
<DD>Integer numerator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear (see above) and daysPerYearDd (see below) to
            specify a days-per-year calendar for any planetary body.
            Default = 0.

</DD>
<DT><STRONG>[daysPerYearDd]</STRONG></DT>
<DD>Integer denominator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear and daysPerYearDn (see above) to
            specify a days-per-year calendar for any planetary body.
            Default = 1.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created calendar.  If not specified, a
            default unique name will be generated: "CalendarNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045700000000000000">
41.5.7 ESMF_CalendarDestroy - Release resources associated with a Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarDestroy(calendar, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(inout)          :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,             intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Releases resources associated with this <TT>ESMF_Calendar</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>Release resources associated with this <TT>ESMF_Calendar</TT> and mark the
         object as invalid.  It is an error to pass this object into any other
         routines after being destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045800000000000000">
41.5.8 ESMF_CalendarGet - Get Calendar properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarGet(calendar, &amp;
         name, calkindflag, daysPerMonth, monthsPerYear, &amp;
         secondsPerDay, secondsPerYear, &amp;
         daysPerYear, daysPerYearDn, daysPerYearDd, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),    intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_CalKind_Flag),intent(out), optional :: calkindflag
       integer,                intent(out), optional :: daysPerMonth(:)
       integer,                intent(out), optional :: monthsPerYear
       integer(ESMF_KIND_I4),  intent(out), optional :: secondsPerDay
       integer(ESMF_KIND_I4),  intent(out), optional :: secondsPerYear
       integer(ESMF_KIND_I4),  intent(out), optional :: daysPerYear
       integer(ESMF_KIND_I4),  intent(out), optional :: daysPerYearDn
       integer(ESMF_KIND_I4),  intent(out), optional :: daysPerYearDd
       character (len=*),      intent(out), optional :: name
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets one or more of an <TT>ESMF_Calendar</TT>'s properties.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>The <TT>CalKind_Flag</TT> ESMF_CALKIND_GREGORIAN, 
            ESMF_CALKIND_JULIAN, etc.
       
</DD>
<DT><STRONG>[daysPerMonth]</STRONG></DT>
<DD>Integer array of days per month, for each month of the year.
       
</DD>
<DT><STRONG>[monthsPerYear]</STRONG></DT>
<DD>Integer number of months per year; the size of the
            daysPerMonth array.
       
</DD>
<DT><STRONG>[secondsPerDay]</STRONG></DT>
<DD>Integer number of seconds per day.
       
</DD>
<DT><STRONG>[secondsPerYear]</STRONG></DT>
<DD>Integer number of seconds per year.
       
</DD>
<DT><STRONG>[daysPerYear]</STRONG></DT>
<DD>Integer number of days per year.  For calendars with
            intercalations, daysPerYear is the number of days for years without
            an intercalation.  For other calendars, it is the number of days in
            every year.
       
</DD>
<DT><STRONG>[daysPerYearDn]</STRONG></DT>
<DD>Integer fractional number of days per year (numerator).
            For calendars with intercalations, daysPerYearDn/daysPerYearDd is
            the average fractional number of days per year (e.g. 25/100 for
            Julian 4-year intercalation).  For other calendars, it is zero.

</DD>
<DT><STRONG>[daysPerYearDd]</STRONG></DT>
<DD>Integer fractional number of days per year (denominator).  See
            daysPerYearDn above.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of this calendar.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045900000000000000">
41.5.9 ESMF_CalendarIsCreated - Check whether a Calendar object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_CalendarIsCreated(calendar, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_CalendarIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Calendar), intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>calendar</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>ESMF_Calendar</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451000000000000000">
41.5.10 ESMF_CalendarIsLeapYear - Determine if given year is a leap year</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarIsLeapYear()
       function ESMF_CalendarIsLeapYear&lt;kind&gt;(calendar, yy, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_CalendarIsLeapYear&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),       intent(in)            :: calendar
       integer(ESMF_KIND_&lt;kind&gt;), intent(in)            :: yy
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                   intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if the given year is a leap year within the given
       calendar, and <TT>.false.</TT> otherwise.  Custom calendars do not define
       leap years, so <TT>.false.</TT> will always be returned in this case;
       see Section&nbsp;<A HREF="#subsec:Calendar_rest">41.4</A>.
       See also <TT>ESMF_TimeIsLeapYear()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>ESMF_Calendar</TT> to determine leap year within.
       
</DD>
<DT><STRONG>yy</STRONG></DT>
<DD>Year to check for leap year.  The type is integer and the &lt;kind&gt; can
            be either I4 or I8:  <TT>ESMF_KIND_I4</TT> or <TT>ESMF_KIND_I8</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451100000000000000">
41.5.11 ESMF_CalendarPrint - Print Calendar information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarPrint(calendar, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(in)            :: calendar
       character (len=*),   intent(in),  optional :: options
       integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints out an <TT>ESMF_Calendar</TT>'s properties to <TT>stdio</TT>, 
       in support of testing and debugging.  The options control the 
       type of information and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>ESMF_Calendar</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all calendar property
                               values. 
<BR>            "calkindflag"    - print the calendar's type 
                                 (e.g. ESMF_CALKIND_GREGORIAN). 
<BR>            "daysPerMonth"   - print the array of number of days for
                                 each month. 
<BR>            "daysPerYear"    - print the number of days per year
                               (integer and fractional parts). 
<BR>            "monthsPerYear"  - print the number of months per year. 
<BR>            "name"           - print the calendar's name. 
<BR>            "secondsPerDay"  - print the number of seconds in a day. 
<BR>            "secondsPerYear" - print the number of seconds in a year. 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451200000000000000">
41.5.12 ESMF_CalendarSet - Set a Calendar to a built-in type</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSet()
       subroutine ESMF_CalendarSetBuiltIn(calendar, calkindflag, &amp;
         name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),     intent(inout)         :: calendar
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets <TT>calendar</TT> to the given built-in <TT>ESMF_CalKind_Flag</TT>. 

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>The built-in <TT>CalKind_Flag</TT>.  Valid values are:
              <BR>
              <TT>ESMF_CALKIND_360DAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_GREGORIAN</TT>,
              <BR>
              <TT>ESMF_CALKIND_JULIAN</TT>, 
              <BR>
              <TT>ESMF_CALKIND_JULIANDAY</TT>,
              <BR>
              <TT>ESMF_CALKIND_MODJULIANDAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_NOCALENDAR</TT>,
              <BR>
and <TT>ESMF_CALKIND_NOLEAP</TT>.
              <BR>
See Section&nbsp;<A HREF="#subsec:Calendar_options">41.2</A> for a description of each
            calendar kind.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this calendar.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451300000000000000">
41.5.13 ESMF_CalendarSet - Set properties of a custom Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSet()
       subroutine ESMF_CalendarSetCustom(calendar, &amp;
         daysPerMonth, secondsPerDay, &amp;
         daysPerYear, daysPerYearDn, daysPerYearDd, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),  intent(inout)         :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,              intent(in),  optional :: daysPerMonth(:)
       integer(ESMF_KIND_I4),intent(in),  optional :: secondsPerDay
       integer(ESMF_KIND_I4),intent(in),  optional :: daysPerYear
       integer(ESMF_KIND_I4),intent(in),  optional :: daysPerYearDn
       integer(ESMF_KIND_I4),intent(in),  optional :: daysPerYearDd
       character (len=*),    intent(in),  optional :: name
       integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets properties in a custom <TT>ESMF_Calendar</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>[daysPerMonth]</STRONG></DT>
<DD>Integer array of days per month, for each month of the year.
            The number of months per year is variable and taken from the
            size of the array.  If unspecified, months per year = 0,
            with the days array undefined.
       
</DD>
<DT><STRONG>[secondsPerDay]</STRONG></DT>
<DD>Integer number of seconds per day.  Defaults to 0 if not 
            specified.
       
</DD>
<DT><STRONG>[daysPerYear]</STRONG></DT>
<DD>Integer number of days per year.  Use with daysPerYearDn and
            daysPerYearDd (see below) to specify a days-per-year calendar
            for any planetary body.  Default = 0.
       
</DD>
<DT><STRONG>[daysPerYearDn]</STRONG></DT>
<DD>Integer numerator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear (see above) and daysPerYearDd (see below) to
            specify a days-per-year calendar for any planetary body.
            Default = 0.
       
</DD>
<DT><STRONG>[daysPerYearDd]</STRONG></DT>
<DD>Integer denominator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear and daysPerYearDn (see above) to
            specify a days-per-year calendar for any planetary body.
            Default = 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this calendar.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451400000000000000">
41.5.14 ESMF_CalendarSetDefault - Set the default Calendar kind</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSetDefault()
       subroutine ESMF_CalendarSetDefaultKind(calkindflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
       integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the default <TT>calendar</TT> to the given type.  Subsequent Time
       Manager operations requiring a calendar where one isn't specified will
       use the internal calendar of this type.

<P>
The arguments are:
       <DL>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>The calendar kind to be the default.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451500000000000000">
41.5.15 ESMF_CalendarSetDefault - Set the default Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSetDefault()
       subroutine ESMF_CalendarSetDefaultCal(calendar, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),     intent(in)            :: calendar
       integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the default <TT>calendar</TT> to the one given.  Subsequent Time
       Manager operations requiring a calendar where one isn't specified will
       use this calendar.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to be the default.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451600000000000000">
41.5.16 ESMF_CalendarValidate - Validate a Calendar's properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarValidate(calendar, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>calendar</TT> is valid.  
       Must be one of the defined calendar kinds.  daysPerMonth, daysPerYear,
       secondsPerDay must all be greater than or equal to zero.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>ESMF_Calendar</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION06050000000000000000">
42 Time Class</A>
</H1>

<H2><A NAME="SECTION06051000000000000000">
42.1 Description</A>
</H2>
<A NAME="sec:Time"></A>
<P>
A Time represents a specific point in time.  In order to accommodate
the range of time scales in Earth system applications, Times in
the ESMF can be specified in many different ways, from years to
nanoseconds.  The Time interface is designed so that you select one or 
more options from a list of time units in order to specify a 
Time. The options for specifying a Time are shown in 
Table&nbsp;<A HREF="#table:timeOpts">40.4</A>.  

<P>
There are Time methods defined for setting and getting a
Time, incrementing and decrementing a Time by a TimeInterval,
taking the difference between two Times, and comparing Times.
Special quantities such as the middle of the month and the 
day of the year associated with a particular Time can be retrieved. 
There is a method for returning the Time value as a string in 
the ISO 8601 format YYYY-MM-DDThh:mm:ss [<A
 HREF="node8.html#ISO">18</A>].

<P>
A Time that is specified in hours, minutes, seconds, or subsecond intervals 
does not need to be associated with a standard calendar; a Time whose
specification includes time units of a day and greater must be.  The 
ESMF representation
of a calendar, the Calendar class, is described in Section&nbsp;<A HREF="#sec:Calendar">41.1</A>.
The <TT>ESMF_TimeSet</TT> method is used to initialize a Time as well as
associate it with a Calendar.  If a Time method is invoked in which a Calendar
is necessary and one has not been set, the ESMF method will return an error
condition.

<P>
In the ESMF the TimeInterval class is used to represent time periods.
This class is frequently used in combination with the Time class.
The Clock class, for example, advances model time by incrementing a
Time with a TimeInterval. 

<P>

<H2><A NAME="SECTION06052000000000000000">
42.2 Use and Examples</A>
</H2>

<P>
Times are most frequently used to represent start, stop, and current 
model times.  The following examples show how to create, initialize, and
manipulate <TT>Time</TT>.

<P>

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_TimeEx - Time initialization and manipulation examples
!
! !DESCRIPTION:
!
! This program shows examples of Time initialization and manipulation
!-----------------------------------------------------------------------------
#include "ESMF.h"

      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! instantiate two times
      type(ESMF_Time) :: time1, time2

      type(ESMF_VM) :: vm

      ! instantiate a time interval
      type(ESMF_TimeInterval) :: timeinterval1

      ! local variables for Get methods
      integer :: YY, MM, DD, H, M, S

      ! return code
      integer:: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(vm=vm, defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="TimeEx.Log", &amp;
        logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06052100000000000000">
42.2.1 Time initialization</A>
</H3>

<P>
This example shows how to initialize an <TT>ESMF_Time</TT>. 

<P>
<PRE>
      ! initialize time1 to 2/28/2000 2:24:45
      call ESMF_TimeSet(time1, yy=2000, mm=2, dd=28, h=2, m=24, s=45, rc=rc)
</PRE>

<P>
<PRE>
      print *, "Time1 = "
      call ESMF_TimePrint(time1, options="string", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06052200000000000000">
42.2.2 Time increment</A>
</H3>

<P>
This example shows how to increment an <TT>ESMF_Time</TT> by
   an <TT>ESMF_TimeInterval</TT>. 

<P>
<PRE>
      ! initialize a time interval to 2 days, 8 hours, 36 minutes, 15 seconds
      call ESMF_TimeIntervalSet(timeinterval1, d=2, h=8, m=36, s=15, rc=rc)
</PRE>

<P>
<PRE>
      print *, "Timeinterval1 = "
      call ESMF_TimeIntervalPrint(timeinterval1, options="string", rc=rc)
</PRE>

<P>
<PRE>
      ! increment time1 with timeinterval1
      time2 = time1 + timeinterval1

      call ESMF_TimeGet(time2, yy=YY, mm=MM, dd=DD, h=H, m=M, s=S, rc=rc)
      print *, "time2 = time1 + timeinterval1 = ", YY, "/", MM, "/", DD, &amp;
               " ",  H, ":", M, ":", S
</PRE>

<P>

<H3><A NAME="SECTION06052300000000000000">
42.2.3 Time comparison</A>
</H3>

<P>
This example shows how to compare two <TT>ESMF_Times</TT>. 

<P>
<PRE>
      if (time2 &gt; time1) then
        print *, "time2 is larger than time1"
      else
        print *, "time1 is smaller than or equal to time2"
      endif
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_TimeEx
</PRE>

<P>


<H2><A NAME="SECTION06053000000000000000">
42.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limits on size and resolution of Time.</B>  The limits on the size and 
resolution of the time representation are based on the
64-bit integer types used.  For seconds, a signed 64-bit integer
will have a range of +/- <IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img200.png"
 ALT="$2^{63}$">-1, or +/- 9,223,372,036,854,775,807.  This
corresponds to a maximum size of +/- (<IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img200.png"
 ALT="$2^{63}$">-1)/(86400 * 365.25) or
+/- 292,271,023,045 years.

<P>
For fractional seconds, a signed 64-bit integer will handle a resolution of
+/- <IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img201.png"
 ALT="$2^{31}$">-1, or +/- 9,223,372,036,854,775,807 parts of a second.

<P>
</LI>
</OL>

<H2><A NAME="SECTION06054000000000000000">
42.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06054100000000000000">
42.4.1 ESMF_TimeAssignment(=) - Assign a Time to another Time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface assignment(=)
       time1 = time2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time) :: time1
       type(ESMF_Time) :: time2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Set <TT>time1</TT> equal to <TT>time2</TT>.  This is the default Fortran
       assignment, which creates a complete, independent copy of <TT>time2</TT> 
       as <TT>time1</TT>.  If <TT>time2</TT> is an invalid <TT>ESMF_Time</TT> object then
       <TT>time1</TT> will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to be set.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to be copied.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054200000000000000">
42.4.2 ESMF_TimeOperator(+) - Increment a Time by a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(+)
       time2 = time1 + timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Time) :: time2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in) :: time1
       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (+) operator for the <TT>ESMF_Time</TT> class to increment
       <TT>time1</TT> with <TT>timeinterval</TT> and return the result as an
       <TT>ESMF_Time</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to increment.
       
</DD>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to add to the given <TT>ESMF_Time</TT>.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054300000000000000">
42.4.3 ESMF_TimeOperator(-) - Decrement a Time by a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(-)
       time2 = time1 - timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Time) :: time2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in) :: time1
       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_Time</TT> class to decrement
       <TT>time1</TT> with <TT>timeinterval</TT>, and return the result as an
       <TT>ESMF_Time</TT>.

<P>
The arguments are:      
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to decrement.
       
</DD>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to subtract from the given
            <TT>ESMF_Time</TT>.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054400000000000000">
42.4.4 ESMF_TimeOperator(-) - Return the difference between two Times</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(-)
       timeinterval = time1 - time2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: timeinterval
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in) :: time1
       type(ESMF_Time),         intent(in) :: time2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_Time</TT> class to return the
       difference between <TT>time1</TT> and <TT>time2</TT> as an
       <TT>ESMF_TimeInterval</TT>.  It is assumed that <TT>time1</TT> is later than
       <TT>time2</TT>; if not, the resulting <TT>ESMF_TimeInterval</TT> will have a
       negative value.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The first <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>The second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054500000000000000">
42.4.5 ESMF_TimeOperator(==) - Test if Time 1 is equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (time1 == time2) then ... endif
                    OR
       result = (time1 == time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> and <TT>time2</TT> represent the same instant 
       in time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054600000000000000">
42.4.6 ESMF_TimeOperator(/=) - Test if Time 1 is not equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (time1 /= time2) then ... endif
                    OR
       result = (time1 /= time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> and <TT>time2</TT> do not represent the same 
       instant in time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054700000000000000">
42.4.7 ESMF_TimeOperator(&lt;) - Test if Time 1 is less than Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&lt;)
       if (time1 &lt; time2) then ... endif
                    OR
       result = (time1 &lt; time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is earlier in time than <TT>time2</TT>, and 
       <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054800000000000000">
42.4.8 ESMF_TimeOperator(&lt;=) - Test if Time 1 is less than or equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&lt;=)
       if (time1 &lt;= time2) then ... endif
                    OR
       result = (time1 &lt;= time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;=) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is earlier in time or the same time as 
       <TT>time2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054900000000000000">
42.4.9 ESMF_TimeOperator(&gt;) - Test if Time 1 is greater than Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&gt;)
       if (time1 &gt; time2) then ... endif
                    OR
       result = (time1 &gt; time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is later in time than <TT>time2</TT>, and 
       <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541000000000000000">
42.4.10 ESMF_TimeOperator(&gt;=) - Test if Time 1 is greater than or equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&gt;=)
       if (time1 &gt;= time2) then ... endif
                    OR
       result = (time1 &gt;= time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;=) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is later in time or the same time as 
       <TT>time2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541100000000000000">
42.4.11 ESMF_TimeGet - Get a Time value </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeGet(time, &amp;
         yy, yy_i8, &amp;
         mm, dd, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         calendar, calkindflag, timeZone, &amp;
         timeString, timeStringISOFrac, &amp;
         dayOfWeek, midMonth, &amp;
         dayOfYear,  dayOfYear_r8, &amp;
         dayOfYear_intvl, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in)            :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer,                 intent(out), optional :: mm
       integer,                 intent(out), optional :: dd
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       integer,                 intent(out), optional :: timeZone ! not imp
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: dayOfWeek
       type(ESMF_Time),         intent(out), optional :: midMonth
       integer(ESMF_KIND_I4),   intent(out), optional :: dayOfYear
       real(ESMF_KIND_R8),      intent(out), optional :: dayOfYear_r8
       type(ESMF_TimeInterval), intent(out), optional :: dayOfYear_intvl
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>time</TT> in units specified by the user
       via Fortran optional arguments.  See <TT>ESMF_TimeSet()</TT> above for a
       description of time units and calendars.

<P>
The ESMF Time Manager represents and manipulates time internally with 
       integers to maintain precision.  Hence, user-specified floating point 
       values are converted internally from integers.  For example, if a time
       value is 5 and 3/8 seconds (s=5, sN=3, sD=8), and you want to get it as
       floating point seconds, you would get 5.375 (s_r8=5.375).

<P>
Units are bound (normalized) by the next larger unit specified.  For
       example, if a time is defined to be 2:00 am on February 2, 2004, then
       <TT>ESMF_TimeGet(dd=day, h=hours, s=seconds)</TT> would return
         <TT>day = 2</TT>, <TT>hours = 2</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeGet(dd = day, s=seconds)</TT> would return
         <TT>day = 2</TT>, <TT>seconds = 7200</TT>.
       Note that <TT>hours</TT> and <TT>seconds</TT> are bound by a day.  If bound
       by a month,
       <TT>ESMF_TimeGet(mm=month, h=hours, s=seconds)</TT> would return
         <TT>month = 2</TT>, <TT>hours = 26</TT>, <TT>seconds = 0</TT>,
       and <TT>ESMF_TimeGet(mm = month, s=seconds)</TT> would return
         <TT>month = 2</TT>, <TT>seconds = 93600</TT> (26 * 3600).
       Similarly, if bound to a year,
       <TT>ESMF_TimeGet(yy=year, h=hours, s=seconds)</TT> would return
         <TT>year = 2004</TT>, <TT>hours = 770</TT> (32*24 + 2), <TT>seconds = 0</TT>,
       and <TT>ESMF_TimeGet(yy = year, s=seconds)</TT> would return
         <TT>year = 2004</TT>, <TT>seconds = 2772000</TT> (770 * 3600).

<P>
For <TT>timeString</TT>, <TT>timeStringISOFrac</TT>, <TT>dayOfWeek</TT>,
       <TT>midMonth</TT>, <TT>dayOfYear</TT>, <TT>dayOfYear_intvl</TT>, and
       <TT>dayOfYear_r8</TT> described below, valid calendars are Gregorian,
       Julian, No Leap, 360 Day and Custom calendars.  Not valid for
       Julian Day, Modified Julian Day, or No Calendar. 
<BR>
<P>
For <TT>timeString</TT> and <TT>timeStringISOFrac</TT>, YYYY format returns
       at least 4 digits; years &lt;= 999 are padded on the left with zeroes and
       years &gt;= 10000 return the number of digits required.

<P>
For timeString, convert <TT>ESMF_Time</TT>'s value into partial ISO 8601
       format YYYY-MM-DDThh:mm:ss[:n/d].  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].
       See also method <TT>ESMF_TimePrint()</TT>.

<P>
For timeStringISOFrac, convert <TT>ESMF_Time</TT>'s value into full ISO 8601
       format YYYY-MM-DDThh:mm:ss[.f].  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].
       See also method <TT>ESMF_TimePrint()</TT>.

<P>
For dayOfWeek, gets the day of the week the given <TT>ESMF_Time</TT>
       instant falls on.  ISO 8601 standard:  Monday = 1 through Sunday = 7.
       See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].

<P>
For midMonth, gets the middle time instant of the month that the given
       <TT>ESMF_Time</TT> instant falls on.

<P>
For dayOfYear, gets the day of the year that the given <TT>ESMF_Time</TT>
       instant falls on.  See range discussion in argument list below.
       Return as an integer value.

<P>
For dayOfYear_r8, gets the day of the year the given <TT>ESMF_Time</TT>
       instant falls on.  See range discussion in argument list below.
       Return as floating point value; fractional part represents the time of
       day.

<P>
For dayOfYear_intvl, gets the day of the year the given <TT>ESMF_Time</TT>
       instant falls on.  Return as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month.
       
</DD>
<DT><STRONG>[dd]</STRONG></DT>
<DD>Integer day of the month.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian date, or Modified Julian date (32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian date, or Modified Julian date (large, 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, &lt;= 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, &lt;= 64-bit).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>.
       
</DD>
<DT><STRONG>[timeZone]</STRONG></DT>
<DD>Associated timezone (hours offset from UCT, e.g. EST = -5).
            (Not implemented yet).
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time value to format string YYYY-MM-DDThh:mm:ss[:n/d],
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimePrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time value to strict ISO 8601 format string
            YYYY-MM-DDThh:mm:ss[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method
            <TT>ESMF_TimePrint()</TT>.
       
</DD>
<DT><STRONG>[dayOfWeek]</STRONG></DT>
<DD>The time instant's day of the week [1-7].
       
</DD>
<DT><STRONG>[MidMonth]</STRONG></DT>
<DD>The given time instant's middle-of-the-month time instant.
       
</DD>
<DT><STRONG>[dayOfYear]</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> instant's integer day of the year.
            [1-366] for Gregorian and Julian calendars, [1-365] for No-Leap
            calendar.  [1-360] for 360-Day calendar.  User-defined range
            for Custom calendar.
       
</DD>
<DT><STRONG>[dayOfYear_r8]</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> instant's floating point day of the year.
            [1.x-366.x] for Gregorian and Julian calendars, [1.x-365.x] for
            No-Leap calendar.  [1.x-360.x] for 360-Day calendar.  User-defined
            range for Custom calendar.
       
</DD>
<DT><STRONG>[dayOfYear_intvl]</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> instant's day of the year as an
            <TT>ESMF_TimeInterval</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541200000000000000">
42.4.12 ESMF_TimeIsLeapYear - Determine if a Time is in a leap year</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_TimeIsLeapYear(time, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_TimeIsLeapYear
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in)            :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,         intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if given time is in a leap year, and <TT>.false.</TT>
       otherwise.  See also <TT>ESMF_CalendarIsLeapYear()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to check for leap year.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541300000000000000">
42.4.13 ESMF_TimeIsSameCalendar - Compare Calendars of two Times</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_TimeIsSameCalendar(time1, time2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_TimeIsSameCalendar
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in)            :: time1
       type(ESMF_Time), intent(in)            :: time2
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,         intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if the Calendars in these Times are
       the same, <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The first <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>The second <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541400000000000000">
42.4.14 ESMF_TimePrint - Print Time information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimePrint(time, options, preString, unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),   intent(in)            :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*), intent(in),  optional :: options
       character(*),      intent(in),  optional :: preString
       character(*),      intent(out), optional :: unit
       integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints out the contents of an <TT>ESMF_Time</TT> to <TT>stdout</TT>, in
       support of testing and debugging.  The options control the type of
       information and level of detail.  For options "string" and "string
       isofrac", YYYY format returns at least 4 digits; years &lt;= 999 are
       padded on the left with zeroes and years &gt;= 10000 return the number
       of digits required. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all Time property values. 
<BR>            "string" - prints <TT>time</TT>'s value in ISO 8601 format for all units
                       through seconds.  For any non-zero fractional seconds,
                       prints in integer rational fraction form n/d.  Format is
                       YYYY-MM-DDThh:mm:ss[:n/d], where [:n/d] is the 
                       integer numerator and denominator of the fractional
                       seconds value, if present.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method
                       <TT>ESMF_TimeGet(..., timeString= , ...)</TT> 
<BR>            "string isofrac" - prints <TT>time</TT>'s value in strict ISO 8601
                       format for all units, including any fractional seconds
                       part.  Format is YYYY-MM-DDThh:mm:ss[.f] where [.f]
                       represents fractional seconds in decimal form, if present.
                       See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method
                       <TT>ESMF_TimeGet(..., timeStringISOFrac= , ...)</TT> 
<BR>       
</DD>
<DT><STRONG>[preString]</STRONG></DT>
<DD>Optionally prepended string. Default to empty string.
       
</DD>
<DT><STRONG>[unit]</STRONG></DT>
<DD>Internal unit, i.e. a string. Default to printing to stdout.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541500000000000000">
42.4.15 ESMF_TimeSet - Initialize or set a Time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeSet(time, &amp;
         yy, yy_i8, &amp;
         mm, dd, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         calendar, calkindflag, &amp;
         timeZone, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(inout)         :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer,                 intent(in),  optional :: mm
       integer,                 intent(in),  optional :: dd
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       type(ESMF_Calendar),     intent(in),  optional :: calendar
       type(ESMF_CalKind_Flag), intent(in),  optional :: calkindflag
       integer,                 intent(in),  optional :: timeZone ! not imp
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Initializes an <TT>ESMF_Time</TT> with a set of user-specified units
       via Fortran optional arguments.

<P>
The range of valid values for mm and dd depend on the calendar used.
       For Gregorian, Julian, and No-Leap calendars, mm is [1-12] and dd is
       [1-28,29,30, or 31], depending on the value of mm and whether yy or
       yy_i8 is a leap year.  For the 360-day calendar, mm is [1-12] and dd is
       [1-30].  For Julian Day, Modified Julian Day, and No-Calendar,
       yy, yy_i8, mm, and dd are invalid inputs, since these calendars do not
       define them.  When valid, the yy and yy_i8 arguments should be fully
       specified, e.g. 2003 instead of 03.  yy and yy_i8 ranges are only
       limited by machine word size, except for the Gregorian and Julian
       calendars, where the lowest (proleptic) date limits are 3/1/-4800 and
       3/1/-4712, respectively.  This is a limitation of the Gregorian
       date-to-Julian day and Julian date-to-Julian day conversion algorithms
       used to convert Gregorian and Julian dates to the internal representation
       of seconds.  See&nbsp;[<A
 HREF="node8.html#Fli68">14</A>] for a description of the Gregorian
       date-to-Julian day algorithm and&nbsp;[<A
 HREF="node8.html#Hat84">17</A>] for a description of the
       Julian date-to-Julian day algorithm.  The Custom calendar will have
       user-defined values for yy, yy_i8, mm, and dd.

<P>
The Julian day specifier, d or d_i8, can only be used with the
       Julian Day and Modified Julian Day calendars, and has a valid range
       depending on the word size.  For a signed 32-bit d, the range for
       Julian day is [+/- 24855].  For a signed 64-bit d_i8, the valid
       range for Julian day is [+/- 106,751,991,167,300].  The Julian day
       number system adheres to the conventional standard where the reference
       day of d=0 corresponds to 11/24/-4713 in the proleptic Gregorian calendar
       and 1/1/-4712 in the proleptic Julian calendar.  See&nbsp;[<A
 HREF="node8.html#Meyer2">22</A>] and
&nbsp;[<A
 HREF="node8.html#JDNcalculator">1</A>].

<P>
The Modified Julian Day system, introduced by space scientists in the late
       1950's, is defined as Julian Day - 2400000.5.  See&nbsp;[<A
 HREF="node8.html#MJD">27</A>].

<P>
Note that d and d_i8 are not valid for the No-Calendar.  To remain
       consistent with non-Earth calendars added to ESMF in the future, ESMF
       requires a calendar to be planet-specific.  Hence the No-Calendar does
       not know what a day is; it cannot assume an Earth day of 86400 seconds.

<P>
Hours, minutes, seconds, and sub-seconds can be used with any calendar,
       since they are standardized units that are the same for any planet.

<P>
Time manager represents and manipulates time internally with integers
       to maintain precision. Hence, user-specified floating point values are
       converted internally to integers.  Sub-second values are represented
       internally with an integer numerator and denominator fraction (sN/sD).
       The smallest required resolution is nanoseconds (denominator).
       For example, pi can be represented as s=3,
       sN=141592654, sD=1000000000.  However, via sN_i8 and sD_i8, larger
       values can be used.  If specifying a constant floating point value, be
       sure to provide at least 16 digits to take full advantage of double
       precision, for example s_r8=2.718281828459045d0 for 'e' seconds.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month.  Default = 1.
       
</DD>
<DT><STRONG>[dd]</STRONG></DT>
<DD>Integer day of the month.  Default = 1.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian Day, or Modified Julian Day (32-bit).  Must not be
            specified with Gregorian calendars.  Default = 0.
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian Day, or Modified Julian Day (large, 64-bit).  Must not be
            specified with Gregorian calendars.  Default = 0.
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.  Default = 0.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.  Default = 0.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.  Default = 0.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.  Default = 0.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.  Default = 0.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
            Default = 0.
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
            Default = 1.
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 1.
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>.  Defaults to calendar
            <TT>ESMF_CALKIND_NOCALENDAR</TT> or default specified in
            <TT>ESMF_Initialize()</TT> or <TT>ESMF_CalendarSetDefault()</TT>.
            Alternate to, and mutually exclusive with, calkindflag
            below.  Primarily for specifying a custom calendar kind.

</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Alternate to, and mutually exclusive with, calendar above.  More
            convenient way of specifying a built-in calendar kind.
       
</DD>
<DT><STRONG>[timeZone]</STRONG></DT>
<DD>Associated timezone (hours offset from UTC, e.g. EST = -5).
            Default = 0 (UTC).  (Not implemented yet).
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541600000000000000">
42.4.16 ESMF_TimeSyncToRealTime - Get system real time (wall clock time)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeSyncToRealTime(time, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(inout) :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the system real time (wall clock time), and returns it as an
       <TT>ESMF_Time</TT>.  Accurate to the nearest second.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The object instance to receive the real time.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541700000000000000">
42.4.17 ESMF_TimeValidate - Validate a Time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeValidate(time, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),   intent(in)            :: time
       character (len=*), intent(in),  optional :: options
       integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Checks whether an <TT>ESMF_Time</TT> is valid.
       Must be a valid date/time on a valid calendar.
       The options control the type of validation.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD><TT>ESMF_Time</TT> instant to be validated.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Validation options. If none specified, validates all <TT>time</TT> property
              values. 
<BR>            "calendar" - validate only the <TT>time</TT>'s calendar. 
<BR>            "timezone" - validate only the <TT>time</TT>'s timezone. 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION06060000000000000000">
43 TimeInterval Class</A>
</H1>

<H2><A NAME="SECTION06061000000000000000">
43.1 Description</A>
</H2>
<A NAME="sec:TimeInterval"></A>A TimeInterval represents a period between time instants.  
It can be either positive or negative.  Like the Time interface, 
the TimeInterval interface is designed so that you can choose 
one or more options from a list of time units in order 
to specify a TimeInterval.
See Section&nbsp;<A HREF="#subsec:Time_Instants_and_TimeIntervals">40.3</A>, 
Table&nbsp;<A HREF="#table:timeOpts">40.4</A> for the available options.

<P>
There are TimeInterval methods defined for setting and getting 
a TimeInterval, for incrementing and decrementing a TimeInterval 
by another TimeInterval, and for multiplying and dividing 
TimeIntervals by integers, reals, fractions and other TimeIntervals.  
Methods are also defined to take the absolute value and negative 
absolute value of a TimeInterval, and for comparing the length of two
TimeIntervals.

<P>
The class used to represent time instants in ESMF is Time,
and this class is frequently used in operations along with 
TimeIntervals.  For example, the difference between two
Times is a TimeInterval.  

<P>
When a TimeInterval is used in calculations that involve an absolute 
reference time, such as incrementing a Time with a TimeInterval, calendar 
dependencies may be introduced.  The length of the time period that the 
TimeInterval represents will depend on the reference Time and the 
standard calendar that is associated with it.  The calendar dependency becomes 
apparent when, for example, adding a TimeInterval of 1 day to the Time 
of February 28, 1996, at 4:00pm EST.  In a 360 day calendar, the 
resulting date would be February 29, 1996, at 4:00pm EST.  In a no-leap 
calendar, the result would be March 1, 1996, at 4:00pm EST.

<P>
TimeIntervals are used by other parts of the ESMF timekeeping
system, such as Clocks (Section&nbsp;<A HREF="#sec:Clock">44.1</A>) and Alarms 
(Section&nbsp;<A HREF="#sec:Alarm">45.1</A>).

<P>

<H2><A NAME="SECTION06062000000000000000">
43.2 Use and Examples</A>
</H2>

<P>
A typical use for a TimeInterval in a geophysical model 
is representation of the time step by which the model is 
advanced.  Some models change the size of their time step as 
the model run progresses; this could
be done by incrementing or decrementing the original time 
step by another TimeInterval, or by dividing or multiplying
the time step by an integer value.  An example of advancing 
model time using a TimeInterval representation of a time
step is shown in Section&nbsp;<A HREF="#sec:Clock">44.1</A>.

<P>
The following brief example shows how to create, initialize 
and manipulate <TT>TimeInterval</TT>.

<P>

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_TimeIntervalEx - Time Interval initialization and 
!                                 manipulation examples
!
! !DESCRIPTION:
!
! This program shows examples of Time Interval initialization and manipulation
!-----------------------------------------------------------------------------
#include "ESMF.h"

      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! instantiate some time intervals
      type(ESMF_TimeInterval) :: timeinterval1, timeinterval2, timeinterval3

      ! local variables
      integer :: d, h, m, s

      ! return code
      integer:: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="TimeIntervalEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06062100000000000000">
43.2.1 TimeInterval initialization</A>
</H3>

<P>
This example shows how to initialize two <TT>ESMF_TimeIntervals</TT>. 

<P>
<PRE>
      ! initialize time interval1 to 1 day
      call ESMF_TimeIntervalSet(timeinterval1, d=1, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalPrint(timeinterval1, options="string", rc=rc)
</PRE>

<P>
<PRE>
      ! initialize time interval2 to 4 days, 1 hour, 30 minutes, 10 seconds
      call ESMF_TimeIntervalSet(timeinterval2, d=4, h=1, m=30, s=10, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalPrint(timeinterval2, options="string", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06062200000000000000">
43.2.2 TimeInterval conversion</A>
</H3>

<P>
This example shows how to convert <TT>ESMF_TimeIntervals</TT> into 
   different units. 

<P>
<PRE>
      call ESMF_TimeIntervalGet(timeinterval1, s=s, rc=rc)
      print *, "Time Interval1 = ", s, " seconds."
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalGet(timeinterval2, h=h, m=m, s=s, rc=rc)
      print *, "Time Interval2 = ", h, " hours, ", m, " minutes, ", &amp;
                                    s, " seconds."
</PRE>

<P>

<H3><A NAME="SECTION06062300000000000000">
43.2.3 TimeInterval difference</A>
</H3>

<P>
This example shows how to calculate the difference between two 
   <TT>ESMF_TimeIntervals</TT>.  

<P>
<PRE>
      ! difference between two time intervals
      timeinterval3 = timeinterval2 - timeinterval1
     call ESMF_TimeIntervalGet(timeinterval3, d=d, h=h, m=m, s=s, rc=rc)
     print *, "Difference between TimeInterval2 and TimeInterval1 = ", &amp;
           d, " days, ", h, " hours, ", m, " minutes, ", s, " seconds."
</PRE>

<P>

<H3><A NAME="SECTION06062400000000000000">
43.2.4 TimeInterval multiplication</A>
</H3>

<P>
This example shows how to multiply an <TT>ESMF_TimeInterval</TT>.  

<P>
<PRE>
      ! multiply time interval by an integer
      timeinterval3 = timeinterval2 * 3
      call ESMF_TimeIntervalGet(timeinterval3, d=d, h=h, m=m, s=s, rc=rc)
      print *, "TimeInterval2 multiplied by 3 = ", d, " days, ", h, &amp;
               " hours, ", m, " minutes, ", s, " seconds."
</PRE>

<P>

<H3><A NAME="SECTION06062500000000000000">
43.2.5 TimeInterval comparison</A>
</H3>

<P>
This example shows how to compare two <TT>ESMF_TimeIntervals</TT>.  

<P>
<PRE>
      ! comparison
      if (timeinterval1 &lt; timeinterval2) then
        print *, "TimeInterval1 is smaller than TimeInterval2"
      else 
        print *, "TimeInterval1 is larger than or equal to TimeInterval2"
      end if
</PRE>

<P>
<PRE>
      end program ESMF_TimeIntervalEx
</PRE>

<P>


<H2><A NAME="SECTION06063000000000000000">
43.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limits on time span.</B> The limits on the time span that can be
represented are based on the 64-bit integer types used.  For
seconds, a signed 64-bit integer will have a range of +/- <IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img200.png"
 ALT="$2^{63}$">-1, or
+/- 9,223,372,036,854,775,807.  This corresponds to a range of
+/- (<IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img200.png"
 ALT="$2^{63}$">-1)/(86400 * 365.25) or +/- 292,271,023,045 years.

<P>
For fractional seconds, a signed 64-bit integer will handle a resolution of
+/- <IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img201.png"
 ALT="$2^{31}$">-1, or +/- 9,223,372,036,854,775,807 parts of a second.

<P>
</LI>
</OL>

<H2><A NAME="SECTION06064000000000000000">
43.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06064100000000000000">
43.4.1 ESMF_TimeIntervalAssignment(=) - Assign a TimeInterval to another TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface assignment(=)
       timeinterval1 = timeinterval2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval) :: timeinterval1
       type(ESMF_TimeInterval) :: timeinterval2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Set <TT>timeinterval1</TT> equal to <TT>timeinterval2</TT>.  This is the default
       Fortran assignment, which creates a complete, independent copy of
       <TT>timeinterval2</TT> as <TT>timeinterval1</TT>.  If <TT>timeinterval2</TT> is an
       invalid <TT>ESMF_TimeInterval</TT> object then <TT>timeinterval1</TT> will be
       equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to be set.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to be copied.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064200000000000000">
43.4.2 ESMF_TimeIntervalOperator(+) - Add two TimeIntervals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(+)
       sum = timeinterval1 + timeinterval2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: sum
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (+) operator for the <TT>ESMF_TimeInterval</TT> class to
       add <TT>timeinterval1</TT> to <TT>timeinterval2</TT> and return the
       sum as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The augend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The addend.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064300000000000000">
43.4.3 ESMF_TimeIntervalOperator(-) - Subtract one TimeInterval from another</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(-)
       difference = timeinterval1 - timeinterval2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: difference
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_TimeInterval</TT> class to
       subtract <TT>timeinterval2</TT> from <TT>timeinterval1</TT> and return
       the difference as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The minuend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The subtrahend.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064400000000000000">
43.4.4 ESMF_TimeIntervalOperator(-) - Perform unary negation on a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(-)
       timeinterval = -timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: -timeInterval
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_TimeInterval</TT> class to
       perform unary negation on <TT>timeinterval</TT> and return the result.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The time interval to be negated.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064500000000000000">
43.4.5 ESMF_TimeIntervalOperator(/) - Divide two TimeIntervals, return double precision quotient</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/)
       quotient = timeinterval1 / timeinterval2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       real(ESMF_KIND_R8) :: quotient
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>timeinterval1</TT> divided by <TT>timeinterval2</TT> as a
       double precision quotient.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The dividend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The divisor.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064600000000000000">
43.4.6 ESMF_TimeIntervalOperator(/) - Divide a TimeInterval by an integer, return TimeInterval quotient </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/)
       quotient = timeinterval / divisor
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: quotient
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
       integer(ESMF_KIND_I4),   intent(in) :: divisor
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/) operator for the <TT>ESMF_TimeInterval</TT> class to
       divide a <TT>timeinterval</TT> by an integer <TT>divisor</TT>, and
       return the quotient as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The dividend.
       
</DD>
<DT><STRONG>divisor</STRONG></DT>
<DD>Integer divisor.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064700000000000000">
43.4.7 ESMF_TimeIntervalFunction(MOD) - Divide two TimeIntervals, return TimeInterval remainder</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface MOD
       function MOD(timeinterval1, timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: MOD
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the Fortran intrinsic MOD() function for the
       <TT>ESMF_TimeInterval</TT> class to return the remainder of 
       <TT>timeinterval1</TT> divided by <TT>timeinterval2</TT> as an 
       <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The dividend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The divisor.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064800000000000000">
43.4.8 ESMF_TimeIntervalOperator(*) - Multiply a TimeInterval by an integer</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(*)
       product = timeinterval * multiplier
                     OR
       product = multiplier * timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: product
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
       integer(ESMF_KIND_I4),   intent(in) :: multiplier
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (*) operator for the <TT>ESMF_TimeInterval</TT> class to
       multiply a <TT>timeinterval</TT> by an integer <TT>multiplier</TT>,
       and return the product as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The multiplicand.
       
</DD>
<DT><STRONG>multiplier</STRONG></DT>
<DD>The integer multiplier.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064900000000000000">
43.4.9 ESMF_TimeIntervalOperator(==) - Test if TimeInterval 1 is equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (timeinterval1 == timeinterval2) then ... endif
                    OR
       result = (timeinterval1 == timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> and <TT>timeinterval2</TT> 
       represent an equal duration of time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641000000000000000">
43.4.10 ESMF_TimeIntervalOperator(/=) - Test if TimeInterval 1 is not equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (timeinterval1 /= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 /= timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> and <TT>timeinterval2</TT> do not 
       represent an equal duration of time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641100000000000000">
43.4.11 ESMF_TimeIntervalOperator(&lt;) - Test if TimeInterval 1 is less than TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&lt;)
       if (timeinterval1 &lt; timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &lt; timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a lesser duration of time 
       than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641200000000000000">
43.4.12 ESMF_TimeIntervalOperator(&lt;=) - Test if TimeInterval 1 is less than or equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&lt;=)
       if (timeinterval1 &lt;= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &lt;= timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;=) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a lesser or equal duration 
       of time than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641300000000000000">
43.4.13 ESMF_TimeIntervalOperator(&gt;) - Test if TimeInterval 1 is greater than TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&gt;)
       if (timeinterval1 &gt; timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &gt; timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a greater duration of time 
       than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641400000000000000">
43.4.14 ESMF_TimeIntervalOperator(&gt;=) - Test if TimeInterval 1 is greater than or equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&gt;=)
       if (timeinterval1 &gt;= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &gt;= timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;=) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a greater or equal 
       duration of time than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641500000000000000">
43.4.15 ESMF_TimeIntervalAbsValue - Get the absolute value of a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_TimeIntervalAbsValue(timeinterval)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: ESMF_TimeIntervalAbsValue
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the absolute value of <TT>timeinterval</TT>.

<P>
The argument is:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to take the absolute value of.
            Absolute value is returned as the value of the function.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641600000000000000">
43.4.16 ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDur(timeinterval, &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, calendar, calkindflag, &amp;
         timeString, timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641700000000000000">
43.4.17 ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurStart(timeinterval, startTimeIn, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, &amp;
         calendar, calkindflag, &amp;
         timeString, timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_Time),         intent(in)            :: startTimeIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>startTimeIn</STRONG></DT>
<DD>INPUT argument:  pins a calendar interval to a specific point
            in time to allow conversion between relative units (yy, mm, d) and
            absolute units (d, h, m, s).  Overrides any startTime and/or endTime
            previously set.  Mutually exclusive with endTimeIn and calendarIn.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>]. See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641800000000000000">
43.4.18 ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurCal(timeinterval, calendarIn, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, &amp;
         calendar, calkindflag, &amp;
         timeString, timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_Calendar),     intent(in)            :: calendarIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>calendarIn</STRONG></DT>
<DD>INPUT argument:  pins a calendar interval to a specific calendar
            to allow conversion between relative units (yy, mm, d) and
            absolute units (d, h, m, s).  Mutually exclusive with startTimeIn
            and endTimeIn since they contain a calendar.  Alternate to, and
            mutually exclusive with, calkindflagIn below.  Primarily for
            specifying a custom calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit). 
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit). 
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>]. See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641900000000000000">
43.4.19 ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurCalTyp(timeinterval, calkindflagIn, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, &amp;
         calendar, calkindflag, &amp;
         timeString, &amp;
         timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflagIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>calkindflagIn</STRONG></DT>
<DD>INPUT argument:  Alternate to, and mutually exclusive with,
            calendarIn above.  More convenient way of specifying a built-in
            calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>]. See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642000000000000000">
43.4.20 ESMF_TimeIntervalNegAbsValue - Return the negative absolute value of a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_TimeIntervalNegAbsValue(timeinterval)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: ESMF_TimeIntervalNegAbsValue
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the negative absolute value of <TT>timeinterval</TT>.

<P>
The argument is:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to take the negative absolute value of.
            Negative absolute value is returned as the value of the function.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642100000000000000">
43.4.21 ESMF_TimeIntervalPrint - Print TimeInterval information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeIntervalPrint(timeinterval, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       character (len=*),       intent(in),  optional :: options
       integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints out the contents of an <TT>ESMF_TimeInterval</TT> to <TT>stdout</TT>,
       in support of testing and debugging.  The options control the type of
       information and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>Time interval to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options.  If none specified, prints all <TT>timeinterval</TT>
            property values. 
<BR>            "string" - prints <TT>timeinterval</TT>'s value in ISO 8601 format
                       for all units through seconds.  For any non-zero
                       fractional seconds, prints in integer rational
                       fraction form n/d.  Format is PyYmMdDThHmMs[:n/d]S,
                       where [:n/d] is the integer numerator and denominator
                       of the fractional seconds value, if present.
                       See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].  See also method
                       <TT>ESMF_TimeIntervalGet(..., timeString= , ...)</TT> 
<BR>            "string isofrac" - prints <TT>timeinterval</TT>'s value in strict
                       ISO 8601 format for all units, including any fractional
                       seconds part.  Format is PyYmMdDThHmMs[.f]S, where [.f]
                       represents fractional seconds in decimal form,
                       if present.  See&nbsp;[<A
 HREF="node8.html#ISO">18</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">5</A>].
                       See also method <TT>ESMF_TimeIntervalGet(..., timeStringISOFrac= , ...)</TT> 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642200000000000000">
43.4.22 ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDur(timeinterval, &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.  Default = 0.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.  Default = 0.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.  Default = 0.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.  Default = 0.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.  Default = 0.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
            Default = 0.
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
            Default = 1.
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 1.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642300000000000000">
43.4.23 ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurStart(timeinterval, startTime, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_Time),         intent(in)            :: startTime
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>startTime</STRONG></DT>
<DD>Starting time of an absolute calendar interval 
            (yy, mm, and/or d); pins a calendar interval to a specific point 
            in time.  If not set, and calendar also not set, calendar interval 
            "floats" across all calendars and times.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.  Default = 0.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.  Default = 0.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.  Default = 0.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.  Default = 0.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.  Default = 0.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
            Default = 0.
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
            Default = 1.
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8).
                                                             (large, 64-bit).
            Default = 1.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642400000000000000">
43.4.24 ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurCal(timeinterval, calendar, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_Calendar),     intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>Calendar</TT> used to give better definition to 
            calendar interval (yy, mm, and/or d) for arithmetic, comparison, 
            and conversion operations.  Allows calendar interval to "float" 
            across all times on a specific calendar.  Default = NULL; 
            if startTime also not specified, calendar interval "floats" across 
            all calendars and times.  Mutually exclusive with startTime since 
            it contains a calendar.  Alternate to, and mutually exclusive with, 
            calkindflag below.  Primarily for specifying a custom calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.  Default = 0.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.  Default = 0.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.  Default = 0.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.  Default = 0.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.  Default = 0.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
            Default = 0.
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8).
                                                             (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
            Default = 1.
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8).
                                                             (large, 64-bit).
            Default = 1.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642500000000000000">
43.4.25 ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurCalTyp(timeinterval, calkindflag, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>Alternate to, and mutually exclusive with, 
            calendar above.  More convenient way of specifying a built-in 
            calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.  Default = 0.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.  Default = 0.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.  Default = 0.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.  Default = 0.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.  Default = 0.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
            Default = 0.
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
            Default = 1.
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 1.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642600000000000000">
43.4.26 ESMF_TimeIntervalValidate - Validate a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeIntervalValidate(timeinterval, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>timeinterval</TT> is valid.
       If fractional value, denominator must be non-zero.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD><TT>ESMF_TimeInterval</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION06070000000000000000">
44 Clock Class</A>
</H1>

<H2><A NAME="SECTION06071000000000000000">
44.1 Description</A>
</H2>

<P>
<A NAME="sec:Clock"></A>
<P>
The Clock class advances model time and tracks its associated
date on a specified Calendar.  It stores start time, stop time,
current time, previous time, and a time step.  It can also store
a reference time, typically the time instant at which a simulation 
originally began.  For a restart run, the reference time can be 
different than the start time, when the application execution resumes.

<P>
A user can call the <TT>ESMF_ClockSet</TT> method and reset the time 
step as desired.  

<P>
A Clock also stores a list of Alarms, which can be set to flag 
events that occur at a specified time instant or at 
a specified time interval.  See Section&nbsp;<A HREF="#sec:Alarm">45.1</A> for 
details on how to use Alarms.

<P>
There are methods for setting and getting the Times and 
Alarms associated with a Clock.  Methods are defined for 
advancing the Clock's current time, checking if the 
stop time has been reached, reversing direction, and 
synchronizing with a real clock. 

<H2><A NAME="SECTION06072000000000000000">
44.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION06072100000000000000"></A>
<A NAME="const:direction"></A>
<BR>
44.2.1 ESMF_DIRECTION
</H3>

<P>
<I>DESCRIPTION:
<BR></I>

Specifies the time-stepping direction of a clock.  Use with "direction"
argument to methods <TT>ESMF_ClockSet()</TT> and <TT>ESMF_ClockGet()</TT>.
Cannot be used with method <TT>ESMF_ClockCreate()</TT>, since it only
initializes a clock in the default forward mode; a clock must be advanced
(timestepped) at least once before reversing direction via
<TT>ESMF_ClockSet()</TT>.  This also holds true for negative timestep clocks
which are initialized (created) with stopTime &lt; startTime, since "forward"
means timestepping from startTime towards stopTime
(see <TT>ESMF_DIRECTION_FORWARD</TT> below).

<P>
"Forward" and "reverse" directions are distinct from positive and negative
timesteps.  "Forward" means timestepping in the direction established at
<TT>ESMF_ClockCreate()</TT>, from startTime towards stopTime, regardless
of the timestep sign.  "Reverse" means timestepping in the opposite direction,
back towards the clock's startTime, regardless of the timestep sign.

<P>
Clocks and alarms run in reverse in such a way that the state of a clock and
its alarms after each time step is precisely replicated as it was in forward
time-stepping mode.  All methods which query clock and alarm state will
return the same result for a given timeStep, regardless of the direction of
arrival.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Direction_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_DIRECTION_FORWARD</STRONG></DT>
<DD>Upon calling <TT>ESMF_ClockAdvance()</TT>, the clock will timestep from
its startTime toward its stopTime.  This is the default direction.  A user
can use either <TT>ESMF_ClockIsStopTime()</TT> or <TT>ESMF_ClockIsDone()</TT>
methods to determine when stopTime is reached.  This forward behavior also
holds for negative timestep clocks which are initialized (created) with
stopTime &lt; startTime.

<P>
</DD>
<DT><STRONG>ESMF_DIRECTION_REVERSE</STRONG></DT>
<DD>Upon calling <TT>ESMF_ClockAdvance()</TT>, the clock will timestep backwards
toward its startTime.  Use method <TT>ESMF_ClockIsDone()</TT> to determine when
startTime is reached.  This reverse behavior also holds for negative timestep
clocks which are initialized (created) with stopTime &lt; startTime.

<P>
</DD>
</DL>

<H2><A NAME="SECTION06073000000000000000">
44.3 Use and Examples</A>
</H2>

<P>
The following is a typical sequence for using a Clock in a 
geophysical model.

<P>
<B>At initialize:</B>

<UL>
<LI>Set a Calendar.
</LI>
<LI>Set start time, stop time and time step as Times and 
Time Intervals.
</LI>
<LI>Create and Initialize a Clock using the start time, stop time and time
step.
</LI>
<LI>Define Times and Time Intervals associated with special
events, and use these to set Alarms.
</LI>
</UL>

<P>
<B>At run:</B>

<UL>
<LI>Advance the Clock, checking for ringing alarms as needed.
</LI>
<LI>Check if it is time to stop.
</LI>
</UL>

<P>
<B>At finalize:</B>

<UL>
<LI>Since Clocks and Alarms are deep classes, they need to be explicitly
destroyed at finalization.  Times and TimeIntervals are lightweight classes,
so they don't need explicit destruction.
</LI>
</UL>

<P>
The following code example illustrates Clock usage.

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_ClockEx - Clock initialization and time-stepping
!
! !DESCRIPTION:
!
! This program shows an example of how to create, initialize, advance, and
! examine a basic clock
!-----------------------------------------------------------------------------
#include "ESMF.h"

      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! instantiate a clock 
      type(ESMF_Clock) :: clock

      ! instantiate time_step, start and stop times
      type(ESMF_TimeInterval) :: timeStep
      type(ESMF_Time) :: startTime
      type(ESMF_Time) :: stopTime

      ! local variables for Get methods
      type(ESMF_Time) :: currTime
      integer(ESMF_KIND_I8) :: advanceCount
      integer :: YY, MM, DD, H, M, S

      ! return code
      integer :: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="ClockEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06073100000000000000">
44.3.1 Clock creation</A>
</H3>

<P>
This example shows how to create and initialize an <TT>ESMF_Clock</TT>. 

<P>
<PRE>
      ! initialize time interval to 2 days, 4 hours (6 timesteps in 13 days)
      call ESMF_TimeIntervalSet(timeStep, d=2, h=4, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize start time to 4/1/2003 2:24:00 ( 1/10 of a day )
      call ESMF_TimeSet(startTime, yy=2003, mm=4, dd=1, h=2, m=24, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize stop time to 4/14/2003 2:24:00 ( 1/10 of a day )
      call ESMF_TimeSet(stopTime, yy=2003, mm=4, dd=14, h=2, m=24, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize the clock with the above values
      clock = ESMF_ClockCreate(timeStep, startTime, stopTime=stopTime, &amp;
                               name="Clock 1", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06073200000000000000">
44.3.2 Clock advance</A>
</H3>

<P>
This example shows how to time-step an <TT>ESMF_Clock</TT>. 

<P>
<PRE>
      ! time step clock from start time to stop time
      do while (.not.ESMF_ClockIsStopTime(clock, rc=rc))
</PRE>

<P>
<PRE>
        call ESMF_ClockPrint(clock, options="currTime string", rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_ClockAdvance(clock, rc=rc)
</PRE>

<P>
<PRE>
      end do
</PRE>

<P>

<H3><A NAME="SECTION06073300000000000000">
44.3.3 Clock examination</A>
</H3>

<P>
This example shows how to examine an <TT>ESMF_Clock</TT>. 

<P>
<PRE>
      ! get the clock's final current time
      call ESMF_ClockGet(clock, currTime=currTime, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeGet(currTime, yy=YY, mm=MM, dd=DD, h=H, m=M, s=S, rc=rc) 
      print *, "The clock's final current time is ", YY, "/", MM, "/", DD, &amp;
               " ", H, ":", M, ":", S
</PRE>

<P>
<PRE>
      ! get the number of times the clock was advanced
      call ESMF_ClockGet(clock, advanceCount=advanceCount, rc=rc)
      print *, "The clock was advanced ", advanceCount, " times."
</PRE>

<P>

<H3><A NAME="SECTION06073400000000000000">
44.3.4 Clock reversal</A>
</H3>

<P>
This example shows how to time-step an <TT>ESMF_Clock</TT> in reverse mode. 

<P>
<PRE>
      call ESMF_ClockSet(clock, direction=ESMF_DIRECTION_REVERSE, rc=rc)
</PRE>

<P>
<PRE>
      ! time step clock in reverse from stop time back to start time;
      !  note use of ESMF_ClockIsDone() rather than ESMF_ClockIsStopTime()
      do while (.not.ESMF_ClockIsDone(clock, rc=rc))
</PRE>

<P>
<PRE>
        call ESMF_ClockPrint(clock, options="currTime string", rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_ClockAdvance(clock, rc=rc)
</PRE>

<P>
<PRE>
      end do
</PRE>

<P>

<H3><A NAME="SECTION06073500000000000000">
44.3.5 Clock destruction</A>
</H3>

<P>
This example shows how to destroy an <TT>ESMF_Clock</TT>. 

<P>
<PRE>
      ! destroy clock
      call ESMF_ClockDestroy(clock, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_ClockEx
</PRE>

<P>


<H2><A NAME="SECTION06074000000000000000">
44.4 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Alarm list allocation factor</B>  The alarm list within a clock is
dynamically allocated automatically, 200 alarm references at a time.
This constant is defined in both Fortran and C++ with a #define for ease
of modification.

<P>
</LI>
<LI><B>Clock variable timesteps in reverse</B> 

In order for a clock with
variable timesteps to be run in <TT>ESMF_DIRECTION_REVERSE</TT>, the user must
supply those timesteps to <TT>ESMF_ClockAdvance()</TT>.  Essentially, the user
must save the timesteps while in forward mode.  In a future release, the
Time Manager will assume this responsibility by saving the clock state
(including the timeStep) at every timestep while in forward mode.

<P>
</LI>
</OL>

<H2><A NAME="SECTION06075000000000000000">
44.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06075100000000000000">
44.5.1 ESMF_ClockAssignment(=) - Assign a Clock to another Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface assignment(=)
       clock1 = clock2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock) :: clock1
       type(ESMF_Clock) :: clock2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign <TT>clock1</TT> as an alias to the same <TT>ESMF_Clock</TT> object in
       memory as <TT>clock2</TT>. If <TT>clock2</TT> is invalid, then <TT>clock1</TT>
       will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock1</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the left hand side of the
            assignment.
       
</DD>
<DT><STRONG>clock2</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the right hand side of the
            assignment.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075200000000000000">
44.5.2 ESMF_ClockOperator(==) - Test if Clock 1 is equal to Clock 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (clock1 == clock2) then ... endif
                    OR
       result = (clock1 == clock2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in) :: clock1
       type(ESMF_Clock), intent(in) :: clock2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Clock</TT> class.
       Compare two clocks for equality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created clocks and identical for clocks created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both
       sides are in the <EM>same</EM> status, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock1</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>clock2</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075300000000000000">
44.5.3 ESMF_ClockOperator(/=) - Test if Clock 1 is not equal to Clock 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (clock1 /= clock2) then ... endif
                    OR
       result = (clock1 /= clock2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in) :: clock1
       type(ESMF_Clock), intent(in) :: clock2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Clock</TT> class.
       Compare two clocks for inequality; return <TT>.true.</TT> if not equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created clocks and identical for clocks created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both sides
       are <EM>not</EM> in the <EM>same</EM> status, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock1</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the left hand side of the
            non-equality operation.
       
</DD>
<DT><STRONG>clock2</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the right hand side of the
            non-equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075400000000000000">
44.5.4 ESMF_ClockAdvance - Advance a Clock's current time by one time step</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockAdvance(clock, &amp;
         timeStep, ringingAlarmList, ringingAlarmCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       type(ESMF_Alarm),        intent(out), optional :: ringingAlarmList(:)
       integer,                 intent(out), optional :: ringingAlarmCount
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Advances the <TT>clock</TT>'s current time by one time step:  either the
       <TT>clock</TT>'s, or the passed-in <TT>timeStep</TT> (see below).  When the
       <TT>clock</TT> is in <TT>ESMF_DIRECTION_FORWARD</TT> (default), this method
       adds the <TT>timeStep</TT> to the <TT>clock</TT>'s current time.
       In <TT>ESMF_DIRECTION_REVERSE</TT>, <TT>timeStep</TT> is subtracted from the
       current time.  In either case, <TT>timeStep</TT> can be positive or negative.
       See the "direction" argument in method <TT>ESMF_ClockSet()</TT>.
       <TT>ESMF_ClockAdvance()</TT> optionally returns a list and number of ringing
       <TT>ESMF_Alarm</TT>s.  See also method <TT>ESMF_ClockGetRingingAlarms()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to advance.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>Time step is performed with given timeStep, instead of
            the <TT>ESMF_Clock</TT>'s.  Does not replace the <TT>ESMF_Clock</TT>'s
            timeStep; use <TT>ESMF_ClockSet(clock, timeStep, ...)</TT> for
            this purpose.  Supports applications with variable time steps.
            timeStep can be positive or negative.
       
</DD>
<DT><STRONG>[ringingAlarmList]</STRONG></DT>
<DD>Returns the array of alarms that are ringing after the
            time step.
       
</DD>
<DT><STRONG>[ringingAlarmCount]</STRONG></DT>
<DD>The number of alarms ringing after the time step.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075500000000000000">
44.5.5 ESMF_ClockCreate - Create a new ESMF Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_ClockCreate()
       function ESMF_ClockCreateNew(timeStep, startTime, &amp;
         stopTime, runDuration, runTimeStepCount, refTime, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Clock) :: ESMF_ClockCreateNew
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeStep
       type(ESMF_Time),         intent(in)            :: startTime
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: runDuration
       integer,                 intent(in),  optional :: runTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates and sets the initial values in a new <TT>ESMF_Clock</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeStep</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time step interval, which can be
            positive or negative.
       
</DD>
<DT><STRONG>startTime</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s starting time.  Can be less than or
            or greater than stopTime, depending on a positive or negative
            timeStep, respectively, and whether a stopTime is specified;
            see below.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s stopping time.  Can be greater than or
            less than the startTime, depending on a positive or negative
            timeStep, respectively.  If neither stopTime, runDuration, nor
            runTimeStepCount is specified, clock runs "forever"; user must
            use other means to know when to stop (e.g. ESMF_Alarm or
            ESMF_ClockGet(clock, currTime)).  Mutually exclusive with
            runDuration and runTimeStepCount.
       
</DD>
<DT><STRONG>[runDuration]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + runDuration.
            Can be positive or negative, consistent with the timeStep's sign.
            Mutually exclusive with stopTime and runTimeStepCount.
       
</DD>
<DT><STRONG>[runTimeStepCount]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + (runTimeStepCount * timeStep).
            stopTime can be before startTime if timeStep is negative.
            Mutually exclusive with stopTime and runDuration.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s reference time.  Provides reference point
            for simulation time (see currSimTime in ESMF_ClockGet() below).
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created clock.  If not specified, a
            default unique name will be generated: "ClockNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075600000000000000">
44.5.6 ESMF_ClockCreate - Create a copy of an existing ESMF Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_ClockCreate()
       function ESMF_ClockCreateCopy(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Clock) :: ESMF_ClockCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a deep copy of a given <TT>ESMF_Clock</TT>, but does not copy its
       list of <TT>ESMF_Alarm</TT>s (pointers), since an <TT>ESMF_Alarm</TT> can only
       be associated with one <TT>ESMF_Clock</TT>.  Hence, the returned
       <TT>ESMF_Clock</TT> copy has no associated <TT>ESMF_Alarm</TT>s, the same as
       with a newly created <TT>ESMF_Clock</TT>.  If desired, new
       <TT>ESMF_Alarm</TT>s must be created and associated with this copied
       <TT>ESMF_Clock</TT> via <TT>ESMF_AlarmCreate()</TT>, or existing
       <TT>ESMF_Alarm</TT>s must be re-associated with this copied
       <TT>ESMF_Clock</TT> via <TT>ESMF_AlarmSet(...clock=...)</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> to copy.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075700000000000000">
44.5.7 ESMF_ClockDestroy - Release resources associated with a Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockDestroy(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)          :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Releases resources associated with this <TT>ESMF_Clock</TT>.  This releases
       the list of associated <TT>ESMF_Alarm</TT>s (pointers), but not the
       <TT>ESMF_Alarm</TT>s themselves; the user must explicitly call
       <TT>ESMF_AlarmDestroy()</TT> on each <TT>ESMF_Alarm</TT> to release its
       resources.  <TT>ESMF_ClockDestroy()</TT> and corresponding
       <TT>ESMF_AlarmDestroy()</TT>s can be called in either order.

<P>
If <TT>ESMF_ClockDestroy()</TT> is called before <TT>ESMF_AlarmDestroy()</TT>,
       any <TT>ESMF_Alarm</TT>s that were in the <TT>ESMF_Clock</TT>'s list will
       no longer be associated with any <TT>ESMF_Clock</TT>.  If desired,
       these "orphaned" <TT>ESMF_Alarm</TT>s can be associated with a different
       <TT>ESMF_Clock</TT> via a call to <TT>ESMF_AlarmSet(...clock=...)</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>Release resources associated with this <TT>ESMF_Clock</TT> and mark the
         object as invalid.  It is an error to pass this object into any other
         routines after being destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075800000000000000">
44.5.8 ESMF_ClockGet - Get a Clock's properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGet(clock, &amp;
         timeStep, startTime, stopTime, &amp;
         runDuration, runTimeStepCount, refTime, currTime, prevTime, &amp;
         currSimTime, prevSimTime, calendar, calkindflag, timeZone, &amp;
         advanceCount, alarmCount, direction, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(out), optional :: timeStep
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Time),         intent(out), optional :: stopTime
       type(ESMF_TimeInterval), intent(out), optional :: runDuration
       real(ESMF_KIND_R8),      intent(out), optional :: runTimeStepCount
       type(ESMF_Time),         intent(out), optional :: refTime
       type(ESMF_Time),         intent(out), optional :: currTime
       type(ESMF_Time),         intent(out), optional :: prevTime
       type(ESMF_TimeInterval), intent(out), optional :: currSimTime
       type(ESMF_TimeInterval), intent(out), optional :: prevSimTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       integer,                 intent(out), optional :: timeZone
       integer(ESMF_KIND_I8),   intent(out), optional :: advanceCount
       integer,                 intent(out), optional :: alarmCount
       type(ESMF_Direction_Flag),    intent(out), optional :: direction
       character (len=*),       intent(out), optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets one or more of the properties of an <TT>ESMF_Clock</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time step interval.
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s starting time.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s stopping time.
       
</DD>
<DT><STRONG>[runDuration]</STRONG></DT>
<DD>Alternative way to get <TT>ESMF_Clock</TT>'s stopping time;
               runDuration = stopTime - startTime.
       
</DD>
<DT><STRONG>[runTimeStepCount]</STRONG></DT>
<DD>Alternative way to get <TT>ESMF_Clock</TT>'s stopping time;
               runTimeStepCount = (stopTime - startTime) / timeStep.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s reference time.
       
</DD>
<DT><STRONG>[currTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s current time.
       
</DD>
<DT><STRONG>[prevTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s previous time.  Equals currTime at
            the previous time step.
       
</DD>
<DT><STRONG>[currSimTime]</STRONG></DT>
<DD>The current simulation time (currTime - refTime).
       
</DD>
<DT><STRONG>[prevSimTime]</STRONG></DT>
<DD>The previous simulation time.  Equals currSimTime at
            the previous time step.
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>The <TT>Calendar</TT> on which all the <TT>Clock</TT>'s times are defined.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>The <TT>CalKind_Flag</TT> on which all the <TT>Clock</TT>'s times are
            defined.
       
</DD>
<DT><STRONG>[timeZone]</STRONG></DT>
<DD>The timezone within which all the <TT>Clock</TT>'s times are defined.
       
</DD>
<DT><STRONG>[advanceCount]</STRONG></DT>
<DD>The number of times the <TT>ESMF_Clock</TT> has been advanced.
            Increments in <TT>ESMF_DIRECTION_FORWARD</TT> and decrements in
            <TT>ESMF_DIRECTION_REVERSE</TT>; see "direction" argument below and
            in <TT>ESMF_ClockSet()</TT>.

</DD>
<DT><STRONG>[alarmCount]</STRONG></DT>
<DD>The number of <TT>ESMF_Alarm</TT>s in the <TT>ESMF_Clock</TT>'s
            <TT>ESMF_Alarm</TT> list.
       
</DD>
<DT><STRONG>[direction]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time stepping direction.  See also
            <TT>ESMF_ClockIsReverse()</TT>, an alternative for convenient use in
            "if" and "do while" constructs.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of this clock.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075900000000000000">
44.5.9 ESMF_ClockGetAlarm - Get an Alarm in a Clock's Alarm list</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGetAlarm(clock, alarmname, alarm, &amp;
         rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),  intent(in)            :: clock
       character (len=*), intent(in)            :: alarmname
       type(ESMF_Alarm),  intent(out)           :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the <TT>alarm</TT> whose name is the value of alarmname in the
       <TT>clock</TT>'s <TT>ESMF_Alarm</TT> list.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to get the <TT>ESMF_Alarm</TT> from.
       
</DD>
<DT><STRONG>alarmname</STRONG></DT>
<DD>The name of the desired <TT>ESMF_Alarm</TT>.
       
</DD>
<DT><STRONG>alarm</STRONG></DT>
<DD>The desired alarm.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751000000000000000">
44.5.10 ESMF_ClockGetAlarmList - Get a list of Alarms from a Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGetAlarmList(clock, alarmlistflag, &amp;
         timeStep, alarmList, alarmCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),          intent(in)            :: clock
       type(ESMF_AlarmList_Flag), intent(in)            :: alarmlistflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval),   intent(in),  optional :: timeStep
       type(ESMF_Alarm),          intent(out), optional :: alarmList(:)
       integer,                   intent(out), optional :: alarmCount
       integer,                   intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the <TT>clock</TT>'s list of alarms and/or number of alarms.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance from which to get an <TT>ESMF_Alarm</TT> list
            and/or count of <TT>ESMF_Alarm</TT>s.
       
</DD>
<DT><STRONG>alarmlistflag</STRONG></DT>
<DD>The kind of list to get:

<P>
<TT>ESMF_ALARMLIST_ALL</TT> :
                  Returns the <TT>ESMF_Clock</TT>'s entire list of alarms.

<P>
<TT>ESMF_ALARMLIST_NEXTRINGING</TT> :
                  Return only those alarms that will ring upon the next
                  <TT>clock</TT> time step.  Can optionally specify argument
                  <TT>timeStep</TT> (see below) to use instead of the <TT>clock</TT>'s.
                  See also method <TT>ESMF_AlarmWillRingNext()</TT> for checking a
                  single alarm.

<P>
<TT>ESMF_ALARMLIST_PREVRINGING</TT> :
                  
                  Return only those alarms that were ringing on the previous
                  <TT>ESMF_Clock</TT> time step.  See also method
                  <TT>ESMF_AlarmWasPrevRinging()</TT> for checking a single alarm.

<P>
<TT>ESMF_ALARMLIST_RINGING</TT> :
                  Returns only those <TT>clock</TT> alarms that are currently
                  ringing.  See also method <TT>ESMF_ClockAdvance()</TT> for
                  getting the list of ringing alarms subsequent to a time step.
                  See also method <TT>ESMF_AlarmIsRinging()</TT> for checking a
                  single alarm.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>Optional time step to be used instead of the <TT>clock</TT>'s.
            Only used with <TT>ESMF_ALARMLIST_NEXTRINGING alarmlistflag</TT>
            (see above); ignored if specified with other <TT>alarmlistflags</TT>.

</DD>
<DT><STRONG>[alarmList]</STRONG></DT>
<DD>The array of returned alarms.  If given, the array must be large
            enough to hold the number of alarms of the specified
            <TT>alarmlistflag</TT> in the specified <TT>clock</TT>.
       
</DD>
<DT><STRONG>[alarmCount]</STRONG></DT>
<DD>If specified, returns the number of <TT>ESMF_Alarm</TT>s of the
            specified <TT>alarmlistflag</TT> in the specified <TT>clock</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751100000000000000">
44.5.11 ESMF_ClockGetNextTime - Calculate a Clock's next time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGetNextTime(clock, nextTime, &amp;
         timeStep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(in)            :: clock
       type(ESMF_Time),         intent(out)           :: nextTime
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Calculates what the next time of the <TT>clock</TT> will be, based on
       the <TT>clock</TT>'s current time step or an optionally passed-in
       <TT>timeStep</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance for which to get the next time.
       
</DD>
<DT><STRONG>nextTime</STRONG></DT>
<DD>The resulting <TT>ESMF_Clock</TT>'s next time.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>The time step interval to use instead of the clock's.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751200000000000000">
44.5.12 ESMF_ClockIsCreated - Check whether a Clock object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_ClockIsCreated(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_ClockIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>clock</TT> has been created. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>clock</STRONG></DT>
<DD><TT>ESMF_Clock</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751300000000000000">
44.5.13 ESMF_ClockIsDone - Based on its direction, test if the Clock has reached or exceeded its stop time or start time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_ClockIsDone(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsDone
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns true if currentTime is greater than or equal to stopTime
       in <TT>ESMF_DIRECTION_FORWARD</TT>, or if currentTime is less than or
       equal to startTime in <TT>ESMF_DIRECTION_REVERSE</TT>.  It returns false
       otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751400000000000000">
44.5.14 ESMF_ClockIsReverse - Test if the Clock is in reverse mode</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_ClockIsReverse(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsReverse
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns true if clock is in <TT>ESMF_DIRECTION_REVERSE</TT>, and false if
       in <TT>ESMF_DIRECTION_FORWARD</TT>.  Allows convenient use in "if" and
       "do while" constructs.  Alternative to
       <TT>ESMF_ClockGet(...direction=...)</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751500000000000000">
44.5.15 ESMF_ClockIsStopTime - Test if the Clock has reached or exceeded its stop time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_ClockIsStopTime(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsStopTime
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns true if the <TT>clock</TT> has reached or exceeded its stop time,
       and false otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751600000000000000">
44.5.16 ESMF_ClockIsStopTimeEnabled - Test if the Clock's stop time is enabled</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_ClockIsStopTimeEnabled(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsStopTimeEnabled
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns true if the <TT>clock</TT>'s stop time is set and enabled,
       and false otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751700000000000000">
44.5.17 ESMF_ClockPrint - Print Clock information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockPrint(clock, options, preString, unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),  intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*), intent(in),  optional :: options
       character(*),      intent(in),  optional :: preString
       character(*),      intent(out), optional :: unit
       integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints out an <TT>ESMF_Clock</TT>'s properties to <TT>stdout</TT>, in
       support of testing and debugging.  The options control the type of
       information and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD><TT>ESMF_Clock</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all <TT>clock</TT> property
            values.
<BR>            "advanceCount" - print the number of times the clock has been
                             advanced. 
<BR>            "alarmCount"   - print the number of alarms in the clock's list. 
<BR>            "alarmList"    - print the clock's alarm list. 
<BR>            "currTime"     - print the current clock time. 
<BR>            "direction"    - print the clock's timestep direction. 
<BR>            "name"         - print the clock's name. 
<BR>            "prevTime"     - print the previous clock time. 
<BR>            "refTime"      - print the clock's reference time. 
<BR>            "startTime"    - print the clock's start time. 
<BR>            "stopTime"     - print the clock's stop time. 
<BR>            "timeStep"     - print the clock's time step. 
<BR>       
</DD>
<DT><STRONG>[preString]</STRONG></DT>
<DD>Optionally prepended string. Default to empty string.
       
</DD>
<DT><STRONG>[unit]</STRONG></DT>
<DD>Internal unit, i.e. a string. Default to printing to stdout.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751800000000000000">
44.5.18 ESMF_ClockSet - Set one or more properties of a Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockSet(clock, &amp;
         timeStep, startTime, stopTime, &amp;
         runDuration, runTimeStepCount, refTime, currTime, advanceCount, &amp;
         direction, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       type(ESMF_Time),         intent(in),  optional :: startTime
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: runDuration
       integer,                 intent(in),  optional :: runTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       type(ESMF_Time),         intent(in),  optional :: currTime
       integer(ESMF_KIND_I8),   intent(in),  optional :: advanceCount
       type(ESMF_Direction_Flag),    intent(in),  optional :: direction
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets/resets one or more of the properties of an <TT>ESMF_Clock</TT> that
       was previously initialized via <TT>ESMF_ClockCreate()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to set.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time step interval, which can be positive or
            negative.  This is used to change a clock's timestep property for
            those applications that need variable timesteps.  See
            <TT>ESMF_ClockAdvance()</TT> below for specifying variable timesteps
            that are NOT saved as the clock's internal time step property.
            See "direction" argument below for behavior with
            
<BR>
t ESMF_DIRECTION_REVERSE direction.
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s starting time.  Can be less than or
            or greater than stopTime, depending on a positive or negative
            timeStep, respectively, and whether a stopTime is specified;
            see below.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s stopping time.  Can be greater than or
            less than the startTime, depending on a positive or negative
            timeStep, respectively.  If neither stopTime, runDuration, nor
            runTimeStepCount is specified, clock runs "forever"; user must
            use other means to know when to stop (e.g. ESMF_Alarm or
            ESMF_ClockGet(clock, currTime)).
            Mutually exclusive with runDuration and runTimeStepCount.
       
</DD>
<DT><STRONG>[runDuration]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + runDuration.
            Can be positive or negative, consistent with the timeStep's sign.
            Mutually exclusive with stopTime and runTimeStepCount.
       
</DD>
<DT><STRONG>[runTimeStepCount]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + (runTimeStepCount * timeStep).
            stopTime can be before startTime if timeStep is negative.
            Mutually exclusive with stopTime and runDuration.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s reference time.
            See description in <TT>ESMF_ClockCreate()</TT> above.
       
</DD>
<DT><STRONG>[currTime]</STRONG></DT>
<DD>The current time.
       
</DD>
<DT><STRONG>[advanceCount]</STRONG></DT>
<DD>The number of times the clock has been timestepped.
       
</DD>
<DT><STRONG>[direction]</STRONG></DT>
<DD>Sets the clock's time-stepping direction.  If called with
            <TT>ESMF_DIRECTION_REVERSE</TT>, sets the clock in "reverse" mode,
            causing it to timestep back towards its startTime.  If called
            with <TT>ESMF_DIRECTION_FORWARD</TT>, sets the clock in normal,
            "forward" mode, causing it to timestep in the direction of its
            startTime to stopTime.  This holds true for negative timestep
            clocks as well, which are initialized (created) with
            stopTime &lt; startTime.  The default mode is
            <TT>ESMF_DIRECTION_FORWARD</TT>, established at
            <TT>ESMF_ClockCreate()</TT>.  timeStep can also be specified as an
            argument at the same time, which allows for a change in magnitude
            and/or sign of the clock's timeStep.  If not specified with
            <TT>ESMF_DIRECTION_REVERSE</TT>, the clock's current timeStep is
            effectively negated.  If timeStep is specified, its sign is used as
            specified; it is not negated internally.  E.g., if the specified
            timeStep is negative and the clock is placed in
            <TT>ESMF_DIRECTION_REVERSE</TT>, subsequent calls to
            <TT>ESMF_ClockAdvance()</TT> will cause the clock's current time to
            be decremented by the new timeStep's magnitude.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this clock.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751900000000000000">
44.5.19 ESMF_ClockStopTimeDisable - Disable a Clock's stop time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockStopTimeDisable(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Disables a <TT>ESMF_Clock</TT>'s stop time; <TT>ESMF_ClockIsStopTime()</TT>
       will always return false, allowing a clock to run past its stopTime.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance whose stop time to disable.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060752000000000000000">
44.5.20 ESMF_ClockStopTimeEnable - Enable an Clock's stop time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockStopTimeEnable(clock, stopTime, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Time),  intent(in),  optional :: stopTime
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Enables a <TT>ESMF_Clock</TT>'s stop time, allowing
       <TT>ESMF_ClockIsStopTime()</TT> to respect the stopTime.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance whose stop time to enable.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time to set or reset.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060752100000000000000">
44.5.21 ESMF_ClockSyncToRealTime - Set Clock's current time to wall clock time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockSyncToRealTime(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets a <TT>clock</TT>'s current time to the wall clock time.  It is
       accurate to the nearest second.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to be synchronized with wall clock time.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060752200000000000000">
44.5.22 ESMF_ClockValidate - Validate a Clock's properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockValidate(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),  intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>clock</TT> is valid.
       Must have a valid startTime and timeStep.  If <TT>clock</TT> has a
       stopTime, its currTime must be within startTime to stopTime, inclusive;
       also startTime's and stopTime's calendars must be the same.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD><TT>ESMF_Clock</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION06080000000000000000">
45 Alarm Class</A>
</H1>

<H2><A NAME="SECTION06081000000000000000">
45.1 Description</A>
</H2>

<P>
<A NAME="sec:Alarm"></A>The Alarm class identifies events that occur at specific Times
or specific TimeIntervals by returning a true value at those times
or subsequent times, and a false value otherwise.  

<H2><A NAME="SECTION06082000000000000000">
45.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION06082100000000000000"></A>
<A NAME="const:alarmlist"></A>
<BR>
45.2.1 ESMF_ALARMLIST
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Specifies the characteristics of Alarms that populate
a retrieved Alarm list.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_AlarmList_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ALARMLIST_ALL</STRONG></DT>
<DD>All alarms.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_NEXTRINGING</STRONG></DT>
<DD>Alarms that will ring before or at the next timestep.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_PREVRINGING</STRONG></DT>
<DD>Alarms that rang at or since the last timestep.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_RINGING</STRONG></DT>
<DD>Only ringing alarms.

<P>
</DD>
</DL>

<H2><A NAME="SECTION06083000000000000000">
45.3 Use and Examples</A>
</H2>

<P>
Alarms are used in conjunction with Clocks (see Section&nbsp;<A HREF="#sec:Clock">44.1</A>).
Multiple Alarms can be associated with a Clock.  During the
<TT>ESMF_ClockAdvance()</TT> method, a Clock iterates over its internal Alarms
to determine if any are ringing.  Alarms ring when a specified Alarm 
time is reached or exceeded, taking into account whether the time step is
positive or negative.  In <TT>ESMF_DIRECTION_REVERSE</TT>
(see Section&nbsp;<A HREF="#sec:Clock">44.1</A>), alarms ring in reverse, i.e., they begin
ringing when they originally ended, and end ringing when they originally
began.  On completion of the time advance call, the Clock optionally returns
a list of ringing alarms.

<P>
Each ringing Alarm can then be processed using Alarm methods for identifying,
turning off, disabling or resetting the Alarm.

<P>
Alarm methods are defined for obtaining the ringing state, turning the
ringer on/off, enabling/disabling the Alarm, and getting/setting 
associated times.

<P>
The following example shows how to set and process Alarms.

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_AlarmEx - Alarm examples
!
! !DESCRIPTION:
!
! This program shows an example of how to create, initialize, and process
! alarms associated with a clock.
!-----------------------------------------------------------------------------
#include "ESMF.h"

      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! instantiate time_step, start, stop, and alarm times
      type(ESMF_TimeInterval) :: timeStep, alarmInterval
      type(ESMF_Time) :: alarmTime, startTime, stopTime

      ! instantiate a clock 
      type(ESMF_Clock) :: clock

      ! instantiate Alarm lists
      integer, parameter :: NUMALARMS = 2
      type(ESMF_Alarm) :: alarm(NUMALARMS)

      ! local variables for Get methods
      integer :: ringingAlarmCount  ! at any time step (0 to NUMALARMS)

      ! name, loop counter, result code
      character (len=ESMF_MAXSTR) :: name
      integer :: i, rc, result
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="AlarmEx.Log", &amp;
        logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06083100000000000000">
45.3.1 Clock initialization</A>
</H3>

<P>
This example shows how to create and initialize an <TT>ESMF_Clock</TT>. 

<P>
<PRE>
      ! initialize time interval to 1 day
      call ESMF_TimeIntervalSet(timeStep, d=1, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize start time to 9/1/2003
      call ESMF_TimeSet(startTime, yy=2003, mm=9, dd=1, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize stop time to 9/30/2003
      call ESMF_TimeSet(stopTime, yy=2003, mm=9, dd=30, rc=rc)
</PRE>

<P>
<PRE>
      ! create &amp; initialize the clock with the above values
      clock = ESMF_ClockCreate(timeStep, startTime, stopTime=stopTime, &amp;
                               name="The Clock", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06083200000000000000">
45.3.2 Alarm initialization</A>
</H3>

<P>
This example shows how to create and initialize two <TT>ESMF_Alarms</TT> and
   associate them with the clock. 

<P>
<PRE>
      ! Initialize first alarm to be a one-shot on 9/15/2003 and associate
      ! it with the clock
      call ESMF_TimeSet(alarmTime, yy=2003, mm=9, dd=15, rc=rc)
</PRE>

<P>
<PRE>
      alarm(1) = ESMF_AlarmCreate(clock, &amp;
         ringTime=alarmTime, name="Example alarm 1", rc=rc)
</PRE>

<P>
<PRE>
      ! Initialize second alarm to ring on a 1 week interval starting 9/1/2003
      ! and associate it with the clock
      call ESMF_TimeSet(alarmTime, yy=2003, mm=9, dd=1, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalSet(alarmInterval, d=7, rc=rc)
</PRE>

<P>
<PRE>
      ! Alarm gets default name "Alarm002"
      alarm(2) = ESMF_AlarmCreate(clock=clock, ringTime=alarmTime, &amp;
                                  ringInterval=alarmInterval, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06083300000000000000">
45.3.3 Clock advance and Alarm processing</A>
</H3>

<P>
This example shows how to advance an <TT>ESMF_Clock</TT> and process any 
   resulting ringing alarms. 

<P>
<PRE>
      ! time step clock from start time to stop time
      do while (.not.ESMF_ClockIsStopTime(clock, rc=rc))
</PRE>

<P>
<PRE>
        ! perform time step and get the number of any ringing alarms
        call ESMF_ClockAdvance(clock, ringingAlarmCount=ringingAlarmCount, &amp;
                               rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_ClockPrint(clock, options="currTime string", rc=rc)
</PRE>

<P>
<PRE>
        ! check if alarms are ringing
        if (ringingAlarmCount &gt; 0) then
          print *, "number of ringing alarms = ", ringingAlarmCount

          do i = 1, NUMALARMS
            if (ESMF_AlarmIsRinging(alarm(i), rc=rc)) then
</PRE>

<P>
<PRE>
              call ESMF_AlarmGet(alarm(i), name=name, rc=rc)
              print *, trim(name), " is ringing!"
</PRE>

<P>
<PRE>
              ! after processing alarm, turn it off
              call ESMF_AlarmRingerOff(alarm(i), rc=rc)
</PRE>

<P>
<PRE>
            end if ! this alarm is ringing
          end do ! each ringing alarm
        endif ! ringing alarms
      end do ! timestep clock
</PRE>

<P>

<H3><A NAME="SECTION06083400000000000000">
45.3.4 Alarm and Clock destruction</A>
</H3>

<P>
This example shows how to destroy <TT>ESMF_Alarms</TT> and <TT>ESMF_Clocks</TT>. 

<P>
<PRE>
      call ESMF_AlarmDestroy(alarm(1), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AlarmDestroy(alarm(2), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_ClockDestroy(clock, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_AlarmEx
</PRE>

<P>


<H2><A NAME="SECTION06084000000000000000">
45.4 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Alarm list allocation factor</B>  The alarm list within a clock is
dynamically allocated automatically, 200 alarm references at a time.
This constant is defined in both Fortran and C++ with a #define for ease
of modification.

<P>
</LI>
<LI><B>Sticky alarm end times in reverse</B>  For sticky alarms, there is
an implicit limitation that in order to properly reverse timestep through a
ring end time, that time must have already been traversed in the forward
direction.  This is due to the fact that the Time Manager cannot predict
when user code will call <TT>ESMF_AlarmRingerOff()</TT>.  An error message
will be logged when this limitation is not satisfied.

<P>
</LI>
<LI><B>Sticky alarm ring interval in reverse</B>  

For repeating sticky alarms,
it is currently assumed that the ringInterval is constant, so that only the
time of the last call to <TT>ESMF_AlarmRingerOff()</TT> is saved.  In
<TT>ESMF_DIRECTION_REVERSE</TT>, this information is used to turn sticky alarms
back on.  In a future release, ringIntervals will be allowed to be variable,
by saving alarm state at every timestep.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION06085000000000000000">
45.5 Design and Implementation Notes</A>
</H2>

<P>
The Alarm class is designed as a deep, dynamically allocatable class,
based on a pointer type.  This allows for both indirect and direct
manipulation of alarms.  Indirect alarm manipulation is where ESMF_Alarm API
methods, such as ESMF_AlarmRingerOff(), are invoked on alarm references
(pointers) returned from ESMF_Clock queries such as "return ringing alarms."
Since the method is performed on an alarm reference, the actual alarm held
by the clock is affected, not just a user's local copy.  Direct alarm
manipulation is the more common case where alarm API methods are invoked on
the original alarm objects created by the user.

<P>
For consistency, the ESMF_Clock class is also designed as a deep, dynamically
allocatable class. 

<P>
An additional benefit from this approach is that Clocks and Alarms can be
created and used from anywhere in a user's code without regard to the scope
in which they were created.  In contrast, statically created Alarms and
Clocks would disappear if created within a user's routine that returns,
whereas dynamically allocated Alarms and Clocks will persist until explicitly
destroyed by the user.

<H2><A NAME="SECTION06086000000000000000">
45.6 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06086100000000000000">
45.6.1 ESMF_AlarmAssignment(=) - Assign an Alarm to another Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface assignment(=)
       alarm1 = alarm2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm) :: alarm1
       type(ESMF_Alarm) :: alarm2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign <TT>alarm1</TT> as an alias to the same <TT>ESMF_Alarm</TT> object in
       memory as <TT>alarm2</TT>. If <TT>alarm2</TT> is invalid, then <TT>alarm1</TT>
       will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm1</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the left hand side of the
            assignment.
       
</DD>
<DT><STRONG>alarm2</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the right hand side of the
            assignment.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086200000000000000">
45.6.2 ESMF_AlarmOperator(==) - Test if Alarm 1 is equal to Alarm 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (alarm1 == alarm2) then ... endif
                    OR
       result = (alarm1 == alarm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in) :: alarm1
       type(ESMF_Alarm), intent(in) :: alarm2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Alarm</TT> class.
       Compare two alarms for equality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created alarms and identical for alarms created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both
       sides are in the <EM>same</EM> status, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm1</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>alarm2</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086300000000000000">
45.6.3 ESMF_AlarmOperator(/=) - Test if Alarm 1 is not equal to Alarm 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (alarm1 /= alarm2) then ... endif
                    OR
       result = (alarm1 /= alarm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in) :: alarm1
       type(ESMF_Alarm), intent(in) :: alarm2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Alarm</TT> class.
       Compare two alarms for inequality; return <TT>.true.</TT> if not equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created alarms and identical for alarms created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both sides
       are <EM>not</EM> in the <EM>same</EM> status, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm1</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the left hand side of the
            non-equality operation.
       
</DD>
<DT><STRONG>alarm2</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the right hand side of the
            non-equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086400000000000000">
45.6.4 ESMF_AlarmCreate - Create a new ESMF Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_AlarmCreate()
       function ESMF_AlarmCreateNew(clock, &amp;
         ringTime, ringInterval, stopTime, ringDuration, ringTimeStepCount, &amp;
         refTime, enabled, sticky, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Alarm) :: ESMF_AlarmCreateNew
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Time),         intent(in),  optional :: ringTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringInterval
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringDuration
       integer,                 intent(in),  optional :: ringTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       logical,                 intent(in),  optional :: enabled
       logical,                 intent(in),  optional :: sticky
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates and sets the initial values in a new <TT>ESMF_Alarm</TT>.

<P>
In <TT>ESMF_DIRECTION_REVERSE</TT> (see Section&nbsp;<A HREF="#sec:Clock">44.1</A>), alarms
       ring in reverse, i.e., they begin ringing when they originally ended,
       and end ringing when they originally began.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The clock with which to associate this newly created alarm.
       
</DD>
<DT><STRONG>[ringTime]</STRONG></DT>
<DD>The ring time for a one-shot alarm or the first ring time for a
            repeating (interval) alarm.  Must specify at least one of ringTime
            or ringInterval.
       
</DD>
<DT><STRONG>[ringInterval]</STRONG></DT>
<DD>The ring interval for repeating (interval) alarms.  If
            <TT>ringTime</TT> is not also specified (first ring time), it will be
            calculated as the <TT>clock</TT>'s current time plus <TT>ringInterval</TT>.
            Must specify at least one of ringTime or ringInterval.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time for repeating (interval) alarms.  If not
            specified, an interval alarm will repeat forever.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>The absolute ring duration.  If not sticky (see argument below),
            alarms rings for ringDuration, then turns itself off.  Default is
            zero (unused).  Mutually exclusive with ringTimeStepCount (below);
            used only if set to a non-zero duration and ringTimeStepCount is 1
            (see below).
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>The relative ring duration.  If not sticky (see argument below),
            alarms rings for ringTimeStepCount, then turns itself off.
            Default is 1: a non-sticky alarm will ring for one clock time step.
            Mutually exclusive with ringDuration (above); used if
            ringTimeStepCount &gt; 1.  If ringTimeStepCount is 1 (default) and
            ringDuration is non-zero, ringDuration is used (see above), otherwise
            ringTimeStepCount is used.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The reference (i.e. base) time for an interval alarm.
       
</DD>
<DT><STRONG>[enabled]</STRONG></DT>
<DD>Sets the enabled state; default is on (true).  If disabled,
            an alarm will not function at all.
            See also <TT>ESMF_AlarmEnable()</TT>, <TT>ESMF_AlarmDisable()</TT>.
       
</DD>
<DT><STRONG>[sticky]</STRONG></DT>
<DD>Sets the sticky state; default is on (true).  If sticky,
            once an alarm is ringing, it will remain ringing until turned off
            manually via a user call to <TT>ESMF_AlarmRingerOff()</TT>.
            If not sticky, an alarm will turn itself off after a certain
            ring duration specified by either ringDuration or
            ringTimeStepCount (see above).  There is an implicit limitation
            that in order to properly reverse timestep through a ring end
            time in <TT>ESMF_DIRECTION_REVERSE</TT>, that time must have already
            been traversed in the forward direction.  This is due to the fact
            that the Time Manager cannot predict when user code will call
            <TT>ESMF_AlarmRingerOff()</TT>.  An error message will be logged
            when this limitation is not satisfied.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created alarm.  If not specified,
            a default unique name will be generated: "AlarmNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086500000000000000">
45.6.5 ESMF_AlarmCreate - Create a copy of an existing ESMF Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_AlarmCreate()
       function ESMF_AlarmCreateCopy(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Alarm) :: ESMF_AlarmCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a complete (deep) copy of a given <TT>ESMF_Alarm</TT>.
       The returned <TT>ESMF_Alarm</TT> copy is associated with the same
       <TT>ESMF_Clock</TT> as the original <TT>ESMF_Alarm</TT>.  If desired, use
       <TT>ESMF_AlarmSet(...clock=...)</TT> to re-associate the
       <TT>ESMF_Alarm</TT> copy with a different <TT>ESMF_Clock</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> to copy.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086600000000000000">
45.6.6 ESMF_AlarmDestroy - Release resources associated with an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmDestroy(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)          :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Releases resources associated with this <TT>ESMF_Alarm</TT>.  Also
       removes this <TT>ESMF_Alarm</TT> from its associated <TT>ESMF_Clock</TT>'s
       list of <TT>ESMF_Alarm</TT>s (removes the <TT>ESMF_Alarm</TT> pointer from
       the list).

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>Release resources associated with this <TT>ESMF_Alarm</TT> and mark the
         object as invalid.  It is an error to pass this object into any other
         routines after being destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086700000000000000">
45.6.7 ESMF_AlarmDisable - Disable an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmDisable(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Disables an <TT>ESMF_Alarm</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to disable.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06086800000000000000">
45.6.8 ESMF_AlarmEnable - Enable an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmEnable(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Enables an <TT>ESMF_Alarm</TT> to function.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to enable.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06086900000000000000">
45.6.9 ESMF_AlarmGet - Get Alarm properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmGet(alarm, &amp;
         clock, ringTime, prevRingTime, ringInterval, stopTime, ringDuration, &amp;
         ringTimeStepCount, timeStepRingingCount, ringBegin, ringEnd, &amp;
         refTime, ringing, ringingOnPrevTimeStep, enabled, sticky, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Clock),        intent(out), optional :: clock
       type(ESMF_Time),         intent(out), optional :: ringTime
       type(ESMF_Time),         intent(out), optional :: prevRingTime
       type(ESMF_TimeInterval), intent(out), optional :: ringInterval
       type(ESMF_Time),         intent(out), optional :: stopTime
       type(ESMF_TimeInterval), intent(out), optional :: ringDuration
       integer,                 intent(out), optional :: ringTimeStepCount
       integer,                 intent(out), optional :: timeStepRingingCount
       type(ESMF_Time),         intent(out), optional :: ringBegin
       type(ESMF_Time),         intent(out), optional :: ringEnd
       type(ESMF_Time),         intent(out), optional :: refTime
       logical,                 intent(out), optional :: ringing
       logical,                 intent(out), optional :: ringingOnPrevTimeStep
       logical,                 intent(out), optional :: enabled
       logical,                 intent(out), optional :: sticky
       character (len=*),       intent(out), optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets one or more of an <TT>ESMF_Alarm</TT>'s properties.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>The associated clock.
       
</DD>
<DT><STRONG>[ringTime]</STRONG></DT>
<DD>The ring time for a one-shot alarm or the next repeating alarm.
       
</DD>
<DT><STRONG>[prevRingTime]</STRONG></DT>
<DD>The previous ring time.
       
</DD>
<DT><STRONG>[ringInterval]</STRONG></DT>
<DD>The ring interval for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>The ring duration.  Mutually exclusive with
            ringTimeStepCount (see below).
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>The number of time steps comprising the ring duration.  Mutually
            exclusive with ringDuration (see above).
       
</DD>
<DT><STRONG>[timeStepRingingCount]</STRONG></DT>
<DD>The number of time steps for which the alarm has been ringing thus
            far.  Used internally for tracking ringTimeStepCount ring
            durations (see above).  Mutually exclusive with ringBegin
            (see below).  Increments in <TT>ESMF_DIRECTION_FORWARD</TT> and
            decrements in <TT>ESMF_DIRECTION_REVERSE</TT>;
            see Section&nbsp;<A HREF="#sec:Clock">44.1</A>.
       
</DD>
<DT><STRONG>[ringBegin]</STRONG></DT>
<DD>The time when the alarm began ringing.  Used internally for tracking
            ringDuration (see above).  Mutually exclusive with
            timeStepRingingCount (see above).
       
</DD>
<DT><STRONG>[ringEnd]</STRONG></DT>
<DD>The time when the alarm ended ringing.  Used internally for
            re-ringing alarm in <TT>ESMF_DIRECTION_REVERSE</TT>.

</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The reference (i.e. base) time for an interval alarm.
       
</DD>
<DT><STRONG>[ringing]</STRONG></DT>
<DD>The current ringing state.
            See also <TT>ESMF_AlarmRingerOn()</TT>, <TT>ESMF_AlarmRingerOff()</TT>.
       
</DD>
<DT><STRONG>[ringingOnPrevTimeStep]</STRONG></DT>
<DD>The ringing state upon the previous time step. Same as
            <TT>ESMF_AlarmWasPrevRinging()</TT>.

</DD>
<DT><STRONG>[enabled]</STRONG></DT>
<DD>The enabled state.
            See also <TT>ESMF_AlarmEnable()</TT>, <TT>ESMF_AlarmDisable()</TT>.
       
</DD>
<DT><STRONG>[sticky]</STRONG></DT>
<DD>The sticky state.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of this alarm.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861000000000000000">
45.6.10 ESMF_AlarmIsCreated - Check whether a Alarm object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_AlarmIsCreated(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_AlarmIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>alarm</TT> has been created. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD><TT>ESMF_Alarm</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861100000000000000">
45.6.11 ESMF_AlarmIsEnabled - Check if Alarm is enabled</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_AlarmIsEnabled(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmIsEnabled
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> is enabled.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to check for enabled state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861200000000000000">
45.6.12 ESMF_AlarmIsRinging - Check if Alarm is ringing</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_AlarmIsRinging(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmIsRinging
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> is ringing.

<P>
See also method
             <TT>ESMF_ClockGetAlarmList(clock, ESMF_ALARMLIST_RINGING, ...)</TT>
       to get a list of all ringing alarms belonging to an <TT>ESMF_Clock</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The alarm to check for ringing state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861300000000000000">
45.6.13 ESMF_AlarmIsSticky - Check if Alarm is sticky</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_AlarmIsSticky(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmIsSticky
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>alarm</TT> is sticky.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to check for sticky state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861400000000000000">
45.6.14 ESMF_AlarmNotSticky - Unset an Alarm's sticky flag</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmNotSticky(alarm, &amp;
         ringDuration, ringTimeStepCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: ringDuration
       integer,                 intent(in),  optional :: ringTimeStepCount
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Unset an <TT>ESMF_Alarm</TT>'s sticky flag; once alarm is ringing,
       it turns itself off after ringDuration.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to unset sticky.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>If not sticky, alarms rings for ringDuration, then turns itself off.
            Mutually exclusive with ringTimeStepCount (see below and full
            description in method <TT>ESMF_AlarmCreate()</TT> or
            <TT>ESMF_AlarmSet()</TT>).
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>If not sticky, alarms rings for ringTimeStepCount, then turns
            itself off.  Mutually exclusive with ringDuration (see above and
            full description in method <TT>ESMF_AlarmCreate()</TT> or
            <TT>ESMF_AlarmSet()</TT>).

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861500000000000000">
45.6.15 ESMF_AlarmPrint - Print Alarm information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmPrint(alarm, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),  intent(in)            :: alarm
       character (len=*), intent(in),  optional :: options
       integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints out an <TT>ESMF_Alarm</TT>'s properties to <TT>stdout</TT>, in support
       of testing and debugging.  The options control the type of information
       and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD><TT>ESMF_Alarm</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all <TT>alarm</TT> property values.
<BR>            "clock"        - print the associated clock's name. 
<BR>            "enabled"      - print the alarm's ability to ring. 
<BR>            "name"         - print the alarm's name. 
<BR>            "prevRingTime" - print the alarm's previous ring time. 
<BR>            "ringBegin"    - print time when the alarm actually begins to ring.
<BR>            "ringDuration" - print how long this alarm is to remain ringing. 
<BR>            "ringEnd"      - print time when the alarm actually ends ringing.
<BR>            "ringing"                - print the alarm's current ringing state.
<BR>            "ringingOnPrevTimeStep"  - print whether the alarm was ringing
                                       immediately after the previous clock
                                       time step. 
<BR>            "ringInterval" - print the alarm's periodic ring interval. 
<BR>            "ringTime"     - print the alarm's next time to ring. 
<BR>            "ringTimeStepCount" - print how long this alarm is to remain
                                  ringing, in terms of a number of clock time
                                  steps. 
<BR>            "refTime"      - print the alarm's interval reference (base) time. 
<BR>            "sticky"       - print whether the alarm must be turned off
                             manually. 
<BR>            "stopTime"     - print when alarm intervals end. 
<BR>            "timeStepRingingCount"   - print the number of time steps the
                                       alarm has been ringing thus far. 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861600000000000000">
45.6.16 ESMF_AlarmRingerOff - Turn off an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmRingerOff(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Turn off an <TT>ESMF_Alarm</TT>; unsets ringing state.  For a sticky
       alarm, this method must be called to turn off its ringing state.
       This is true for either <TT>ESMF_DIRECTION_FORWARD</TT> (default) or
       <TT>ESMF_DIRECTION_REVERSE</TT>.  See Section&nbsp;<A HREF="#sec:Clock">44.1</A>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to turn off.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861700000000000000">
45.6.17 ESMF_AlarmRingerOn - Turn on an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmRingerOn(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Turn on an <TT>ESMF_Alarm</TT>; sets ringing state.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to turn on.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861800000000000000">
45.6.18 ESMF_AlarmSet - Set Alarm properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmSet(alarm, &amp;
         clock, ringTime, ringInterval, stopTime, ringDuration, &amp;
         ringTimeStepCount, refTime, ringing, enabled, sticky, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Clock),        intent(in),  optional :: clock
       type(ESMF_Time),         intent(in),  optional :: ringTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringInterval
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringDuration
       integer,                 intent(in),  optional :: ringTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       logical,                 intent(in),  optional :: ringing
       logical,                 intent(in),  optional :: enabled
       logical,                 intent(in),  optional :: sticky
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets/resets one or more of the properties of an <TT>ESMF_Alarm</TT> that
       was previously initialized via <TT>ESMF_AlarmCreate()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to set.
       
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Re-associates this alarm with a different clock.
       
</DD>
<DT><STRONG>[ringTime]</STRONG></DT>
<DD>The next ring time for a one-shot alarm or a repeating (interval)
            alarm.
       
</DD>
<DT><STRONG>[ringInterval]</STRONG></DT>
<DD>The ring interval for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>The absolute ring duration.  If not sticky (see argument below),
            alarms rings for ringDuration, then turns itself off.  Default is
            zero (unused).  Mutually exclusive with ringTimeStepCount (below);
            used only if set to a non-zero duration and ringTimeStepCount is 1
            (see below).
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>The relative ring duration.  If not sticky (see argument below),
            alarms rings for ringTimeStepCount, then turns itself off.
            Default is 1: a non-sticky alarm will ring for one clock time step.
            Mutually exclusive with ringDuration (above); used if
            ringTimeStepCount &gt; 1.  If ringTimeStepCount is 1 (default) and
            ringDuration is non-zero, ringDuration is used (see above), otherwise
            ringTimeStepCount is used.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The reference (i.e. base) time for an interval alarm.
       
</DD>
<DT><STRONG>[ringing]</STRONG></DT>
<DD>Sets the ringing state.
            See also <TT>ESMF_AlarmRingerOn()</TT>, <TT>ESMF_AlarmRingerOff()</TT>.
       
</DD>
<DT><STRONG>[enabled]</STRONG></DT>
<DD>Sets the enabled state.  If disabled, an alarm will not function
            at all.
            See also <TT>ESMF_AlarmEnable()</TT>, <TT>ESMF_AlarmDisable()</TT>.
       
</DD>
<DT><STRONG>[sticky]</STRONG></DT>
<DD>Sets the sticky state.  If sticky, once an alarm is ringing, it
            will remain ringing until turned off manually via a user call to
            <TT>ESMF_AlarmRingerOff()</TT>.  If not sticky, an alarm will turn
            itself off after a certain ring duration specified by either
            ringDuration or ringTimeStepCount (see above).
            There is an implicit limitation that in order to properly reverse
            timestep through a ring end time in <TT>ESMF_DIRECTION_REVERSE</TT>,
            that time must have already been traversed in the forward direction.
            This is due to the fact that the Time Manager cannot predict when
            user code will call <TT>ESMF_AlarmRingerOff()</TT>.  An error message
            will be logged when this limitation is not satisfied.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this alarm.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861900000000000000">
45.6.19 ESMF_AlarmSticky - Set an Alarm's sticky flag</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmSticky(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Set an <TT>ESMF_Alarm</TT>'s sticky flag; once alarm is ringing,
       it remains ringing until <TT>ESMF_AlarmRingerOff()</TT> is called.
       There is an implicit limitation that in order to properly reverse
       timestep through a ring end time in <TT>ESMF_DIRECTION_REVERSE</TT>, that
       time must have already been traversed in the forward direction.
       This is due to the fact that an <TT>ESMF_Alarm</TT> cannot predict when
       user code will call <TT>ESMF_AlarmRingerOff()</TT>.  An error message
       will be logged when this limitation is not satisfied.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to be set sticky.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060862000000000000000">
45.6.20 ESMF_AlarmValidate - Validate an Alarm's properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmValidate(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),  intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Performs a validation check on an <TT>ESMF_Alarm</TT>'s properties.
       Must have a valid ringTime, set either directly or indirectly via
       ringInterval.  See <TT>ESMF_AlarmCreate()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD><TT>ESMF_Alarm</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060862100000000000000">
45.6.21 ESMF_AlarmWasPrevRinging - Check if Alarm was ringing on the previous Clock timestep</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_AlarmWasPrevRinging(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmWasPrevRinging
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> was ringing on the previous clock timestep.

<P>
See also method
         <TT>ESMF_ClockGetAlarmList(clock, ESMF_ALARMLIST_PREVRINGING, ...)</TT>
       get a list of all alarms belonging to a <TT>ESMF_Clock</TT> that were
       ringing on the previous time step.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to check for previous ringing state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060862200000000000000">
45.6.22 ESMF_AlarmWillRingNext - Check if Alarm will ring upon the next Clock timestep</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_AlarmWillRingNext(alarm, timeStep, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmWillRingNext
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> will ring on the next clock timestep, either
       the current clock timestep or a passed-in timestep.

<P>
See also method
         <TT>ESMF_ClockGetAlarmList(clock, ESMF_ALARMLIST_NEXTRINGING, ...)</TT>
       to get a list of all alarms belonging to a <TT>ESMF_Clock</TT> that will
       ring on the next time step.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The alarm to check for next ringing state.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>Optional timestep to use instead of the clock's.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>


<H1><A NAME="SECTION06090000000000000000">
46 Config Class</A>
</H1>

<H2><A NAME="SECTION06091000000000000000">
46.1 Description</A>
</H2>

<P>
<A NAME="sec:Config"></A>
<P>
ESMF Configuration Management is based on NASA DAO's 
Inpak 90 package, a Fortran 90 collection of routines/functions
for accessing <EM>Resource Files</EM> in ASCII format.The package 
is optimized for minimizing formatted I/O, performing all of its 
string operations in memory using Fortran intrinsic functions.
<BR>
<P>

<H3><A NAME="SECTION06091100000000000000">
46.1.1 Package history</A>
</H3>

<P>
The ESMF Configuration Management Package was evolved by
Leonid Zaslavsky and Arlindo da Silva from Ipack90 package
created by Arlindo da Silva at NASA DAO.

<P>
Back in the 70's Eli Isaacson wrote IOPACK in Fortran
66.  In June of 1987 Arlindo da Silva wrote Inpak77 using
Fortran 77 string functions; Inpak 77 is a vastly
simplified IOPACK, but has its own goodies not found in
IOPACK.  Inpak 90 removes some obsolete functionality in
Inpak77, and parses the whole resource file in memory for
performance.

<P>

<H3><A NAME="SECTION06091200000000000000">
46.1.2 Resource files</A>
</H3>

<P>
A <EM>Resource File (RF)</EM> is a text file consisting of list of 
   <EM>label</EM>-<EM>value</EM> pairs. There is a limit of 250 characters 
   per line and the Resource File can contain a maximum of 200 records. 
   Each <EM>label</EM> should be followed by some data, the <EM>value</EM>. 
   An example Resource File follows.  It is the file used in the example 
   below. 

<P>
<PRE>
 # This is an example Resource File.  
 # It contains a list of &lt;label,value&gt; pairs.
 # The colon after the label is required. 

 # The values after the label can be an list.
 # Multiple types are authorized.
  
  my_file_names:         jan87.dat jan88.dat jan89.dat  # all strings
  constants:             3.1415   25                    # float and integer
  my_favorite_colors:    green blue 022               


 # Or, the data can be a list of single value pairs. 
 # It is simplier to retrieve data in this format:

  radius_of_the_earth:   6.37E6         
  parameter_1:           89
  parameter_2:           78.2
  input_file_name:       dummy_input.netcdf 


 # Or, the data can be located in a table using the following
 # syntax:

  my_table_name::
   1000     3000     263.0
    925     3000     263.0
    850     3000     263.0
    700     3000     269.0
    500     3000     287.0
    400     3000     295.8
    300     3000     295.8
  ::
</PRE>

<P>
Note that the colon after the label is required and that the double colon is required
 to declare tabular data. 

<P>
Resource files are intended for random access (except between ::'s in a 
 table definition). This means that order in which a particular 
 <EM>label-value</EM> pair is retrieved is not dependent upon the original order 
 of the pairs. The only exception to this, however, is when the same <EM>label</EM> appears 
 multiple times within the Resource File.

<P>

<H2><A NAME="SECTION06092000000000000000">
46.2 Use and Examples</A>
</H2>

<P>

<P>

<P>
This example/test code performs simple Config/Resource File routines. It does not
   include attaching a Config to a component. The important thing to remember there
   is that you can have one Config per component. 

<P>
There are two methodologies for accessing data in a Resource File.  This example will
   demonstrate both.

<P>
Note the API section contains a complete description of arguments in
   the methods/functions demonstrated in this example. 

<P>

<H3><A NAME="SECTION06092100000000000000">
46.2.1 Variable declarations</A>
</H3>

<P>
The following are the variable declarations used as arguments in the following code 
   fragments. They represent the locals names for the variables listed in the Resource 
   File (RF).  Note they do not need to be the same. 

<P>
<PRE>
      character(ESMF_MAXPATHLEN) :: fname ! config file name
      character(ESMF_MAXPATHLEN) :: fn1, fn2, fn3, input_file ! strings to be read in
      integer       :: rc            ! error return code (0 is OK)
      integer       :: i_n           ! the first constant in the RF
      real          :: param_1       ! the second constant in the RF
      real          :: radius        ! radius of the earth
      real          :: table(7,3)    ! an array to hold the table in the RF

      type(ESMF_Config)   :: cf      ! the Config itself
</PRE>

<P>

<H3><A NAME="SECTION06092200000000000000">
46.2.2 Creation of a Config</A>
</H3>

<P>
While there are two methodologies for accessing the data within a Resource File, 
   there is only one way to create the initial Config and load its ASCII text into 
   memory. This is the first step in the process.

<P>
Note that subsequent calls to <TT>ESMF_ConfigLoadFile</TT> will OVERWRITE the current
   Config NOT append to it. There is no means of appending to a Config. 

<P>
<PRE>
      cf = ESMF_ConfigCreate(rc=rc)             ! Create the empty Config
</PRE>

<P>
<PRE>
      fname = "myResourceFile.rc"                ! Name the Resource File
      call ESMF_ConfigLoadFile(cf, fname, rc=rc) ! Load the Resource File 
                                                 ! into the empty Config
</PRE>

<P>

<H3><A NAME="SECTION06092300000000000000">
46.2.3 How to retrieve a label with a single value</A>
</H3>
   The first method for retrieving information from the 
   Resource File takes advantage of the &lt;label,value&gt; relationship
   within the file and access the data in a dictionary-like manner. This is the
   simplest methodology, but it does imply the use of only one value per label
   in the Resource File.  

<P>
Remember,
   that the order in which a particular label/value pair is retrieved
   is not dependent upon the order which they exist within the Resource File.  

<P>
<PRE>
    call ESMF_ConfigGetAttribute(cf, radius, label='radius_of_the_earth:', &amp;
                                 default=1.0, rc=rc)
</PRE>

<P>
Note that the colon must be included in the label string when using this
   methodology.  It is also important to provide a default value in case the label
   does not exist in the file 

<P>
This methodology works for all types. The following is an example of retrieving a 
   string: 

<P>
<PRE>
    call ESMF_ConfigGetAttribute(cf, input_file, label='input_file_name:', &amp;
                                 default="./default.nc", rc=rc)
</PRE>

<P>
The same code fragment can be used to demonstrate what happens when the label is not 
   present.  Note that "file_name" does not exist in the Resource File. The result of 
   its absence is the default value provided in the call. 

<P>
<PRE>
    call ESMF_ConfigGetAttribute(cf, input_file, label='file_name:', &amp;
                                 default="./default.nc", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06092400000000000000">
46.2.4 How to retrieve a label with multiple values</A>
</H3>
   When there are multiple, mixed-typed values associated with a label, the 
   values can be retrieved in two steps:  1) Use ESMF_ConfigFindLabel() 
   to find the label in the Config class; 2) use
   ESMF_ConfigGetAttribute() without the optional 'label' argument to 
   retrieve the values one at a time, reading from left to right in
   the record. 

<P>
A second reminder that the order in which a particular label/value pair is 
   retrieved is not dependent upon the order which they exist within the 
   Resource File. The label used in this method allows the user to skip to
   any point in the file.  

<P>
<PRE>
      call ESMF_ConfigFindLabel(cf, 'constants:', rc=rc) ! Step a) Find the 
                                                         ! label
</PRE>

<P>
Two constants, radius and i_n, can now be retrieved without having to specify their
   label or use an array. They are also different types. 

<P>
<PRE>
      call ESMF_ConfigGetAttribute(cf, param_1, rc=rc) ! Step b) read in the 
                                                       ! first constant in 
                                                       ! the sequence
      call ESMF_ConfigGetAttribute(cf, i_n, rc=rc)     ! Step c) read in the 
                                                       ! second constant in 
                                                       ! the sequence
</PRE>

<P>
This methodology also works with strings. 

<P>
<PRE>
       call ESMF_ConfigFindLabel(cf, 'my_file_names:', &amp;
               rc=rc)                       ! Step a) find the label
</PRE>

<P>
<PRE>
       call ESMF_ConfigGetAttribute(cf, fn1, &amp;
                 rc=rc)                    ! Step b) retrieve the 1st filename
       call ESMF_ConfigGetAttribute(cf, fn2, &amp;
                 rc=rc)                    ! Step c) retrieve the 2nd filename
       call ESMF_ConfigGetAttribute(cf, fn3, &amp;
                 rc=rc)                    ! Step d) retrieve the 3rd filename
</PRE>

<P>

<H3><A NAME="SECTION06092500000000000000">
46.2.5 How to retrieve a table</A>
</H3>

<P>
To access tabular data, the user must use the multi-value method.  

<P>
<PRE>
      call ESMF_ConfigFindLabel(cf, 'my_table_name::', &amp;
               rc=rc)        ! Step a) Set the label location to the 
                             ! beginning of the table
</PRE>

<P>
Subsequently, <TT>call ESMF_ConfigNextLine()</TT> is used to move the location 
   to the next row of the table. The example table in the Resource File contains
   7 rows and 3 columns (7,3). 

<P>
<PRE>
      do i = 1, 7
        call ESMF_ConfigNextLine(cf, rc=rc) ! Step b) Increment the rows
        do j = 1, 3                         ! Step c) Fill in the table 
          call ESMF_ConfigGetAttribute(cf, table(i,j), rc=rc)
        enddo
      enddo
</PRE>

<P>

<H3><A NAME="SECTION06092600000000000000">
46.2.6 Destruction of a Config</A>
</H3>

<P>
The work with the configuration file <TT>cf</TT> is finalized by call to
   <TT>ESMF_ConfigDestroy()</TT>: 

<P>
<PRE>
      call ESMF_ConfigDestroy(cf, rc=rc) ! Destroy the Config
</PRE>

<P>


<H2><A NAME="SECTION06093000000000000000">
46.3 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06093100000000000000">
46.3.1 ESMF_ConfigAssignment(=) - Config assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     config1 = config2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Config) :: config1
     type(ESMF_Config) :: config2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Assign <TT>config1</TT> as an alias to the same <TT>ESMF_Config</TT> object in memory
     as <TT>config2</TT>. If <TT>config2</TT> is invalid, then <TT>config1</TT> will be
     equally invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>config1</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>config2</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093200000000000000">
46.3.2 ESMF_ConfigOperator(==) - Test if Config objects are equivalent</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (config1 == config2) then ... endif
                    OR
       result = (config1 == config2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       configical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(in) :: config1
       type(ESMF_Config), intent(in) :: config2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Config</TT> class.
       Compare two configs for equality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise. Comparison is based on whether the objects
       are distinct, as with two newly created objects, or are simply aliases
       to the same object as would be the case when assignment was involved.

<P>
The arguments are:
       <DL>
<DT><STRONG>config1</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>config2</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093300000000000000">
46.3.3 ESMF_ConfigOperator(/=) - Test if Config objects are not equivalent</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (config1 /= config2) then ... endif
                    OR
       result = (config1 /= config2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       configical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(in) :: config1
       type(ESMF_Config), intent(in) :: config2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Config</TT> class.
       Compare two configs for equality; return <TT>.true.</TT> if not equivalent,
       <TT>.false.</TT> otherwise. Comparison is based on whether the Config objects
       are distinct, as with two newly created objects, or are simply aliases
       to the same object as would be the case when assignment was involved.

<P>
The arguments are:
       <DL>
<DT><STRONG>config1</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>config2</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093400000000000000">
46.3.4 ESMF_ConfigCreate - Instantiate a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_ConfigCreate()
       type(ESMF_Config) function ESMF_ConfigCreateEmpty(rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,intent(out), optional              :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Instantiates an <TT>ESMF_Config</TT> object for use in subsequent calls.

<P>
The arguments are:
     <DL>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093500000000000000">
46.3.5 ESMF_ConfigCreate - Instantiate a new Config object from a Config section</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_ConfigCreate()
     type(ESMF_Config) function ESMF_ConfigCreateFromSection(config, &amp;
       openlabel, closelabel, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config)             :: config
       character(len=*),  intent(in) :: openlabel, closelabel
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Instantiates an <TT>ESMF_Config</TT> object from a section of an existing
     <TT>ESMF_Config</TT> object delimited by <TT>openlabel</TT> and <TT>closelabel</TT>.
     An error is returned if neither of the input labels is found in input
     <TT>config</TT>.

<P>
Note that a section is intended as the content of a given <TT>ESMF_Config</TT>
     object delimited by two distinct labels. Such content, as well as each of the
     surrounding labels, are still within the scope of the parent <TT>ESMF_Config</TT>
     object. Therefore, including in a section labels used outside that
     section should be done carefully to prevent parsing conflicts.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>The input <TT>ESMF_Config</TT> object.
       
</DD>
<DT><STRONG>openlabel</STRONG></DT>
<DD>Label marking the beginning of a section in <TT>config</TT>.
       
</DD>
<DT><STRONG>closelabel</STRONG></DT>
<DD>Label marking the end of a section in <TT>config</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if a section is found
        and a new <TT>ESMF_Config</TT> object returned.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093600000000000000">
46.3.6 ESMF_ConfigDestroy - Destroy a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigDestroy(config, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroys the <TT>config</TT> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093700000000000000">
46.3.7 ESMF_ConfigFindLabel - Find a label in a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigFindLabel(config, label, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)           :: config 
       character(len=*),  intent(in)              :: label
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,           intent(out),  optional  :: isPresent
       integer,           intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added the <TT>isPresent</TT> argument.  Allows detection of
    end-of-line condition to be separate from the <TT>rc</TT>.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Finds the <TT>label</TT> (key) string in the <TT>config</TT> object 
     starting from the beginning of its content.

<P>
Since the search is done by looking for a string, possibly multi-worded,
     in the whole <TT>Config</TT> object, it is important to use special 
     conventions to distinguish <TT>labels</TT> from other words. This is done 
     in the Resource File by using the NASA/DAO convention to finish
     line labels with a colon (:) and table labels with a double colon (::).

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Identifying label. 
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the item is found.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       If the label is not found, and the <TT>isPresent</TT> argument is
       not present, an error is returned.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093800000000000000">
46.3.8 ESMF_ConfigFindNextLabel - Find a label in Config object starting from current position</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigFindNextLabel(config, label, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)           :: config
       character(len=*),  intent(in)              :: label
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,           intent(out),  optional  :: isPresent
       integer,           intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Finds the <TT>label</TT> (key) string in the <TT>config</TT> object, 
     starting from the current position pointer.

<P>
This method is equivalent to <TT>ESMF_ConfigFindLabel</TT>, but the search
     is performed starting from the current position pointer.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Identifying label.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the item is found.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       If the label is not found, and the <TT>isPresent</TT> argument is
       not present, an error is returned.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093900000000000000">
46.3.9 ESMF_ConfigGetAttribute - Get an attribute value from Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>        subroutine ESMF_ConfigGetAttribute(config, &lt;value&gt;, &amp;
          label, default, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Config), intent(inout)         :: config     
        &lt;value argument&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        character(len=*),  intent(in),  optional :: label 
        character(len=*),  intent(in),  optional :: default 
        integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets a value from the <TT>config</TT> object.  When the
        value is a sequence of characters
        it will be terminated by the first white space.

<P>
Supported values for &lt;value argument&gt; are:
        <DL>
<DT></DT>
<DD>character(len=*), intent(out)          :: value
        
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), intent(out)      :: value    
        
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), intent(out)      :: value
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out)   :: value
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(out)   :: value
        
</DD>
<DT></DT>
<DD>logical, intent(out)                   :: value
        
</DD>
</DL>

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>Returned value.
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifing label. 
     
</DD>
<DT><STRONG>[default]</STRONG></DT>
<DD>Default value if <TT>label</TT> is not found in <TT>config</TT> object. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060931000000000000000">
46.3.10 ESMF_ConfigGetAttribute - Get a list of attribute values from Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>        subroutine ESMF_ConfigGetAttribute(config, &lt;value list argument&gt;, &amp;
          count, label, default, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Config), intent(inout)         :: config     
        &lt;value list argument&gt;, see below for values      
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,           intent(in)   optional :: count
        character(len=*),  intent(in),  optional :: label 
        character(len=*),  intent(in),  optional :: default 
        integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets a list of values from the <TT>config</TT> object.  

<P>
Supported values for &lt;value list argument&gt; are:
        <DL>
<DT></DT>
<DD>character(len=*), intent(out)            :: valueList(:)
        
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), intent(inout)      :: valueList(:)
        
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), intent(inout)      :: valueList(:)
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(inout)   :: valueList(:)
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(inout)   :: valueList(:)
        
</DD>
<DT></DT>
<DD>logical, intent(inout)                   :: valueList(:)
        
</DD>
</DL>

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>&lt;value list argument&gt;</STRONG></DT>
<DD>Returned value.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of returned values expected.  
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifing label. 
     
</DD>
<DT><STRONG>[default]</STRONG></DT>
<DD>Default value if <TT>label</TT> is not found in <TT>config</TT> object. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060931100000000000000">
46.3.11 ESMF_ConfigGetChar - Get a character attribute value from Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ConfigGetChar(config, value, &amp;
         label, default, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)         :: config 
       character,         intent(out)           :: value
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),  optional :: label   
       character,         intent(in),  optional :: default
       integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets a character <TT>value</TT> from the <TT>config</TT> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>Returned value. 
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying label. 
     
</DD>
<DT><STRONG>[default]</STRONG></DT>
<DD>Default value if label is not found in configuration object. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931200000000000000">
46.3.12 ESMF_ConfigGetDim - Get table sizes from Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigGetDim(config, lineCount, columnCount, &amp;
       label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)         :: config
       integer,           intent(out)           :: lineCount
       integer,           intent(out)           :: columnCount
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),  optional :: label
       integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the number of lines in the table in <TT>lineCount</TT> and 
    the maximum number of words in a table line in <TT>columnCount</TT>.

<P>
After the call, the line pointer is positioned to the end of the table.
    To reset it to the beginning of the table, use <TT>ESMF_ConfigFindLabel</TT>. 

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>lineCount</STRONG></DT>
<DD>Returned number of lines in the table. 
     
</DD>
<DT><STRONG>columnCount</STRONG></DT>
<DD>Returned maximum number of words in a table line. 
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying label (if present), otherwise current line.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931300000000000000">
46.3.13 ESMF_ConfigGetLen - Get the length of the line in words from Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     integer function ESMF_ConfigGetLen(config, label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),   optional :: label
       integer,           intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the length of the line in words by counting words
   disregarding types.  Returns the word count as an integer.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying label.   If not specified, use the current line.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931400000000000000">
46.3.14 ESMF_ConfigIsCreated - Check whether a Config object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_ConfigIsCreated(config, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_ConfigIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Config), intent(in)            :: config
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>config</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD><TT>ESMF_Config</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931500000000000000">
46.3.15 ESMF_ConfigLoadFile - Load resource file into Config object memory</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigLoadFile(config, filename, &amp;
       delayout, unique, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config),   intent(inout)         :: config     
       character(len=*),    intent(in)            :: filename 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_DELayout), intent(in),  optional :: delayout 
       logical,             intent(in),  optional :: unique 
       integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Resource file with <TT>filename</TT> is loaded into memory.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Configuration file name.
     
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD><TT>ESMF_DELayout</TT> associated with this <TT>config</TT> object.
     
</DD>
<DT><STRONG>[unique]</STRONG></DT>
<DD>If specified as true, uniqueness of labels are checked and 
       error code set if duplicates found.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931600000000000000">
46.3.16 ESMF_ConfigNextLine - Find next line in a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigNextLine(config, tableEnd, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,           intent(out),  optional :: tableEnd
       integer,           intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Selects the next line (for tables).

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>[tableEnd]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if end of table mark (::) is encountered.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931700000000000000">
46.3.17 ESMF_ConfigPrint - Write content of Config object to unit</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigPrint(config, unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(in)  :: config
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, optional, intent(in)  :: unit
       integer, optional, intent(out) :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write content of input <TT>ESMF_Config</TT> object to unit <TT>unit</TT>.
     If <TT>unit</TT> not provided, writes to standard output.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>The input <TT>ESMF_Config</TT> object.
       
</DD>
<DT><STRONG>[unit]</STRONG></DT>
<DD>Output unit.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931800000000000000">
46.3.18 ESMF_ConfigSetAttribute - Set a value in Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ConfigSetAttribute(config, &lt;value argument&gt;, &amp;
         label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)           :: config     
       &lt;value argument&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),   optional  :: label 
       integer,           intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets a value in the <TT>config</TT> object.

<P>
Supported values for &lt;value argument&gt; are:
        <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in)            :: value
        
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>Value to set. 
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying attribute label. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931900000000000000">
46.3.19 ESMF_ConfigValidate - Validate a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigValidate(config, &amp;
       options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*), intent(in),   optional :: options
       integer,           intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>config</TT> object is valid.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD><TT>ESMF_Config</TT> object to be validated.
     
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>If none specified:  simply check that the buffer is not full and the
         pointers are within range.
       "unusedAttributes" - Report to the default logfile all attributes not
         retrieved via a call to <TT>ESMF_ConfigGetAttribute()</TT> or
         <TT>ESMF_ConfigGetChar()</TT>.  The attribute name (label) will be
         logged via <TT>ESMF_LogErr</TT> with the WARNING log message type.
         For an array-valued attribute, retrieving at least one value via
         <TT>ESMF_ConfigGetAttribute()</TT> or <TT>ESMF_ConfigGetChar()</TT>
         constitutes being "used."

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       Equals <TT>ESMF_RC_ATTR_UNUSED</TT> if any unused attributes are found
       with option "unusedAttributes" above.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION060100000000000000000"></A>
<A NAME="log_class"></A>
<BR>
47 Log Class
</H1>

<H2><A NAME="SECTION060101000000000000000">
47.1 Description</A>
</H2>

<P>
<A NAME="sec:Log"></A>
<P>
The Log class consists of a variety of methods for writing error, warning, and
informational messages to files.  A default Log is created at ESMF
initialization.  Other Logs can be created later in the code by the user.  Most
Log methods take a Log as an optional argument and apply to the default Log
when another Log is not specified.  A set of standard return codes and
associated messages are provided for error handling.  

<P>
Log provides capabilities to store message entries in a buffer, which is 
flushed to a file, either when the buffer is full, or when the user calls an 
<TT>ESMF_LogFlush()</TT> method.  Currently, the default is for the Log to flush
after every ten entries.  This can easily be changed by using the 
<TT>ESMF_LogSet()</TT> method and setting the <TT>maxElements</TT> property to 
another value.  The <TT>ESMF_LogFlush()</TT> method is automatically called when 
the program exits by any means (program completion, halt on error, or when the
Log is closed).

<P>
The user has the capability to abort the program on conditions such as
an error or on a warning by using the <TT>ESMF_LogSet()</TT> method with
the <TT>logmsgAbort</TT> argument.  For example if the  <TT>logmsgAbort</TT> array
is set to <TT>(ESMF_LOGMSG_ERROR,ESMF_LOGMSG_WARNING)</TT>, the program will 
stop on any and all warning or errors.  When the <TT>logmsgAbort</TT> argument
is set to  <TT>ESMF_LOGMSG_ERROR</TT>, the program will only abort on
errors.  Lastly, the user can choose to never abort by using
<TT>ESMF_LOGMSG_NONE</TT>; this is the default.

<P>
Log will automatically put the PET number into the Log.  Also, the user can 
either specify <TT>ESMF_LOGKIND_SINGLE</TT> which writes all the entries to a single 
Log or <TT>ESMF_LOGKIND_MULTI</TT> which writes entries to multiple Logs according to 
the PET number.  To distinguish Logs from each other when using 
<TT>ESMF_LOGKIND_MULTI</TT>, the PET number (in the format <TT>PETx.</TT>) will be 
prepended to the file name where x is the PET number.

<P>
Opening multiple log files and writing log messages from all the processors
may affect the application performance while running on a large number of
processors.  For that reason, <TT>ESMF_LOGKIND_NONE</TT> is provided to
switch off the Log capability.  All the Log methods have no effect
in the <TT>ESMF_LOGKIND_NONE</TT> mode.

<P>
A tracing capability may be enabled by setting the <TT>trace</TT> flag by
using the <TT>ESMF_LogSet()</TT> method.  When tracing is enabled, calls to
methods such as <TT>ESMF_LogFoundError</TT>, <TT>ESMF_LogFoundAllocError</TT>,
and <TT>ESMF_LogFoundDeallocError</TT> are logged in the default log file.
This can result in voluminous output.  It is typically used only around areas
of code which are being debugged.

<P>
Other options that are planned for Log are to adjust the verbosity of output, and to optionally write to <TT>stdout</TT> instead of file(s).

<P>

<H2><A NAME="SECTION060102000000000000000">
47.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION060102100000000000000"></A>
<A NAME="const:logerr"></A>
<BR>
47.2.1 ESMF_LOGERR
</H3>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGERR_PASSTHRU</STRONG></DT>
<DD>A named character constant, with a predefined generic error message, 
		that can be used for the <TT>msg</TT> argument in any <TT>ESMF_Log</TT> 
		routine.  The message indicated 
		by this named constant is ``<I>Passing error in return code</I>."
</DD>
</DL>

<P>

<H3><A NAME="SECTION060102200000000000000"></A>
<A NAME="const:logkindflag"></A>
<BR>
47.2.2 ESMF_LOGKIND
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Specifies a single log file, multiple log files (one per PET), or no log files.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_LogKind_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGKIND_SINGLE</STRONG></DT>
<DD>Use a single log file, combining messages from all of the PETs.  Not supported on some platforms.
   
</DD>
<DT><STRONG>ESMF_LOGKIND_MULTI</STRONG></DT>
<DD>Use multiple log files -- one per PET.
   
</DD>
<DT><STRONG>ESMF_LOGKIND_MULTI_ON_ERROR</STRONG></DT>
<DD>Use multiple log files -- one per PET.  A log file is only opened when a message
         of type <TT>ESMF_LOGMSG_ERROR</TT> is encountered.
   
</DD>
<DT><STRONG>ESMF_LOGKIND_NONE</STRONG></DT>
<DD>Do not issue messages to a log file.
</DD>
</DL>

<P>

<H3><A NAME="SECTION060102300000000000000"></A>
<A NAME="const:logmsgflag"></A>
<BR>
47.2.3 ESMF_LOGMSG
</H3>

<P>
<I>DESCRIPTION:
<BR></I>

Specifies a message level

<P>
The type of this flag is:

<P>
<TT>type(ESMF_LogMsg_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGMSG_INFO</STRONG></DT>
<DD>Informational messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_WARNING</STRONG></DT>
<DD>Warning messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_ERROR</STRONG></DT>
<DD>Error messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_TRACE</STRONG></DT>
<DD>Trace messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_JSON</STRONG></DT>
<DD>JSON format messages
</DD>
</DL>

<P>
Valid predefined named array constant values are:

<P>
<DL>
<DT><STRONG>ESMF_LOGMSG_ALL</STRONG></DT>
<DD>All messages
	
</DD>
<DT><STRONG>ESMF_LOGMSG_NONE</STRONG></DT>
<DD>No messages
	
</DD>
<DT><STRONG>ESMF_LOGMSG_NOTRACE</STRONG></DT>
<DD>All messages EXCEPT trace messages
</DD>
</DL>

<P>

<H2><A NAME="SECTION060103000000000000000">
47.3 Use and Examples</A>
</H2>

<P>
By default <TT>ESMF_Initialize()</TT> opens a default Log in 
<TT>ESMF_LOGKIND_MULTI</TT> mode. ESMF handles the initialization and finalization
of the default Log so the user can immediately start using it. If additional Log
objects are desired, they must be explicitly created or opened using
<TT>ESMF_LogOpen()</TT>.

<P>
<TT>ESMF_LogOpen()</TT> requires a Log object and filename argument. Additionally,
the user can specify single or multi Logs by setting the <TT>logkindflag</TT> property
to <TT>ESMF_LOGKIND_SINGLE</TT> or <TT>ESMF_LOGKIND_MULTI</TT>.
This is useful as the PET numbers are automatically added to the Log entries.
A single Log will put all entries, regardless of PET number, into a single
log while a multi Log will create multiple Logs with the PET number prepended
to the filename and all entries will be written to their corresponding Log 
by their PET number.

<P>
By default, the Log file is not truncated at the start of a new run; it just
gets appended each time.  Future functionality may include an option to
either truncate or append to the Log file. 

<P>
In all cases where a Log is opened, a Fortran unit number is assigned to a specific
Log.  A Log is assigned an unused unit number using the algorithm described in
the <TT>ESMF_IOUnitGet()</TT> method.

<P>
The user can then set or get options on how the Log should be used 
with the <TT>ESMF_LogSet()</TT> and <TT>ESMF_LogGet()</TT> methods.  These are 
partially implemented at this time. 

<P>
Depending on how the options are set, <TT>ESMF_LogWrite()</TT> either writes user
messages directly to a Log file or writes to a buffer that can be flushed when 
full or by using the <TT>ESMF_LogFlush()</TT> method.  The default is to flush 
after every ten entries because <TT>maxElements</TT> is initialized to ten 
(which means the buffer reaches its full state after every ten writes and then
flushes).

<P>
A message filtering option may be set with <TT>ESMF_LogSet()</TT> so
that only selected message types are actually written to the log.  One key
use of this feature is to allow placing informational log write requests
into the code for debugging or tracing.  Then, when the informational entries
are not needed, the messages at that level may be turned off -- leaving only
warning and error messages in the logs. 

<P>
For every <TT>ESMF_LogWrite()</TT>, a time and date stamp is prepended to the
Log entry.  The time is given in microsecond precision.  The user can call 
other methods to write to the Log.  In every case, all methods eventually make 
a call implicitly to <TT>ESMF_LogWrite()</TT> even though the user may never 
explicitly call it.

<P>
When calling <TT>ESMF_LogWrite()</TT>, the user can supply an optional line,
file and method.  These arguments can be passed in explicitly or with the help
of cpp macros.  In the latter case, a define for an <TT>ESMF_FILENAME</TT> must 
be placed at the beginning of a file and a define for <TT>ESMF_METHOD</TT> must
be placed at the beginning of each method.  The user can then use the
<TT>ESMF_CONTEXT</TT> cpp macro in place of line, file and method to insert the 
parameters into the method.  The user does not have to specify line number as
it is a value supplied by cpp.

<P>
An example of Log output is given below running with <TT>logkindflag</TT> 
property set to <TT>ESMF_LOGKIND_MULTI</TT> (default) using the default Log:

<P>
(Log file <TT>PET0.ESMF_LogFile</TT>)
<PRE>
20041105 163418.472210 INFO      PET0     Running with ESMF Version 2.2.1
</PRE>

<P>
(Log file <TT>PET1.ESMF_LogFile</TT>)
<PRE>
20041105 163419.186153 ERROR     PET1     ESMF_Field.F90             812  
ESMF_FieldGet No Grid or Bad Grid attached to Field
</PRE>

<P>
The first entry shows date and time stamp.  The time is given in microsecond 
precision.  The next item shown is the type of message (INFO in this case).  
Next, the PET number is added.  Lastly, the content is written.

<P>
The second entry shows something slightly different.  In this case, we have
an ERROR.  The method name (ESMF_Field.F90) is automatically provided from 
the cpp macros as well as the line number (812).  Then the content of the 
message is written.

<P>
When done writing messages, the default Log is closed by calling 
<TT>ESMF_LogFinalize()</TT>  or <TT>ESMF_LogClose()</TT> for user created Logs.  
Both methods will release the assigned unit number.

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_LogErrEx - Log Error examples
!
! !DESCRIPTION:
!
! This program shows examples of Log Error writing
!-----------------------------------------------------------------------------
</PRE>

<P>
<PRE>
! Macros for cpp usage
! File define
#define ESMF_FILENAME "ESMF_LogErrEx.F90"
! Method define
#define ESMF_METHOD "program ESMF_LogErrEx"
#include "ESMF_LogMacros.inc"

    ! ESMF Framework module
    use ESMF
    use ESMF_TestMod
    implicit none

    ! return variables
    integer :: rc1, rc2, rc3, rcToTest, allocRcToTest, result
    type(ESMF_LOG) :: alog  ! a log object that is not the default log
    type(ESMF_LogKind_Flag) :: logkindflag
    type(ESMF_Time) :: time
    type(ESMF_VM) :: vm
    integer, pointer :: intptr(:)
</PRE>

<P>

<H3><A NAME="SECTION060103100000000000000">
47.3.1 Default Log</A>
</H3>

<P>
This example shows how to use the default Log.  This example does not use cpp
   macros but does use multi Logs.  A separate Log will be created for each PET. 

<P>
<PRE>
    ! Initialize ESMF to initialize the default Log
    call ESMF_Initialize(vm=vm, defaultlogfilename="LogErrEx.Log", &amp;
                     logkindflag=ESMF_LOGKIND_MULTI, rc=rc1)
</PRE>

<P>
<PRE>
    ! LogWrite
    call ESMF_LogWrite("Log Write 2", ESMF_LOGMSG_INFO, rc=rc2)
</PRE>

<P>
<PRE>
    ! LogMsgSetError
    call ESMF_LogSetError(ESMF_RC_OBJ_BAD, msg="Convergence failure", &amp;
                             rcToReturn=rc2)
</PRE>

<P>
<PRE>
    ! LogMsgFoundError
    call ESMF_TimeSet(time, calkindflag=ESMF_CALKIND_NOCALENDAR)
    call ESMF_TimeSyncToRealTime(time, rc=rcToTest)
    if (ESMF_LogFoundError(rcToTest, msg="getting wall clock time", &amp;
                              rcToReturn=rc2)) then
        ! Error getting time. The previous call will have printed the error
        ! already into the log file.  Add any additional error handling here.
        ! (This call is expected to provoke an error from the Time Manager.)
    endif

    ! LogMsgFoundAllocError
    allocate(intptr(10), stat=allocRcToTest)
    if (ESMF_LogFoundAllocError(allocRcToTest, msg="integer array", &amp;
                                   rcToReturn=rc2)) then
        ! Error during allocation.  The previous call will have logged already
        ! an error message into the log.
    endif
    deallocate(intptr)
</PRE>

<P>

<H3><A NAME="SECTION060103200000000000000">
47.3.2 User created Log</A>
</H3>
   This example shows how to use a user created Log.  This example uses
   cpp macros. 

<P>
<PRE>
    ! Open a Log named "Testlog.txt" associated with alog.
    call ESMF_LogOpen(alog, "TestLog.txt", rc=rc1)
</PRE>

<P>
<PRE>
 
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    ! LogWrite
    call ESMF_LogWrite("Log Write 2", ESMF_LOGMSG_INFO, &amp;
                       line=__LINE__, file=ESMF_FILENAME, &amp;
                       method=ESMF_METHOD, log=alog, rc=rc2)
</PRE>

<P>
<PRE>
    ! LogMsgSetError
    call ESMF_LogSetError(ESMF_RC_OBJ_BAD,  msg="Interpolation Failure", &amp;
                          line=__LINE__, file=ESMF_FILENAME, &amp;
                           method=ESMF_METHOD, rcToReturn=rc2, log=alog)
</PRE>

<P>

<H3><A NAME="SECTION060103300000000000000">
47.3.3 Get and Set</A>
</H3>
   This example shows how to use Get and Set routines, on both the default Log
   and the user created Log from the previous examples. 

<P>
<PRE>
    ! This is an example showing a query of the default Log.  Please note that
    ! no Log is passed in the argument list, so the default Log will be used.
    call ESMF_LogGet(logkindflag=logkindflag, rc=rc3)
</PRE>

<P>
<PRE>
    ! This is an example setting a property of a Log that is not the default.
    ! It was opened in a previous example, and the handle for it must be
    ! passed in the argument list.
    call ESMF_LogSet(log=alog, logmsgAbort=(/ESMF_LOGMSG_ERROR/), rc=rc2)
</PRE>

<P>
<PRE>
    ! Close the user log.
    call ESMF_LogClose(alog, rc=rc3)
</PRE>

<P>
<PRE>
    ! Finalize ESMF to close the default log
    call ESMF_Finalize(rc=rc1)
</PRE>

<P>


<H2><A NAME="SECTION060104000000000000000">
47.4 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Line, file and method are only available when using the C 
preprocessor</B>
Message writing methods are expanded using the ESMF macro ESMF_CONTEXT 
that adds the predefined symbolic constants __LINE__ and __FILE__ (or 
the ESMF constant ESMF_FILENAME if defined) and the ESMF constant ESMF_METHOD 
to the argument list.  Using these constants, we can associate a file name, 
line number and method name with the message.  If the CPP preprocessor is not 
used, this expansion will not be done and hence the ESMF macro ESMF_CONTEXT 
can not be used, leaving the file name, line number and method out of the Log 
text.

<P>
</LI>
<LI><B>Get and set methods are partially implemented.</B>
Currently, the <TT>ESMF_LogGet()</TT> and <TT>ESMF_LogSet()</TT> methods are 
partially implemented.   

<P>
</LI>
<LI><B>Log only appends entries.</B>
All writing to the Log is appended rather than overwriting the Log.  Future 
enhancements include the option to either append to an existing Log or 
overwrite the existing Log.

<P>
</LI>
<LI><B>Avoiding conflicts with the default Log.</B>

The private methods <TT>ESMF_LogInitialize()</TT> and <TT>ESMF_LogFinalize()</TT> 
are called during <TT>ESMF_Initialize()</TT> and <TT>ESMF_Finalize()</TT> 
respectively, so they do not need to be called if the default Log is used. 
If a new Log is required, <TT>ESMF_LogOpen()</TT> is used with a new Log object 
passed in so that there are no conflicts with the default Log.

<P>
</LI>
<LI><B>ESMF_LOGKIND_SINGLE does not work properly.</B>
When the <TT>ESMF_LogKind_Flag</TT> is set to <TT>ESMF_LOGKIND_SINGLE</TT>, different system may behave
differently.  The log messages from some processors may be lost or overwritten
by other processors.  Users are advised not to use this mode.  The MPI-based
I/O will be implemented to fix the problem in the future release. 

<P>
</LI>
</OL>

<H2><A NAME="SECTION060105000000000000000">
47.5 Design and Implementation Notes</A>
</H2>

<OL>
<LI>The Log class was implemented in Fortran and uses the Fortran I/O 
libraries when the class methods are called from Fortran. The C/C++ Log
methods use the Fortran I/O library by calling utility functions that are
written in Fortran. These utility functions call the standard Fortran write, 
open and close functions.  At initialization an <TT>ESMF_LOG</TT> is created. 
The <TT>ESMF_LOG</TT> stores information for a specific Log file.   When working 
with more than one Log file, multiple <TT>ESMF_LOG</TT>'s are required (one 
<TT>ESMF_LOG</TT> for each Log file).  For each Log, a handle is returned 
through the <TT>ESMF_LogInitialize</TT> method for the default log or <TT>ESMF_LogOpen</TT> for a user created log.  The user can specify single or multi logs by 
setting the <TT>logkindflag</TT> property in the <TT>ESMF_LogInitialize</TT> or 
<TT>ESMF_Open</TT> method to <TT>ESMF_LOGKIND_SINGLE</TT> or <TT>ESMF_LOGKIND_MULTI</TT>.
Similarly, the user can set the <TT>logkindflag</TT> property for the default
Log with the <TT>ESMF_Initialize</TT> method call.
The <TT>logkindflag</TT> is useful as the PET numbers are automatically added to the 
log entries.  A single log will put all entries, regardless of PET number, 
into a single log while a multi log will create multiple logs with the PET 
number prepended to the filename and all entries will be written to their 
corresponding log by their PET number.

<P>
The properties for a Log are set with the <TT>ESMF_LogSet()</TT> method and 
retrieved with the <TT>ESMF_LogGet()</TT> method.

<P>
Additionally, buffering is enabled.  Buffering allows <TT>ESMF</TT> to manage 
output data streams in a desired way.  Writing to the buffer is transparent 
to the user because all the Log entries are handled automatically by the 
<TT>ESMF_LogWrite()</TT> method.  All the user has to do is specify the buffer
size (the default is ten) by setting the <TT>maxElements</TT> property.  Every 
time the <TT>ESMF_LogWrite()</TT> method is called, a LogEntry element is 
populated with the <TT>ESMF_LogWrite()</TT> information.  When the buffer is 
full (i.e., when all the LogEntry elements are populated), the buffer will be 
flushed and all the contents will be written to file.  If buffering is not 
needed, that is <TT>maxElements=1</TT> or <TT>flushImmediately=ESMF_TRUE</TT>, 
the <TT>ESMF_LogWrite()</TT> method will immediately write to the Log file(s).
</LI>
</OL>

<H2><A NAME="SECTION060106000000000000000">
47.6 Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
Log class.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="749" HEIGHT="332" ALIGN="BOTTOM" BORDER="0"
 SRC="img202.png"
 ALT="\includegraphics{Log_obj}">   

</DIV>

<H2><A NAME="SECTION060107000000000000000">
47.7 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060107100000000000000">
47.7.1 ESMF_LogAssignment(=) - Log assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     log1 = log2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Log) :: log1
     type(ESMF_Log) :: log2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Assign <TT>log1</TT> as an alias to the same <TT>ESMF_Log</TT> object in memory
     as <TT>log2</TT>. If <TT>log2</TT> is invalid, then <TT>log1</TT> will be
     equally invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>log1</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>log2</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107200000000000000">
47.7.2 ESMF_LogOperator(==) - Test if Log 1 is equivalent to Log 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (log1 == log2) then ... endif
                    OR
       result = (log1 == log2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log), intent(in) :: log1
       type(ESMF_Log), intent(in) :: log2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Log</TT> class.
       Compare two logs for equality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise. Comparison is based on whether the objects
       are distinct, as with two newly created logs, or are simply aliases
       to the same log as would be the case when assignment was involved.

<P>
The arguments are:
       <DL>
<DT><STRONG>log1</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>log2</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107300000000000000">
47.7.3 ESMF_LogOperator(/=) - Test if Log 1 is not equivalent to Log 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (log1 /= log2) then ... endif
                    OR
       result = (log1 /= log2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log), intent(in) :: log1
       type(ESMF_Log), intent(in) :: log2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Log</TT> class.
       Compare two logs for inequality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise.  Comparison is based on whether the objects
       are distinct, as with two newly created logs, or are simply aliases
       to the same log as would be the case when assignment was involved.

<P>
The arguments are:
       <DL>
<DT><STRONG>log1</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the left hand side of the non-equality
            operation.
       
</DD>
<DT><STRONG>log2</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the right hand side of the non-equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107400000000000000">
47.7.4 ESMF_LogClose - Close Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LogClose(log, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log), intent(inout), optional :: log
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,        intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This routine closes the log file(s) associated with <TT>log</TT>.
        If the log is not explicitly closed, it will be closed by
        <TT>ESMF_Finalize</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>[log]</STRONG></DT>
<DD>An <TT>ESMF_Log</TT> object.  If not specified, the default log is closed.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107500000000000000">
47.7.5 ESMF_LogFlush - Flush the Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LogFlush(log, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log), intent(inout), optional :: log
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,        intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This subroutine flushes the file buffer associated with <TT>log</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107600000000000000">
47.7.6 ESMF_LogFoundAllocError - Check Fortran allocation status error and write message</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_LogFoundAllocError(statusToCheck,  &amp;
                                        msg,line,file, &amp;
                                        method,rcToReturn,log)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical                                    :: ESMF_LogFoundAllocError
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer,          intent(in)              :: statusToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg
       integer,          intent(in),    optional :: line
       character(len=*), intent(in),    optional :: file
       character(len=*), intent(in),    optional :: method
       integer,          intent(inout), optional :: rcToReturn
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This function returns <TT>.true.</TT> when <TT>statusToCheck</TT> indicates
        an allocation error, otherwise it returns <TT>.false.</TT>.  The status
        value is typically returned from a Fortran ALLOCATE statement.
        If an error is indicated, a ESMF memory allocation error message
        will be written to the <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>,
        <TT>line</TT>, <TT>file</TT> and <TT>method</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>statusToCheck</STRONG></DT>
<DD>Fortran allocation status to check.  Fortran specifies
              that a status of 0 (zero) indicates success.
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, when the allocation status indicates an error,
              set the <TT>rcToReturn</TT> value to <TT>ESMF_RC_MEM</TT>.  Otherwise,
              <TT>rcToReturn</TT> is not modified.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107700000000000000">
47.7.7 ESMF_LogFoundDeallocError - Check Fortran deallocation status error and write message</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_LogFoundDeallocError(statusToCheck,  &amp;
                                          msg,line,file, &amp;
                                          method,rcToReturn,log)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical ::ESMF_LogFoundDeallocError
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer,          intent(in)              :: statusToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg
       integer,          intent(in),    optional :: line
       character(len=*), intent(in),    optional :: file
       character(len=*), intent(in),    optional :: method
       integer,          intent(inout), optional :: rcToReturn
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This function returns <TT>.true.</TT> when <TT>statusToCheck</TT> indicates
        a deallocation error, otherwise it returns <TT>.false.</TT>.  The status
        value is typically returned from a Fortran DEALLOCATE statement.
        If an error is indicated, a ESMF memory allocation error message
        will be written to the <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>,
        <TT>line</TT>, <TT>file</TT> and <TT>method</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>statusToCheck</STRONG></DT>
<DD>Fortran deallocation status to check.  Fortran specifies
              that a status of 0 (zero) indicates success.
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, when the deallocation status indicates an error,
              set the <TT>rcToReturn</TT> value to <TT>ESMF_RC_MEM</TT>.  Otherwise,
              <TT>rcToReturn</TT> is not modified.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107800000000000000">
47.7.8 ESMF_LogFoundError - Check ESMF return code for error and write message</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive function ESMF_LogFoundError(rcToCheck,   &amp;
                                   msg, line, file, method, &amp;
                                   rcToReturn, log) result (LogFoundError)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: LogFoundError
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer,          intent(in),    optional :: rcToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg
       integer,          intent(in),    optional :: line
       character(len=*), intent(in),    optional :: file
       character(len=*), intent(in),    optional :: method
       integer,          intent(inout), optional :: rcToReturn
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This function returns <TT>.true.</TT> when <TT>rcToCheck</TT> indicates
        an return code other than <TT>ESMF_SUCCESS</TT>, otherwise it returns
        <TT>.false.</TT>.
        If an error is indicated, a ESMF predefined error message
        will be written to the <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>,
        <TT>line</TT>, <TT>file</TT> and <TT>method</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>[rcToCheck]</STRONG></DT>
<DD>Return code to check. Default is <TT>ESMF_SUCCESS</TT>.
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, when <TT>rcToCheck</TT> indicates an error,
              set the <TT>rcToReturn</TT> to the value of <TT>rcToCheck</TT>.
              Otherwise, <TT>rcToReturn</TT> is not modified.
              This is not the return code for this function; it allows
              the calling code to do an assignment of the error code
              at the same time it is testing the value.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107900000000000000">
47.7.9 ESMF_LogFoundNetCDFError - Check NetCDF status code for success or log the associated NetCDF error message.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> function ESMF_LogFoundNetCDFError(ncerrToCheck, msg, line, &amp;
                                   file, method, rcToReturn, log)
 
 #if defined ESMF_NETCDF
   use netcdf
 #elif defined ESMF_PNETCDF
   use pnetcdf
 #endif
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: ESMF_LogFoundNetCDFError
</PRE><EM>ARGUMENTS:</EM>
<PRE>   integer,          intent(in)              :: ncerrToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character(len=*), intent(in),    optional :: msg
   integer,          intent(in),    optional :: line
   character(len=*), intent(in),    optional :: file
   character(len=*), intent(in),    optional :: method
   integer,          intent(inout), optional :: rcToReturn
   type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This function returns <TT>.true.</TT> when <TT>ncerrToCheck</TT> indicates
        an return code other than <TT>0</TT> (the success code from NetCDF Fortran)
        or <TT>NF_NOERR</TT> (the success code for PNetCDF). Otherwise it returns
        <TT>.false.</TT>.
        If an error is indicated, a predefined ESMF error message
        will be written to the <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>,
        <TT>line</TT>, <TT>file</TT> and <TT>method</TT>. The NetCDF string error
        representation will also be logged.

<P>
The arguments are:
        <DL>
<DT><STRONG>[ncerrToCheck]</STRONG></DT>
<DD>NetCDF error code to check.
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by using the
              preprocessor <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, when <TT>ncerrToCheck</TT> indicates an error,
              set <TT>rcToReturn</TT> to <TT>ESMF_RC_NETCDF_ERROR</TT>. The string
              representation for the error code will be retrieved from the NetCDF
              Fortran library and logged alongside any user-provided message
              string.
              Otherwise, <TT>rcToReturn</TT> is not modified.
              This is not the return code for this function; it allows the
              calling code to do an assignment of the error code at the same time
              it is testing the value.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601071000000000000000">
47.7.10 ESMF_LogGet - Return information about a log object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LogGet(log,  &amp;
                              flush,    &amp;
                              logmsgAbort, logkindflag, &amp;
                              maxElements, trace, fileName,  &amp;
                              highResTimestampFlag, indentCount,  &amp;
                              noPrefix, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log),          intent(in),  optional :: log
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,                 intent(out), optional :: flush
       type(ESMF_LogMsg_Flag),  pointer,     optional :: logmsgAbort(:)
       type(ESMF_LogKind_Flag), intent(out), optional :: logkindflag
       integer,                 intent(out), optional :: maxElements
       logical,                 intent(out), optional :: trace
       character(*),            intent(out), optional :: fileName
       logical,                 intent(out), optional :: highResTimestampFlag
       integer,                 intent(out), optional :: indentCount
       logical,                 intent(out), optional :: noPrefix
       integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This subroutine returns properties about a Log object.

<P>
The arguments are:
        <DL>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.
        
</DD>
<DT><STRONG>[flush]</STRONG></DT>
<DD>Flush flag.
        
</DD>
<DT><STRONG>[logmsgAbort]</STRONG></DT>
<DD>Returns an array containing current message halt settings.
              If the array is not pre-allocated, <TT>ESMF_LogGet</TT> will
              allocate an array of the correct size.  If no message types
              are defined, an array of length zero is returned.  It is the
              callers responsibility to deallocate the array.
        
</DD>
<DT><STRONG>[logkindflag]</STRONG></DT>
<DD>Defines either single or multilog.
        
</DD>
<DT><STRONG>[maxElements]</STRONG></DT>
<DD>Maximum number of elements in the Log.
        
</DD>
<DT><STRONG>[trace]</STRONG></DT>
<DD>Current setting of the Log call tracing flag.
        
</DD>
<DT><STRONG>[fileName]</STRONG></DT>
<DD>Current file name.  When the log has been opened with
              <TT>ESMF_LOGKIND_MULTI</TT>, the filename has a PET number
              prefix.
        
</DD>
<DT><STRONG>[highResTimestampFlag]</STRONG></DT>
<DD>Current setting of the extended elapsed timestamp flag.
        
</DD>
<DT><STRONG>[indentCount]</STRONG></DT>
<DD>Current setting of the leading white space padding.
        
</DD>
<DT><STRONG>[noPrefix]</STRONG></DT>
<DD>Current setting of the message prefix enable/disable flag.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601071100000000000000">
47.7.11 ESMF_LogOpen - Open Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_LogOpen(log, filename,  &amp;
         appendflag, logkindflag, noPrefix, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Log),          intent(inout)         :: log
     character(len=*),        intent(in)            :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                 intent(in),  optional :: appendFlag
     type(ESMF_LogKind_Flag), intent(in),  optional :: logkindFlag
     logical,                 intent(in),  optional :: noPrefix
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This routine opens a file named <TT>filename</TT> and associates
        it with the <TT>ESMF_Log</TT>.  When <TT>logkindflag</TT> is set to
        <TT>ESMF_LOGKIND_MULTI</TT> or <TT>ESMF_LOGKIND_MULTI_ON_ERROR</TT>
        the file name is prepended with PET number identification.  If the
        incoming log is already open, an error is returned.

<P>
The arguments are:
        <DL>
<DT><STRONG>log</STRONG></DT>
<DD>An <TT>ESMF_Log</TT> object.
        
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Name of log file to be opened.
        
</DD>
<DT><STRONG>[appendFlag]</STRONG></DT>
<DD>If the log file exists, setting to <TT>.false.</TT> will set the file position
              to the beginning of the file.  Otherwise, new records will be appended to the
              end of the file.  If not specified, defaults to <TT>.true.</TT>.
        
</DD>
<DT><STRONG>[logkindFlag]</STRONG></DT>
<DD>Set the logkindflag. See section <A HREF="#const:logkindflag">47.2.2</A> for a list of
              valid options.  When the <TT>ESMF_LOGKIND_MULTI_ON_ERROR</TT> is selected,
              the log opening is deferred until a <TT>ESMF_LogWrite</TT> with log message of
              type <TT>ESMF_LOGMSG_ERROR</TT> is written.
              If not specified, defaults to <TT>ESMF_LOGKIND_MULTI</TT>.
        
</DD>
<DT><STRONG>[noPrefix]</STRONG></DT>
<DD>Set the noPrefix flag.  If set to <TT>.false.</TT>, log messages are prefixed
              with time stamps, message type, and PET number.  If set to <TT>.true.</TT> the
              messages will be written without prefixes.  If not specified, defaults to
              <TT>.false.</TT>.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601071200000000000000">
47.7.12 ESMF_LogOpen - Open Default Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LogOpen ()
     subroutine ESMF_LogOpenDefault (filename,  &amp;
         appendflag, logkindflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),        intent(in)            :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                 intent(in),  optional :: appendflag
     type(ESMF_LogKind_Flag), intent(in),  optional :: logkindflag
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This routine opens a file named <TT>filename</TT> and associates
        it with the default log.  When <TT>logkindflag</TT> is set to
        <TT>ESMF_LOGKIND_MULTI</TT> the file name is prepended with PET
        number identification.  If the incoming default log is already open,
        an error is returned.

<P>
The arguments are:
        <DL>
<DT><STRONG>filename</STRONG></DT>
<DD>Name of DEFAULT log file to be opened.
        
</DD>
<DT><STRONG>[appendflag]</STRONG></DT>
<DD>If the log file exists, setting to <TT>.false.</TT> will set the file position
              to the beginning of the file.  Otherwise, new records will be appended to the
              end of the file.  If not specified, defaults to <TT>.true.</TT>.
        
</DD>
<DT><STRONG>[logkindflag]</STRONG></DT>
<DD>Set the logkindflag. See section <A HREF="#const:logkindflag">47.2.2</A> for a list of
              valid options.
              If not specified, defaults to <TT>ESMF_LOGKIND_MULTI</TT>.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601071300000000000000">
47.7.13 ESMF_LogSet - Set Log parameters</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_LogSet(log,  &amp;
         flush,  &amp;
         logmsgAbort, maxElements, logmsgList,  &amp;
         errorMask, trace, highResTimestampFlag, indentCount,  &amp;
         noPrefix, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log),         intent(inout), optional :: log
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,                intent(in),    optional :: flush
       type(ESMF_LogMsg_Flag), intent(in),    optional :: logmsgAbort(:)
       integer,                intent(in),    optional :: maxElements
       type(ESMF_LogMsg_Flag), intent(in),    optional :: logmsgList(:)
       integer,                intent(in),    optional :: errorMask(:)
       logical,                intent(in),    optional :: trace
       logical,                intent(in),    optional :: highResTimestampFlag
       integer,                intent(in),    optional :: indentCount
       logical,                intent(in),    optional :: noPrefix
       integer,                intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This subroutine sets the properties for the Log object.

<P>
The arguments are:
        <DL>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object.  The default is to use the
              default log that was opened at <TT>ESMF_Initialize</TT> time.
        
</DD>
<DT><STRONG>[flush]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, flush log messages immediately, rather
              than buffering them.  Default is to flush after <TT>maxElements</TT>
              messages.
        
</DD>
<DT><STRONG>[logmsgAbort]</STRONG></DT>
<DD>Sets the condition on which ESMF aborts.  The array
              can contain any combination of <TT>ESMF_LOGMSG</TT> named constants.  These
              named constants are described in section <A HREF="#const:logmsgflag">47.2.3</A>.
              Default is to always continue processing.
        
</DD>
<DT><STRONG>[maxElements]</STRONG></DT>
<DD>Maximum number of elements in the Log buffer before flushing occurs.
              Default is to flush when 10 messages have been accumulated.
        
</DD>
<DT><STRONG>[logmsgList]</STRONG></DT>
<DD>An array of message types that will be logged.  Log write requests
              not matching the list will be ignored.  If an empty array is
              provided, no messages will be logged.
              See section <A HREF="#const:logmsgflag">47.2.3</A> for a list of
              valid message types.  By default, all non-trace messages will be
              logged.
        
</DD>
<DT><STRONG>[errorMask]</STRONG></DT>
<DD>List of error codes that will <EM>not</EM> be logged as errors.
              Default is to log all error codes.
        
</DD>
<DT><STRONG>[trace]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, calls such as <TT>ESMF_LogFoundError()</TT>,
              <TT>ESMF_LogFoundAllocError()</TT>, and
              <TT>ESMF_LogFoundDeallocError()</TT>
              will be logged in the default log files.  This option is intended
              to be used as a tool for debugging and program flow tracing
              within the ESMF library. Voluminous output may appear in the log,
              with a consequent slowdown in performance.  Therefore, it is
              recommended that this option only be enabled before a problematic
              call to a ESMF method, and disabled afterwards. Default is to
              not trace these calls.

</DD>
<DT><STRONG>[highResTimestampFlag]</STRONG></DT>
<DD>Sets the extended elapsed timestamp flag.  If set to <TT>.true.</TT>, a timestamp
              from <TT>ESMF_VMWtime</TT> will be included in each log message.  Default is
              to not add the additional timestamps.
        
</DD>
<DT><STRONG>[indentCount]</STRONG></DT>
<DD>Number of leading white spaces.
        
</DD>
<DT><STRONG>[noPrefix]</STRONG></DT>
<DD>If set to <TT>.false.</TT>, log messages are prefixed with time stamps,
              message type and PET number.  If set to <TT>.true.</TT> the messages will be
              written without the prefixes.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601071400000000000000">
47.7.14 ESMF_LogSetError - Set ESMF return code for error and write msg</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LogSetError(rcToCheck,  &amp;
                                   msg, line, file, method, &amp;
                                   rcToReturn, log)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer,          intent(in)              :: rcToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg
       integer,          intent(in),    optional :: line
       character(len=*), intent(in),    optional :: file
       character(len=*), intent(in),    optional :: method
       integer,          intent(out),   optional :: rcToReturn
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This subroutine sets the <TT>rcToReturn</TT> value to <TT>rcToCheck</TT> if
        <TT>rcToReturn</TT> is present and writes this error code to the <TT>ESMF_Log</TT>
        if an error is generated.  A predefined error message will added to the
        <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>, <TT>line</TT>, <TT>file</TT>
        and <TT>method</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>rcToCheck</STRONG></DT>
<DD>rc value for set
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor macro <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, copy the <TT>rcToCheck</TT> value to <TT>rcToreturn</TT>.
              This is not the return code for this function; it allows
              the calling code to do an assignment of the error code
              at the same time it is testing the value.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601071500000000000000">
47.7.15 ESMF_LogWrite - Write to Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       recursive subroutine ESMF_LogWrite(msg, logmsgFlag, &amp;
                         logmsgList,      &amp; ! DEPRECATED ARGUMENT
                         line, file, method, log, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character(len=*),      intent(in)             :: msg
       type(ESMF_LogMsg_Flag),intent(in),optional    :: logmsgFlag
       type(ESMF_LogMsg_Flag),intent(in),optional::logmsgList ! DEPRECATED ARG
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,               intent(in),   optional :: line
       character(len=*),      intent(in),   optional :: file
       character(len=*),      intent(in),   optional :: method
       type(ESMF_Log),        intent(inout),optional :: log
       integer,               intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.2.0rp1</STRONG></DT>
<DD>Added argument <TT>logmsgFlag</TT>.
                   Started to deprecate argument <TT>logmsgList</TT>.
                   This corrects inconsistent use of the <TT>List</TT> suffix on
                   the argument name. In ESMF this suffix indicates
                   one-dimensional array arguments.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This subroutine writes to the file associated with an <TT>ESMF_Log</TT>.
        A message is passed in along with the <TT>logmsgFlag</TT>, <TT>line</TT>,
        <TT>file</TT> and <TT>method</TT>.  If the write to the <TT>ESMF_Log</TT>
        is successful, the function will return a logical <TT>true</TT>.  This
        function is the base function used by all the other <TT>ESMF_Log</TT>
        writing methods.

<P>
The arguments are:
        <DL>
<DT><STRONG>msg</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[logmsgFlag]</STRONG></DT>
<DD>The type of message.  See Section&nbsp;<A HREF="#const:logmsgflag">47.2.3</A> for
              possible values.  If not specified, the default is <TT>ESMF_LOGMSG_INFO</TT>.
        
</DD>
<DT><STRONG>[logmsgList]</STRONG></DT>
<DD>DEPRECATED ARGUMENT! Please use the argument <TT>logmsgFlag</TT> instead.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor macro <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>


<H1><A NAME="SECTION060110000000000000000">
48 DELayout Class</A>
</H1>

<H2><A NAME="SECTION060111000000000000000">
48.1 Description</A>
</H2>

<P>
The DELayout class provides an additional layer of abstraction on top of the Virtual Machine (VM) layer. DELayout does this by introducing DEs (Decomposition Elements) as logical resource units. The DELayout object keeps track of the relationship between its DEs and the resources of the associated VM object. 

<P>
The relationship between DEs and VM resources (PETs (Persistent Execution Threads) and VASs (Virtual Address Spaces)) contained in a DELayout object is defined during its creation and cannot be changed thereafter. There are, however, a number of hint and specification arguments that can be used to shape the DELayout during its creation.

<P>
Contrary to the number of PETs and VASs contained in a VM object, which are fixed by the available resources, the number of DEs contained in a DELayout can be chosen freely to best match the computational problem or other design criteria. Creating a DELayout with less DEs than there are PETs in the associated VM object can be used to share resources between decomposed objects within an ESMF component. Creating a DELayout with more DEs than there are PETs in the associated VM object can be used to evenly partition the computation over the available resources.

<P>
The simplest case, however, is where the DELayout contains the same number of DEs as there are PETs in the associated VM context. In this case the DELayout may be used to re-label the hardware and operating system resources held by the VM. For instance, it is possible to order the resources so that specific DEs have best available communication paths. The DELayout will map the DEs to the PETs of the VM according to the resource details provided by the VM instance. 

<P>
Furthermore, general DE to PET mapping can be used to offer computational resources with finer granularity than the VM does. The DELayout can be queried for computational and communication capacities of DEs and DE pairs, respectively. This information can be used to best utilize the DE resources when partitioning the computational problem. In combination with other ESMF classes, general DE to PET mapping can be used to realize cache blocking, communication hiding and dynamic load balancing.

<P>
Finally, the DELayout layer offers primitives that allow a work queue style dynamic load balancing between DEs.

<H2><A NAME="SECTION060112000000000000000">
48.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION060112100000000000000"></A>
<A NAME="const:pin_flag"></A>
<BR>
48.2.1 ESMF_PIN
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Specifies which VM resource DEs are pinned to (PETs, VASs, SSIs).

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Pin_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_PIN_DE_TO_PET</STRONG></DT>
<DD>Pin DEs to PETs. Only the owning PET has access to a DE.
  
</DD>
<DT><STRONG>ESMF_PIN_DE_TO_VAS</STRONG></DT>
<DD>Pin DEs to virtual address spaces (VAS). DEs are accessible from all PETs
    within the same VAS.
  
</DD>
<DT><STRONG>ESMF_PIN_DE_TO_SSI</STRONG></DT>
<DD>Pin DEs to single system images (SSI) - typically shared memory nodes.
    DEs are accessible from all PETs within the same SSI. The memory allocation
    between different DEs is allowed to be non-contiguous.
  
</DD>
<DT><STRONG>ESMF_PIN_DE_TO_SSI_CONTIG</STRONG></DT>
<DD>Same as <TT>ESMF_PIN_DE_TO_SSI</TT>, but the shared memory allocation
    across DEs located on the same SSI must be contigous throughout.
</DD>
</DL>

<P>

<H3><A NAME="SECTION060112200000000000000"></A>
<A NAME="const:servicereply_flag"></A>
<BR>
48.2.2 ESMF_SERVICEREPLY
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Reply when a PET offers to service a DE.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_ServiceReply_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_SERVICEREPLY_ACCEPT</STRONG></DT>
<DD>The service offer has been accepted. The PET is expected to service the DE.
  
</DD>
<DT><STRONG>ESMF_SERVICEREPLY_DENY</STRONG></DT>
<DD>The service offer has been denied. The PET is expected to not service the
    DE.
</DD>
</DL>

<H2><A NAME="SECTION060113000000000000000">
48.3 Use and Examples</A>
</H2>

<P>
The following examples demonstrate how to create, use and destroy DELayout objects.

<P>

<P>

<P>

<H3><A NAME="SECTION060113100000000000000">
48.3.1 Default DELayout</A>
</H3>

<P>
Without specifying any of the optional parameters the created 
   <TT>ESMF_DELayout</TT>
   defaults into having as many DEs as there are PETs in the associated VM 
   object. Consequently the resulting DELayout describes a simple 1-to-1 DE to
   PET mapping. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(rc=rc)
</PRE>

<P>
The default DE to PET mapping is simply:
   <PRE>
   DE 0  -&gt; PET 0
   DE 1  -&gt; PET 1
   ...
</PRE>

<P>
DELayout objects that are not used any longer should be destroyed. 

<P>
<PRE>
  call ESMF_DELayoutDestroy(delayout, rc=rc)
</PRE>

<P>
The optional <TT>vm</TT> argument can be provided to DELayoutCreate() to lower 
   the method's overhead by the amount it takes to determine the current VM. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(vm=vm, rc=rc)
</PRE>

<P>
By default all PETs of the associated VM will be considered. However, if the 
   optional argument <TT>petList</TT> is present DEs will only be mapped against
   the PETs contained in the list. When the following example is executed on
   four PETs it creates a DELayout with four DEs by default that are mapped 
   to the provided PETs in their given order. It is erroneous to specify PETs 
   that are not part of the VM context on which the DELayout is defined.  

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petList=(/(i,i=petCount-1,1,-1)/), rc=rc)
</PRE>

<P>
Once the end of the petList has been reached the DE to PET mapping 
   continues from the beginning of the list. For a 4 PET VM the above created
   DELayout will end up with the following DE to PET mapping:

<P>
<PRE>
   DE 0  -&gt; PET 3
   DE 1  -&gt; PET 2
   DE 2  -&gt; PET 1
   DE 2  -&gt; PET 3
</PRE> 

<P>

<H3><A NAME="SECTION060113200000000000000">
48.3.2 DELayout with specified number of DEs</A>
</H3>

<P>
The <TT>deCount</TT> argument can be used to specify the number of DEs. In this
   example a DELayout is created that contains four times as many DEs as there 
   are PETs in the VM. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=4*petCount, rc=rc)
</PRE>

<P>
Cyclic DE to PET mapping is the default. For 4 PETs this means:
   <PRE>
   DE 0, 4,  8, 12  -&gt; PET 0
   DE 1, 5,  9, 13  -&gt; PET 1
   DE 2, 6, 10, 14  -&gt; PET 2
   DE 3, 7, 11, 15  -&gt; PET 3
</PRE>
   The default DE to PET mapping can be overridden by providing the
   <TT>deGrouping</TT> argument. This argument provides a positive integer group 
   number for each DE in the DELayout. All of the DEs of a group will be mapped 
   against the same PET. The actual group index is arbitrary (but must be 
   positive) and its value is of no consequence. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=4*petCount, &amp;
    deGrouping=(/(i/4,i=0,4*petCount-1)/), rc=rc)
</PRE>

<P>
This will achieve blocked DE to PET mapping. For 4 PETs this means:
   <PRE>
   DE  0,  1,  2,  3  -&gt; PET 0
   DE  4,  5,  6,  7  -&gt; PET 1
   DE  8,  9, 10, 11  -&gt; PET 2
   DE 12, 13, 14, 15  -&gt; PET 3
</PRE> 

<P>

<H3><A NAME="SECTION060113300000000000000">
48.3.3 DELayout with computational and communication weights</A>
</H3>

<P>
The quality of the partitioning expressed by the DE to PET mapping depends
   on the amount and quality of information provided during DELayout creation.
   In the following example the <TT>compWeights</TT> argument is used to specify
   relative computational weights for all DEs and communication weights for
   DE pairs are provided by the <TT>commWeights</TT> argument. The example assumes
   four DEs. 

<P>
<PRE>
  allocate(compWeights(4))
  allocate(commWeights(4, 4))
  ! setup compWeights and commWeights according to computational problem
  delayout = ESMF_DELayoutCreate(deCount=4, compWeights=compWeights, &amp;
    commWeights=commWeights, rc=rc)
  deallocate(compWeights, commWeights)
</PRE>

<P>
The resulting DE to PET mapping depends on the specifics of the VM object and
   the provided compWeights and commWeights arrays. 

<P>

<H3><A NAME="SECTION060113400000000000000">
48.3.4 DELayout from petMap</A>
</H3>

<P>
Full control over the DE to PET mapping is provided via the <TT>petMap</TT>
   argument. This example maps the DEs to PETs in reverse order. In the 4-PET
   case this will result in the following mapping:
   <PRE>
   DE 0 -&gt; PET 3
   DE 1 -&gt; PET 2
   DE 2 -&gt; PET 1
   DE 3 -&gt; PET 0
</PRE> 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petMap=(/(i,i=petCount-1,0,-1)/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION060113500000000000000">
48.3.5 DELayout from petMap with multiple DEs per PET</A>
</H3>

<P>
The <TT>petMap</TT> argument gives full control over DE to PET mapping. The 
   following example run on 4 or more PETs maps DEs to PETs according to the 
   following table:
   <PRE>
   DE 0 -&gt; PET 3
   DE 1 -&gt; PET 3
   DE 2 -&gt; PET 1
   DE 3 -&gt; PET 0
   DE 4 -&gt; PET 2
   DE 5 -&gt; PET 1
   DE 6 -&gt; PET 3
   DE 7 -&gt; PET 1
</PRE> 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petMap=(/3, 3, 1, 0, 2, 1, 3, 1/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION060113600000000000000">
48.3.6 Working with a DELayout - simple 1-to-1 DE-to-PET mapping</A>
</H3>

<P>
The simplest case is a DELayout where there is exactly one DE for every PET.
   Of course this implies that the number of DEs equals the number of PETs. 
   This special 1-to-1 DE-to-PET mapping is very common and many applications
   assume it. The following example shows how a DELayout can be queried about
   its mapping.

<P>
First a default DELayout is created where the number of DEs equals the number
   of PETs, and are associated 1-to-1. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(rc=rc)
</PRE>

<P>
Next the DELayout is queried for the <TT>oneToOneFlag</TT>, and the user code
   makes a decision based on its value. 

<P>
<PRE>
  call ESMF_DELayoutGet(delayout, oneToOneFlag=oneToOneFlag, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  if (.not. oneToOneFlag) then
    ! handle the unexpected case of not dealing with a 1-to-1 mapping
  else
</PRE>

<P>
1-to-1 mapping is guaranteed in this branch and the following code can
   work under the simplifying assumption that every PET holds exactly one DE: 

<P>
<PRE>
    allocate(localDeToDeMap(1))
    call ESMF_DELayoutGet(delayout, localDeToDeMap=localDeToDeMap, rc=rc)
    if (rc /= ESMF_SUCCESS) finalrc=rc
    myDe = localDeToDeMap(1)
    deallocate(localDeToDeMap)
    if (finalrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>

<H3><A NAME="SECTION060113700000000000000"></A>
   <A NAME="DELayout_general_mapping"></A>
<BR>
48.3.7 Working with a DELayout - general DE-to-PET mapping
</H3>

<P>
In general a DELayout may map any number (including zero) of DEs against
   a single PET. The exact situation can be detected by querying the DELayout
   for the <TT>oneToOneFlag</TT>. If this flag comes back as <TT>.true.</TT> then the 
   DELayout maps exactly one DE against each PET, but if it comes back as
   <TT>.false.</TT> the DELayout describes a more general DE-to-PET layout. The 
   following example shows how code can be be written to work for a general
   DELayout.

<P>
First a DELayout is created with two more DEs than there are PETs. The 
   DELayout will consequently map some DEs to the same PET. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=petCount+2, rc=rc)
</PRE>

<P>
The first piece of information needed on each PET is the <TT>localDeCount</TT>.
   This number may be different on each PET and indicates how many DEs are 
   mapped against the local PET. 

<P>
<PRE>
  call ESMF_DELayoutGet(delayout, localDeCount=localDeCount, rc=rc)
</PRE>

<P>
The DELayout can further be queried for a list of DEs that are held by
   the local PET. This information is provided by the <TT>localDeToDeMap</TT>
   argument. In ESMF a <TT>localDe</TT> is an index that enumerates the DEs that
   are associated with the local PET. In many cases the exact bounds of the
   <TT>localDe</TT> index range, e.g. <!-- MATH
 $[0...localDeCount-1]$
 -->
<IMG
 WIDTH="160" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img203.png"
 ALT="$[0...localDeCount-1]$">, or <!-- MATH
 $[1...localDeCount]$
 -->
<IMG
 WIDTH="133" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img204.png"
 ALT="$[1...localDeCount]$"> 
   does not matter, since it only affects how user code indexes into variables
   the user allocated, and therefore set the specific bounds. However, there are 
   a few Array and Field level calls that take <TT>localDe</TT> input arguments. In 
   all those cases where the <TT>localDe</TT> index variable is passed into an ESMF
   call as an input argument, it <EM>must</EM> be defined with a range starting at
   zero, i.e. <!-- MATH
 $[0...localDeCount-1]$
 -->
<IMG
 WIDTH="160" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img203.png"
 ALT="$[0...localDeCount-1]$">.

<P>
For consistency with Array and Field, the following code uses a 
   <!-- MATH
 $[0...localDeCount-1]$
 -->
<IMG
 WIDTH="160" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img203.png"
 ALT="$[0...localDeCount-1]$"> range for the <TT>localDe</TT> index variable, 
   although it is not strictly necessary here: 

<P>
<PRE>
  allocate(localDeToDeMap(0:localDeCount-1))
  call ESMF_DELayoutGet(delayout, localDeToDeMap=localDeToDeMap, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  do localDe=0, localDeCount-1
    workDe = localDeToDeMap(localDe)
!    print *, "I am PET", localPET, " and I am working on DE ", workDe
  enddo
  deallocate(localDeToDeMap)
  if (finalrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION060113800000000000000">
48.3.8 Work queue dynamic load balancing</A>
</H3>

<P>
The DELayout API includes two calls that can be used to easily implement
   work queue dynamic load balancing. The workload is broken up into DEs
   (more than there are PETs) and processed by the PETs. Load balancing is
   only possible for ESMF multi-threaded VMs and requires that DEs are pinned
   to VASs instead of the PETs (default). The following example will
   run for any VM and DELayout, however, load balancing will only occur under the
   mentioned conditions. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=petCount+2, &amp;
    pinflag=ESMF_PIN_DE_TO_VAS, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DELayoutGet(delayout, vasLocalDeCount=localDeCount, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  allocate(localDeToDeMap(localDeCount))
  call ESMF_DELayoutGet(delayout, vasLocalDeToDeMap=localDeToDeMap, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  do i=1, localDeCount
    workDe = localDeToDeMap(i)
    print *, "I am PET", localPET, &amp;
             " and I am offering service for DE ", workDe
    reply = ESMF_DELayoutServiceOffer(delayout, de=workDe, rc=rc)
    if (rc /= ESMF_SUCCESS) finalrc=rc
    if (reply == ESMF_SERVICEREPLY_ACCEPT) then
      ! process work associated with workDe
      print *, "I am PET", localPET, ", service offer for DE ", workDe, &amp;
        " was accepted."
      call ESMF_DELayoutServiceComplete(delayout, de=workDe, rc=rc)
      if (rc /= ESMF_SUCCESS) finalrc=rc
    endif
  enddo
  deallocate(localDeToDeMap)
  if (finalrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>


<H2><A NAME="SECTION060114000000000000000">
48.4 Restrictions and Future Work</A>
</H2>

<P>

<H2><A NAME="SECTION060115000000000000000">
48.5 Design and Implementation Notes</A>
</H2>

<P>
The DELayout class is a light weight object. It stores the DE to PET and VAS mapping for all DEs within all PET instances and a list of local DEs for each PET instance. The DELayout does not store the computational and communication weights optionally provided as arguments to the create method. These hints are only used during create while they are available in user owned arrays.

<H2><A NAME="SECTION060116000000000000000">
48.6 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060116100000000000000">
48.6.1 ESMF_DELayoutAssignment(=) - DELayout assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     delayout1 = delayout2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout) :: delayout1
     type(ESMF_DELayout) :: delayout2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign delayout1 as an alias to the same ESMF DELayout object in memory
     as delayout2. If delayout2 is invalid, then delayout1 will be equally
     invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout1</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>delayout2</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116200000000000000">
48.6.2 ESMF_DELayoutOperator(==) - DELayout equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (delayout1 == delayout2) then ... endif
               OR
     result = (delayout1 == delayout2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout), intent(in) :: delayout1
     type(ESMF_DELayout), intent(in) :: delayout2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether delayout1 and delayout2 are valid aliases to the same ESMF
     DELayout object in memory. For a more general comparison of two
     ESMF DELayouts, going beyond the simple alias test, the 
     ESMF_DELayoutMatch() function (not yet implemented) must
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout1</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>delayout2</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116300000000000000">
48.6.3 ESMF_DELayoutOperator(/=) - DELayout not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (delayout1 /= delayout2) then ... endif
               OR
     result = (delayout1 /= delayout2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout), intent(in) :: delayout1
     type(ESMF_DELayout), intent(in) :: delayout2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether delayout1 and delayout2 are <I>not</I> valid aliases to the
     same ESMF DELayout object in memory. For a more general comparison of two
     ESMF DELayouts, going beyond the simple alias test, the 
     ESMF_DELayoutMatch() function (not yet implemented) must
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout1</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>delayout2</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116400000000000000">
48.6.4 ESMF_DELayoutCreate - Create DELayout object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DELayoutCreate()
   recursive function ESMF_DELayoutCreateDefault(deCount, &amp;
     deGrouping, pinflag, petList, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DELayout) :: ESMF_DELayoutCreateDefault
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                      intent(in),  optional :: deCount
     integer, target,              intent(in),  optional :: deGrouping(:)
     type(ESMF_Pin_Flag),          intent(in),  optional :: pinflag
     integer, target,              intent(in),  optional :: petList(:)
     type(ESMF_VM),                intent(in),  optional :: vm
     integer,                      intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DELayout</TT> object on the basis of optionally provided
       restrictions. By default a DELayout with deCount equal to petCount will
       be created, each DE mapped to a single PET. However, the number of DEs
       as well grouping of DEs and PETs can be specified via the optional
       arguments.

<P>
The arguments are:
       <DL>
<DT><STRONG>[deCount]</STRONG></DT>
<DD>Number of DEs to be provided by the created DELayout. By default
            the number of DEs equals the number of PETs in the associated VM
            context. Specifying a <TT>deCount</TT> smaller than the number
            of PETs will result in unassociated PETs.
            This may be used to share VM resources between DELayouts within the
            same ESMF component. Specifying a <TT>deCount</TT> greater than the 
            number of PETs will result in multiple DE to PET mapping.
       
</DD>
<DT><STRONG>[deGrouping]</STRONG></DT>
<DD>This optional argument must be of size deCount. Its content assigns
            a DE group index to each DE of the DELayout. A group index of -1 
            indicates that the associated DE isn't member of any particular 
            group. The significance of DE groups is that all the DEs belonging
            to a certain group will be mapped against the <EM>same</EM> PET. This
            does not, however, mean that DEs belonging to different DE groups 
            must be mapped to different PETs.
       
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>This flag specifies which type of resource DEs are pinned to. 
            The default is to pin DEs to PETs. Alternatively it is
            also possible to pin DEs to VASs. See section 
            <A HREF="#const:pin_flag">48.2.1</A> for a list of valid pinning options.
       
</DD>
<DT><STRONG>[petList]</STRONG></DT>
<DD>List specifying PETs to be used by this DELayout. This can be used
            to control the PET overlap between DELayouts within the same
            ESMF component. It is erroneous to specify PETs that are not within 
            the provided VM context. The default is to include all the PETs of
            the VM.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the DELayout object is created on the specified 
            <TT>ESMF_VM</TT> object. The default is to create on the VM of the 
            current context.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116500000000000000">
48.6.5 ESMF_DELayoutCreate - Create DELayout from petMap</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DELayoutCreate()
   recursive function ESMF_DELayoutCreateFromPetMap(petMap, &amp;
     pinflag, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DELayout) :: ESMF_DELayoutCreateFromPetMap
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                      intent(in)            :: petMap(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Pin_Flag),          intent(in),  optional :: pinflag
     type(ESMF_VM),                intent(in),  optional :: vm
     integer,                      intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DELayout</TT> with exactly specified DE to PET mapping.

<P>
This ESMF method must be called in unison by all PETs of the VM. Calling
       this method from a PET not part of the VM or not calling it from a PET
       that is part of the VM will result in undefined behavior. ESMF does not
       guard against violation of the unison requirement. The call is not
       collective, there is no communication between PETs.

<P>
The arguments are:
       <DL>
<DT><STRONG>petMap</STRONG></DT>
<DD>List specifying the DE-to-PET mapping. The list elements correspond 
            to DE 0, 1, 2, ... and map against the specified PET of the VM
            context. The size of the <TT>petMap</TT> 
            argument determines the number of DEs in the created DELayout. It is
            erroneous to specify a PET identifier that lies outside the VM 
            context.
       
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>This flag specifies which type of resource DEs are pinned to. 
            The default is to pin DEs to PETs. Alternatively it is
            also possible to pin DEs to VASs. See section 
            <A HREF="#const:pin_flag">48.2.1</A> for a list of valid pinning options.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the DELayout object is created on the specified 
            <TT>ESMF_VM</TT> object. The default is to create on the VM of the 
            current context.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116600000000000000">
48.6.6 ESMF_DELayoutDestroy - Release resources associated with DELayout object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_DELayoutDestroy(delayout, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(inout)          :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,              intent(in),   optional :: noGarbage
     integer,              intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMF_DELayout</TT> object, releasing the resources associated
     with the object.

<P>
By default a small remnant of the object is kept in memory in order to 
     prevent problems with dangling aliases. The default garbage collection
     mechanism can be overridden with the <TT>noGarbage</TT> argument.

<P>
The arguments are:
   <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD><TT>ESMF_DELayout</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
        from the ESMF garbage collection system. Note however that under this 
        condition ESMF cannot protect against accessing the destroyed object 
        through dangling aliases - a situation which may lead to hard to debug 
        application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
        set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
        garbage collection system which will prevent problems with dangling
        aliases or incorrect sequences of destroy calls. However this level of
        support requires that a small remnant of the object is kept in memory
        past the destroy call. This can lead to an unexpected increase in memory
        consumption over the course of execution in applications that use 
        temporary ESMF objects. For situations where the repeated creation and 
        destruction of temporary objects leads to memory issues, it is 
        recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
        removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116700000000000000">
48.6.7 ESMF_DELayoutGet - Get object-wide DELayout information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_DELayoutGet(delayout, vm, deCount,&amp;
     petMap, vasMap, oneToOneFlag, pinflag, localDeCount, localDeToDeMap, &amp;
     localDeList, &amp;      ! DEPRECATED ARGUMENT
     vasLocalDeCount, vasLocalDeToDeMap, &amp;
     vasLocalDeList, &amp;   ! DEPRECATED ARGUMENT
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),      intent(in)            :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_VM),            intent(out), optional :: vm
     integer,                  intent(out), optional :: deCount
     integer, target,          intent(out), optional :: petMap(:)
     integer, target,          intent(out), optional :: vasMap(:)
     logical,                  intent(out), optional :: oneToOneFlag
     type(ESMF_Pin_Flag),      intent(out), optional :: pinflag
     integer,                  intent(out), optional :: localDeCount
     integer, target,          intent(out), optional :: localDeToDeMap(:)
     integer, target, intent(out), optional :: localDeList(:)  !DEPRECATED ARG
     integer,                  intent(out), optional :: vasLocalDeCount
     integer, target,          intent(out), optional :: vasLocalDeToDeMap(:)
     integer, target, intent(out), optional :: vasLocalDeList(:) !DEPRECATED ARG
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.2.0rp1</STRONG></DT>
<DD>Added arguments <TT>localDeToDeMap</TT> and <TT>vasLocalDeToDeMap</TT>.
                   Started to deprecate arguments <TT>localDeList</TT> and 
                   <TT>vasLocalDeList</TT>. 
                   The new argument names correctly use the <TT>Map</TT> suffix and
                   better describe the returned information.
                   This was pointed out by user request.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Access to DELayout information.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Queried <TT>ESMF_DELayout</TT> object.
     
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on which <TT>delayout</TT> is defined.
     
</DD>
<DT><STRONG>[deCount]</STRONG></DT>
<DD>The total number of DEs in the DELayout.
     
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>List of PETs against which the DEs are mapped. The <TT>petMap</TT> 
       argument must at least be of size <TT>deCount</TT>.
     
</DD>
<DT><STRONG>[vasMap]</STRONG></DT>
<DD>List of VASs against which the DEs are mapped. The <TT>vasMap</TT>
       argument must at least be of size <TT>deCount</TT>.
     
</DD>
<DT><STRONG>[oneToOneFlag]</STRONG></DT>
<DD>A value of <TT>.TRUE.</TT> indicates that <TT>delayout</TT> maps each DE to a
       single PET, and each PET maps to a single DE. All other layouts return
       a value of <TT>.FALSE.</TT>.
     
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>The type of DE pinning. See section <A HREF="#const:pin_flag">48.2.1</A> for a list
       of valid pinning options.
     
</DD>
<DT><STRONG>[localDeCount]</STRONG></DT>
<DD>The number of DEs in the DELayout associated with the local PET.
     
</DD>
<DT><STRONG>[localDeToDeMap]</STRONG></DT>
<DD>Mapping between localDe indices and the (global) DEs associated with
       the local PET. The localDe index variables are discussed in sections
       <A HREF="#DELayout_general_mapping">48.3.7</A> and <A HREF="node5.html#Array_native_language_localde">28.2.5</A>.
       The provided actual argument must be of size <TT>localDeCount</TT>.
     
</DD>
<DT><STRONG>[localDeList]</STRONG></DT>
<DD>DEPRECATED ARGUMENT! Please use the argument <TT>localDeToDeMap</TT> instead.
     
</DD>
<DT><STRONG>[vasLocalDeCount]</STRONG></DT>
<DD>The number of DEs in the DELayout associated with the local VAS.
     
</DD>
<DT><STRONG>[vasLocalDeToDeMap]</STRONG></DT>
<DD>Mapping between localDe indices and the (global) DEs associated with
       the local VAS. The localDe index variables are discussed in sections
       <A HREF="#DELayout_general_mapping">48.3.7</A> and <A HREF="node5.html#Array_native_language_localde">28.2.5</A>.
       The provided actual argument must be of size <TT>localDeCount</TT>.
     
</DD>
<DT><STRONG>[vasLocalDeList]</STRONG></DT>
<DD>DEPRECATED ARGUMENT! Please use the argument <TT>vasLocalDeToDeMap</TT> instead.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116800000000000000">
48.6.8 ESMF_DELayoutIsCreated - Check whether a DELayout object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_DELayoutIsCreated(delayout, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_DELayoutIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout), intent(in)            :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>delayout</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD><TT>ESMF_DELayout</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116900000000000000">
48.6.9 ESMF_DELayoutPrint - Print DELayout information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DELayoutPrint(delayout, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Prints internal information about the specified <TT>ESMF_DELayout</TT> 
       object to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601161000000000000000">
48.6.10 ESMF_DELayoutServiceComplete - Close service window</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_DELayoutServiceComplete(delayout, de, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
     integer,              intent(in)            :: de
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
The PET who's service offer was accepted for <TT>de</TT> must use 
     <TT>ESMF_DELayoutServiceComplete</TT> to close the service window.

<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>de</STRONG></DT>
<DD>DE for which to close service window.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601161100000000000000">
48.6.11 ESMF_DELayoutServiceOffer - Offer service for a DE in DELayout</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive function ESMF_DELayoutServiceOffer(delayout, de, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_ServiceReply_Flag) :: ESMF_DELayoutServiceOffer
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
     integer,              intent(in)            :: de
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Offer service for a DE in the <TT>ESMF_DELayout</TT> object. This call
       together with <TT>ESMF_DELayoutServiceComplete()</TT> provides the
       synchronization primitives between the PETs of an ESMF multi-threaded VM
       necessary for dynamic load balancing via a work queue approach.

<P>
The calling PET will either receive <TT>ESMF_SERVICEREPLY_ACCEPT</TT> if
       the service offer has been accepted by DELayout or 
       <TT>ESMF_SERVICEREPLY_DENY</TT> if the service offer was denied. The 
       service offer paradigm is different from a simple mutex approach in that
       the DELayout keeps track of the number of service offers issued for each
       DE by each PET and accepts only one PET's offer for each offer increment.
       This requires that all PETs use <TT>ESMF_DELayoutServiceOffer()</TT> in 
       unison. See section <A HREF="#const:servicereply_flag">48.2.2</A> for the potential return
       values.

<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>de</STRONG></DT>
<DD>DE for which service is offered by the calling PET.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601161200000000000000">
48.6.12 ESMF_DELayoutValidate - Validate DELayout internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DELayoutValidate(delayout, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>delayout</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION060120000000000000000">
49 VM Class</A>
</H1>

<H2><A NAME="SECTION060121000000000000000">
49.1 Description</A>
</H2>

<P>
The ESMF VM (Virtual Machine) class is a generic representation of hardware and system software resources. There is exactly one VM object per ESMF Component, providing the execution environment for the Component code. The VM class handles all resource management tasks for the Component class and provides a description of the underlying configuration of the compute resources used by a Component.

<P>
In addition to resource description and management, the VM class offers the lowest level of ESMF communication methods. The VM communication calls are very similar to MPI. Data references in VM communication calls must be provided as raw, language-specific, one-dimensional, contiguous data arrays. The similarity between VM and MPI communication calls is striking and there are many equivalent point-to-point and collective communication calls. However, unlike MPI, the VM communication calls support communication between threaded PETs in a completely transparent fashion.

<P>
Many ESMF applications do not interact with the VM class directly very much. The  resource management aspect is wrapped completely transparent into the ESMF Component concept. Often the only reason that user code queries a Component
object for the associated VM object is to inquire about resource information, such as the <TT>localPet</TT> or the <TT>petCount</TT>. Further, for most applications the use of higher level communication APIs, such as provided by Array and Field, are much more convenient than using the low level VM communication calls.

<P>
The basic elements of a VM are called PETs, which stands for Persistent Execution Threads. These are equivalent to OS threads with a lifetime of at least that of the associated component. All VM functionality is expressed in terms of PETs. In the simplest, and most common case, a PET is equivalent to an MPI process. However, ESMF also supports multi-threading, where multiple PETs run as Pthreads inside the same virtual address space (VAS).

<P>
The resource management functions of the VM class become visible when a component, or the driver code, creates sub-components. Section <A HREF="node4.html#sec:AppDriverSetVM">16.4.7</A> discusses this aspect from the Superstructure 
perspective and provides links to the relevant Component examples in the documentation.

<P>
There are two parts to resource management, the parent and the child. When the parent component creates a child component, the parent VM object provides the resources on which the child is created with <TT>ESMF_GridCompCreate()</TT> or <TT>ESMF_CplCompCreate()</TT>. The optional <TT>petList</TT> argument to these calls limits the resources that the parent gives to a specific child. The child component, may specify - during its optional 
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> method - how it wants to arrange the inherited resources in its own VM. After this, all standard ESMF methods of the Component, including <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, will execute in the child VM. Notice that the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> routine, although part of the child Component, must execute <EM>before</EM> the child VM has been started up. It runs in the parent VM context. The child VM is created and started up just before the user-written set services routine, specified as an argument to <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, is entered.

<H2><A NAME="SECTION060122000000000000000">
49.2 Use and Examples</A>
</H2>

<P>
The concept of the ESMF Virtual Machine (VM) is so fundamental to the framework that every ESMF application uses it. However, for many user applications the VM class is transparently hidden behind the ESMF Component concept and higher data classes (e.g. Array, Field). The interaction between user code and VM is often only indirect. The following examples provide an overview of where the VM class can come into play in user code.

<P>

<P>

<P>

<H3><A NAME="SECTION060122100000000000000">
49.2.1 Global VM</A>
</H3>

<P>
This complete example program demonstrates the simplest ESMF application, 
   consisting of only a main program without any Components. The global
   VM, which is automatically created during the <TT>ESMF_Initialize()</TT> call,
   is obtained using two different methods. First the global VM will be returned
   by <TT>ESMF_Initialize()</TT> if the optional <TT>vm</TT> argument is specified.
   The example uses the VM object obtained this way to call the VM print method.
   Second, the global VM can be obtained anywhere in the user application using
   the <TT>ESMF_VMGetGlobal()</TT> call. The identical VM is returned and several
   VM query methods are called to inquire about the associated resources.

<P>
<PRE>
program ESMF_VMDefaultBasicsEx
#include "ESMF.h"

  use ESMF
  use ESMF_TestMod
  
  implicit none
  
  ! local variables
  integer:: rc
  type(ESMF_VM):: vm
  integer:: localPet, petCount, peCount, ssiId, vas
</PRE>

<P>
<PRE>
  call ESMF_Initialize(vm=vm, defaultlogfilename="VMDefaultBasicsEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  ! Providing the optional vm argument to ESMF_Initialize() is one way of
  ! obtaining the global VM.
</PRE>

<P>
<PRE>
  call ESMF_VMPrint(vm, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_VMGetGlobal(vm=vm, rc=rc)
  ! Calling ESMF_VMGetGlobal() anywhere in the user application is the other
  ! way to obtain the global VM object.
</PRE>

<P>
<PRE>
  call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, peCount=peCount, &amp;
    rc=rc)
  ! The VM object contains information about the associated resources. If the
  ! user code requires this information it must query the VM object.
</PRE>

<P>
<PRE>
  print *, "This PET is localPet: ", localPet
  print *, "of a total of ",petCount," PETs in this VM."
  print *, "There are ", peCount," PEs referenced by this VM"

  call ESMF_VMGet(vm, localPet, peCount=peCount, ssiId=ssiId, vas=vas, rc=rc)
</PRE>

<P>
<PRE>
  print *, "This PET is executing in virtual address space (VAS) ", vas
  print *, "located on single system image (SSI) ", ssiId
  print *, "and is associated with ", peCount, " PEs."
</PRE>

<P>
<PRE>
end program
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060122200000000000000">
49.2.2 Getting the MPI Communicator from an VM object</A>
</H3>

<P>
Sometimes user code requires access to the MPI communicator, e.g. to support
   legacy code that contains explict MPI communication calls. The correct way of
   wrapping such code into ESMF is to obtain the MPI intra-communicator out of
   the VM object. In order not to interfere with ESMF communications it is
   advisable to duplicate the communicator before using it in user-level MPI
   calls. In this example the duplicated communicator is used for a user
   controlled <TT>MPI_Barrier()</TT>.

<P>
<PRE>
  integer:: mpic
</PRE>

<P>
<PRE>
  integer:: mpic2
</PRE>

<P>
<PRE>
  call ESMF_VMGet(vm, mpiCommunicator=mpic, rc=rc)
  ! The returned MPI communicator spans the same MPI processes that the VM
  ! is defined on.
</PRE>

<P>
<PRE>
  call MPI_Comm_dup(mpic, mpic2, ierr)
  ! Duplicate the MPI communicator not to interfere with ESMF communications.
  ! The duplicate MPI communicator can be used in any MPI call in the user
  ! code. Here the MPI_Barrier() routine is called.
  call MPI_Barrier(mpic2, ierr)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060122300000000000000"></A>
   <A NAME="vm_inside_user_mpi"></A>
<BR>
49.2.3 Nesting ESMF inside a user MPI application
</H3>

<P>
It is possible to nest an ESMF application inside a user application that 
   explicitly calls <TT>MPI_Init()</TT> and <TT>MPI_Finalize()</TT>. The
   <TT>ESMF_Initialize()</TT> call automatically checks whether MPI has already
   been initialized, and if so does not call <TT>MPI_Init()</TT> internally. 
   On the finalize side, <TT>ESMF_Finalize()</TT> can be instructed to <EM>not</EM>
   call <TT>MPI_Finalize()</TT>, making it the responsibility of the outer code
   to finalize MPI.

<P>
<PRE>
  ! User code initializes MPI.
  call MPI_Init(ierr)
</PRE>

<P>
<PRE>
  ! ESMF_Initialize() does not call MPI_Init() if it finds MPI initialized.
  call ESMF_Initialize(defaultlogfilename="VMUserMpiEx.Log", &amp;
    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
  ! Use ESMF here...
</PRE>

<P>
<PRE>
  ! Calling ESMF_Finalize() with endflag=ESMF_END_KEEPMPI instructs ESMF
  ! to keep MPI active.
  call ESMF_Finalize(endflag=ESMF_END_KEEPMPI, rc=rc)
</PRE>

<P>
<PRE>
  ! It is the responsibility of the outer user code to finalize MPI.
  call MPI_Finalize(ierr)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060122400000000000000"></A>
   <A NAME="vm_nesting_esmf"></A>
<BR>
49.2.4 Nesting ESMF inside a user MPI application on a subset of MPI ranks
</H3>

<P>
The previous example demonstrated that it is possible to nest an ESMF 
   application, i.e. <TT>ESMF_Initialize()</TT>...<TT>ESMF_Finalize()</TT> inside
   <TT>MPI_Init()</TT>...<TT>MPI_Finalize()</TT>. It is not necessary that all
   MPI ranks enter the ESMF application. The following example shows how the
   user code can pass an MPI communicator to <TT>ESMF_Initialize()</TT>, and
   enter the ESMF application on a subset of MPI ranks.

<P>
<PRE>
  ! User code initializes MPI.
  call MPI_Init(ierr)
</PRE>

<P>
<PRE>
  ! User code determines the local rank.
  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
</PRE>

<P>
<PRE>
  ! User code prepares MPI communicator "esmfComm", that allows rank 0 and 1
  ! to be grouped together.
  if (rank &lt; 2) then
    ! first communicator split with color=0
    call MPI_Comm_split(MPI_COMM_WORLD, 0, 0, esmfComm, ierr)
  else
    ! second communicator split with color=1
    call MPI_Comm_split(MPI_COMM_WORLD, 1, 0, esmfComm, ierr)
  endif
</PRE>

<P>
<PRE>
  if (rank &lt; 2) then
    ! Only call ESMF_Initialize() on rank 0 and 1, passing the prepared MPI
    ! communicator that spans these ranks.
    call ESMF_Initialize(mpiCommunicator=esmfComm, &amp;
      defaultlogfilename="VMUserMpiCommEx.Log", &amp;
      logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
    ! Use ESMF here...
</PRE>

<P>
<PRE>
    ! Calling ESMF_Finalize() with endflag=ESMF_END_KEEPMPI instructs ESMF
    ! to keep MPI active.
    call ESMF_Finalize(endflag=ESMF_END_KEEPMPI, rc=rc)
</PRE>

<P>
<PRE>
  else
    ! Ranks 2 and above do non-ESMF work...
</PRE>

<P>
<PRE>
  endif
</PRE>

<P>
<PRE>
  ! Free the MPI communicator before finalizing MPI.
  call MPI_Comm_free(esmfComm, ierr)
  
  ! It is the responsibility of the outer user code to finalize MPI.
  call MPI_Finalize(ierr)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060122500000000000000"></A>
   <A NAME="vm_multi_instance_esmf"></A>
<BR>
49.2.5 Multiple concurrent instances of ESMF under separate MPI communicators
</H3>

<P>
Multiple instances of ESMF can run concurrently under the same user main 
   program on separate MPI communicators. The user program first splits
   <TT>MPI_COMM_WORLD</TT> into separate MPI communicators. Each communicator is
   then used to run a separate ESMF instance by passing it into 
   <TT>ESMF_Initialize()</TT> on the appropriate MPI ranks.

<P>
Care must be taken to set the <TT>defaultlogfilename</TT> to be unique on each
   ESMF instances. This prevents concurrent ESMF instances from writing to the
   same log file. 
   Further, each ESMF instances must call 
   <TT>ESMF_Finalize()</TT> with the <TT>endflag=ESMF_END_KEEPMPI</TT> option in
   order to hand MPI control back to the user program. The outer user program is
   ultimately responsible for destroying the MPI communicators and to cleanly
   shut down MPI.

<P>
<PRE>
  ! User code initializes MPI.
  call MPI_Init(ierr)
</PRE>

<P>
<PRE>
  ! User code determines the local rank and overall size of MPI_COMM_WORLD
  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
  call MPI_Comm_size(MPI_COMM_WORLD, size, ierr)
</PRE>

<P>
<PRE>
  ! User code prepares different MPI communicators.
  ! Here a single MPI_Comm_split() call is used to split MPI_COMM_WORLD
  ! into two non-overlapping communicators:
  ! One communicator for ranks 0 and 1, and the other for ranks 2 and above.
  if (rank &lt; 2) then
    ! first communicator split with color=0
    call MPI_Comm_split(MPI_COMM_WORLD, 0, 0, esmfComm, ierr)
  else
    ! second communicator split with color=1
    call MPI_Comm_split(MPI_COMM_WORLD, 1, 0, esmfComm, ierr)
  endif
</PRE>

<P>
<PRE>
  if (rank &lt; 2) then
    ! Ranks 0 and 1 enter ESMF_Initialize() with the prepared communicator.
    ! Care is taken to set a unique log file name.
    call ESMF_Initialize(mpiCommunicator=esmfComm, &amp;
      defaultlogfilename="VMUserMpiCommMultiEx1.Log", &amp;
      logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
    ! Use ESMF here...
</PRE>

<P>
<PRE>
    ! Finalize ESMF without finalizing MPI. The user application will call
    ! MPI_Finalize() on all ranks.
    call ESMF_Finalize(endflag=ESMF_END_KEEPMPI, rc=rc)
</PRE>

<P>
<PRE>
  else
    ! Ranks 2 and above enter ESMF_Initialize() with the prepared communicator.
    ! Care is taken to set a unique log file name.
    call ESMF_Initialize(mpiCommunicator=esmfComm, &amp;
      defaultlogfilename="VMUserMpiCommMultiEx2.Log", &amp;
      logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
    ! Use ESMF here...
</PRE>

<P>
<PRE>
    ! Finalize ESMF without finalizing MPI. The user application will call
    ! MPI_Finalize() on all ranks.
    call ESMF_Finalize(endflag=ESMF_END_KEEPMPI, rc=rc)
</PRE>

<P>
<PRE>
  endif
</PRE>

<P>
<PRE>
  ! Free the MPI communicator(s) before finalizing MPI.
  call MPI_Comm_free(esmfComm, ierr)
  
  ! It is the responsibility of the outer user code to finalize MPI.
  call MPI_Finalize(ierr)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060122600000000000000">
49.2.6 VM and Components</A>
</H3>

<P>
The following example shows the role that the VM plays in connection with ESMF 
   Components. A single Component is created in the main program. Through the
   optional <TT>petList</TT> argument the driver code specifies that only resources
   associated with PET 0 are given to the <TT>gcomp</TT> object. 

<P>
When the Component code is invoked through the standard ESMF Component methods
   Initialize, Run, or Finalize the Component's VM is automatically entered.
   Inside of the user-written Component code the Component VM can be obtained
   by querying the Component object. The VM object will indicate that only a
   single PET is executing the Component code.

<P>
<PRE>
module ESMF_VMComponentEx_gcomp_mod
</PRE>

<P>
<PRE>
  recursive subroutine mygcomp_init(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp)   :: gcomp
    type(ESMF_State)      :: istate, estate
    type(ESMF_Clock)      :: clock
    integer, intent(out)  :: rc

    ! local variables
    type(ESMF_VM):: vm
    
    ! get this Component's vm    
    call ESMF_GridCompGet(gcomp, vm=vm)
    
    ! the VM object contains information about the execution environment of
    ! the Component

    call ESMF_VMPrint(vm, rc=rc)
    
    rc = 0
  end subroutine !--------------------------------------------------------------

  
  recursive subroutine mygcomp_run(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp)   :: gcomp
    type(ESMF_State)      :: istate, estate
    type(ESMF_Clock)      :: clock
    integer, intent(out)  :: rc
    
    ! local variables
    type(ESMF_VM):: vm
    
    ! get this Component's vm    
    call ESMF_GridCompGet(gcomp, vm=vm)
    
    ! the VM object contains information about the execution environment of
    ! the Component

    call ESMF_VMPrint(vm, rc=rc)
    
    rc = 0
  end subroutine !--------------------------------------------------------------

  recursive subroutine mygcomp_final(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp)   :: gcomp
    type(ESMF_State)      :: istate, estate
    type(ESMF_Clock)      :: clock
    integer, intent(out)  :: rc
    
    ! local variables
    type(ESMF_VM):: vm
    
    ! get this Component's vm    
    call ESMF_GridCompGet(gcomp, vm=vm)
    
    ! the VM object contains information about the execution environment of
    ! the Component

    call ESMF_VMPrint(vm, rc=rc)
    
    rc = 0
  end subroutine !--------------------------------------------------------------

end module
</PRE>

<P>
<PRE>
program ESMF_VMComponentEx
#include "ESMF.h"
  use ESMF
  use ESMF_TestMod
  use ESMF_VMComponentEx_gcomp_mod
  implicit none
  
  ! local variables
</PRE>

<P>
<PRE>
  gcomp = ESMF_GridCompCreate(petList=(/0/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompSetServices(gcomp, userRoutine=mygcomp_register, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompInitialize(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompRun(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompFinalize(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompDestroy(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060122700000000000000">
49.2.7 Communication - Send and Recv</A>
</H3>

<P>
The VM layer provides MPI-like point-to-point communication. Use 
   <TT>ESMF_VMSend()</TT> and <TT>ESMF_VMRecv()</TT> to pass data between two PETs.
   The following code sends data from PET 'src' and receives it on PET 'dst'.
   Both PETs must be part of the same VM.

<P>
<PRE>
  integer, allocatable:: localData(:)
</PRE>

<P>
<PRE>
  count = 10
  allocate(localData(count))
  do i=1, count
    localData(i) = localPet*100 + i
  enddo
</PRE>

<P>
<PRE>
  if (localPet==src) then
    call ESMF_VMSend(vm, sendData=localData, count=count, dstPet=dst, rc=rc)
  endif
</PRE>

<P>
<PRE>
  if (localPet==dst) then
    call ESMF_VMRecv(vm, recvData=localData, count=count, srcPet=src, rc=rc)
  endif
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060122800000000000000">
49.2.8 Communication - Scatter and Gather</A>
</H3>

<P>
The VM layer provides MPI-like collective communication. <TT>ESMF_VMScatter()</TT>
   scatters data located on <TT>root</TT> PET across all the PETs of the VM. 
   <TT>ESMF_VMGather()</TT> provides the opposite operation, gathering data from
   all the PETs of the VM onto <TT>root</TT> PET.

<P>
<PRE>
  integer, allocatable:: array1(:), array2(:)
</PRE>

<P>
<PRE>
  ! allocate data arrays
  nsize = 2
  nlen = nsize * petCount
  allocate(array1(nlen))
  allocate(array2(nsize))

  ! prepare data array1
  do i=1, nlen
    array1(i) = localPet * 100 + i
  enddo
</PRE>

<P>
<PRE>
  call ESMF_VMScatter(vm, sendData=array1, recvData=array2, count=nsize, &amp;
    rootPet=scatterRoot, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_VMGather(vm, sendData=array2, recvData=array1, count=nsize, &amp;
    rootPet=gatherRoot, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060122900000000000000">
49.2.9 Communication - AllReduce and AllFullReduce</A>
</H3>

<P>
Use <TT>ESMF_VMAllReduce()</TT> to reduce data distributed across the PETs of a 
   VM into a result vector, returned on all the PETs. Further, use
   <TT>ESMF_VMAllFullReduce()</TT> to reduce the data into a single scalar returned
   on all PETs.

<P>
<PRE>
  integer, allocatable:: array1(:), array2(:)
</PRE>

<P>
<PRE>
  ! allocate data arrays
  nsize = 2
  allocate(array1(nsize))
  allocate(array2(nsize))

  ! prepare data array1
  do i=1, nsize
    array1(i) = localPet * 100 + i
  enddo
</PRE>

<P>
<PRE>
  call ESMF_VMAllReduce(vm, sendData=array1, recvData=array2, count=nsize, &amp;
    reduceflag=ESMF_REDUCE_SUM, rc=rc)
  ! Reduce distributed sendData, element by element into recvData and
  ! return it on all the PETs.
</PRE>

<P>
<PRE>
  call ESMF_VMAllFullReduce(vm, sendData=array1, recvData=result, &amp;
    count=nsize, reduceflag=ESMF_REDUCE_SUM, rc=rc)
  ! Fully reduce the distributed sendData into a single scalar and
  ! return it in recvData on all PETs.
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION0601221000000000000000"></A>
   <A NAME="vm_higherrank"></A>
<BR>
49.2.10 Using VM communication methods with data of rank greater than one
</H3>

<P>
In the current implementation of the VM communication methods all the data
   array arguments are declared as <EM>assumed shape</EM> dummy arrays of rank one.
   The assumed shape flavor was chosen in order to minimize the chance of 
   copy in/out problems, associated with the other options for declaring the 
   dummy data arguments.
   However, currently the interfaces are not overloaded for higher ranks. This
   restriction requires that users that need to communicate data arrays with
   rank greater than one, must only pass the first dimension of the data array
   into the VM communication calls. Specifying the full size of the data arrays
   (considering <EM>all</EM> dimensions) ensure that the complete data is
   transferred in or out of the contiguous array memory. 

<P>
<PRE>
  integer, allocatable:: sendData(:,:)
  integer, allocatable:: recvData(:,:,:,:)
</PRE>

<P>
<PRE>
  count1 = 5
  count2 = 8
  allocate(sendData(count1,count2)) ! 5 x 8 = 40 elements
  do j=1, count2
    do i=1, count1
      sendData(i,j) = localPet*100 + i + (j-1)*count1
    enddo
  enddo
  
  count1 = 2
  count2 = 5
  count3 = 1
  count4 = 4
  allocate(recvData(count1,count2,count3,count4)) ! 2 x 5 x 1 x 4 = 40 elements
  do l=1, count4
    do k=1, count3
      do j=1, count2
        do i=1, count1
          recvData(i,j,k,l) = 0
        enddo
      enddo
    enddo
  enddo
</PRE>

<P>
<PRE>
  if (localPet==src) then
    call ESMF_VMSend(vm, &amp;
      sendData=sendData(:,1), &amp; ! 1st dimension as contiguous array section
      count=count1*count2, &amp;    ! total count of elements
      dstPet=dst, rc=rc)
  endif
</PRE>

<P>
<PRE>
  if (localPet==dst) then
    call ESMF_VMRecv(vm, &amp;
      recvData=recvData(:,1,1,1), &amp; ! 1st dimension as contiguous array section
      count=count1*count2*count3*count4, &amp;  ! total count of elements
      srcPet=src, rc=rc)
  endif
</PRE>

<P>


<H2><A NAME="SECTION060123000000000000000">
49.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Only array section syntax that leads to contiguous sub sections is supported</B>. The source and destination arguments in VM communication calls must reference contiguous data arrays. Fortran array sections are not guaranteed to be contiguous in all cases.

<P>
</LI>
<LI><B>Non-blocking <TT>Reduce()</TT> operations <EM>not</EM> implemented.</B> None of the reduce communication calls have an implementation for the non-blocking feature. This affects:

<UL>
<LI><TT>ESMF_VMAllFullReduce()</TT>,
</LI>
<LI><TT>ESMF_VMAllReduce()</TT>,
</LI>
<LI><TT>ESMF_VMReduce()</TT>.
</LI>
</UL>

<P>
</LI>
<LI><B>Limitations when using <TT>mpiuni</TT> mode.</B> In <TT>mpiuni</TT> mode non-blocking communications are limited to one outstanding message per source-destination PET pair. Furthermore, in <TT>mpiuni</TT> mode the message length must be smaller than the internal ESMF buffer size.

<P>
</LI>
<LI><B>Alternative communication paths not accessible.</B> All user accessible VM communication calls are currently implemented using MPI-1.2. VM's implementation of alternative communication techniques, such as shared memory between threaded PETs and POSIX IPC between PETs located on the same single system image, are currently inaccessible to the user. (One exception to this is the <TT>mpiuni</TT> case for which the VM automatically utilizes a shared memory path.)

<P>
</LI>
<LI><B>Data arrays in VM comm calls are <EM>assumed shape</EM> with rank=1.</B> Currently all dummy arrays in VM comm calls are defined as <EM>assumed shape</EM> arrays of rank=1. The motivation for this choice is that the use of assumed shape dummy arrays guards against the Fortran copy in/out problem. However it may not be as flexible as desired from the user perspective. Alternatively all dummy arrays could be defined as <EM>assumed size</EM> arrays, as it is done in most MPI implementations, allowing arrays of various rank to be passed into the comm methods. Arrays of higher rank can be passed into the current interfaces using Fortran array syntax. This approach is explained in section <A HREF="#vm_higherrank">49.2.10</A>.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION060124000000000000000">
49.4 Design and Implementation Notes</A>
</H2>

<P>
The VM class provides an additional layer of abstraction on top of the POSIX machine model, making it suitable for HPC applications. There are four key aspects the VM class deals with.

<P>

<OL>
<LI>Encapsulation of hardware and operating system details within the concept of Persistent Execution Threads (PETs).

<P>
</LI>
<LI>Resource management in terms of PETs with a guard against over-subscription.

<P>
</LI>
<LI>Topological description of the underlying configuration of the compute resources in terms of PETs.

<P>
</LI>
<LI>Transparent communication API for point-to-point and collective PET-based primitives, hiding the many different communication channels and offering best possible performance.

<P>
</LI>
</OL>

<P>
<DIV ALIGN="CENTER">
<!-- MATH
 $\scalebox{0.6}{\includegraphics{VM_design}}$
 -->
<IMG
 WIDTH="723" HEIGHT="527" ALIGN="BOTTOM" BORDER="0"
 SRC="img205.png"
 ALT="\scalebox{0.6}{\includegraphics{VM_design}}">
</DIV>

<P>
<B>Definition of terms used in the diagram</B>

<P>

<UL>
<LI>PE: A processing element (PE) is an alias for the smallest physical processing unit available on a particular hardware platform. In the language of today's microprocessor architecture technology a PE is identical to a core, however, if future microprocessor designs change the smallest physical processing unit the mapping of the PE to actual hardware will change accordingly. Thus the PE layer separates the hardware specific part of the VM from the hardware-independent part. Each PE is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>Core: A Core is the smallest physical processing unit which typically comprises a register set, an integer arithmetic unit, a floating-point unit and various control units. Each Core is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>CPU: The central processing unit (CPU) houses single or multiple cores, providing them with the interface to system memory, interconnects and I/O. Typically the CPU provides some level of caching for the instruction and data streams in and out of the Cores. Cores in a multi-core CPU typically share some caches. Each CPU is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>SSI: A single system image (SSI) spans all the CPUs controlled by a single running instance of the operating system. SMP and NUMA are typical multi-CPU SSI architectures. Each SSI is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>TOE: A thread of execution (TOE) executes an instruction sequence. TOE's come in two flavors: PET and TET.

<P>
</LI>
<LI>PET: A persistent execution thread (PET) executes an instruction sequence on an associated set of data. The PET has a lifetime at least as long as the associated data set. In ESMF the PET is the central concept of abstraction provided by the VM class. The PETs of an VM object are labeled from 0 to N-1 where N is the total number of PETs in the VM object.

<P>
</LI>
<LI>TET: A transient execution thread (TET) executes an instruction sequence on an associated set of data. A TET's lifetime might be shorter than that of the associated data set.

<P>
</LI>
<LI>OS-Instance: The OS-Instance of a TOE describes how a particular TOE is instantiated on the OS level. Using POSIX terminology a TOE will run as a single thread within a single- or multi-threaded process.

<P>
</LI>
<LI>Pthreads: Communication via the POSIX Thread interface.

<P>
</LI>
<LI>MPI-1, MPI-2: Communication via MPI standards 1 and 2.

<P>
</LI>
<LI>armci: Communication via the aggregate remote memory copy interface.

<P>
</LI>
<LI>SHMEM: Communication via the SHMEM interface.

<P>
</LI>
<LI>OS-IPC: Communication via the operating system's inter process communication interface. Either POSIX IPC or System V IPC.

<P>
</LI>
<LI>InterCon-lib: Communication via the interconnect's library native interface. An example is the Elan library for Quadrics.

<P>
</LI>
</UL>

<P>
The POSIX machine abstraction, while a very powerful concept, needs augmentation when applied to HPC applications. Key elements of the POSIX abstraction are processes, which provide virtually unlimited resources (memory, I/O, sockets, ...) to possibly multiple threads of execution. Similarly POSIX threads create the illusion that there is virtually unlimited processing power available to each POSIX process. While the POSIX abstraction is very suitable for many multi-user/multi-tasking applications that need to share limited physical resources, it does not directly fit the HPC workload where over-subscription of resources is one of the most expensive modes of operation.

<P>
ESMF's virtual machine abstraction is based on the POSIX machine model but holds additional information about the available physical processing units in terms of Processing Elements (PEs). A PE is the smallest physical processing unit and encapsulates the hardware details (Cores, CPUs and SSIs).

<P>
There is exactly one physical machine layout for each application, and all VM instances have access to this information. The PE is the smallest processing unit which, in today's microprocessor technology, corresponds to a single Core. Cores are arranged in CPUs which in turn are arranged in SSIs. The setup of the physical machine layout is part of the ESMF initialization process.

<P>
On top of the PE concept the key abstraction provided by the VM is the PET. All user code is executed by PETs while OS and hardware details are hidden. The VM class contains a number of methods which allow the user to prescribe how the PETs of a desired virtual machine should be instantiated on the OS level and how they should map onto the hardware. This prescription is kept in a private virtual machine plan object which is created at the same time the associated component is being created. Each time component code is entered through one of the component's registered top-level methods (Initialize/Run/Finalize), the virtual machine plan along with a pointer to the respective user function is used to instantiate the user code on the PETs of the associated VM in form of single- or multi-threaded POSIX processes.

<P>
The process of starting, entering, exiting and shutting down a VM is very transparent, all spawning and joining of threads is handled by VM methods "behind the scenes". Furthermore, fundamental synchronization and communication primitives are provided on the PET level through a uniform API, hiding details related to the actual instantiation of the participating PETs.

<P>
Within a VM object each PE of the physical machine maps to 0 or 1 PETs. Allowing unassigned PEs provides a means to prevent over-subscription between multiple concurrently running virtual machines. Similarly a maximum of one PET per PE prevents over-subscription within a single VM instance. However, over-subscription is possible by subscribing PETs from different virtual machines to the same PE. This type of over-subscription can be desirable for PETs associated with I/O workloads expected to be used infrequently and to block often on I/O requests.

<P>
On the OS level each PET of a VM object is represented by a POSIX thread (Pthread) either belonging to a single- or multi-threaded process and maps to at least 1 PE of the physical machine, ensuring its execution. Mapping a single PET to multiple PEs provides resources for user-level multi-threading, in which case the user code inquires how many PEs are associated with its PET and if there are multiple PEs available the user code can spawn an equal number of threads (e.g. OpenMP) without risking over-subscription. Typically these user spawned threads are short-lived and used for fine-grained parallelization in form of TETs. All PEs mapped against a single PET must be part of a unique SSI in order to allow user-level multi-threading!

<P>
In addition to discovering the physical machine the ESMF initialization process sets up the default global virtual machine. This VM object, which is the ultimate parent of all VMs created during the course of execution, contains as many PETs as there are PEs in the physical machine. All of its PETs are instantiated in form of single-threaded MPI processes and a 1:1 mapping of PETs to PEs is used for the default global VM.

<P>
The VM design and implementation is based on the POSIX process and thread model as well as the MPI-1.2 standard. As a consequence of the latter standard the number of processes is static during the course of execution and is determined at start-up. The VM implementation further requires that the user starts up the ESMF application with as many MPI processes as there are PEs in the available physical machine using the platform dependent mechanism to ensure proper process placement. 

<P>
All MPI processes participating in a VM are grouped together by means of an MPI_Group object and their context is defined via an MPI_Comm object (MPI intra-communicator). The PET local process id within each virtual machine is equal to the MPI_Comm_rank in the local MPI_Comm context whereas the PET process id is equal to the MPI_Comm_rank in MPI_COMM_WORLD. The PET process id is used within the VM methods to determine the virtual memory space a PET is operating in. 

<P>
In order to provide a migration path for legacy MPI-applications the VM offers accessor functions to its MPI_Comm object. Once obtained this object may be used in explicit user-code MPI calls within the same context.

<P>

<H2><A NAME="SECTION060125000000000000000">
49.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060125100000000000000">
49.5.1 ESMF_VMAssignment(=) - VM assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     vm1 = vm2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM) :: vm1
     type(ESMF_VM) :: vm2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign vm1 as an alias to the same ESMF VM object in memory
     as vm2. If vm2 is invalid, then vm1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm1</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>vm2</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125200000000000000">
49.5.2 ESMF_VMOperator(==) - VM equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (vm1 == vm2) then ... endif
               OR
     result = (vm1 == vm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in) :: vm1
     type(ESMF_VM), intent(in) :: vm2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether vm1 and vm2 are valid aliases to the same ESMF
     VM object in memory. For a more general comparison of two ESMF VMs,
     going beyond the simple alias test, the ESMF_VMMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm1</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>vm2</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125300000000000000">
49.5.3 ESMF_VMOperator(/=) - VM not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (vm1 /= vm2) then ... endif
               OR
     result = (vm1 /= vm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in) :: vm1
     type(ESMF_VM), intent(in) :: vm2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether vm1 and vm2 are <I>not</I> valid aliases to the
     same ESMF VM object in memory. For a more general comparison of two ESMF
     VMs, going beyond the simple alias test, the ESMF_VMMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm1</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>vm2</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125400000000000000">
49.5.4 ESMF_VMAllFullReduce - Fully reduce data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllFullReduce(vm, sendData, recvData, &amp;
      count, reduceflag, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;),         intent(out)           :: recvData
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that reduces a contiguous data 
     array of &lt;type&gt;&lt;kind&gt; across the <TT>ESMF_VM</TT> object 
     into a single value of the same &lt;type&gt;&lt;kind&gt;. The result is
     returned on all PETs. Different reduction operations can be specified.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Single data variable to be received. All PETs must specify a
          valid result variable.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in sendData. Allowed to be different across the 
          PETs, as long as <TT>count</TT> &gt; 0.
     
</DD>
<DT><STRONG>reduceflag</STRONG></DT>
<DD>Reduction operation. See section <A HREF="node9.html#const:reduce">52.46</A> for a list of 
          valid reduce operations.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125500000000000000">
49.5.5 ESMF_VMAllGather - Gather data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllGather(vm, sendData, recvData, count, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data 
     from all PETs of an <TT>ESMF_VM</TT> object into an array on all PETs.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be gathered from each PET. Must be the
          same on all PETs.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125600000000000000">
49.5.6 ESMF_VMAllGatherV - GatherV data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllGatherV(vm, sendData, sendCount, &amp;
      recvData, recvCounts, recvOffsets, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data 
     from all PETs of an <TT>ESMF_VM</TT> object into an array on all PETs.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>sendCount</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to send from local PET to all other
          PETs.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument.
     
</DD>
<DT><STRONG>recvCounts</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to be received from corresponding
          source PET.
     
</DD>
<DT><STRONG>recvOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>recvData</TT> marking the start of
          element sequence to be received from source PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125700000000000000">
49.5.7 ESMF_VMAllReduce - Reduce data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllReduce(vm, sendData, recvData, count, &amp;
      reduceflag, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that reduces a contiguous data 
     array across the <TT>ESMF_VM</TT> object into a contiguous data array of the
     same &lt;type&gt;&lt;kind&gt;. The result array is returned on all PETs. 
     Different reduction operations can be specified.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in sendData and recvData. Must be the same on all
          PETs.
     
</DD>
<DT><STRONG>reduceflag</STRONG></DT>
<DD>Reduction operation. See section <A HREF="node9.html#const:reduce">52.46</A> for a list of 
          valid reduce operations.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125800000000000000">
49.5.8 ESMF_VMAllToAll - AllToAll communications across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllToAll(vm, sendData, sendCount, &amp;
      recvData, recvCount, syncflag, &amp;
      commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCount
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.3.0r. If code using this interface compiles with any version of ESMF starting with 5.3.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that performs a total exchange
     operation, sending pieces of the contiguous data buffer <TT>sendData</TT> to
     all other PETs while receiving data into the contiguous data buffer
     <TT>recvData</TT> from all other PETs.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>sendCount</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to send from local PET to
          each destination PET.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument.
     
</DD>
<DT><STRONG>recvCount</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to be received by local PET from
          each source PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125900000000000000">
49.5.9 ESMF_VMAllToAllV - AllToAllV communications across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllToAllV(vm, sendData, sendCounts, &amp;
      sendOffsets, recvData, recvCounts, recvOffsets, syncflag, &amp;
      commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCounts(:)
      integer,                          intent(in)            :: sendOffsets(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that performs a total exchange
     operation, sending pieces of the contiguous data buffer <TT>sendData</TT> to
     all other PETs while receiving data into the contiguous data buffer
     <TT>recvData</TT> from all other PETs.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>sendCounts</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to send from local PET to
          destination PET.
     
</DD>
<DT><STRONG>sendOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>sendData</TT> marking to start of
          element sequence to be sent from local PET to destination PET.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument.
     
</DD>
<DT><STRONG>recvCounts</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to be received by local PET from
          source PET.
     
</DD>
<DT><STRONG>recvOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>recvData</TT> marking to start of
          element sequence to be received by local PET from source PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251000000000000000">
49.5.10 ESMF_VMBarrier - VM wide barrier</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMBarrier(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),  intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,        intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that blocks calling PET until
     all PETs of the VM context have issued the call.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251100000000000000">
49.5.11 ESMF_VMBroadcast - Broadcast data across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMBroadcast(vm, bcstData, count, rootPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(inout)         :: bcstData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that broadcasts a contiguous 
     data array from <TT>rootPet</TT> to all other PETs of the <TT>ESMF_VM</TT>
     object.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>, 
     <TT>ESMF_TYPEKIND_CHARACTER</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>bcstData</STRONG></DT>
<DD>Contiguous data array. On <TT>rootPet</TT> <TT>bcstData</TT> holds data that
          is to be broadcasted to all other PETs. On all other PETs 
          <TT>bcstData</TT> is used to receive the broadcasted data.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in /bcstData. Must be the same on all PETs.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds data that is being broadcast.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251200000000000000">
49.5.12 ESMF_VMCommWait - Wait for non-blocking VM communication to complete</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMCommWait(vm, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),         intent(in)            :: vm
     type(ESMF_CommHandle), intent(in)            :: commhandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,               intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Wait for non-blocking VM communication specified by the <TT>commhandle</TT> to
     complete.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>commhandle</STRONG></DT>
<DD>Handle specifying a previously issued non-blocking communication 
          request.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251300000000000000">
49.5.13 ESMF_VMCommWaitAll - Wait for all non-blocking VM comms to complete</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMCommWaitAll(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Wait for <EM>all</EM> pending non-blocking VM communication within the 
     specified VM context to complete.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251400000000000000">
49.5.14 ESMF_VMGather - Gather data from across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMGather(vm, sendData, recvData, count, rootPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data 
     from all PETs of an <TT>ESMF_VM</TT> object (including <TT>rootPet</TT>) into an
     array on <TT>rootPet</TT>.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. Only the <TT>recvData</TT>
          array specified by the <TT>rootPet</TT> will be used by this method.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be sent from each PET to <TT>rootPet</TT>. Must be
          the same on all PETs.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET on which data is gathereds.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251500000000000000">
49.5.15 ESMF_VMGatherV - GatherV data from across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMGatherV(vm, sendData, sendCount, recvData, &amp;
      recvCounts, recvOffsets, rootPet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data 
     from all PETs of an <TT>ESMF_VM</TT> object into an array on rootPet.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>sendCount</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to send from local PET to all other
          PETs.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. Only the <TT>recvData</TT>
          array specified by the <TT>rootPet</TT> will be used by this method.
     
</DD>
<DT><STRONG>recvCounts</STRONG></DT>
<DD>An integer array (of length group size, specified in VM object) containing 
          number of <TT>recvData</TT> elements to be received from corresponding
          source PET. This argument is significant only at rootPet.
     
</DD>
<DT><STRONG>recvOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>recvData</TT> marking the start of
          element sequence to be received from source PET.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET on which data is gathered.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251600000000000000">
49.5.16 ESMF_VMGet - Get object-wide information from a VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_VMGet()
   recursive subroutine ESMF_VMGetDefault(vm, localPet, &amp;
     petCount, peCount, ssiCount, ssiMinPetCount, ssiMaxPetCount, &amp;
     ssiLocalPetCount, mpiCommunicator, pthreadsEnabledFlag, openMPEnabledFlag, &amp;
     ssiSharedMemoryEnabledFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),      intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: localPet
     integer,            intent(out), optional :: petCount
     integer,            intent(out), optional :: peCount
     integer,            intent(out), optional :: ssiCount
     integer,            intent(out), optional :: ssiMinPetCount
     integer,            intent(out), optional :: ssiMaxPetCount
     integer,            intent(out), optional :: ssiLocalPetCount
     integer,            intent(out), optional :: mpiCommunicator
     logical,            intent(out), optional :: pthreadsEnabledFlag
     logical,            intent(out), optional :: openMPEnabledFlag
     logical,            intent(out), optional :: ssiSharedMemoryEnabledFlag
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added arguments <TT>ssiCount</TT>, <TT>ssiMinPetCount</TT>, 
     <TT>ssiMaxPetCount</TT>, and <TT>ssiLocalPetCount</TT> to provide access 
     to information about how the VM is mapped across the single system images
     (SSIs) - typically synonymous to nodes - of the compute environment. This
     information is useful when constructing custom petLists. <BR>
Added argument <TT>ssiSharedMemoryEnabledFlag</TT> that allows the user to 
     query whether ESMF was compiled with support for shared memory 
     access between PETs on the same SSI.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal information about the specified <TT>ESMF_VM</TT> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Queried <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[localPet]</STRONG></DT>
<DD>Upon return this holds the local id of the PET that issued this call.
          The valid range of <TT>localPet</TT> is <!-- MATH
 $[0..petCount-1]$
 -->
<IMG
 WIDTH="123" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img206.png"
 ALT="$[0..petCount-1]$">. A value of <IMG
 WIDTH="24" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img82.png"
 ALT="$-1$">
          is returned on PETs that are not active under the specified <TT>vm</TT>.
     
</DD>
<DT><STRONG>[petCount]</STRONG></DT>
<DD>Upon return this holds the number of PETs running under <TT>vm</TT>.
     
</DD>
<DT><STRONG>[peCount]</STRONG></DT>
<DD>Upon return this holds the number of PEs referenced by <TT>vm</TT>.
     
</DD>
<DT><STRONG>[ssiCount]</STRONG></DT>
<DD>Upon return this holds the number of single system images referenced 
          by <TT>vm</TT>.
     
</DD>
<DT><STRONG>[ssiMinPetCount]</STRONG></DT>
<DD>Upon return this holds the smallest number of PETs running in the same
          single system images under <TT>vm</TT>.
     
</DD>
<DT><STRONG>[ssiMaxPetCount]</STRONG></DT>
<DD>Upon return this holds the largest number of PETs running in the same
          single system images under <TT>vm</TT>.
     
</DD>
<DT><STRONG>[ssiLocalPetCount]</STRONG></DT>
<DD>Upon return this holds the number of PETs running in the same
          single system as <TT>localPet</TT>.
     
</DD>
<DT><STRONG>[mpiCommunicator]</STRONG></DT>
<DD>Upon return this holds the MPI intra-communicator used by the 
          specified <TT>ESMF_VM</TT> object. This communicator may be used for
          user-level MPI communications. It is recommended that the user
          duplicates the communicator via <TT>MPI_Comm_Dup()</TT> in order to
          prevent any interference with ESMF communications.
          <TT>MPI_COMM_NULL</TT> is returned on PETs that are not active
          under the specified <TT>vm</TT>.
     
</DD>
<DT><STRONG>[pthreadsEnabledFlag]</STRONG></DT>
<DD><DL>
<DT><STRONG><TT>.TRUE.</TT></STRONG></DT>
<DD>ESMF has been compiled with Pthreads.
          
</DD>
<DT><STRONG><TT>.FALSE.</TT></STRONG></DT>
<DD>ESMF has <EM>not</EM> been compiled with Pthreads.
          
</DD>
</DL>
     
</DD>
<DT><STRONG>[openMPEnabledFlag]</STRONG></DT>
<DD><DL>
<DT><STRONG><TT>.TRUE.</TT></STRONG></DT>
<DD>ESMF has been compiled with OpenMP.
          
</DD>
<DT><STRONG><TT>.FALSE.</TT></STRONG></DT>
<DD>ESMF has <EM>not</EM> been compiled with OpenMP.
          
</DD>
</DL>
     
</DD>
<DT><STRONG>[ssiSharedMemoryEnabledFlag]</STRONG></DT>
<DD><DL>
<DT><STRONG><TT>.TRUE.</TT></STRONG></DT>
<DD>ESMF has been compiled to support shared memory access
               between PETs that are on the same single system image (SSI).
          
</DD>
<DT><STRONG><TT>.FALSE.</TT></STRONG></DT>
<DD>ESMF has <EM>not</EM> been compiled to support shared memory access
               between PETs that are on the same single system image (SSI).
          
</DD>
</DL>
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251700000000000000">
49.5.17 ESMF_VMGet - Get PET-local VM information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_VMGet()
   subroutine ESMF_VMGetPetLocalInfo(vm, pet, peCount, &amp;
     accDeviceCount, ssiId, threadCount, threadId, vas, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in)            :: vm
     integer,       intent(in)            :: pet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: peCount
     integer,       intent(out), optional :: accDeviceCount
     integer,       intent(out), optional :: ssiId
     integer,       intent(out), optional :: threadCount
     integer,       intent(out), optional :: threadId
     integer,       intent(out), optional :: vas
     integer,       intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>accDeviceCount</TT>.
     The argument provides access to the number of available accelerator devices.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal information about a specific PET within an <TT>ESMF_VM</TT> 
     object.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Queried <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>pet</STRONG></DT>
<DD>Queried PET id within the specified <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[peCount]</STRONG></DT>
<DD>Upon return this holds the number of PEs associated with the specified
          PET in the <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[accDeviceCount]</STRONG></DT>
<DD>Upon return this holds the number of accelerated devices accessible
          from the specified PET in the <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[ssiId]</STRONG></DT>
<DD>Upon return this holds the id of the single-system image (SSI) the
          specified PET is running on.
     
</DD>
<DT><STRONG>[threadCount]</STRONG></DT>
<DD>Upon return this holds the number of PETs in the specified PET"s 
          thread group.
     
</DD>
<DT><STRONG>[threadId]</STRONG></DT>
<DD>Upon return this holds the thread id of the specified PET within the 
          PET"s thread group.
     
</DD>
<DT><STRONG>[vas]</STRONG></DT>
<DD>Virtual address space in which this PET operates.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251800000000000000">
49.5.18 ESMF_VMGetGlobal - Get Global VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMGetGlobal(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(out)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional  :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get the global <TT>ESMF_VM</TT> object. This is the VM object
     that is created during <TT>ESMF_Initialize()</TT> and is the ultimate
     parent of all VM objects in an ESMF application. It is identical to the VM
     object returned by <TT>ESMF_Initialize(..., vm=vm, ...)</TT>.

<P>
The <TT>ESMF_VMGetGlobal()</TT> call provides access to information about the
     global execution context via the global VM. This call is necessary because
     ESMF does not created a global ESMF Component during
     <TT>ESMF_Initialize()</TT> that could be queried for information about
     the global execution context of an ESMF application.

<P>
Usage of <TT>ESMF_VMGetGlobal()</TT> from within Component code is
     strongly discouraged. ESMF Components should only access their own VM
     objects through Component methods. Global information, if required by
     the Component user code, should be passed down to the Component from the 
     driver through the Component calling interface.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Upon return this holds the <TT>ESMF_VM</TT> object of the global execution 
       context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251900000000000000">
49.5.19 ESMF_VMGetCurrent - Get Current VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMGetCurrent(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(out)           :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get the <TT>ESMF_VM</TT> object of the current execution context. Calling
     <TT>ESMF_VMGetCurrent()</TT> within an ESMF Component, will return the
     same VM object as
     <TT>ESMF_GridCompGet(..., vm=vm, ...)</TT> or
     <TT>ESMF_CplCompGet(..., vm=vm, ...)</TT>.

<P>
The main purpose of providing <TT>ESMF_VMGetCurrent()</TT> is to simplify ESMF
     adoption in legacy code. Specifically, code that uses <TT>MPI_COMM_WORLD</TT>
     deep within its calling tree can easily be modified to use the correct MPI
     communicator of the current ESMF execution context. The advantage is that
     these modifications are very local, and do not require wide reaching
     interface changes in the legacy code to pass down the ESMF component object,
     or the MPI communicator.

<P>
The use of <TT>ESMF_VMGetCurrent()</TT> is strongly discouraged in newly
     written Component code. Instead, the ESMF Component object should be used as
     the appropriate container of ESMF context information. This object should be
     passed between the subroutines of a Component, and be queried for any
     Component specific information.

<P>
Outside of a Component context, i.e. within the driver context, the call
     to <TT>ESMF_VMGetCurrent()</TT> is identical to <TT>ESMF_VMGetGlobal()</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Upon return this holds the <TT>ESMF_VM</TT> object of the current execution
       context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252000000000000000">
49.5.20 ESMF_VMIsCreated - Check whether a VM object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_VMIsCreated(vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_VMIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>vm</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252100000000000000">
49.5.21 ESMF_VMPrint - Print VM information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMPrint(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),  intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,        intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Print internal information about the specified <TT>ESMF_VM</TT> to
     <TT>stdout</TT>.
<BR>
<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Specified <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252200000000000000">
49.5.22 ESMF_VMRecv - Receive data from srcPet</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMRecv(vm, recvData, count, srcPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                     intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target,  intent(out)           :: recvData(:)  
      integer,                           intent(in)            :: count
      integer,                           intent(in)            :: srcPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),              intent(in),  optional :: syncflag
      type(ESMF_CommHandle),             intent(out), optional :: commhandle
      integer,                           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Receive contiguous data from <TT>srcPet</TT> within the same <TT>ESMF_VM</TT> 
     object.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>, 
     <TT>ESMF_TYPEKIND_CHARACTER</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be received.
     
</DD>
<DT><STRONG>srcPet</STRONG></DT>
<DD>Sending PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252300000000000000">
49.5.23 ESMF_VMReduce - Reduce data from across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMReduce(vm, sendData, recvData, count, &amp;
      reduceflag, rootPet, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that reduces a contiguous data 
     array across the <TT>ESMF_VM</TT> object into a contiguous data array of 
     the same &lt;type&gt;&lt;kind&gt;. The result array is returned on <TT>rootPet</TT>. 
     Different reduction operations can be specified.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. Only the <TT>recvData</TT>
          array specified by the <TT>rootPet</TT> will be used by this method.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in sendData and recvData. Must be the same on all
          PETs.
     
</DD>
<DT><STRONG>reduceflag</STRONG></DT>
<DD>Reduction operation. See section <A HREF="node9.html#const:reduce">52.46</A> for a list of 
          valid reduce operations.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET on which reduced data is returned.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252400000000000000">
49.5.24 ESMF_VMScatter - Scatter data across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMScatter(vm, sendData, recvData, count, &amp;
      rootPet, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that scatters contiguous data 
     from the <TT>rootPet</TT> to all PETs across the <TT>ESMF_VM</TT> object
     (including <TT>rootPet</TT>).

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. Only the <TT>sendData</TT>
          array specified by the <TT>rootPet</TT> will be used by this method.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid destination array.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be sent from <TT>rootPet</TT> to each of the PETs.
          Must be the same on all PETs.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds data that is being scattered.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252500000000000000">
49.5.25 ESMF_VMScatterV - ScatterV across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMScatterV(vm, sendData, sendCounts, &amp;
      sendOffsets, recvData, recvCount, rootPet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCounts(:)
      integer,                          intent(in)            :: sendOffsets(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCount
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that scatters contiguous data 
     from the <TT>rootPet</TT> to all PETs across the <TT>ESMF_VM</TT> object
     (including <TT>rootPet</TT>).

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. Only the <TT>sendData</TT>
          array specified by the <TT>rootPet</TT> will be used by this method.
     
</DD>
<DT><STRONG>sendCounts</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to be sent to corresponding
          receive PET.
     
</DD>
<DT><STRONG>sendOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>sendData</TT> marking the start of
          element sequence to be sent to receive PET.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument.
     
</DD>
<DT><STRONG>recvCount</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to receive by local PET from
          <TT>rootPet</TT>.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds data that is being scattered.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252600000000000000">
49.5.26 ESMF_VMSend - Send data to dstPet</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMSend(vm, sendData, count, dstPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)  
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: dstPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Send contiguous data to <TT>dstPet</TT> within the same <TT>ESMF_VM</TT> object.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>, 
     <TT>ESMF_TYPEKIND_CHARACTER</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be sent.
     
</DD>
<DT><STRONG>dstPet</STRONG></DT>
<DD>Receiving PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252700000000000000">
49.5.27 ESMF_VMSendRecv - Send and Recv data to and from PETs</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMSendRecv(vm, sendData, sendCount, dstPet, &amp;
      recvData, recvCount, srcPet, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)  
      integer,                          intent(in)            :: sendCount
      integer,                          intent(in)            :: dstPet
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)  
      integer,                          intent(in)            :: recvCount
      integer,                          intent(in)            :: srcPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Send contiguous data to <TT>dstPet</TT> within the same <TT>ESMF_VM</TT> object
     while receiving contiguous data from <TT>srcPet</TT> within the same 
     <TT>ESMF_VM</TT> object. The <TT>sendData</TT> and <TT>recvData</TT> arrays must be
     disjoint!

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>,
     <TT>ESMF_TYPEKIND_LOGICAL</TT>, 
     <TT>ESMF_TYPEKIND_CHARACTER</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent.
     
</DD>
<DT><STRONG>sendCount</STRONG></DT>
<DD>Number of elements to be sent.
     
</DD>
<DT><STRONG>dstPet</STRONG></DT>
<DD>PET that holds <TT>recvData</TT>.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received.
     
</DD>
<DT><STRONG>recvCount</STRONG></DT>
<DD>Number of elements to be received.
     
</DD>
<DT><STRONG>srcPet</STRONG></DT>
<DD>PET that holds <TT>sendData</TT>.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">52.56</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252800000000000000">
49.5.28 ESMF_VMValidate - Validate VM internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMValidate(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>vm</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Specified <TT>ESMF_VM</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252900000000000000">
49.5.29 ESMF_VMWtime - Get floating-point number of seconds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMWtime(time, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(out)           :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get floating-point number of seconds of elapsed wall-clock time since the
     beginning of execution of the application.

<P>
The arguments are:
     <DL>
<DT><STRONG>time</STRONG></DT>
<DD>Time in seconds.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601253000000000000000">
49.5.30 ESMF_VMWtimeDelay - Delay execution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_VMWtimeDelay(delay, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(in)            :: delay
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Delay execution for amount of seconds.

<P>
The arguments are:
     <DL>
<DT><STRONG>delay</STRONG></DT>
<DD>Delay time in seconds.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601253100000000000000">
49.5.31 ESMF_VMWtimePrec - Timer precision as floating-point number of seconds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMWtimePrec(prec, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(out)           :: prec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get a run-time estimate of the timer precision as floating-point number 
     of seconds. This is a relatively expensive call since the timer precision
     is measured several times before the maximum is returned as the estimate.
     The returned value is PET-specific and may differ across the VM 
     context.

<P>
The arguments are:
     <DL>
<DT><STRONG>prec</STRONG></DT>
<DD>Timer precision in seconds.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION060130000000000000000">
50 Profiling and Tracing</A>
</H1>

<H2><A NAME="SECTION060131000000000000000">
50.1 Description</A>
</H2>

<P>

<H3><A NAME="SECTION060131100000000000000"></A>
<A NAME="sec:Profiling"></A>
<BR>
50.1.1 Profiling
</H3>

<P>
ESMF's built in <EM>profiling</EM> capability collects runtime statistics
of an executing ESMF application through both automatic and manual code
instrumentation. Timing information for all phases of all ESMF components
executing in an application can be automatically collected using the
<TT>ESMF_RUNTIME_PROFILE</TT> environment variable (see below for settings).
Additionally, arbitrary user-defined code regions can be timed by
manually instrumenting code with special API calls.  Timing profiles
of component phases and user-defined regions can be output in several
different formats:

<UL>
<LI>in text at the end of ESMF Log files
</LI>
<LI>in separate text file, one per PET (if the ESMF Logs are turned off)
</LI>
<LI>in a single summary text file that aggregates timings over multiple PETs
</LI>
<LI>in a binary format for import into <A NAME="tex2html86"
  HREF="https://earthsystemcog.org/projects/cupid/">Cupid</A>
for detailed analysis
</LI>
</UL>

<P>
The following table lists important environment variables that control
aspects of ESMF profiling.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Environment Variable</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><B>Description</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Example Values</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Default</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_PROFILE</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Enable/disables all profiling functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ON</TT> or <TT>OFF</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>OFF</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_PROFILE_PETLIST</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Limits profiling to an explicit list of PETs</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>``<TT>0-9 50 99</TT>''</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><EM>profile all PETs</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_PROFILE_OUTPUT</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Controls output format of profiles;  multiple can be specified in a space separated list</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>TEXT</TT>, <TT>SUMMARY</TT>, <TT>BINARY</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>TEXT</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION060131200000000000000"></A>
<A NAME="sec:Tracing"></A>
<BR>
50.1.2 Tracing
</H3>

<P>
Whereas profiling collects summary information from an application,
<EM>tracing</EM> records a more detailed set of events for later analysis. Trace
analysis can be used to understand what happened during a program's
execution and is often used for diagnosing problems, debugging, and
performance analysis.

<P>
ESMF has a built-in tracing capability that records events into special
binary log files.  Unlike log files written by the <TT>ESMF_Log</TT> class,
which are primarily for human consumption (see Section <A HREF="#sec:Log">47.1</A>),
the trace output files are
recorded in a compact binary representation and are processed by tools
to produce various analyses. ESMF event streams are recorded in the
<A NAME="tex2html87"
  HREF="http://diamon.org/ctf/">Common Trace Format</A>
(CTF).
CTF traces include one or more event streams,
as well as a metadata file describing the events in the streams.

<P>
Several tools are available for reading in the CTF traces output by ESMF.
Of the tools listed below, the first one is designed specifically for
analyzing ESMF applications and the second two are general purpose tools
for working with all CTF traces.

<UL>
<LI><A NAME="tex2html88"
  HREF="https://earthsystemcog.org/projects/cupid/">Cupid</A>
is a plugin for the Eclipse Integrated Development Environment
  that can read and analyze ESMF traces.
</LI>
<LI><A NAME="tex2html89"
  HREF="http://tracecompass.org/">TraceCompass</A>
is a general purpose tool for reading, analyzing, and visualizing traces.
</LI>
<LI><A NAME="tex2html90"
  HREF="http://www.efficios.com/babeltrace">Babeltrace</A>
is a command-line tool and library for trace conversion
  that can read and write CTF traces. Python bindings are available
  to open CTF traces are iterate through events.  
</LI>
</UL>

<P>
Events that can be captured by the ESMF tracer include the following. Events
are recorded with a high-precision timestamp to allow timing analyses.
<DL>
<DT><STRONG>phase_enter</STRONG></DT>
<DD>indicates entry into an initialize, run, or finalize ESMF component routine
</DD>
<DT><STRONG>phase_exit</STRONG></DT>
<DD>indicates exit from an initialize, run, or finalize ESMF component routine
</DD>
<DT><STRONG>region_enter</STRONG></DT>
<DD>indicates entry into a user-defined code region
</DD>
<DT><STRONG>region_exit</STRONG></DT>
<DD>indicates exit from a user-defined code region
</DD>
<DT><STRONG>mem</STRONG></DT>
<DD>records current memory usage information
</DD>
</DL>

<P>
The following table lists important environment variables that control
aspects of ESMF tracing.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Environment Variable</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><B>Description</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Example Values</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Default</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_TRACE</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Enable/disables all tracing functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ON</TT> or <TT>OFF</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>OFF</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_TRACE_CLOCK</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Sets the type of clock for timestamping events (see Section <A HREF="#sec:TracingClocks">50.2.6</A>).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>REALTIME</TT> or <TT>MONOTONIC</TT> or <TT>MONOTONIC_SYNC</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>REALTIME</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_TRACE_PETLIST</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Limits tracing to an explicit list of PETs</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>``<TT>0-9 50 99</TT>''</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><EM>trace all PETs</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_TRACE_COMPONENT</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Enables/disable tracing of Component phase_enter and phase_exit events</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ON</TT> or <TT>OFF</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ON</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_TRACE_FLUSH</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Controls frequency of event stream flushing to file</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>DEFAULT</TT> or <TT>EAGER</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>DEFAULT</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION060132000000000000000">
50.2 Use and Examples</A>
</H2>

<P>

<H3><A NAME="SECTION060132100000000000000"></A>
<A NAME="sec:BasicProfiling"></A>
<BR>
50.2.1 Output a Timing Profile to Text
</H3>

<P>
ESMF profiling is disabled by default. To profile an application,
set the <TT>ESMF_RUNTIME_PROFILE</TT> variable to <TT>ON</TT> prior
to executing the application.  You do not need to recompile
your code to enable profiling.

<P>
<PRE>
# csh shell
$ setenv ESMF_RUNTIME_PROFILE ON

# bash shell
$ export ESMF_RUNTIME_PROFILE=ON

# (from now on, only the csh shell version will be shown)
</PRE>

<P>
Then execute the application in the usual way. At the end of
the run the profile information will be available at the end
of each PET log (if ESMF Logs are turned on) or in a set of
separate files, one per PET, with names <EM>ESMF_Profile.XXX</EM>
where XXX is the PET number.  Below is an example timing
profile.  Some regions are left out for brevity.

<P>
<PRE>
Region                           Count  Total (s)   Self (s)    Mean (s)    Min (s)     Max (s)
  [esm] Init 1                   1      4.0878      0.0341      4.0878      4.0878      4.0878
    [OCN-TO-ATM] IPDv05p6b       1      2.6007      2.6007      2.6007      2.6007      2.6007
    [ATM-TO-OCN] IPDv05p6b       1      1.4333      1.4333      1.4333      1.4333      1.4333
    [ATM] IPDv00p2               1      0.0055      0.0055      0.0055      0.0055      0.0055
    [OCN] IPDv00p2               1      0.0023      0.0023      0.0023      0.0023      0.0023
    [ATM] IPDv00p1               1      0.0011      0.0011      0.0011      0.0011      0.0011
    [OCN] IPDv00p1               1      0.0009      0.0009      0.0009      0.0009      0.0009
    [ATM-TO-OCN] IPDv05p3        1      0.0008      0.0008      0.0008      0.0008      0.0008
    [ATM-TO-OCN] IPDv05p1        1      0.0008      0.0008      0.0008      0.0008      0.0008
    [ATM-TO-OCN] IPDv05p2b       1      0.0007      0.0007      0.0007      0.0007      0.0007
    [ATM-TO-OCN] IPDv05p4        1      0.0007      0.0007      0.0007      0.0007      0.0007
    [ATM-TO-OCN] IPDv05p2a       1      0.0007      0.0007      0.0007      0.0007      0.0007
    [ATM-TO-OCN] IPDv05p5        1      0.0007      0.0007      0.0007      0.0007      0.0007
    [OCN-TO-ATM] IPDv05p3        1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p4        1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p2b       1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p2a       1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p5        1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p1        1      0.0005      0.0005      0.0005      0.0005      0.0005
  [esm] RunPhase1                1      2.7423      0.9432      2.7423      2.7423      2.7423
    [OCN-TO-ATM] RunPhase1       864    0.6094      0.6094      0.0007      0.0006      0.0179
    [ATM] RunPhase1              864    0.5296      0.2274      0.0006      0.0005      0.0011
      ATM:ModelAdvance           864    0.3022      0.3022      0.0003      0.0003      0.0005
    [ATM-TO-OCN] RunPhase1       864    0.3345      0.3345      0.0004      0.0002      0.0299
    [OCN] RunPhase1              864    0.3256      0.3256      0.0004      0.0003      0.0010
  [esm] FinalizePhase1           1      0.0029      0.0020      0.0029      0.0029      0.0029
    [OCN-TO-ATM] FinalizePhase1  1      0.0006      0.0006      0.0006      0.0006      0.0006
    [ATM-TO-OCN] FinalizePhase1  1      0.0002      0.0002      0.0002      0.0002      0.0002
    [OCN] FinalizePhase1         1      0.0001      0.0001      0.0001      0.0001      0.0001
    [ATM] FinalizePhase1         1      0.0000      0.0000      0.0000      0.0000      0.0000
</PRE>

<P>
A timed region is either an ESMF component phase (e.g., initialize,
run, or finalize) or a user-defined region of code surrounded by calls to
<TT>ESMF_TraceRegionEnter()</TT> and <TT>ESMF_TraceRegionExit()</TT>. (See
section <A HREF="#ex:TraceUserEx">50.2.8</A> for more information on instrumenting
user-defined regions.)
Regions are organized hierarchically with sub-regions nested.
For example, in the profile above,
the <TT>[OCN] RunPhase1</TT> is a sub-region of <TT>[esm] RunPhase1</TT> and is
entirely contained inside that region. Regions with the same name may appear
at multiple places in the hierarchy, and so would appear in multiple rows
in the table.  The statistics in that row apply to that region at that
location in the hierarchy. Component names appear in square brackets,
e.g., <TT>[ATM]</TT>,  <TT>[OCN]</TT>, and <TT>[ATM-TO-OCN]</TT>.
By default, timings are based on elapsed wall clock time and are collected
on a per-PET basis. Therefore, regions timings may differ across PETs. Regions
are sorted with the most expensive regions appearing at the top. The following
describes the meaning of the statistics in each column:

<P>
<DL COMPACT>
<DT><TT>Count</TT></DT>
<DD>the number of times the region is executed
</DD>
<DT><TT>Total</TT></DT>
<DD>the aggregate time spent in the region, inclusive of all sub-regions
</DD>
<DT><TT>Self</TT></DT>
<DD>the aggregate time spend in the region, exclusive of all sub-regions
</DD>
<DT><TT>Mean</TT></DT>
<DD>the average amount of time for one execution of the region
</DD>
<DT><TT>Min</TT></DT>
<DD>time of the fastest execution of the region
</DD>
<DT><TT>Max</TT></DT>
<DD>time of the slowest execution of the region
</DD>
</DL>

<P>

<H3><A NAME="SECTION060132200000000000000"></A>
<A NAME="sec:SummaryProfiling"></A>
<BR>
50.2.2 Summarize Timings across Multiple PETs
</H3>

<P>
By default, separate timing profiles are generated for each PET
in the application.  The per-PET profiles can be aggregated together
and output to a single file, <EM>ESMF_Profile.summary</EM>, by setting the
<TT>ESMF_RUNTIME_PROFILE_OUTPUT</TT> environment variable as follows:

<P>
<PRE>
$ setenv ESMF_RUNTIME_PROFILE ON              # turn on profiling
$ setenv ESMF_RUNTIME_PROFILE_OUTPUT SUMMARY  # specify summary output
</PRE>

<P>
Note the <TT>ESMF_RUNTIME_PROFILE</TT> environment variable must
also be set to <TT>ON</TT> since this controls all profiling capabilities.
The <EM>ESMF_Profile.summary</EM> file will contain a tree of
timed regions, but aggregated across all PETs. For example:

<P>
<PRE>
Region                           PETs   Count    Mean (s)    Min (s)     Min PET Max (s)     Max PET
  [esm] Init 1                   4      1        4.0880      4.0878      2       4.0883      1
    [OCN-TO-ATM] IPDv05p6b       4      1        2.6007      2.6007      2       2.6007      3
    [ATM-TO-OCN] IPDv05p6b       4      1        1.4335      1.4333      0       1.4337      3
    [ATM-TO-OCN] IPDv05p4        4      1        0.0037      0.0007      0       0.0060      1
    [ATM] IPDv00p2               4      1        0.0034      0.0020      1       0.0055      0
    [ATM-TO-OCN] IPDv05p1        4      1        0.0020      0.0007      2       0.0033      3
    [OCN] IPDv00p2               4      1        0.0019      0.0015      3       0.0024      2
    [ATM-TO-OCN] IPDv05p3        4      1        0.0010      0.0008      0       0.0013      1
    [ATM-TO-OCN] IPDv05p2a       4      1        0.0009      0.0007      0       0.0012      3
    [ATM] IPDv00p1               4      1        0.0009      0.0007      3       0.0011      0
    [ATM-TO-OCN] IPDv05p2b       4      1        0.0008      0.0007      0       0.0010      3
    [ATM-TO-OCN] IPDv05p5        4      1        0.0008      0.0007      0       0.0010      3
    [ATM-TO-OCN] IPDv05p6a       4      1        0.0008      0.0005      2       0.0012      3
    [OCN-TO-ATM] IPDv05p3        4      1        0.0008      0.0006      2       0.0010      3
    [OCN-TO-ATM] IPDv05p4        4      1        0.0008      0.0006      0       0.0009      3
    [OCN-TO-ATM] IPDv05p2b       4      1        0.0007      0.0006      2       0.0009      3
    [OCN] IPDv00p1               4      1        0.0007      0.0005      1       0.0009      2
    [OCN-TO-ATM] IPDv05p2a       4      1        0.0007      0.0006      2       0.0009      1
    [OCN-TO-ATM] IPDv05p5        4      1        0.0007      0.0006      0       0.0009      3
    [OCN-TO-ATM] IPDv05p1        4      1        0.0006      0.0005      0       0.0008      1
    [OCN-TO-ATM] IPDv05p6a       4      1        0.0006      0.0004      2       0.0007      1
  [esm] RunPhase1                4      1        2.7444      2.7423      0       2.7454      1
    [OCN-TO-ATM] RunPhase1       4      864      0.6123      0.6004      2       0.6244      1
    [ATM] RunPhase1              4      864      0.5386      0.5296      0       0.5530      1
      ATM:ModelAdvance           4      864      0.3038      0.3022      0       0.3065      1
    [OCN] RunPhase1              4      864      0.3471      0.3256      0       0.3824      1
    [ATM-TO-OCN] RunPhase1       4      864      0.2843      0.1956      1       0.3345      0
  [esm] FinalizePhase1           4      1        0.0029      0.0029      1       0.0030      2
    [OCN-TO-ATM] FinalizePhase1  4      1        0.0007      0.0006      0       0.0008      3
    [ATM-TO-OCN] FinalizePhase1  4      1        0.0002      0.0001      3       0.0002      1
    [OCN] FinalizePhase1         4      1        0.0001      0.0001      3       0.0001      0
    [ATM] FinalizePhase1         4      1        0.0001      0.0000      0       0.0001      2
</PRE>

<P>
The meaning of the statistics in each column in as follows:
<DL COMPACT>
<DT><TT>PETs</TT></DT>
<DD>the number of reporting PETs that executed the region
</DD>
<DT><TT>Count</TT></DT>
<DD>the number of times each reporting PET executed the region
      or ``MULTIPLE'' if not all PETs executed the region the same number of times
</DD>
<DT><TT>Mean</TT></DT>
<DD>the mean across all reporting PETs of the total time spent in the region
</DD>
<DT><TT>Min</TT></DT>
<DD>the minimum across all reporting PETs of the total time spent in the region
</DD>
<DT><TT>Min PET</TT></DT>
<DD>the PET that reported the minimum time
</DD>
<DT><TT>Max</TT></DT>
<DD>the maximum across all reporting PETs of the total time spent in the region
</DD>
<DT><TT>Max PET</TT></DT>
<DD>the PET that reported the maximum time
</DD>
</DL>

<P>
Note that setting the <TT>ESMF_RUNTIME_PROFILE_PETLIST</TT> environment variable
(described below) may reduce the number of reporting PETs. Only reporting PETs are
included in the summary profile. To output both the per-PET and summary timing profiles,
set the <TT>ESMF_RUNTIME_PROFILE_OUTPUT</TT> environment variable as follows:

<P>
<PRE>
$ setenv ESMF_RUNTIME_PROFILE_OUTPUT "TEXT SUMMARY"
</PRE>

<P>

<H3><A NAME="SECTION060132300000000000000"></A>
<A NAME="sec:LimitProfiling"></A>
<BR>
50.2.3 Limit the Set of Profiled PETs
</H3>

<P>
By default, all PETs in an application are profiled. It may be desirable
to only profile a subset of PETs to reduce the amount of output.
An explicit list of PETs can be specified by setting the
<TT>ESMF_RUNTIME_PROFILE_PETLIST</TT> environment variable.
The syntax of this environment variable is to list
PET numbers separated by spaces. PET ranges are also supported using
the ``X-Y'' syntax where X &lt; Y.
For example:

<P>
<PRE>
# only profile PETs 0, 20, and 35 through 39
$ setenv ESMF_RUNTIME_PROFILE_PETLIST "0 20 35-39"
</PRE>

<P>
When used in conjunction with the <TT>SUMMARY</TT> option above, the summarized
profile will only aggregate over the specified set of PETs. The one exception is that
PET 0 is always profiled if <TT>ESMF_RUNTIME_PROFILE=ON</TT>, regardless of the
<TT>ESMF_RUNTIME_TRACE_PETLIST</TT> setting.

<P>

<H3><A NAME="SECTION060132400000000000000"></A>
<A NAME="sec:MPIProfiling"></A>
<BR>
50.2.4 Include MPI Communication in the Profile
</H3>

<P>
MPI functions can be included in the timing profile to indicate how much time
is spent inside communication calls.  This can also help to determine load imbalance
in the system, since large times spent inside MPI may indicate that communication
between PETs is not tightly synchronized.  This option includes <EM>all</EM> MPI calls in
the application, whether or not they originate from the ESMF library.  Here is a partial
example summary profile that contains MPI times:

<P>
<PRE>
Region                           PETs   Count    Mean (s)    Min (s)     Min PET Max (s)     Max PET
  [esm] RunPhase1                8      1        4.9307      4.6867      0       4.9656      1
    [OCN] RunPhase1              8      1824     0.8344      0.8164      0       0.8652      1
    [MED] RunPhase1              8      1824     0.8203      0.7900      5       0.8584      1
    [ATM] RunPhase1              8      1824     0.6387      0.6212      5       0.6610      1
    [ATM-TO-MED] RunPhase1       8      1824     0.5975      0.5317      0       0.6583      5
      MPI_Bcast                  8      1824     0.0443      0.0025      4       0.1231      5
      MPI_Wait                   8      MULTIPLE 0.0421      0.0032      0       0.0998      2
    [MED-TO-OCN] RunPhase1       8      1824     0.4879      0.4497      0       0.5362      4
      MPI_Wait                   8      MULTIPLE 0.0234      0.0030      0       0.0821      4
      MPI_Bcast                  8      1824     0.0111      0.0024      4       0.0273      5
    [OCN-TO-MED] RunPhase1       8      1824     0.4541      0.4075      0       0.4918      4
      MPI_Wait                   8      MULTIPLE 0.0339      0.0017      0       0.0824      4
      MPI_Bcast                  8      1824     0.0194      0.0026      4       0.0452      6
    [MED-TO-ATM] RunPhase1       8      1824     0.4487      0.4005      0       0.4911      5
      MPI_Bcast                  8      1824     0.0338      0.0026      4       0.0942      5
      MPI_Wait                   8      MULTIPLE 0.0241      0.0022      1       0.0817      2
  [esm] Init 1                   8      1        0.6287      0.6287      1       0.6287      4
    [ATM-TO-MED] IPDv05p6b       8      1        0.1501      0.1500      1       0.1501      2
      MPI_Barrier                8      242      0.0082      0.0006      3       0.0157      7
      MPI_Wait                   8      MULTIPLE 0.0034      0.0010      0       0.0053      7
      MPI_Allreduce              8      62       0.0030      0.0003      3       0.0063      7
      MPI_Alltoall               8      6        0.0015      0.0000      1       0.0022      5
      MPI_Allgather              8      21       0.0010      0.0002      1       0.0017      7
      MPI_Waitall                8      MULTIPLE 0.0006      0.0001      3       0.0015      7
      MPI_Send                   8      MULTIPLE 0.0004      0.0001      7       0.0008      6
      MPI_Allgatherv             8      6        0.0001      0.0001      4       0.0001      0
      MPI_Scatter                8      5        0.0000      0.0000      0       0.0000      7
      MPI_Reduce                 8      5        0.0000      0.0000      1       0.0000      0
      MPI_Recv                   8      MULTIPLE 0.0000      0.0000      0       0.0000      3
      MPI_Bcast                  8      1        0.0000      0.0000      0       0.0000      7
</PRE>

<P>
The procedure for including MPI
functions in the timing profile depends on whether the application is
dynamically or statically linked. Most applications are dynamically linked,
however on some systems (such as Cray), static linking may be used.
Note that for either option, ESMF must be built with <TT>ESMF_TRACE_BUILD_LIB=ON</TT>,
which is the default.

<P>
In <EM>dynamically linked applications</EM>, the <TT>LD_PRELOAD</TT> environment variable
must be used when executing the MPI application.  This instructs the dynamic
linker to interpose certain MPI symbols so they can be captured by the ESMF
profiler.  To simplify this process, a script is provided at
<TT>$(ESMF_INSTALL_LIBDIR)/preload.sh</TT> that sets the <TT>LD_PRELOAD</TT> variable.
For example, if you typically execute your application as as follows:

<P>
<PRE>
$ mpirun -np 8 ./myApp
</PRE>

<P>
then you should add the <EM>preload.sh</EM> script in front of the
executable when starting the application as follows:

<P>
<PRE>
# replace $(ESMF_INSTALL_LIBDIR) with absolute path to the ESMF installation lib directory
$ mpirun -np 8 $(ESMF_INSTALL_LIBDIR)/preload.sh ./myApp
</PRE>

<P>
An advantage of this approach is that your application does <EM>not</EM> need to
be recompiled. The MPI timing information will be included in the per-PET profiles and/or the summary
profile, depending on the setting of <TT>ESMF_RUNTIME_PROFILE_OUTPUT</TT>.

<P>
In <EM>statically linked applications</EM>, the application must be re-linked
with specific options provided to the linker.  These options instruct the linker
to wrap the MPI symbols with the ESMF profiling functions. The linking flags that
must be provided are included in the <EM>esmf.mk</EM> Makefile fragment that
is part of the ESMF installation. These link flags should be imported into
your application Makefile, and included in the final link command. To do this,
first import the <EM>esmf.mk</EM> file into your application Makefile. The path
to this file is typically stored in the <TT>ESMFMKFILE</TT> environment variable.
Then, pass the variables <TT>$(ESMF_TRACE_STATICLINKOPTS)</TT> and
<TT>$(ESMF_TRACE_STATICLINKLIBS)</TT> to the final linking command.  For example:

<P>
<PRE>
# import esmf.mk
include $(ESMFMKFILE)

# other makefile targets here...

# example final link command, with $(ESMF_TRACE_STATICLINKOPTS) and $(ESMF_TRACE_STATICLINKLIBS) added
myApp: myApp.o driver.o model.o
	$(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) $(ESMF_F90LINKRPATHS) -o $@ $^ $(ESMF_F90ESMFLINKLIBS) $(ESMF_TRACE_STATICLINKOPTS) $(ESMF_TRACE_STATICLINKLIBS)
</PRE>

<P>
This option will statically wrap all of the MPI functions and include them
in the profile output.  Execute the application in the normal way
with the environment variable <TT>ESMF_RUNTIME_PROFILE</TT> set to <TT>ON</TT>.
You will see the MPI functions included in the timing profile.

<P>

<H3><A NAME="SECTION060132500000000000000">
50.2.5 Output a Detailed Trace for Analysis</A>
</H3>

<P>
ESMF tracing is disabled by default. To enable tracing, set the
<TT>ESMF_RUNTIME_TRACE</TT> environment variable to <TT>ON</TT>. You
do not need to recompile your code to enable tracing.

<P>
<PRE>
# csh shell
$ setenv ESMF_RUNTIME_TRACE ON

# bash shell
$ export ESMF_RUNTIME_TRACE=ON
</PRE>

<P>
When enabled, the default behavior is to trace all PETs of the
ESMF application. Although the ESMF tracer is designed to write
events in a compact form, tracing can produce an extremely
large number of events depending on the total number of PETs and
the length of the run. To reduce output, it is possible to restrict
the PETs that produce trace output by setting the <TT>ESMF_RUNTIME_TRACE_PETLIST</TT>
environment variable. For example, this setting:

<P>
<PRE>
$ setenv ESMF_RUNTIME_TRACE_PETLIST "0 101 192-196"
</PRE>

<P>
will instruct the tracer to only trace PETs 0, 101, and 192 through 196
(inclusive). The syntax of this environment variable is to list
PET numbers separated by spaces. PET ranges are also supported using
the ``X-Y'' syntax where X &lt; Y. For PET counts greater than 100, it is
recommended to set this environment variable. The one exception is that
PET 0 is always traced, regardless of the <TT>ESMF_RUNTIME_TRACE_PETLIST</TT>
setting.

<P>
ESMF's profiling and tracing options can be used together.  A typical
use would be to set <TT>ESMF_RUNTIME_PROFILE=ON</TT> for all PETs to
capture summary timings, and set <TT>ESMF_RUNTIME_TRACE=ON</TT> and
<TT>ESMF_RUNTIME_TRACE_PETLIST</TT> to a subset of of PETs,
such as the root PET of each ESMF component. This helps to keep trace
sizes small while still providing timing summaries over all PETs.

<P>
When tracing is enabled, <TT>phase_enter</TT> and <TT>phase_exit</TT> events will
automatically be recorded for all initialize, run, and finalize phases of all
Components in the application. To trace <EM>only</EM> user-instrumented regions (via
the <TT>ESMF_TraceRegionEnter()</TT> and <TT>ESMF_TraceRegionExit()</TT> calls),
Component-level tracing can be turned off by setting:

<P>
<PRE>
$ setenv ESMF_RUNTIME_TRACE_COMPONENT OFF
</PRE>

<P>
After running an ESMF application with tracing enabled, a directory
called <EM>traceout</EM> will be created in the run directory and it will
contain a <EM>metadata</EM> file and an event stream file <EM>esmf_stream_XXXX</EM>
for each PET with tracing enabled. Together these files form a valid
CTF trace which may be analyzed with any of the tools listed above.

<P>
Trace events are flushed to file at a regular interval. If the application
crashes, some of the most recent events may not be flushed to file. To
maximize the number of events appearing in the trace, an option is available
to flush events to file more frequently. Because this option may have
negative performance implications due to increased file I/O, it is not
recommended unless needed. To turn on eager flushing use:

<P>
<PRE>
$ setenv ESMF_RUNTIME_TRACE_FLUSH EAGER
</PRE>

<P>

<H3><A NAME="SECTION060132600000000000000"></A>
<A NAME="sec:TracingClocks"></A>
<BR>
50.2.6 Set the Clock used for Profiling/Tracing
</H3>

<P>
There are three options for the kind of clock to use to timestamp
events when profiling/tracing an application.
These options are controlled by setting the environment variable
<TT>ESMF_RUNTIME_TRACE_CLOCK</TT>.
<DL COMPACT>
<DT><TT>REALTIME</TT></DT>
<DD>The <TT>REALTIME</TT> clock timestamps events with the current time on
      the system.  This is the default clock if the above environment
      variable is not set.  This setting can be useful when tracing PETs that
      span multiple physical computing nodes assuming that the system clocks
      on each node are adequately synchronized.  On most HPC systems, system
      clocks are periodically updated to stay in sync.  A disadvantage of this
      clock is that periodic adjustments mean the clock is not monotonically
      increasing so some timings may be inaccurate if the system clock jumps
      forward or backward significantly. Testing has shown that this is not
      typically an issue on most systems.
</DD>
<DT><TT>MONOTONIC</TT></DT>
<DD>The <TT>MONOTONIC</TT> clock is guaranteed to be monotonically increasing
      and does not suffer from periodic adjustments.  The timestamps represent
      an amount of time since some arbitrary point in the past.  There is no
      guarantee that these timestamps will be synchronized across physical
      computing nodes, so this option should only be used for tracing a set of PETs
      running on a single physical machine.
</DD>
<DT><TT>MONOTONIC_SYNC</TT></DT>
<DD>The <TT>MONOTONIC_SYNC</TT> clock is similar to the <TT>MONOTONIC</TT> clock
      in that it is guaranteed to be monotonically increasing. In addition, at
      application startup, all PET clocks are synchronized to a common time
      by determining a PET-local offset to be applied to timestamps. Therefore this option
      can be used to compare trace streams across physical nodes.
</DD>
</DL>

<P>

<P>

<P>

<H3><A NAME="SECTION060132700000000000000"></A> <A NAME="ex:TraceEx"></A>
<BR>
50.2.7 Tracing a simple ESMF application
</H3>

<P>
This example illustrates how to trace a simple ESMF
   application and print the event stream using Babeltrace.
   The first part of the code is a module representing
   a trivial ESMF Gridded Component.  The second part is a
   main program that creates and executes the component. 

<P>
<PRE>
module SimpleComp

  use ESMF
  implicit none

  private
  public SetServices

contains

  subroutine SetServices(gcomp, rc)
      type(ESMF_GridComp)   :: gcomp
      integer, intent(out)  :: rc  

      call ESMF_GridCompSetEntryPoint(gcomp, ESMF_METHOD_INITIALIZE, &amp;
           userRoutine=Init, rc=rc)
      call ESMF_GridCompSetEntryPoint(gcomp, ESMF_METHOD_RUN, &amp;
           userRoutine=Run, rc=rc)
      call ESMF_GridCompSetEntryPoint(gcomp, ESMF_METHOD_FINALIZE, &amp;
           userRoutine=Finalize, rc=rc)
      
      rc = ESMF_SUCCESS
      
    end subroutine SetServices

    subroutine Init(gcomp, istate, estate, clock, rc)
      type(ESMF_GridComp):: gcomp
      type(ESMF_State):: istate, estate
      type(ESMF_Clock):: clock
      integer, intent(out):: rc
      
      print *, "Inside Init"
      
    end subroutine Init

    subroutine Run(gcomp, istate, estate, clock, rc)
      type(ESMF_GridComp):: gcomp
      type(ESMF_State):: istate, estate
      type(ESMF_Clock):: clock
      integer, intent(out):: rc
      
      print *, "Inside Run"
      
    end subroutine Run

    subroutine Finalize(gcomp, istate, estate, clock, rc)
      type(ESMF_GridComp):: gcomp
      type(ESMF_State):: istate, estate
      type(ESMF_Clock):: clock
      integer, intent(out):: rc
      
    print *, "Inside Finalize"
    
  end subroutine Finalize 

end module SimpleComp
</PRE>

<P>
<PRE>
program ESMF_TraceEx
</PRE>

<P>
<PRE>
      ! Use ESMF framework module
      use ESMF
      use SimpleComp, only: SetServices
</PRE>

<P>
<PRE>
      implicit none

      ! Local variables  
      integer :: rc, finalrc, i
      type(ESMF_GridComp)     :: gridcomp
</PRE>

<P>
<PRE>
      ! initialize ESMF
      finalrc = ESMF_SUCCESS
      call ESMF_Initialize(vm=vm, defaultlogfilename="TraceEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      ! create the component and then execute
      ! initialize, run, and finalize routines
      gridcomp = ESMF_GridCompCreate(name="test", rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompSetServices(gridcomp, userRoutine=SetServices, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompInitialize(gridcomp, rc=rc)
</PRE>

<P>
<PRE>
      do i=1, 5
         call ESMF_GridCompRun(gridcomp, rc=rc)
      enddo
</PRE>

<P>
<PRE>
      call ESMF_GridCompFinalize(gridcomp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompDestroy(gridcomp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program ESMF_TraceEx
</PRE>

<P>
Assuming the code above is executed on four PETs with
   the environment variable <TT>ESMF_RUNTIME_TRACE</TT> set to
   <TT>ON</TT>, then a folder will be created in the run directory
   called <EM>traceout</EM> containing a <EM>metadata</EM> file and
   four event stream files named <EM>esmf_stream_XXXX</EM>
   where <EM>XXXX</EM> is the PET number.  If Babeltrace is
   available on the system, the list of events can be printed
   by executing the following from the run directory:
   <PRE>
   $ babeltrace ./traceout
</PRE>
   For details about iterating over trace events and performing
   analyses on CTF traces, see the corresponding documentation
   in the tools listed in Section <A HREF="#sec:Tracing">50.1.2</A>.


<P>

<P>

<P>

<H3><A NAME="SECTION060132800000000000000"></A> <A NAME="ex:TraceUserEx"></A>
<BR>
50.2.8 Profiling/Tracing User-defined Code Regions
</H3>

<P>
This example illustrates how to manually instrument code with
   entry and exit points for user-defined code regions. Note that the
   API calls <TT>ESMF_TraceRegionEnter</TT> and <TT>ESMF_TraceRegionExit</TT>
   should always appear in pairs, wrapping a particular section
   of code. The environment variable <TT>ESMF_RUNTIME_TRACE</TT> 
   or <TT>ESMF_RUNTIME_PROFILE</TT> must  
   be set to <TT>ON</TT> to enable these regions. If at least one is not set, the calls to
   <TT>ESMF_TraceRegionEnter</TT> and <TT>ESMF_TraceRegionExit</TT>
   will simply return immediately. For this reason, it is safe to
   leave this instrumentation in application code, even when not being profiled.   

<P>
<PRE>
      ! Use ESMF framework module
      use ESMF
</PRE>

<P>
<PRE>
      implicit none

      ! Local variables  
      integer :: rc, finalrc
      integer :: i, j, tmp
</PRE>

<P>
<PRE>
      ! initialize ESMF
      finalrc = ESMF_SUCCESS
      call ESMF_Initialize(vm=vm, defaultlogfilename="TraceUserEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      ! record entrance into "outer_region"
      call ESMF_TraceRegionEnter("outer_region", rc=rc)

      tmp = 0
      do i=1, 10
         
         ! record entrance into "inner_region_1"
         call ESMF_TraceRegionEnter("inner_region_1", rc=rc)
         ! arbitrary computation
         do j=1,10000
            tmp=tmp+j+i
         enddo
         ! record exit from "inner_region_1"
         call ESMF_TraceRegionExit("inner_region_1", rc=rc)

         tmp = 0
         
         ! record entrance into "inner_region_2"
         call ESMF_TraceRegionEnter("inner_region_2", rc=rc)
         ! arbitrary computation
         do j=1,5000
            tmp=tmp+j+i
         enddo
         ! record exit from "inner_region_2"
         call ESMF_TraceRegionExit("inner_region_2", rc=rc)
      enddo

      ! record exit from "outer_region"
      call ESMF_TraceRegionExit("outer_region", rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_Finalize(rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION060133000000000000000">
50.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limited types of trace events.</B>
  Currently only a few trace event types are available. The tracer may
  be extended in the future to record additional types of events.
</LI>
</OL>

<P>

<H2><A NAME="SECTION060134000000000000000">
50.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060134100000000000000">
50.4.1 ESMF_TraceRegionEnter - Trace user-defined region entry event</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_TraceRegionEnter(name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*), intent(in) :: name
     integer, intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Record an event in the trace for this PET indicating entry
     into a user-defined region with the given name.  This call
     must be paired with a call to <TT>ESMF_TraceRegionExit()</TT>
     with a matching <TT>name</TT> parameter.  User-defined regions may be
     nested.
     If tracing is disabled on the calling PET or for the application
     as a whole, no event will be recorded and
     the call will return immediately.

<P>
The arguments are:
   <DL>
<DT><STRONG>name</STRONG></DT>
<DD>A user-defined name for the region of code being entered
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>     

<P>

<P>

<H3><A NAME="SECTION060134200000000000000">
50.4.2 ESMF_TraceRegionExit - Trace user-defined region exit event</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_TraceRegionExit(name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*), intent(in) :: name
     integer, intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Record an event in the trace for this PET indicating exit
     from a user-defined region with the given name.  This call
     must appear after a call to <TT>ESMF_TraceRegionEnter()</TT>
     with a matching <TT>name</TT> parameter.
     If tracing is disabled on the calling PET or for the application
     as a whole, no event will be recorded and
     the call will return immediately.

<P>
The arguments are:
   <DL>
<DT><STRONG>name</STRONG></DT>
<DD>A user-defined name for the region of code being exited
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>


<H1><A NAME="SECTION060140000000000000000">
51 Fortran I/O and System Utilities</A>
</H1>

<H2><A NAME="SECTION060141000000000000000">
51.1 Description</A>
</H2>

<P>
<A NAME="sec:IOUtil"></A>
<P>
The ESMF Fortran I/O and System utilities provide portable methods to
access capabilities which are often implemented in different
ways amongst different environments.  These utility methods are
divided into three groups: command line access, Fortran I/O, and
sorting.

<P>
Command line arguments may be accessed using three methods:
<TT>ESMF_UtilGetArg()</TT> returns a given command line argument,
<TT>ESMF_UtilGetArgC()</TT> returns a count of the number of command line
arguments available.  Finally, the <TT>ESMF_UtilGetArgIndex()</TT> method
returns the index of a desired argument value, given its keyword name.

<P>
Two I/O methods are implemented: <TT>ESMF_IOUnitGet()</TT>,
to obtain an unopened Fortran unit number within the range of unit numbers that
ESMF is allowed to use, and <TT>ESMF_IOUnitFlush()</TT> to flush the
I/O buffer associated with a specific Fortran unit.

<P>
Finally, the <TT>ESMF_UtilSort()</TT> method sorts integer, floating point,
and character string data types in either ascending or descending order.


<H2><A NAME="SECTION060142000000000000000">
51.2 Use and Examples</A>
</H2>

<P>

<H3><A NAME="SECTION060142100000000000000"></A> <A NAME="fio:unitnumbers"></A>
<BR>
51.2.1 Fortran unit number management
</H3>
The <TT>ESMF_UtilIOUnitGet()</TT> method is provided so that applications
using ESMF can remain free of unit number conflicts -- both when combined
with other third party code, or with ESMF itself.  This call is typically
used just prior to an <TT>OPEN</TT> statement:

<P>
<PRE>
  call ESMF_UtilIOUnitGet (unit=grid_unit, rc=rc)
  open (unit=grid_unit, file='grid_data.dat', status='old', action='read')
</PRE>

<P>
By default, unit numbers between 50 and 99 are scanned to find an unopened
unit number.

<P>
Internally, ESMF also uses <TT>ESMF_UtilIOUnitGet()</TT> when it needs to open
Fortran unit numbers for file I/O.  By using the same API for both user and
ESMF code, unit number collisions can be avoided.

<P>
When integrating ESMF into an application where there are conflicts with
other uses of the same unit number range, such as when hard-coded unit number
values are used, an alternative unit number range can be specified.
The <TT>ESMF_Initialize()</TT> optional arguments <TT>IOUnitLower</TT> and <TT>IOUnitUpper</TT>
may be set as needed.  Note that <TT>IOUnitUpper</TT> must be set to a value higher than
<TT>IOUnitLower</TT>, and that both must be non-negative.  Otherwise <TT>ESMF_Initialize</TT>
will return a return code of <TT>ESMF_FAILURE</TT>.  ESMF itself does not typically need more
than about five units for internal use.

<P>
<PRE>
  call ESMF_Initialize (..., IOUnitLower=120, IOUnitUpper=140)
</PRE>

<P>
All current Fortran environments have preconnected unit numbers, such as
units 5 and 6 for standard input and output, in the single digit range.
So it is recommended that the unit number range is chosen to begin at unit 10
or higher to avoid these preconnected units.

<P>

<H3><A NAME="SECTION060142200000000000000">
51.2.2 Flushing output</A>
</H3>

<P>
Fortran run-time libraries generally use buffering techniques to improve I/O
performance.  However output buffering can be problematic when output is needed,
but is ``trapped'' in the buffer because it is not full.
This is a common occurrance when debugging a program, and inserting <TT>WRITE</TT> statements
to track down the bad area of code.  If the program crashes before the output
buffer has been flushed, the desired debugging output may never be seen -- giving
a misleading indication of where the problem occurred.  It would be desirable
to ensure that the output buffer is flushed at predictable
points in the program in order to get the needed results.
Likewise, in parallel code, predictable flushing of output buffers is a common
requirement, often in conjunction with <TT>ESMF_VMBarrier()</TT> calls.  

<P>
The <TT>ESMF_UtilIOUnitFlush()</TT> API is provided to flush a unit as desired.  Here is
an example of code which prints debug values, and serializes the output to a
terminal in PET order:

<P>
<PRE>
  type(ESMF_VM) :: vm

  integer :: tty_unit
  integer :: me, npets

  call ESMF_Initialize (vm=vm, rc=rc)
  call ESMF_VMGet (vm, localPet=me, petCount=npes)

  call ESMF_UtilIOUnitGet (unit=tty_unit)
  open (unit=tty_unit, file='/dev/tty', status='old', action='write')
  ...
  call ESMF_VMBarrier (vm=vm)
  do, i=0, npets-1
    if (i == me) then
      write (tty_unit, *) 'PET: ', i, ', values are: ', a, b, c
      call ESMF_UtilIOUnitFlush (unit=tty_unit)
    end if
    call ESMF_VMBarrier (vm=vm)
  end do
</PRE>

<H2><A NAME="SECTION060143000000000000000">
51.3 Design and Implementation Notes</A>
</H2>

<P>

<H3><A NAME="SECTION060143100000000000000">
51.3.1 Fortran unit number management</A>
</H3>

<P>
When ESMF needs to open a Fortran I/O unit, it calls <TT>ESMF_IOUnitGet()</TT> to find
an unopened unit number.  As delivered, the range of unit numbers that are
searched are between <TT>ESMF_LOG_FORTRAN_UNIT_NUMBER</TT> (normally set to
50), and <TT>ESMF_LOG_UPPER</TT> (normally set to 99.)
Unopened unit numbers are found by using the Fortran <TT>INQUIRE</TT> statement.

<P>
When integrating ESMF into an application where there are conflicts with
other uses of the same unit number range, an alternative range can be specified
in the <TT>ESMF_Initialize()</TT> call by setting the <TT>IOUnitLower</TT> and <TT>IOUnitUpper</TT>
arguments as needed.  <TT>ESMF_IOUnitGet()</TT> will then search the alternate range
of unit numbers.  Note that <TT>IOUnitUpper</TT> must be set to a value higher than
<TT>IOUnitLower</TT>, and that both must be non-negative.  Otherwise <TT>ESMF_Initialize</TT>
will return a return code of <TT>ESMF_FAILURE</TT>.

<P>
Fortran unit numbers are not standardized in the Fortran 90 Standard.  The standard
only requires that they be non-negative integers.  But other than that, it is
up to the compiler writers and application developers to provide and
use units which work with the particular implementation.  For example,
units 5 and 6 are a defacto standard for ``standard input'' and
``standard output'' -- even though this is not specified in the actual Fortran
standard.  The Fortran standard also does not specify which unit numbers can
be used, nor does it specify how many can be open simultaneously.

<P>
Since all current compilers have preconnected unit numbers, and these are
typically found on units lower than 10, it is recommended that applications
use unit numbers 10 and higher.

<P>

<H3><A NAME="SECTION060143200000000000000">
51.3.2 Flushing output</A>
</H3>

<P>
When ESMF needs to flush a Fortran unit, the <TT>ESMF_IOUnitFlush()</TT> API is used
to centralize the file flushing capability, because Fortran has not historically
had a standard mechanism for flushing output buffers.  Most compilers run-time libraries
support various library extensions to provide this functionality -- though,
being non-standard, the spelling and number of arguments vary between implementations.
Fortran 2003 also provides for a <TT>FLUSH</TT> statement which is built into the
language.  When possible, <TT>ESMF_IOUnitFlush()</TT> uses the F2003 <TT>FLUSH</TT> statement.
With older compilers, the appropriate library call is made.

<P>

<H3><A NAME="SECTION060143300000000000000">
51.3.3 Sorting algorithms</A>
</H3>

<P>
The <TT>ESMF_UtilSort()</TT> algorithms are the same as those in the <TT>LAPACK</TT>
sorting procedures <TT>SLASRT()</TT> and <TT>DLASRT()</TT>.  Two algorithms are used.
For small sorts, arrays with 20 or fewer elements, a simple Insertion sort is
used.  For larger sorts, a Quicksort algorithm is used.

<P>
Compared to the original <TT>LAPACK</TT> code, a full Fortran 90 style
interface is supported for ease of use and enhanced compile time checking.
Additional support is also provided for integer and character string data
types.

<H2><A NAME="SECTION060144000000000000000">
51.4 Utility API</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060144100000000000000">
51.4.1 ESMF_UtilGetArg - Return a command line argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilGetArg(argindex, argvalue, arglength, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,      intent(in)            :: argindex
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*), intent(out), optional :: argvalue
     integer,      intent(out), optional :: arglength
     integer,      intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method returns a copy of a command line argument specified
   when the process was started.  This argument is the same as an
   equivalent C++ program would find in the argv array.

<P>
Some MPI implementations do not consistently provide command line
   arguments on PETs other than PET 0.  It is therefore recommended
   that PET 0 call this method and broadcast the results to the other
   PETs by using the <TT>ESMF_VMBroadcast()</TT> method.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>argindex</STRONG></DT>
<DD>A non-negative index into the command line argument <TT>argv</TT> array.
   If argindex is negative or greater than the number of user-specified
   arguments, <TT>ESMF_RC_ARG_VALUE</TT> is returned in the <TT>rc</TT> argument.
   
</DD>
<DT><STRONG>[argvalue]</STRONG></DT>
<DD>Returns a copy of the desired command line argument.  If the provided
   character string is longer than the command line argument, the string
   will be blank padded.  If the string is too short, truncation will
   occur and <TT>ESMF_RC_ARG_SIZE</TT> is returned in the <TT>rc</TT> argument.
   
</DD>
<DT><STRONG>[arglength]</STRONG></DT>
<DD>Returns the length of the desired command line argument in characters.
   The length result does not depend on the length of the <TT>value</TT>
   string.  It may be used to query the length of the argument.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060144200000000000000">
51.4.2 ESMF_UtilGetArgC - Return number of command line arguments</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilGetArgC(count, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, intent(out)           :: count
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method returns the number of command line arguments specified
   when the process was started.

<P>
The number of arguments returned does not include the name of the
   command itself - which is typically returned as argument zero.

<P>
Some MPI implementations do not consistently provide command line
   arguments on PETs other than PET 0.  It is therefore recommended
   that PET 0 call this method and broadcast the results to the other
   PETs by using the <TT>ESMF_VMBroadcast()</TT> method.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>count</STRONG></DT>
<DD>Count of command line arguments.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060144300000000000000">
51.4.3 ESMF_UtilGetArgIndex - Return the index of a command line argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilGetArgIndex(argvalue, argindex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*), intent(in)            :: argvalue
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,      intent(out), optional :: argindex
     integer,      intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method searches for, and returns the index of a desired command
   line argument.  An example might be to find a specific keyword
   (e.g., -esmf_path) so that its associated value argument could be
   obtained by adding 1 to the argindex and calling <TT>ESMF_UtilGetArg()</TT>.

<P>
Some MPI implementations do not consistently provide command line
   arguments on PETs other than PET 0.  It is therefore recommended
   that PET 0 call this method and broadcast the results to the other
   PETs by using the <TT>ESMF_VMBroadcast()</TT> method.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>argvalue</STRONG></DT>
<DD>A character string which will be searched for in the command line
   argument list.
   
</DD>
<DT><STRONG>[argindex]</STRONG></DT>
<DD>If the <TT>value</TT> string is found, the position will be returned
   as a non-negative integer.  If the string is not found, a negative
   value will be returned.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060144400000000000000">
51.4.4 ESMF_UtilIOGetCWD - Get the current directory</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilIOGetCWD (pathName, rc)
</PRE><EM>PARAMETERS:</EM>
<PRE>     character(*), intent(out)           :: pathName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,      intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the system-dependent routine to get the current directory from the file
     system.

<P>
The arguments are:
       <DL>
<DT><STRONG>pathName</STRONG></DT>
<DD>Name of the current working directory.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060144500000000000000">
51.4.5 ESMF_UtilIOMkDir - Create a directory in the file system</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_UtilIOMkDir (pathName,  &amp;
        mode, relaxedFlag,  &amp;
        rc)
</PRE><EM>PARAMETERS:</EM>
<PRE>      character(*), intent(in)            :: pathName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,      intent(in),  optional :: mode
      logical,      intent(in),  optional :: relaxedFlag
      integer,      intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the system-dependent routine to create a directory in the file system.

<P>
The arguments are:
       <DL>
<DT><STRONG>pathName</STRONG></DT>
<DD>Name of the directory to be created.
       
</DD>
<DT><STRONG>[mode]</STRONG></DT>
<DD>File permission mode.  Typically an octal constant is used as a value, for example:
         <TT>mode=o'755'</TT>.  If not specified on POSIX-compliant systems, the default
         is <TT>o'755'</TT> - corresponding to owner read/write/execute,
         group read/execute, and world read/execute.  On native Windows, this argument is
         ignored and default security settings are used.
       
</DD>
<DT><STRONG>[relaxedFlag]</STRONG></DT>
<DD>When set to <TT>.true.</TT>, if the directory already exists, <TT>rc</TT>
         will be set to <TT>ESMF_SUCCESS</TT> instead of an error.
         If not specified, the default is <TT>.false.</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060144600000000000000">
51.4.6 ESMF_UtilIORmDir - Remove a directory from the file system</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_UtilIORmDir (pathName,  &amp;
        relaxedFlag, rc)
</PRE><EM>PARAMETERS:</EM>
<PRE>      character(*), intent(in)            :: pathName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      logical,      intent(in),  optional :: relaxedFlag
      integer,      intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Call the system-dependent routine to remove a directory from the file
     system.  Note that the directory must be empty in order to be successfully
     removed.

<P>
The arguments are:
       <DL>
<DT><STRONG>pathName</STRONG></DT>
<DD>Name of the directory to be removed.
       
</DD>
<DT><STRONG>[relaxedFlag]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, and if the specified directory does not exist,
         the error is ignored and <TT>rc</TT> will be set to <TT>ESMF_SUCCESS</TT>.
         If not specified, the default is <TT>.false.</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060144700000000000000">
51.4.7 ESMF_UtilString2Double - Convert a string to floating point real</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_UtilString2Double(string, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     real(ESMF_KIND_R8) :: ESMF_UtilString2Double
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*), intent(in)            :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return the numerical real value represented by the <TT>string</TT>.

<P>
Leading and trailing blanks in <TT>string</TT> are ignored when directly
     converting into integers.

<P>
This procedure may fail when used in an expression in a <TT>write</TT> statement
     with some older, pre-Fortran 2003, compiler environments that do not support
     re-entrant I/O calls.

<P>
The arguments are:
     <DL>
<DT><STRONG>string</STRONG></DT>
<DD>The string to be converted
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060144800000000000000">
51.4.8 ESMF_UtilString2Int - Convert a string to an integer</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_UtilString2Int(string,  &amp;
       specialStringList, specialValueList, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     integer :: ESMF_UtilString2Int
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*), intent(in)            :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*), intent(in),  optional :: specialStringList(:)
     integer,          intent(in),  optional :: specialValueList(:)
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return the numerical integer value represented by the <TT>string</TT>.
     If <TT>string</TT> matches a string in the optional <TT>specialStringList</TT>, the
     corresponding special value will be returned instead.

<P>
If special strings are to be taken into account, both 
     <TT>specialStringList</TT> and <TT>specialValueList</TT> arguments must be
     present and of same size.

<P>
An error is returned, and return value set to 0, if <TT>string</TT> is not
     found in <TT>specialStringList</TT>, and does not convert into an integer
     value.

<P>
Leading and trailing blanks in <TT>string</TT> are ignored when directly
     converting into integers.

<P>
This procedure may fail when used in an expression in a <TT>write</TT> statement
     with some older, pre-Fortran 2003, compiler environments that do not support
     re-entrant I/O calls.

<P>
The arguments are:
     <DL>
<DT><STRONG>string</STRONG></DT>
<DD>The string to be converted
     
</DD>
<DT><STRONG>[specialStringList]</STRONG></DT>
<DD>List of special strings.
     
</DD>
<DT><STRONG>[specialValueList]</STRONG></DT>
<DD>List of values associated with special strings.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060144900000000000000">
51.4.9 ESMF_UtilString2Real - Convert a string to floating point real</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_UtilString2Real(string, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     real :: ESMF_UtilString2Real
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*), intent(in)            :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return the numerical real value represented by the <TT>string</TT>.

<P>
Leading and trailing blanks in <TT>string</TT> are ignored when directly
     converting into integers.

<P>
This procedure may fail when used in an expression in a <TT>write</TT> statement
     with some older, pre-Fortran 2003, compiler environments that do not support
     re-entrant I/O calls.

<P>
The arguments are:
     <DL>
<DT><STRONG>string</STRONG></DT>
<DD>The string to be converted
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601441000000000000000">
51.4.10 ESMF_UtilStringInt2String - convert integer to character string</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     function ESMF_UtilStringInt2String (i, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer, intent(in) :: i
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional  :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>       character(int2str_len (i)) :: ESMF_UtilStringInt2String
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Converts given an integer to string representation.  The returned string is
     sized such that it does not contain leading or trailing blanks.

<P>
This procedure may fail when used in an expression in a <TT>write</TT> statement
     with some older, pre-Fortran 2003, compiler environments that do not support
     re-entrant I/O calls.

<P>
The arguments are:
       <DL>
<DT><STRONG>i</STRONG></DT>
<DD>An integer.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601441100000000000000">
51.4.11 ESMF_UtilStringLowerCase - convert string to lowercase</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     function ESMF_UtilStringLowerCase(string, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character(len=*), intent(in) :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional  :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>       character(len (string)) :: ESMF_UtilStringLowerCase
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Converts given string to lowercase.

<P>
The arguments are:
       <DL>
<DT><STRONG>string</STRONG></DT>
<DD>A character string.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601441200000000000000">
51.4.12 ESMF_UtilStringUpperCase - convert string to uppercase</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_UtilStringUpperCase(string, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character(len=*), intent(in) :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional  :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>       character(len (string)) :: ESMF_UtilStringUpperCase
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Converts given string to uppercase.

<P>
The arguments are:
       <DL>
<DT><STRONG>string</STRONG></DT>
<DD>A character string.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<P>

<P>

<P>

<P>

<H3><A NAME="SECTION0601441300000000000000">
51.4.13 ESMF_UtilIOUnitFlush - Flush output on a unit number</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilIOUnitFlush(unit, rc)
</PRE><EM>PARAMETERS:</EM>
<PRE>     integer, intent(in)            :: unit
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the system-dependent routine to force output on a specific
     Fortran unit number.

<P>
The arguments are:
       <DL>
<DT><STRONG>unit</STRONG></DT>
<DD>A Fortran I/O unit number.  If the unit is not connected to a file,
         no flushing occurs.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION0601441400000000000000">
51.4.14 ESMF_UtilIOUnitGet - Scan for a free I/O unit number</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilIOUnitGet(unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, intent(out)           :: unit
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Scan for, and return, a free Fortran I/O unit number.
     By default, the range of unit numbers returned is between 50 and 99
     (parameters <TT>ESMF_LOG_FORTRAN_UNIT_NUMBER</TT> and <TT>ESMF_LOG_UPPER</TT>
     respectively.) When integrating ESMF into an application where these values
     conflict with other usages, the range of values may be moved by setting the
     optional <TT>IOUnitLower</TT> and <TT>IOUnitUpper</TT> arguments in the initial
     <TT>ESMF_Initialize()</TT> call with values in a safe, alternate, range.

<P>
The Fortran unit number which is returned is not reserved in any way.
     Successive calls without intervening <TT>OPEN</TT> or <TT>CLOSE</TT> statements
     (or other means of connecting to units), might not return a unique unit
     number.  It is recommended that an <TT>OPEN</TT> statement immediately follow
     the call to <TT>ESMF_IOUnitGet()</TT> to activate the unit.

<P>
The arguments are:
       <DL>
<DT><STRONG>unit</STRONG></DT>
<DD>A Fortran I/O unit number.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>


<P>

<P>

<P>

<H3><A NAME="SECTION0601441500000000000000">
51.4.15 ESMF_UtilSort - Sort data </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilSort (list, direction, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;list&gt;, see below for supported values 
   type(ESMF_SortFlag), intent(in) :: direction 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Supported values for &lt;list&gt; are: 
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(inout) :: list(:) 
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(inout) :: list(:) 
   
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), intent(inout) :: list(:) 
   
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), intent(inout) :: list(:) 
   
</DD>
<DT></DT>
<DD>character(len=*), intent(inout) :: list(:) 
   
</DD>
</DL>

<P>
Use Quick Sort, reverting to Insertion sort on lists of 
   size &lt;= 20. 

<P>
This is an ESMFized version of SLASRT from LAPACK version 3.1. 
   Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd. 
   November 2006 

<P>
The arguments are: 
   <DL>
<DT><STRONG>list</STRONG></DT>
<DD>Array of data to be sorted. The original data is overwritten by the 
   sorted data. 
   
</DD>
<DT><STRONG>direction</STRONG></DT>
<DD>Direction of sorting. Legal values are <TT>ESMF_SORT_ASCENDING</TT> 
   and <TT>ESMF_SORT_DESCENDING</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if the sorting is successful. 
   
</DD>
</DL> 

<P>


<HR>
<!--Navigation Panel-->
<A NAME="tex2html2806"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2802"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2796"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2804"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2807"
  HREF="node7.html">6 References</A>
<B> Up:</B> <A NAME="tex2html2803"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html2797"
  HREF="node5.html">4 Infrastructure: Fields and</A>
 &nbsp; <B>  <A NAME="tex2html2805"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
