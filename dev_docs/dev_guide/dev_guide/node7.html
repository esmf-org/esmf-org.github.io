<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2012 (1.2)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>6 Test Harness</TITLE>
<META NAME="description" CONTENT="6 Test Harness">
<META NAME="keywords" CONTENT="dev_guide">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2012">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="dev_guide.css">

<LINK REL="next" HREF="node8.html">
<LINK REL="previous" HREF="node6.html">
<LINK REL="up" HREF="dev_guide.html">
<LINK REL="next" HREF="node8.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html537"
  HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html533"
  HREF="dev_guide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html527"
  HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html535"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html538"
  HREF="node8.html">7 Conventions</A>
<B> Up:</B> <A NAME="tex2html534"
  HREF="dev_guide.html">dev_guide</A>
<B> Previous:</B> <A NAME="tex2html528"
  HREF="node6.html">5 Apps</A>
 &nbsp; <B>  <A NAME="tex2html536"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html539"
  HREF="node7.html#SECTION00071000000000000000">6.1 Specifying Test Harness Tests</A>
<LI><A NAME="tex2html540"
  HREF="node7.html#SECTION00072000000000000000">6.2 Running Test Harness Tests as Part of Unit Tests</A>
<LI><A NAME="tex2html541"
  HREF="node7.html#SECTION00073000000000000000">6.3 Invoking a Single Test Harness Test Case Using gmake</A>
<LI><A NAME="tex2html542"
  HREF="node7.html#SECTION00074000000000000000">6.4 Invoking a Single Test Harness Test Case from the Command Line</A>
<LI><A NAME="tex2html543"
  HREF="node7.html#SECTION00075000000000000000">6.5 Top Level Configuration File</A>
<UL>
<LI><A NAME="tex2html544"
  HREF="node7.html#SECTION00075100000000000000">6.5.1 Problem descriptor file</A>
<LI><A NAME="tex2html545"
  HREF="node7.html#SECTION00075200000000000000">6.5.2 Problem descriptor string syntax</A>
<UL>
<LI><A NAME="tex2html546"
  HREF="node7.html#SECTION00075210000000000000">6.5.2.1 Grid syntax</A>
<LI><A NAME="tex2html547"
  HREF="node7.html#SECTION00075220000000000000">6.5.2.2 Distribution syntax</A>
<LI><A NAME="tex2html548"
  HREF="node7.html#SECTION00075230000000000000">6.5.2.3 Transformation method</A>
<LI><A NAME="tex2html549"
  HREF="node7.html#SECTION00075240000000000000">6.5.2.4 Staggering syntax (Not currently implemented)</A>
</UL>
<LI><A NAME="tex2html550"
  HREF="node7.html#SECTION00075300000000000000">6.5.3 General Data Structures</A>
<LI><A NAME="tex2html551"
  HREF="node7.html#SECTION00075400000000000000">6.5.4 Specifier files</A>
<LI><A NAME="tex2html552"
  HREF="node7.html#SECTION00075500000000000000">6.5.5 Grid Specification</A>
<UL>
<LI><A NAME="tex2html553"
  HREF="node7.html#SECTION00075510000000000000">6.5.5.1 Curvilinear Grid Coordinate Generation (For Future Implementation)</A>
<LI><A NAME="tex2html554"
  HREF="node7.html#SECTION00075520000000000000">6.5.5.2 Specifier file syntax for redistribution</A>
<LI><A NAME="tex2html555"
  HREF="node7.html#SECTION00075530000000000000">6.5.5.3 Specifier file syntax for regridding</A>
</UL>
<LI><A NAME="tex2html556"
  HREF="node7.html#SECTION00075600000000000000">6.5.6 Distribution Specification</A>
<LI><A NAME="tex2html557"
  HREF="node7.html#SECTION00075700000000000000">6.5.7 Class Specification</A>
</UL>
<BR>
<LI><A NAME="tex2html558"
  HREF="node7.html#SECTION00076000000000000000">6.6 Reporting test results</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00070000000000000000"></A>
<A NAME="sec:harness"></A>
<BR>
6 Test Harness
</H1>

<P>
The Test Harness is a flexible test control system intended to provide a thorough 
parameter space exploration of remapping and redistribution of distributed arrays and fields.
The parameter space is defined through configuration files which are interpreted at
run time to perform the desired tests.

<P>
The Test Harness is integrated into the Unit test framework, enabling
the Test Harness to be built and run as part of the Unit tests. The test results 
are reported to a single standard-out file which is located with the unit test 
results.

<P>
The motivation for employing such a hierarchy configuration files is to allow a 
high degree of customization of the test configurations by combining individual 
specification files. Complex combinations of test cases are easily specified in high level terms.
Each class will have its own collection of specification files tailored to the needs of that class.

<P>

<H2><A NAME="SECTION00071000000000000000">
6.1 Specifying Test Harness Tests</A>
</H2>
The test harness code consists of a single executable that uses a customizable configuration
files which are located within the <TT>&lt;classdir&gt;/tests/harness_config</TT> directory of each 
supported class; currently only ESMF_ARRAY and ESMF_FIELD.

<P>
There are three ways to invoke the test harness, as an integral part of running unit
tests; as a stand-alone test invoked through gmake; and as a standalone test invoked through the command line.

<P>
Running the harness along with the unit tests provides
frequent regression testing of the redistribution and regridding features.  

<P>
Running the test harness
in stand alone mode using gmake is useful for isolating faults in failed test cases.  

<P>
Running the test harness from the command line provides the most control over Test Harness execution.
Understanding the underlying program allows the developer full access to test harness features.  
This is useful in developing makefiles, scripts, and configuration files. 

<P>

<H2><A NAME="SECTION00072000000000000000">
6.2 Running Test Harness Tests as Part of Unit Tests</A>
</H2>
When running as an integral part of the unit tests, the makefile contained in the
<TT>&lt;classdir&gt;/tests</TT> directory of each supported class is executed through the run_unit_tests target.
As part of this target, the makefile selects the desired test harness target using a class
specific environment variable (e.g. ESMF_TESTHARNESS_FIELD).  A default case is provided in
case the environment variable variable is not set.

<P>
The environment variables currently defined are:

<UL>
<LI>ESMF_TESTHARNESS_ARRAY - set target for Array class tests
</LI>
<LI>ESMF_TESTHARNESS_FIELD - set target for Field class tests
</LI>
</UL>

<P>
The targets currently supported for the ESMF_TESTHARNESS_ARRAY variable are:

<UL>
<LI>RUN_ESMF_TestHarnessArray_default - Used to verify functionality of the test harness
</LI>
<LI>RUN_ESMF_TestHarnessArray_1 - Basic test of 2D and 3D redistribution
</LI>
<LI>RUN_ESMF_TestHarnessArray_2 - Quick test of 2D and 3D redistribution
</LI>
<LI>RUN_ESMF_TestHarnessArrayUNI_default - Used to verify functionality of the test harness in uni-PET mode
</LI>
<LI>RUN_ESMF_TestHarnessArrayUNI_1 - Basic test of 2D and 3D redistribution in uni-PET mode
</LI>
<LI>RUN_ESMF_TestHarnessArrayUNI_2 - Quick test of 2D and 3D redistribution in uni-PET mode
</LI>
</UL>

<P>
The targets currently supported for the ESMF_TESTHARNESS_FIELD variable are:

<UL>
<LI>RUN_ESMF_TestHarnessField_default - Used to verify functionality of the test harness
</LI>
<LI>RUN_ESMF_TestHarnessField_1 - Basic test of 2D and 3D regrid
</LI>
<LI>RUN_ESMF_TestHarnessFieldUNI_default - Used to verify functionality of the test harness in uni-PET mode
</LI>
<LI>RUN_ESMF_TestHarnessFieldUNI_1 - Basic test of 2D and 3D regrid in uni-PET mode
</LI>
</UL>

<P>
Each target selects the desired sequence of test cases for that target.
For example, a series of test cases could be developed to run on different days providing partial
test coverage on a particular day, but complete coverage over a week.
In this case, each day would have a separate target and the environment variable would be set for
that day's test case.

<P>
An example of a test harness appears below.
<PRE>
RUN_ESMF_TestHarnessField_1:
	\$(MAKE) TESTHARNESSCASE=field_1 NP=4 run_test_harness
</PRE>

<P>
In this example, the test harness target is RUN_ESMF_TestHarnessField_1.  This target will execute a
single test harness test case. Additional lines can be added if additional steps are desired.
The next section will describe the details of invoking a test case.

<P>

<H2><A NAME="SECTION00073000000000000000">
6.3 Invoking a Single Test Harness Test Case Using gmake</A>
</H2>
A single test harness test case can be invoked from the <TT>&lt;classdir&gt;/tests</TT>
directory through the make command with the local parameters <TT>TESTHARNESSCASE</TT> and
<TT>NP</TT> with the <TT>run_test_harness</TT> target.

<P>
For example,
<PRE>
gmake TESTHARNESSCASE=field_1 NP=4 run_test_harness
</PRE>
will run the test harness test case, <TT>field_1</TT> on <TT>4</TT> processors.

<P>
Each test case is defeined by a series of configuration files in the
<TT>&lt;classdir&gt;/tests/harness_config</TT> directory.  
All of the configuration files for a particular test case will be prefixed with 
<TT>&lt;casename&gt;_</TT> where &lt;classname&gt; is a unique name for the test. 
The top level configuration file will have a suffix of <TT>_test.rc</TT>.
Thus, the top level configuration file for the <TT>field_1</TT> test case will be
<TT>field_1_test.rc</TT>.

<P>
The next section describes invoking the Test Harness from the Command Line.

<P>

<H2><A NAME="SECTION00074000000000000000">
6.4 Invoking a Single Test Harness Test Case from the Command Line</A>
</H2>
The Test Harness is built by invoking gmake from the $ESMF_DIR/src/test_harness/src directory or 
by building all the unit tests. This creates the exececutable file ESMF_TestHarnessUTest in 
the currently selected test directory.

<P>
To run the executable, enter:
<PRE>
\&lt;run path\&gt;ESMF\_TestHarnessUTest \&lt;cmd args\&gt;
where,
\&lt;run path\&gt; is the path to the executable,
and \&lt;cmd args\&gt; are the optional command arguments

The cmd args are as follows:
-path \&lt;config path\&gt;
-case \&lt;case filename\&gt;
-xml \&lt;xml filename\&gt;
-norun
</PRE>

<P>
The path argument sets the path to the configuration files.  All of the configuration files 
for a testcase must reside in the same directory.  If this argument is not present, the current working directory
will be used as the path.

<P>
The case argument is the name of the top level configuration file.  This is described in a later 
section of this document.  If this argument is not present, test_harness.rc will be used.

<P>
The xml argument instructs the test harness to generate an XML test case summary file 
in the current working directory.

<P>
The norun argument instructs the test harness not to run the test cases.  The configuration files will be parsed
and if selected, an XML file will be generated.  The XML file can be post-processed to generate human
readable test configuration summary reports.

<P>
If running under mpi, you would need to prefix this command with the proper mpirun command.

<P>
The next section describes the format of the top level resource file.

<P>

<H2><A NAME="SECTION00075000000000000000"></A>
<A NAME="sec:harness_toplevelfile"></A>
<BR>
6.5 Top Level Configuration File
</H2>
As mentioned above, the top level configuration file will be located in the 
<TT>&lt;classdir&gt;/tests/harness_config</TT> directory and named <TT>&lt;casename&gt;_test.rc</TT>.

<P>
The top level configuration file specifies the test class, the 
format for reporting the test results, and the location and file names containing 
the <I>problem descriptor files</I>. 

<P>
Originally, the test harness had a single configuration file for each class and 
supported only two test cases, a non-exhaustive case and an exhaustive case.
This turned out to be too restrictive and test cases are now selected through environment variables.
Unfortunately, some of the old constructs remain until the obsolete feature is removed.

<P>
Currently, the test harness only uses the non-exhaustive test case for each configuration file.
So, referencing the example below, only the nonexhaustive tag is actually used by the test harness. 

<P>
Also note, that comments are preceded by the # sign, that single parameter values follow 
a single colon : punctuation mark, while tables of multiple parameter values follow, 
and are terminated by, a double set of colon :: punctuation marks.  
This file is read by the <TT>ESMF_Config</TT> class methods, therefore must adhere 
to their specific syntax requirements. 
The entries can be in any order, but the name tags must be exact - including CAPITALIZATION. 
While it is not strictly necessary, the file names are enclosed in quotation marks, 
either single or double, to guarantee they are read correctly.
<PRE>
# Field test Harness Config file

# test class
test_class: FIELD 

# report a summary of the test configurations before actually conducting tests
setup_report: TRUE

# test result report - options are:
# test_report: FULL  - full report presenting both success and failure configs
# test_report: FAILURE - report only failure configurations
# test_report: SUCCESS - report only successful configurations
# test_report: NONE - no report
test_report: FAILURE

# descriptor file for the nonexhaustive case
nonexhaustive::
   'nonexhaustive_descriptor.rc'
::   # end of list

# descriptor files for the exhaustive case (obsolete, but keep in for awhile)
exhaustive::
   'exhaustive_descriptor.rc'
:: # end of list
</PRE>

<P>
The argument for the tag <TT>test_class:</TT> specifies the ESMF class to be tested. 
Here it is Field.The tag  <TT>setup_report:</TT> specifies if a setup report is sent to the test report. 
The tag  <TT>test_report:</TT> specifies the style of report to be constructed. 
This report is appended to the standard-out file which is located with the Unit test results. 
The tag <TT>nonexhaustive::</TT> delimits a table which contains the file names of 
problem descriptor files pertaining to the current test configuration. 

<P>
The tag exhaustive is obsolete and will be removed when time permits.  It has been replaced with the Test Harness
environment variables which can select the desired test case from the available portfolio.

<P>

<H3><A NAME="SECTION00075100000000000000"></A>
<A NAME="sec:harness_problemdescriptorfile"></A>
<BR>
6.5.1 Problem descriptor file
</H3>

<P>
The problem descriptor files contain <I>descriptor strings</I> that describe the family 
of problems with the same memory topology, distribution, and grid association. 
The files also contain the names of <I>specifier files</I> which complete the descriptions 
contained within the descriptor strings. This structure allows a high level of customization of the test suite.

<P>
The problem descriptor file contains only one table, again conforming to the <TT>ESMF_Config</TT> class standard. 
The contents of the table must be delimited by the tag <TT>problem_descriptor_string::</TT>. 
The first element on the line, enclosed by quotes, is the problem descriptor string itself. 
Since the descriptor strings contain gaps and special characters, it is necessary 
to enclose the strings in quotation marks to guarantee proper parsing. 
The problem descriptor table may contain any number of descriptor strings, 
up to the limit imposed by the <TT>ESMF_Config</TT> class, each on a new line. 
Lines can be continued by use of an ampersand &amp; as a continuation symbol 
at the beginning of any continued line. 
The syntax of the problem descriptor string follows the field taxonomy syntax. 
The following is a basic redistribution example.
<PRE>
# Basic redistribution example
#####################################
problem_descriptor_string::
'[B1G1;B2G2] --&gt; [B1G1;B2G2]'  -d Dist.rc -g Grid.rc 
'[B1G1;B2G2] --&gt; [B1G2;B2G1]'  -d DistGrid.rc 
 &amp; otherDistGrid.rc yetanotherDistGrid.rc
 &amp;  -g Grid.rc anotherGrid.rc  
::   # end of list
</PRE>
In the above example, the two problem descriptor strings specify that a redistribution test 
is to be conducted, indicated by the syntax  <TT>-&gt;</TT>, between a pair of rank two blocks of memory. 
Following the problem descriptor string, are multiple flags and the names of specifier files. 
Each flag indicates a portion of the configuration space which is defined by the contents 
of the indicated specifier files.  
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><EM>argument </EM></TD>
<TD ALIGN="CENTER"><EM>definition</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">-d</TD>
<TD ALIGN="CENTER">DELayout/DistGrid specification</TD>
</TR>
<TR><TD ALIGN="CENTER">-g</TD>
<TD ALIGN="CENTER">Grid specification</TD>
</TR>
</TABLE>
</DIV>
The filenames following a flag are used to specify the values for the parameter associated with that flag. 
The specified values from each file are combined to define that parameter's span of values.  
All the files associated with all the flags are combined to define the full ensemble of tests. 
The first problem descriptor string in the example indicates that the ensemble of distribution 
configurations to be tested are specified by the configurations contained within the file <TT>Dist.rc</TT>. 
Similarly, the range of grid configurations are specified within the single file <TT>Grid.rc</TT>. 
For the second problem descriptor string, the ensemble of distribution configurations 
to be tested are specified by the union of configurations contained within the 
three files <TT>DistGrid.rc</TT>, <TT>otherDistGrid.rc</TT>, and <TT>yetanotherDistGrid.rc</TT>. 
While in the first case, the range of grid configurations is specified by the single 
file <TT>Grid.rc</TT>, the second case adds the configurations found in <TT>anotherGrid.rc</TT> to the ensemble.

<P>

<H3><A NAME="SECTION00075200000000000000">
6.5.2 Problem descriptor string syntax</A>
</H3>
The problem descriptor string is contained in the problem descriptor file and describes a 
class of tests to be conducted. 
The basic syntax describes a contiguous chunk of memory spanned by some sort of logically 
rectangular indexing, where the left most index varies fastest in memory. 
Each semicolon delineated entry is associated with a native array dimension. 
The index locations are replaced by signifiers that express associations and distributions 
of the memory through the use of short descriptors. 

<P>
For example <!-- MATH
 $[ G1 \; ; G2 ]$
 -->
 indicates that a 2D logically rectangular block of memory 
is associated with a 2D grid in its natural order. 
The signifier  represents an undistributed tensor grid. 
Reversing the grid signifiers  indicates that the fastest varying dimension 
is instead associated with the second grid dimension. 
Specific information about the grid, such as its size, type, topology are left to be defined 
by the specifier files. It is the associations between memory and the grid that are stressed with this syntax.

<P>
To distribute the grid, a distribution signifier is needed. 
The block distribution of each memory dimension is indicated by the signifier . 
Therefore <!-- MATH
 $[B1 \; G1; \; B2 \; G2; \; G3]$
 -->
 signifies that a 3D logically rectangular block of memory, 
which has a 3D associated grid, is distributed in its first two dimensions, and not its third.

<P>

<H4><A NAME="SECTION00075210000000000000">
6.5.2.1 Grid syntax</A>
</H4>
As we have already seen, the symbol  in the problem descriptor string indicates 
that a dimension of a tensor grid is associated with a memory location. 
Alternatively, an unstructured grid is indicated with the symbol .

<P>
As an example, consider a block of memory. To associate a tensor grid with specific dimensions of that block, 
the symbol  is used with a numerical  suffix  to indicate a specific dimension of the grid. 
The specific aspects of this grid are left undefined at this point, only the fact 
that a particular dimension of a grid is associated with a particular dimension 
of the memory block is implied by the grid syntax. 

<P>
The complete syntax for a tensor grid specification is <!-- MATH
 $G i_g \; + H \{ \# : \# \}$
 -->
 where

<UL>
<LI>where  is the index of the grid axis,
</LI>
<LI><!-- MATH
 $H \{ \# : \# \}$
 -->
, is the optional signifier indicating the upper and lower sizes of the halo, where the  symbols represent integer values. The option of a separate upper and lower values allow the indication of asymmetric haloes.
</LI>
</UL>
The symbol to indicate a halo is appended to the grid description through use of a  sign. Its absence indicates that there is no halo. Currently, only symmetric haloes are supported.

<P>
To illustrate the use of this syntax consider the following example.
<DIV ALIGN="CENTER">
</DIV><PRE>
 [ G1 ; G2 + H{1:1} ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
This string indicates that each memory location of a 2D block of memory is associated with a grid dimension. 
The first memory location with the first grid dimension, and the second memory location 
with the second grid dimension. In addition the second memory index has an asymmetric halo 
of size one at the low end, and size 1 at the high end.

<P>
At times a memory location might have no grid association. 
The symbol  is used in this case as a place holder. For example, 
<DIV ALIGN="CENTER">
</DIV><PRE>
 [ G2 ; G1 ; * ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
indicates that only the first two memory locations are associated with grid dimensions. 
The symbol  located in the last memory location is a placeholder that indicates 
that location in memory has no associations. 
We will see later that the  can be used to indicate that a memory location 
has both no grid and no distribution association. 

<P>
In this example, the grid association has been reversed from from its natural order. 
The first memory location is associated with the second grid dimension, 
and the second memory location with the first grid dimension. 

<P>

<H4><A NAME="SECTION00075220000000000000">
6.5.2.2 Distribution syntax</A>
</H4>
The distribution syntax describes how a contiguous chunk of memory is distributed among the DEs. 
The syntax is analogous to the grid description syntax.Three styles of memory distribution are supported;
<DL>
<DT><STRONG>simple block</STRONG></DT>
<DD>; where  is the distribution space axis.
   
</DD>
<DT><STRONG>full block-cyclic</STRONG></DT>
<DD>; where  is the distribution space axis.  
   
</DD>
<DT><STRONG>arbitrary</STRONG></DT>
<DD>
</DD>
</DL>
Assuming a two dimensional distribution, the expression <!-- MATH
 $[ B1 \; G1; \; B2 \; G2 ]$
 -->
 indicates 
that the two dimensional logically rectangular block of memory is;

<UL>
<LI>associated with a two dimensional grid, in its natural order.
</LI>
<LI>the first memory dimension is distributed according to the first distribution axis.
</LI>
<LI>the second memory dimension is distributed according to the second distribution axis.
</LI>
</UL>
The order of the distribution signifiers can be reversed just as with the grid association. 

<P>
As was mentioned before, the symbol  is used as a place holder to indicate a lack of association. 
If the third memory location of an undistributed block of memory has no grid association, it would look like this;
<DIV ALIGN="CENTER">
</DIV><PRE>
[ G1; G2; * ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
Alternatively if the first two dimensions of a block of memory are distributed, 
but all three have associated grid dimensions it would take the form;
<DIV ALIGN="CENTER">
</DIV><PRE>
[ B1 G1; B2 G2; * G3 ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
An example of where the third memory location would have a grid association, but no distribution, 
is the case where the domain has been decomposed along the horizontal, but not the vertical. 
This is common for a 3D field such as the ocean or atmosphere. 

<P>
Lastly, if the last memory location has no associations, it would look like;
<DIV ALIGN="CENTER">
</DIV><PRE>
[ B1 G1; B2 G2; * * ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
The purpose of the  symbols is increase readability by acting as a place holder. 
An illustrative example of this memory configuration is a two dimensional spatial field 
with multiple species or tracers represented by the third dimension.

<P>

<H4><A NAME="SECTION00075230000000000000">
6.5.2.3 Transformation method</A>
</H4>
The action of redistribution and remapping are signified by the symbols  and  
respectively, where  refers to a character key representing a specific interpolation method. 
The currently supported interpolation methods are  for first order bilinear and  
for the patch recovery method, which provides a smoother first order surface, which can meaningly differentiated. 
Future implementations will include , for first order conservative,  for second order bilinear, 
and  for nearest neighbor. The character  is reserved for unknown or user provided methods. 

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD></TD>
<TD ALIGN="CENTER"><EM>Action</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">B</TD>
<TD ALIGN="CENTER">first order bilinear interpolation</TD>
</TR>
<TR><TD ALIGN="CENTER">P</TD>
<TD ALIGN="CENTER">patch recovery interpolation</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">first order conservative interpolation</TD>
</TR>
<TR><TD ALIGN="CENTER">S</TD>
<TD ALIGN="CENTER">second order conservative interpolation</TD>
</TR>
<TR><TD ALIGN="CENTER">N</TD>
<TD ALIGN="CENTER">nearest neighbor distance weighted average interpolation</TD>
</TR>
<TR><TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">unknown or user provided interpolation</TD>
</TR>
</TABLE>
</DIV>

<P>
The problem descriptor string
<DIV ALIGN="CENTER">
</DIV><PRE>
      [B1 G1; B2 G2 ] --&gt; [B1 G1; B2 G2 ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
indicates an ensemble of redistribution problems where a 2D distributed source field, associated with a 2D grid, is redistributed into a new  2D <EM>destination</EM> distribution. 

<P>
Alternatively the example 
<DIV ALIGN="CENTER">
</DIV><PRE>
      [ B1 G1; B2 G2 ] =C=&gt;  [ B1 G1; B2 G2 ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
indicates the interpolation of one distributed 2D gridded field to another 2D grid using a first order conservative method. The interpolation method of first order conservative is indicated by placing a character  in between a pair of equal  signs. 

<P>

<H4><A NAME="SECTION00075240000000000000">
6.5.2.4 Staggering syntax (Not currently implemented)</A>
</H4>
In addition to the default grid description, the stagger of the associated grid
can be indicated by appending a key with an @ sign to the end of the block memory syntax. Since the stagger relates to the whole grid and not individual components of the grid, it is natural for it to be located outside of the block memory syntax .
<DIV ALIGN="CENTER">
</DIV><PRE>
      [ B1 G1; B2 G2 ] @{#,#}
</PRE>
<DIV ALIGN="CENTER">
</DIV>
The key consists of values enclosed by a pair of brackets . The rank of these values, equals the rank of the associated grid. Thus in the above example, there are two values indicating the stagger since the grid is of rank two. 

<P>
The stagger location key represents the location of a field with respect to the cell center location. It is indicated by relative cartesian coordinates of a unit square, cube etc. To illustrate this further, consider the example of a 2D grid. The cell is represented by a unit square with the xy axis placed at its center, with the positive x-axis oriented <EM>East</EM> and the positive y-axis oriented <EM>North</EM>. The actual values are suppressed, only the directions , and  are used. This geometry is for reference purposes only, and does not literally represent the shape of an actual cell. 

<P>
The cell center, located at the origin of the cell, is indicated by . The corner of the cell is indicated by , where the ones have been dropped to just leave the plus signs. The cell face normal to the X axis (right wall) is indicated by , while the face normal to the Y axis ( top wall) is indicated by . This approach generalizes well to higher dimensions. 
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><EM>argument </EM></TD>
<TD ALIGN="CENTER"><EM>definition</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">Center</TD>
<TD ALIGN="CENTER">{ 0,0 }</TD>
</TR>
<TR><TD ALIGN="CENTER">Corner</TD>
<TD ALIGN="CENTER">{ +,+ }</TD>
</TR>
<TR><TD ALIGN="CENTER">Face normal to X axis</TD>
<TD ALIGN="CENTER">{+,0 }</TD>
</TR>
<TR><TD ALIGN="CENTER">Face normal to Y axis</TD>
<TD ALIGN="CENTER">{0,+ }</TD>
</TR>
</TABLE>
</DIV>

<P>
With these four locations, it is possible to indicate the standard Arakawa grid staggerings. A key of  would be equivalent to an Arakawa A-grid, while a key of  would represent an Arakawa B-grid. Components of the C and D grids would be indicated by wall positions  and .
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><EM>Grid Stagger </EM></TD>
<TD ALIGN="CENTER"><EM>coordinates</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">A-grid</TD>
<TD ALIGN="CENTER">{ 0,0 }</TD>
</TR>
<TR><TD ALIGN="CENTER">B-grid</TD>
<TD ALIGN="CENTER">{ 1,1 }</TD>
</TR>
<TR><TD ALIGN="CENTER">C-grid &amp; D-grid</TD>
<TD ALIGN="CENTER">{ 0,1 } and { 1,0}</TD>
</TR>
</TABLE>
</DIV>
Therefore a key of  in the previous example would indicate that the stagger is located at the cell center location, or the A-grid. Typically the stagger coordinates are suppressed for the A-grid. 

<P>
For example, the string
<PRE>
[B1 G1; B2 G2 ] =C=&gt; [B1 G1; B2 G2 ] @(+,+)
</PRE>
indicates that a collection of regridding tests are to be run where a block distributed two dimensional field, is interpolated from one two dimensional grid onto a second two dimensional grid, using a first order conservative method. The source field data is located at the cell centers (an A-grid stagger location) and the destination field is to be located at north east corner (a B-grid stagger location). Additional information about the pair of grids and their distributions must be specified to run an actual test. 

<P>
This process generalizes to higher dimensions. Consider 
<PRE>
[B1 G1; B2 G2 ; G3 ] =C=&gt; [B1 G1; B2 G2 ; G3 ] @(+,+,+)
</PRE>
indicates that a collection of regridding tests are to be run between a 3D source grid (cell centered) and a 3D destination grid where the field stagger location is the upper corner of the 3D cell (B-grid horizontally and top of the cell vertically).

<P>
A further discussion on grid staggers can be found in section on the ESMF Grid class in the Reference manual.  

<P>

<H3><A NAME="SECTION00075300000000000000">
6.5.3 General Data Structures</A>
</H3>
It is possible to represent more general data structures which cannot be described as simple logically rectangular blocks of memory. These embedded structures are represented by combining multiple contiguous data chunks separated by commas. 

<P>
For example, in models with nested grids or which employ multi-grid methods, it is useful to have an indexed structure of  logically rectangular blocks of memory, where each block is generally a different shape and size. Such a structure can be represented with parentheses as delimiters, such as
<DIV ALIGN="CENTER">
</DIV><PRE>
   ( tile , [ B1 G1; B2 G2 ] )
</PRE>
<DIV ALIGN="CENTER">
</DIV>
Here we have a collection of 2D blocks of memory, each block being associated with a 2D grid and being distributed in both dimensions.

<P>

<H3><A NAME="SECTION00075400000000000000">
6.5.4 Specifier files</A>
</H3>
The <I>problem descriptor strings</I> are augmented by two types of <I>specifier files</I> which complete the description of the test configuration. The specifier files indicate which members of the family described by the <TT>problem descriptor string</TT> are to be tested. The two types of specifier files define the grid and the distribution information needed to completely define a test. The two specifier files define information such as the type, size, and coordinates of the grid, the test function to be interpolated or redistributed, and the size of the distribution.  

<P>
The nature of the grid specifier file varies depending on whether the test is a redistribution or a regridding. A redistribution test takes a field associated with a grid and rearranges it in processor space. So while a source and destination distribution are needed, only a single grid is necessary to conduct the test. A regridding test, on the other hand, takes a field associated with a source grid and interpolates it to a destination grid thaty is also part of a field. In this case both source and destination grids are needed. It is also assumed that a source and destination distribution is specified.
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><EM>Redistribution</EM></TD>
<TD ALIGN="CENTER">source grid</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">source &amp; destination distribution</TD>
</TR>
<TR><TD ALIGN="CENTER"><EM>Regridding</EM></TD>
<TD ALIGN="CENTER">source &amp; destination grids</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">source &amp; destination distribution</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00075500000000000000"></A>
<A NAME="sec:harness_gridspecifier"></A>
<BR>
6.5.5 Grid Specification
</H3>
For the purposes of the test harness, a grid is completely defined in terms of its type, size, coordinates, and units. From this information either a rectilinear or a curvilinear grid is generated. 

<P>
The first step of the grid generation is to generate a rectilinear grid of specified size, range of coordinates, and either uniform or gaussian spacing between the coordinates. If only a rectilinear grid needed, the grid generation is finished. If a curvilinear grid is desired, the rectilinear grid is taken as a base grid and its coordinates are smoothly stretched and/or shrunk according to an analytical function, to produce a curvilinear mesh according.

<P>

<H4><A NAME="SECTION00075510000000000000">
6.5.5.1 Curvilinear Grid Coordinate Generation (For Future Implementation)</A>
</H4>
If a curvilinear grid is desired, the rectilinear grid is taken as a base grid and its coordinates are smoothly stretched and/or shrunk according to an analytical function, to produce a curvilinear mesh according.  
The algebraic grid generation takes the form
<P></P>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{eqnarray*}
X_{ij} &=& \hat{x}_{i} + \epsilon \Delta x \Gamma_{x}(x_{i},y_{j}) \\
Y_{ij} &=& \hat{y}_{j} + \epsilon \Delta y  \Gamma_{y}(x_{i},y_{j})
\end{eqnarray*}
 -->
</DIV>
<BR CLEAR="ALL"><P></P>
where the new curvilinear coordinates  and  are functions of  the original rectilinear grid coordinates  and , a small parameter <!-- MATH
 $0 < \epsilon < 1$
 -->
, the smallest mesh spacings  and , and an analytical function of the coordinates . Four forms of  are supported, a contacted grid, an expanded grid, a symmetric sine perturbed grid, and an asymmetric sine perturbed grid. 

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>key word </EM></TD>
<TD ALIGN="LEFT"><EM>formula </EM><!-- MATH
 $\Gamma(x_{i},y_{j})$
 -->
</TD>
</TR>
<TR><TD ALIGN="LEFT">contracting</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{x}(x_{i},y_{j}) = -(x_{i}/L_{x})(1-x_{i}/L_{x})(0.5-x_{i}/L_{x} )(y_{j}/L_{y})(1-y_{j}/L_{y})$
 -->
</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{y}(x_{i},y_{j}) = -(y_{j}/L_{y})(1-y_{j}/L_{y})(0.5-y_{j}/L_{y} )(x_{i}/L_{x})(1-x_{i}/L_{x})$
 -->
</TD>
</TR>
<TR><TD ALIGN="LEFT">expanding</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{x}(x_{i},y_{j}) = +(x_{i}/L_{x})(1-x_{i}/L_{x} )(0.5-x_{i}/L_{x} )(y_{j}/L_{y})(1-y_{j}/L_{y})$
 -->
</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{y}(x_{i},y_{j}) = +(y_{j}/L_{y})(1-y_{j}/L_{y})(0.5-y_{j}/L_{y} )(x_{i}/L_{x})(1-x_{i}/L_{x})$
 -->
</TD>
</TR>
<TR><TD ALIGN="LEFT">symmetric_sin</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{x}(x_{i},y_{j}) = \sin(4 \pi x{i}/L_{x}) \cos(6 \pi y_{j})/L_{y})$
 -->
</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{y}(x_{i},y_{j}) = \sin(4 \pi x{i}/L_{x}) \cos(6 \pi y_{j})/L_{y})$
 -->
</TD>
</TR>
<TR><TD ALIGN="LEFT">asymmetric_sin</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{x}(x_{i},y_{j}) = \sin(4 \pi x{i}/L_{x}) \cos(6 \pi y_{j})/L_{y})$
 -->
</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{y}(x_{i},y_{j}) = \sin(4 \pi y{j}/L_{y}) \cos(6 \pi x_{i})/L_{x})$
 -->
</TD>
</TR>
</TABLE>
</DIV>

<P>
These four choices for  equate into four options for analytically generated curvilinear grids.

<P>
Examples of these four curvilinear grid options are plotted in figure&nbsp;<A HREF="#fig:harness_smoothGrids">1</A>.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:harness_smoothGrids"></A><A NAME="1369"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
The four options for smooth curvilinear grids; clockwise from the top left corner, a contacted grid, an expanded grid, a symmetric sine perturbed grid, and an asymmetric sine perturbed grid.</CAPTION>
<TR><TD><TABLE CELLPADDING=3 ALIGN="CENTER">
<TR><TD ALIGN="LEFT"><!-- MATH
 $\scalebox{0.3}{\includegraphics{Harness_ContractedGrid} }$
 -->
</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\scalebox{0.3}{\includegraphics{Harness_ExpandedGrid} }$
 -->
</TD>
</TR>
<TR><TD ALIGN="LEFT"><!-- MATH
 $\scalebox{0.3}{\includegraphics{Harness_SymmetricGrid} }$
 -->
</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\scalebox{0.3}{\includegraphics{Harness_AsymmetricGrid} }$
 -->
</TD>
</TR>
</TABLE></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
This adds up to a total of 2 types of rectilinear grids (uniform and gaussian), each with three options (no connection, spherical pole connection, and a periodic option). A large variety of grids can be formed by mixing and matching the grid types and options. For example a standard latitude-longitude grid on a sphere is formed by using the pair of grid types uniform_periodic and uniform_pole. A gaussian grid is formed with uniform_periodic and gaussian_pole. And a regional grid on a sphere, without periodicity, with uniform and uniform. A summary of the rectilinear grid types is given below. 
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2>Rectilinear grid options</TD>
</TR>
<TR><TD ALIGN="CENTER"><EM>grid type </EM></TD>
<TD ALIGN="LEFT"><EM>modifier</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">UNIFORM</TD>
<TD ALIGN="LEFT"><EM>none </EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
<TR><TD ALIGN="CENTER">GAUSSIAN</TD>
<TD ALIGN="LEFT"><EM>none </EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
</TABLE>
</DIV>

<P>
The various curvilinear grid types are created in the same way of mixing and matching grid type options. A regional expanding grid is formed using the grid types expanding and expanding. Likewise a rotated regional grid is created by
using the grid types rotation_15degrees and rotation_15degrees to indicate the grid type. A summary of the curvilinear grid types is given below. 
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2>Curvilinear grid options</TD>
</TR>
<TR><TD ALIGN="CENTER"><EM>grid type </EM></TD>
<TD ALIGN="LEFT"><EM>modifier</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">CONTRACTING</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
<TR><TD ALIGN="CENTER">EXPANDING</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
<TR><TD ALIGN="CENTER">SYMMETRIC_SIN</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
<TR><TD ALIGN="CENTER">ASYMMETRIC_SIN</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
<TR><TD ALIGN="CENTER">rotation_15degrees</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">rotation_30degrees</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">rotation_30degrees</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
</TABLE>
</DIV>
It should be noted that the rotated grid type only supports non-connected domains, and therefore has no option for _pole and _periodic connectivity.

<P>

<H4><A NAME="SECTION00075520000000000000">
6.5.5.2 Specifier file syntax for redistribution</A>
</H4>
Since a redistribution test takes either an array or a field and rearranges it in processor space, the test requires only a single grid for the source and destination. The information required is:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>parameters to define a grid for redistribution </EM></TD>
</TR>
<TR><TD ALIGN="LEFT">Grid rank</TD>
</TR>
<TR><TD ALIGN="LEFT">Grid dimensions</TD>
</TR>
<TR><TD ALIGN="LEFT">Range of the coordinate axis</TD>
</TR>
<TR><TD ALIGN="LEFT">Coordinate units</TD>
</TR>
</TABLE>
</DIV>

<P>
This is the information is provided by the redistribution grid specifier file.
An example of a redistribution grid specifier file is provided below. 
<DIV ALIGN="CENTER">
</DIV><PRE>
# grid.rc
########################################
map_type: REDISTRIBUTION

# regular rectilinear Grid specification 
map_redist::
#rank spacing  size  range (min/max)  units
#
2  'UNIFORM'  120  -3.14159  3.14159  'RAD'   'UNIFORM'  90  -1.57  1.57  'RAD'   
#
2  'UNIFORM'  400  -180   180  'DEG_E'  'GAUSSIAN'  200 -88   88   'DEG_N'  
::
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
The first piece of information required for the file is the <TT>map_type</TT> key. It should be set to <TT>REDISTRIBUTION</TT> to indicate that it is intended to define grids for a redistribution test. Next is a configuration table which specifies multiple grids. The specification can be stretched over multiple table lines by use of the continuation symbol . The order of information is as follows:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>parameters to define a grid for redistribution </EM></TD>
</TR>
<TR><TD ALIGN="LEFT">Grid rank</TD>
</TR>
<TR><TD ALIGN="LEFT">Grid axis type</TD>
</TR>
<TR><TD ALIGN="LEFT">Grid size</TD>
</TR>
<TR><TD ALIGN="LEFT">Range of the coordinate axis</TD>
</TR>
<TR><TD ALIGN="LEFT">Coordinate units</TD>
</TR>
</TABLE>
</DIV>

<P>
There are two 2D grids specified in the file. The first is a standard uniformly spaced latitude-longitude grid, where none of the grid coordinates has any topological connections. The horizontal coordinates are in radians. The second 2D grid is a gaussian spherical grid. The gaussian grid has a spherical topology and is in degrees. 

<P>
Four types of coordinate units are supported; degrees, radians, meters and kilometers.  Each has multiple equivalent key words. 
 <DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2>Supported units</TD>
</TR>
<TR><TD ALIGN="LEFT"><EM>name </EM></TD>
<TD ALIGN="LEFT"><EM>key word</EM></TD>
</TR>
<TR><TD ALIGN="LEFT">Degrees</TD>
<TD ALIGN="LEFT">DEGREES</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">DEG</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">DEG_E</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">DEG_N</TD>
</TR>
<TR><TD ALIGN="LEFT">Radians</TD>
<TD ALIGN="LEFT">RADIANS</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">RAD</TD>
</TR>
<TR><TD ALIGN="LEFT">Meters</TD>
<TD ALIGN="LEFT">METERS</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">M</TD>
</TR>
<TR><TD ALIGN="LEFT">Kilometers</TD>
<TD ALIGN="LEFT">KILOMETERS</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">KM</TD>
</TR>
</TABLE>
</DIV>

<P>

<H4><A NAME="SECTION00075530000000000000">
6.5.5.3 Specifier file syntax for regridding</A>
</H4>
The process of regridding takes a distributed test field from a source grid and interpolates it to a distributed destination grid. Therefore it requires information specifying both a source and destination grid, and an explicit test function to interpolate. The information required is:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>parameters to define a grid for remapping </EM></TD>
</TR>
<TR><TD ALIGN="LEFT">source and destination grid rank</TD>
</TR>
<TR><TD ALIGN="LEFT">source and destination grid axis type</TD>
</TR>
<TR><TD ALIGN="LEFT">source and destination grid dimensions</TD>
</TR>
<TR><TD ALIGN="LEFT">source and destination range of coordinate axis</TD>
</TR>
<TR><TD ALIGN="LEFT">source and destination coordinate units</TD>
</TR>
<TR><TD ALIGN="LEFT">test function with parameters to interpolate</TD>
</TR>
</TABLE>
</DIV>

<P>
This information is provided by the regridding grid specifier file.
An example of a regridding grid specifier file is provided below. 
<DIV ALIGN="CENTER">
</DIV><PRE>
# grid.rc
########################################
map_type: REGRID

################################################################################
# grid | source | grid    |    grid   | grid  | units | destination | 
# rank |  tag   | spacing | dimension | range |       |    tag      |
################################################################################
# Grid specification for regridding

#rank spacing  size  range (min/max)  units
map_regrid::
# example of a pair of 2D periodic grids 
2   SRC    UNIFORM_PERIODIC   120   -3.14159  3.14159  RADIANS   
&amp;              UNIFORM_POLE             90    -1.57        1.57        RADIANS   
&amp;   DST    UNIFORM_PERIODIC   120  -180      180             DEG_E   
&amp;              GAUSSIAN_POLE           88    -88        88             DEG_N   
&amp;   FUNCTION    CONSTANT   2.1 0.1  END
::
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
The first piece of information required for the file is the <TT>map_type</TT> key. It should be set to <TT>REGRID</TT> to indicate that it is intended to define grids for a regridding test. Next is a configuration table which specifies multiple pairs of grids. The specification can be stretched over multiple table lines by use of the continuation symbol . The order of information is as follows:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>parameters to define a grid for reremapping </EM></TD>
</TR>
<TR><TD ALIGN="LEFT">Grid rank</TD>
</TR>
<TR><TD ALIGN="LEFT">Source grid axis type</TD>
</TR>
<TR><TD ALIGN="LEFT">Source grid size</TD>
</TR>
<TR><TD ALIGN="LEFT">Source range of the coordinate axis</TD>
</TR>
<TR><TD ALIGN="LEFT">Source coordinate units</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination grid axis type</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination grid size</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination range of the coordinate axis</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination coordinate units</TD>
</TR>
<TR><TD ALIGN="LEFT">Test function and parameters</TD>
</TR>
</TABLE>
</DIV>

<P>
The regridding grid specifier file contains a pair of 2D grids. The source grid is a standard latitude-longitude grid on a spherical topology. The destination grid is a spherical gaussian grid also on a spherical topology. The source grid is in radians, while the destination grid is in degrees. The test function is a periodic function of the grid coordinates. 

<P>
The one new piece of information for the regridding specifier files are the predefined test functions. The test functions provide a physical field to be interpolated and are generated as an analytical function of the grid coordinates. Supported options include:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2>Test functions</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT"><EM>name </EM></TD>
<TD ALIGN="LEFT"><EM>function</EM></TD>
<TD ALIGN="LEFT"><EM>parameters</EM></TD>
</TR>
<TR><TD ALIGN="LEFT">constant</TD>
<TD ALIGN="LEFT">set value at all locations</TD>
<TD ALIGN="LEFT">value, relative error</TD>
</TR>
<TR><TD ALIGN="LEFT">coordinate</TD>
<TD ALIGN="LEFT">set to a multiple of the coordinate values</TD>
<TD ALIGN="LEFT">scale, relative error</TD>
</TR>
<TR><TD ALIGN="LEFT">spherical harmonic</TD>
<TD ALIGN="LEFT">periodic function of the grid coordinates</TD>
<TD ALIGN="LEFT">amplitudes and phases, relative error</TD>
</TR>
</TABLE>
</DIV>

<P>
The CONSTANT value test function sets the field to the value of the first parameter following the name. The second value is the relative error threshold. For example, the test function specification:

<P>
<DIV ALIGN="CENTER">
</DIV><PRE>
&amp;   FUNCTION    CONSTANT   2.1 0.1  END
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
indicates that the field is set to the constant value of , with a relative error threshold 
of . This test function specification holds for grids of any rank. 

<P>
The COORDINATE test function sets the field to the value of the one of the grid coordinates multiplied by the value of the first parameter following the name. The second value is the relative error threshold. For example, the test function specification:

<P>
<DIV ALIGN="CENTER">
</DIV><PRE>
&amp;   FUNCTION    COORDINATEX   0.5 0.1  END
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
indicates that the field is set to one half of the X coordinate values. For a 2D grid the coordinate options include COORDINATEX and COORDINATEY. For a 3D grid there is the additional option of COORDINATEZ. Again, the relative error threshold is .
This test function specification holds for grids of any rank. 

<P>
The SPHERICAL_HARMONIC test function sets the field to the periodic harmonic function 
<!-- MATH
 $|a+b| + a*\cos(2\pi * k_x * x/L_x ) + b*\sin(2\pi * l_y * x/L_y )$
 -->
.
The parameters follow the order

<P>
<DIV ALIGN="CENTER">
</DIV><PRE>
&amp;   FUNCTION    SPHERICAL_HARMONIC  a   kx  b   ly    rel_error  END
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
This test function specification is only valid for 2D grids.     

<P>

<H3><A NAME="SECTION00075600000000000000"></A>
<A NAME="sec:harness_distributionsspecifier"></A>
<BR>
6.5.6 Distribution Specification
</H3>
The purpose of the distribution specification is to characterize the distribution of the grid. It differs from the grid specification in that it is designed to specify the distribution as both absolute values such as  PETs as well as in relative terms based on fractions of the total number of PETs. This second option is intended to allow the distribution space to scale with changing machine resources without having to change the distribution specification file.

<P>
Here is an example of a distribution specification file for block and block cyclic distributions.
<DIV ALIGN="CENTER">
</DIV><PRE>
##################################################
# descriptive | source | source | operator | destination | dest | operator | end
# string      |  tag   |  rank  |  &amp; value |     tag     | rank | &amp; value  | tag
##################################################

# table specifing 2D to 2D distributions
distgrid_block_2d2d::

# example with two fixed distribution sizes
 '(1,2)--&gt;(2,1)'  'SRC' 2  'D1==' 1  'D2==' 2  'DST' 2  'D1==' 2  'D2==' 1  'END'  

# example with one fixed and one variable distribution size
 '(1,n)--&gt;(n,1)'  'SRC' 2  'D1==' 1  'D2=*' 1  'DST' 2  'D1=*' 1  'D2==' 1  'END'  

# example with variable distribution sizes
 '(2n,n/2)--&gt;(n/2,2n)'  'SRC'  2  'D1=*'  2    'D2=*'  0.5  
 &amp;                      'DST'  2  'D1=*'  0.5  'D2=*'  2     'END'

# another example with variable distribution sizes
 '(2n,n/2)--&gt;(2n,(n/2)-1)'  'SRC' 2  'D1=*' 2  'D2=*'  0.5  
 &amp;                          'DST' 2  'D1=*' 2  'D2=*'  0.5  'D2=+' 1   'END'
::

# table specifing 3D to 3D distributions
distgrid_block_3d3d::

# example with two fixed distribution sizes
 '(1,2,1)--&gt;(2,1,1)'  'SRC' 3  'D1==' 1  'D2==' 2  'D3==' 1  
 &amp;                    'DST' 3  'D1==' 2  'D2==' 1  'D3==' 1  'END'  
::
</PRE>
<DIV ALIGN="CENTER">
</DIV>
The contents of the file are tables which specify pairs of distributions. Each table specifies a particular rank of distributions. The first table consists of 2D to 2D distributions, while the second table consists of a 3D to 3D pair of distributions. 
The order of information is as follows:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>parameters to define a grid distribution </EM></TD>
</TR>
<TR><TD ALIGN="LEFT">Descriptive string</TD>
</TR>
<TR><TD ALIGN="LEFT">Source key</TD>
</TR>
<TR><TD ALIGN="LEFT">Source distribution rank</TD>
</TR>
<TR><TD ALIGN="LEFT">Source distribution axis and size for each dimension of the distribution</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination key</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination distribution rank</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination grid size</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination distribution axis and size for each dimension of the distribution</TD>
</TR>
<TR><TD ALIGN="LEFT">Termination key</TD>
</TR>
</TABLE>
</DIV>
The first example in the table starts with a string used by the report as a brief description of the distribution. Such as   which indicates a source distribution of  and a destination distribution of . Next comes a key word, either <TT>SRC</TT> or <TT>DST</TT> to indicate the beginning of the source and destination descriptions, respectively. Following each tag is a specification of the distribution. In the first case a fixed source distribution is specified by the entries  and . This indicates that the source distribution is fixed to be , provided that the test is running with at least two processors. Likewise the destination distribution is fixed to .

<P>
The second example, illustrates how to indicate a scalable distribution. Again the entry  indicates that the first dimension of the distribution is set to one, but the entry  has a different meaning. It takes the total number of PETs NPETS and scales it by one. Therefore the source distribution becomes <!-- MATH
 $1 \times NPETS$
 -->
. It automatically scales with the number of PETs. Likewise, the destination distribution is set to <!-- MATH
 $NPETS \times 1$
 -->
.

<P>
The third example is completely dynamic. Since both  and  are scalable, each dimension starts with  PETs, where  is the square root of  rounded down to the nearest integer. Therefore <!-- MATH
 $N\times N \leq NPETS$
 -->
. So if , Then . If  then  still equals . This base value is then modified by the indicated entries. In this case the source distribution is <!-- MATH
 $2 N \times 1/2 N$
 -->
, since the tag  indicates that first dimension is the result of the base value being multiplied by two, and the second dimension is the result of the base value being multiplied by one half. Likewise, the destination distribution is set to <!-- MATH
 $1/2 N \times 2N$
 -->
, no matter the number of .

<P>
For a rank three scalable distribution,  is the cube root of NPETS rounded down to the next integer. And so on for higher rank distributions. 

<P>
The fourth example illustrates the last option in the syntax. Again, since the distribution specifies two scalable distributions,  is the square root of  rounded down to the nearest integer. The source distribution is exactly the same as in the third example, but destination distribution has a new entry . The first dimension of the destination distribution is set to  by the entry . the second dimension is first set to  by the entry , but then modified further to  by the entry . The resulting destination distribution is <!-- MATH
 $2N \times (1/2)(N) +1$
 -->
. 

<P>
The syntax for modifying the size of the distribution space combines according to the order of the operations. The entries  and , are not identical to  and , which would result in a dimension of size .

<P>
Three operations are supported:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><EM>Distribution specification operations</EM></TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="CENTER">D# ==</TD>
<TD ALIGN="CENTER">specify a fixed value</TD>
</TR>
<TR><TD ALIGN="CENTER">D# =*</TD>
<TD ALIGN="CENTER">multiply a base value by a constant</TD>
</TR>
<TR><TD ALIGN="CENTER">D# =+</TD>
<TD ALIGN="CENTER">add a constant to the base value</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00075700000000000000">
6.5.7 Class Specification</A>
</H3>
The class specific specifier file is current unused, but is made available for future test expansion.

<P>

<H2><A NAME="SECTION00076000000000000000">
6.6 Reporting test results</A>
</H2>
The test harness offers the option of producing a human readable report on the test results. The report consists of a concise summary of the test configuration along with the test results. The test configuration is described in terms of the Field Taxonomy syntax and user provided strings. The intent is not to provide a exhaustive description of the test, but rather to provide a useful description of the failed tests.

<P>
Consider a problem descriptor string consisting of two descriptor strings describing an ensemble of remapping tests. 
<DIV ALIGN="CENTER">
</DIV><PRE>
[ B1 G1; B2 G2 ] =C=&gt; [ B1 G1; B2 G2 ] @{+,+}
[ B1 G1; B2 G2 ] =B=&gt; [ B1 G1; B2 G2 ] @{+,+}
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
Suppose the associated specifier files indicate that the source grid is rectilinear and is 100 X 50 in size. The destination grid is also rectilinear and is 80 X 20 in size. The remapping is conducted from the A-grid position of the source grid to the B-grid stagger of the destination grid. Both grids are block distributed in two ways, 1 X NPETS and NPETS X 1. And suppose that the first dimension of both the source and destination grids are periodic. If the test succeeds for the conservative remapping, but fails for one of the first order bilinear remapping configurations, the reported results
could look something like
<DIV ALIGN="CENTER">
</DIV><PRE>
SUCCESS: [B1 G1; B2 G2 ] =C=&gt; [B1 G1; B2 G2 ] @{+,+}
FAILURE: [B1{1} G1{100}+P; B2{npets} G2{50} ] =B=&gt; 
                         [B1{1} G1{80}+P; B2{npets} G2{20} ] @{+,+}
     failure at line 101 of test.F90
SUCCESS: [ B1{npets} G1{100} +P; B2{1} G2{50} ] =B=&gt; 
                         [ B1{npets} G1{80}+P; B2{1} G2{20} ] @{+,+}
</PRE>
<DIV ALIGN="CENTER">
</DIV>
Notice that the problem descriptor string differs from that of the configuration files. This is because it represents specific realizations of ensemble. For example 
<DIV ALIGN="CENTER">
</DIV><PRE>
[ B1{npets} G1{80}+P; B2{1} G2{20} ] @{+,+}
</PRE>
<DIV ALIGN="CENTER">
</DIV>
indicates that the 2D block of memory is periodic in the first dimension by the addition of the  to the first grid key. The size of the grid is indicated as  by the size arguments appended to the grid indicators  and . The size of the distribution is indicated in the same way as <!-- MATH
 $npets \times 1$
 -->
 by the block distribution indicators <!-- MATH
 $B1 \{ npets \}$
 -->
 and .

<P>
The report indicates that all the test configurations for the conservative remapping are successful. This is indicated by the key word SUCCESS which is followed by the successful problem descriptor string. Since all of the tests in the first case pass,there is no need to include any of the specifier information. For the second ensemble of tests, one configuration passed, while the other failed. In this case, since there is a mixture of successes and failures, the report includes specifier information for all the configurations to help indicate the source of the test failure. 

<P>
The supplemental information, while not a complete problem description, since it lacks items such as the physical coordinates of the grid and the nature of the test field, includes information crucial to isolating the failed test.

<P>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html537"
  HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html533"
  HREF="dev_guide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html527"
  HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html535"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html538"
  HREF="node8.html">7 Conventions</A>
<B> Up:</B> <A NAME="tex2html534"
  HREF="dev_guide.html">dev_guide</A>
<B> Previous:</B> <A NAME="tex2html528"
  HREF="node6.html">5 Apps</A>
 &nbsp; <B>  <A NAME="tex2html536"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
