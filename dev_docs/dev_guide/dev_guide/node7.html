<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018 (Released Feb 1, 2018) -->
<HTML>
<HEAD>
<TITLE>6 Test Harness</TITLE>
<META NAME="description" CONTENT="6 Test Harness">
<META NAME="keywords" CONTENT="dev_guide">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="dev_guide.css">

<LINK REL="next" HREF="node8.html">
<LINK REL="previous" HREF="node6.html">
<LINK REL="up" HREF="dev_guide.html">
<LINK REL="next" HREF="node8.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html537"
  HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html533"
  HREF="dev_guide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html527"
  HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html535"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html538"
  HREF="node8.html">7 Conventions</A>
<B> Up:</B> <A NAME="tex2html534"
  HREF="dev_guide.html">dev_guide</A>
<B> Previous:</B> <A NAME="tex2html528"
  HREF="node6.html">5 Apps</A>
 &nbsp; <B>  <A NAME="tex2html536"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html539"
  HREF="node7.html#SECTION00071000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> Specifying Test Harness Tests</A>
<LI><A NAME="tex2html540"
  HREF="node7.html#SECTION00072000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> Running Test Harness Tests as Part of Unit Tests</A>
<LI><A NAME="tex2html541"
  HREF="node7.html#SECTION00073000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> Invoking a Single Test Harness Test Case Using gmake</A>
<LI><A NAME="tex2html542"
  HREF="node7.html#SECTION00074000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> Invoking a Single Test Harness Test Case from the Command Line</A>
<LI><A NAME="tex2html543"
  HREF="node7.html#SECTION00075000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> Top Level Configuration File</A>
<UL>
<LI><A NAME="tex2html544"
  HREF="node7.html#SECTION00075100000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Problem descriptor file</A>
<LI><A NAME="tex2html545"
  HREF="node7.html#SECTION00075200000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Problem descriptor string syntax</A>
<UL>
<LI><A NAME="tex2html546"
  HREF="node7.html#SECTION00075210000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid syntax</A>
<LI><A NAME="tex2html547"
  HREF="node7.html#SECTION00075220000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Distribution syntax</A>
<LI><A NAME="tex2html548"
  HREF="node7.html#SECTION00075230000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Transformation method</A>
<LI><A NAME="tex2html549"
  HREF="node7.html#SECTION00075240000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Staggering syntax (Not currently implemented)</A>
</UL>
<LI><A NAME="tex2html550"
  HREF="node7.html#SECTION00075300000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> General Data Structures</A>
<LI><A NAME="tex2html551"
  HREF="node7.html#SECTION00075400000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> Specifier files</A>
<LI><A NAME="tex2html552"
  HREF="node7.html#SECTION00075500000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> Grid Specification</A>
<UL>
<LI><A NAME="tex2html553"
  HREF="node7.html#SECTION00075510000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Curvilinear Grid Coordinate Generation (For Future Implementation)</A>
<LI><A NAME="tex2html554"
  HREF="node7.html#SECTION00075520000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Specifier file syntax for redistribution</A>
<LI><A NAME="tex2html555"
  HREF="node7.html#SECTION00075530000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> Specifier file syntax for regridding</A>
</UL>
<LI><A NAME="tex2html556"
  HREF="node7.html#SECTION00075600000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> Distribution Specification</A>
<LI><A NAME="tex2html557"
  HREF="node7.html#SECTION00075700000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class Specification</A>
</UL>
<BR>
<LI><A NAME="tex2html558"
  HREF="node7.html#SECTION00076000000000000000"><SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> Reporting test results</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00070000000000000000"></A>
<A NAME="sec:harness"></A>
<BR>
<SPAN CLASS="arabic">6</SPAN> Test Harness
</H1>

<P>
The Test Harness is a flexible test control system intended to provide a thorough 
parameter space exploration of remapping and redistribution of distributed arrays and fields.
The parameter space is defined through configuration files which are interpreted at
run time to perform the desired tests.

<P>
The Test Harness is integrated into the Unit test framework, enabling
the Test Harness to be built and run as part of the Unit tests. The test results 
are reported to a single standard-out file which is located with the unit test 
results.

<P>
The motivation for employing such a hierarchy configuration files is to allow a 
high degree of customization of the test configurations by combining individual 
specification files. Complex combinations of test cases are easily specified in high level terms.
Each class will have its own collection of specification files tailored to the needs of that class.

<P>

<H2><A NAME="SECTION00071000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> Specifying Test Harness Tests</A>
</H2>
The test harness code consists of a single executable that uses a customizable configuration
files which are located within the <TT>&lt;classdir&gt;/tests/harness_config</TT> directory of each 
supported class; currently only ESMF_ARRAY and ESMF_FIELD.

<P>
There are three ways to invoke the test harness, as an integral part of running unit
tests; as a stand-alone test invoked through gmake; and as a standalone test invoked through the command line.

<P>
Running the harness along with the unit tests provides
frequent regression testing of the redistribution and regridding features.  

<P>
Running the test harness
in stand alone mode using gmake is useful for isolating faults in failed test cases.  

<P>
Running the test harness from the command line provides the most control over Test Harness execution.
Understanding the underlying program allows the developer full access to test harness features.  
This is useful in developing makefiles, scripts, and configuration files. 

<P>

<H2><A NAME="SECTION00072000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> Running Test Harness Tests as Part of Unit Tests</A>
</H2>
When running as an integral part of the unit tests, the makefile contained in the
<TT>&lt;classdir&gt;/tests</TT> directory of each supported class is executed through the run_unit_tests target.
As part of this target, the makefile selects the desired test harness target using a class
specific environment variable (e.g. ESMF_TESTHARNESS_FIELD).  A default case is provided in
case the environment variable variable is not set.

<P>
The environment variables currently defined are:

<UL>
<LI>ESMF_TESTHARNESS_ARRAY - set target for Array class tests
</LI>
<LI>ESMF_TESTHARNESS_FIELD - set target for Field class tests
</LI>
</UL>

<P>
The targets currently supported for the ESMF_TESTHARNESS_ARRAY variable are:

<UL>
<LI>RUN_ESMF_TestHarnessArray_default - Used to verify functionality of the test harness
</LI>
<LI>RUN_ESMF_TestHarnessArray_1 - Basic test of 2D and 3D redistribution
</LI>
<LI>RUN_ESMF_TestHarnessArray_2 - Quick test of 2D and 3D redistribution
</LI>
<LI>RUN_ESMF_TestHarnessArrayUNI_default - Used to verify functionality of the test harness in uni-PET mode
</LI>
<LI>RUN_ESMF_TestHarnessArrayUNI_1 - Basic test of 2D and 3D redistribution in uni-PET mode
</LI>
<LI>RUN_ESMF_TestHarnessArrayUNI_2 - Quick test of 2D and 3D redistribution in uni-PET mode
</LI>
</UL>

<P>
The targets currently supported for the ESMF_TESTHARNESS_FIELD variable are:

<UL>
<LI>RUN_ESMF_TestHarnessField_default - Used to verify functionality of the test harness
</LI>
<LI>RUN_ESMF_TestHarnessField_1 - Basic test of 2D and 3D regrid
</LI>
<LI>RUN_ESMF_TestHarnessFieldUNI_default - Used to verify functionality of the test harness in uni-PET mode
</LI>
<LI>RUN_ESMF_TestHarnessFieldUNI_1 - Basic test of 2D and 3D regrid in uni-PET mode
</LI>
</UL>

<P>
Each target selects the desired sequence of test cases for that target.
For example, a series of test cases could be developed to run on different days providing partial
test coverage on a particular day, but complete coverage over a week.
In this case, each day would have a separate target and the environment variable would be set for
that day's test case.

<P>
An example of a test harness appears below.
<PRE>
RUN_ESMF_TestHarnessField_1:
	\$(MAKE) TESTHARNESSCASE=field_1 NP=4 run_test_harness
</PRE>

<P>
In this example, the test harness target is RUN_ESMF_TestHarnessField_1.  This target will execute a
single test harness test case. Additional lines can be added if additional steps are desired.
The next section will describe the details of invoking a test case.

<P>

<H2><A NAME="SECTION00073000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> Invoking a Single Test Harness Test Case Using gmake</A>
</H2>
A single test harness test case can be invoked from the <TT>&lt;classdir&gt;/tests</TT>
directory through the make command with the local parameters <TT>TESTHARNESSCASE</TT> and
<TT>NP</TT> with the <TT>run_test_harness</TT> target.

<P>
For example,
<PRE>
gmake TESTHARNESSCASE=field_1 NP=4 run_test_harness
</PRE>
will run the test harness test case, <TT>field_1</TT> on <TT>4</TT> processors.

<P>
Each test case is defeined by a series of configuration files in the
<TT>&lt;classdir&gt;/tests/harness_config</TT> directory.  
All of the configuration files for a particular test case will be prefixed with 
<TT>&lt;casename&gt;_</TT> where &lt;classname&gt; is a unique name for the test. 
The top level configuration file will have a suffix of <TT>_test.rc</TT>.
Thus, the top level configuration file for the <TT>field_1</TT> test case will be
<TT>field_1_test.rc</TT>.

<P>
The next section describes invoking the Test Harness from the Command Line.

<P>

<H2><A NAME="SECTION00074000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> Invoking a Single Test Harness Test Case from the Command Line</A>
</H2>
The Test Harness is built by invoking gmake from the $ESMF_DIR/src/test_harness/src directory or 
by building all the unit tests. This creates the exececutable file ESMF_TestHarnessUTest in 
the currently selected test directory.

<P>
To run the executable, enter:
<PRE>
\&lt;run path\&gt;ESMF\_TestHarnessUTest \&lt;cmd args\&gt;
where,
\&lt;run path\&gt; is the path to the executable,
and \&lt;cmd args\&gt; are the optional command arguments

The cmd args are as follows:
-path \&lt;config path\&gt;
-case \&lt;case filename\&gt;
-xml \&lt;xml filename\&gt;
-norun
</PRE>

<P>
The path argument sets the path to the configuration files.  All of the configuration files 
for a testcase must reside in the same directory.  If this argument is not present, the current working directory
will be used as the path.

<P>
The case argument is the name of the top level configuration file.  This is described in a later 
section of this document.  If this argument is not present, test_harness.rc will be used.

<P>
The xml argument instructs the test harness to generate an XML test case summary file 
in the current working directory.

<P>
The norun argument instructs the test harness not to run the test cases.  The configuration files will be parsed
and if selected, an XML file will be generated.  The XML file can be post-processed to generate human
readable test configuration summary reports.

<P>
If running under mpi, you would need to prefix this command with the proper mpirun command.

<P>
The next section describes the format of the top level resource file.

<P>

<H2><A NAME="SECTION00075000000000000000"></A>
<A NAME="sec:harness_toplevelfile"></A>
<BR>
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> Top Level Configuration File
</H2>
As mentioned above, the top level configuration file will be located in the 
<TT>&lt;classdir&gt;/tests/harness_config</TT> directory and named <TT>&lt;casename&gt;_test.rc</TT>.

<P>
The top level configuration file specifies the test class, the 
format for reporting the test results, and the location and file names containing 
the <SPAN  CLASS="textit">problem descriptor files</SPAN>. 

<P>
Originally, the test harness had a single configuration file for each class and 
supported only two test cases, a non-exhaustive case and an exhaustive case.
This turned out to be too restrictive and test cases are now selected through environment variables.
Unfortunately, some of the old constructs remain until the obsolete feature is removed.

<P>
Currently, the test harness only uses the non-exhaustive test case for each configuration file.
So, referencing the example below, only the nonexhaustive tag is actually used by the test harness. 

<P>
Also note, that comments are preceded by the # sign, that single parameter values follow 
a single colon : punctuation mark, while tables of multiple parameter values follow, 
and are terminated by, a double set of colon :: punctuation marks.  
This file is read by the <TT>ESMF_Config</TT> class methods, therefore must adhere 
to their specific syntax requirements. 
The entries can be in any order, but the name tags must be exact - including CAPITALIZATION. 
While it is not strictly necessary, the file names are enclosed in quotation marks, 
either single or double, to guarantee they are read correctly.
<PRE>
# Field test Harness Config file

# test class
test_class: FIELD 

# report a summary of the test configurations before actually conducting tests
setup_report: TRUE

# test result report - options are:
# test_report: FULL  - full report presenting both success and failure configs
# test_report: FAILURE - report only failure configurations
# test_report: SUCCESS - report only successful configurations
# test_report: NONE - no report
test_report: FAILURE

# descriptor file for the nonexhaustive case
nonexhaustive::
   'nonexhaustive_descriptor.rc'
::   # end of list

# descriptor files for the exhaustive case (obsolete, but keep in for awhile)
exhaustive::
   'exhaustive_descriptor.rc'
:: # end of list
</PRE>

<P>
The argument for the tag <TT>test_class:</TT> specifies the ESMF class to be tested. 
Here it is Field.The tag  <TT>setup_report:</TT> specifies if a setup report is sent to the test report. 
The tag  <TT>test_report:</TT> specifies the style of report to be constructed. 
This report is appended to the standard-out file which is located with the Unit test results. 
The tag <TT>nonexhaustive::</TT> delimits a table which contains the file names of 
problem descriptor files pertaining to the current test configuration. 

<P>
The tag exhaustive is obsolete and will be removed when time permits.  It has been replaced with the Test Harness
environment variables which can select the desired test case from the available portfolio.

<P>

<H3><A NAME="SECTION00075100000000000000"></A>
<A NAME="sec:harness_problemdescriptorfile"></A>
<BR>
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Problem descriptor file
</H3>

<P>
The problem descriptor files contain <SPAN  CLASS="textit">descriptor strings</SPAN> that describe the family 
of problems with the same memory topology, distribution, and grid association. 
The files also contain the names of <SPAN  CLASS="textit">specifier files</SPAN> which complete the descriptions 
contained within the descriptor strings. This structure allows a high level of customization of the test suite.

<P>
The problem descriptor file contains only one table, again conforming to the <TT>ESMF_Config</TT> class standard. 
The contents of the table must be delimited by the tag <TT>problem_descriptor_string::</TT>. 
The first element on the line, enclosed by quotes, is the problem descriptor string itself. 
Since the descriptor strings contain gaps and special characters, it is necessary 
to enclose the strings in quotation marks to guarantee proper parsing. 
The problem descriptor table may contain any number of descriptor strings, 
up to the limit imposed by the <TT>ESMF_Config</TT> class, each on a new line. 
Lines can be continued by use of an ampersand &amp; as a continuation symbol 
at the beginning of any continued line. 
The syntax of the problem descriptor string follows the field taxonomy syntax. 
The following is a basic redistribution example.
<PRE>
# Basic redistribution example
#####################################
problem_descriptor_string::
'[B1G1;B2G2] --&gt; [B1G1;B2G2]'  -d Dist.rc -g Grid.rc 
'[B1G1;B2G2] --&gt; [B1G2;B2G1]'  -d DistGrid.rc 
 &amp; otherDistGrid.rc yetanotherDistGrid.rc
 &amp;  -g Grid.rc anotherGrid.rc  
::   # end of list
</PRE>
In the above example, the two problem descriptor strings specify that a redistribution test 
is to be conducted, indicated by the syntax  <TT>-&gt;</TT>, between a pair of rank two blocks of memory. 
Following the problem descriptor string, are multiple flags and the names of specifier files. 
Each flag indicates a portion of the configuration space which is defined by the contents 
of the indicated specifier files.  
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><EM>argument </EM></TD>
<TD ALIGN="CENTER"><EM>definition</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">-d</TD>
<TD ALIGN="CENTER">DELayout/DistGrid specification</TD>
</TR>
<TR><TD ALIGN="CENTER">-g</TD>
<TD ALIGN="CENTER">Grid specification</TD>
</TR>
</TABLE>
</DIV>
The filenames following a flag are used to specify the values for the parameter associated with that flag. 
The specified values from each file are combined to define that parameter's span of values.  
All the files associated with all the flags are combined to define the full ensemble of tests. 
The first problem descriptor string in the example indicates that the ensemble of distribution 
configurations to be tested are specified by the configurations contained within the file <TT>Dist.rc</TT>. 
Similarly, the range of grid configurations are specified within the single file <TT>Grid.rc</TT>. 
For the second problem descriptor string, the ensemble of distribution configurations 
to be tested are specified by the union of configurations contained within the 
three files <TT>DistGrid.rc</TT>, <TT>otherDistGrid.rc</TT>, and <TT>yetanotherDistGrid.rc</TT>. 
While in the first case, the range of grid configurations is specified by the single 
file <TT>Grid.rc</TT>, the second case adds the configurations found in <TT>anotherGrid.rc</TT> to the ensemble.

<P>

<H3><A NAME="SECTION00075200000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Problem descriptor string syntax</A>
</H3>
The problem descriptor string is contained in the problem descriptor file and describes a 
class of tests to be conducted. 
The basic syntax describes a contiguous chunk of memory spanned by some sort of logically 
rectangular indexing, where the left most index varies fastest in memory. 
Each semicolon delineated entry is associated with a native array dimension. 
The index locations are replaced by signifiers that express associations and distributions 
of the memory through the use of short descriptors. 

<P>
For example <!-- MATH
 $[ G1 \; ; G2 ]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="65" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img1.png"
 ALT="$[ G1 \; ; G2 ]$"></SPAN> indicates that a 2D logically rectangular block of memory 
is associated with a 2D grid in its natural order. 
The signifier <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$G$"></SPAN> represents an undistributed tensor grid. 
Reversing the grid signifiers <SPAN CLASS="MATH"><IMG
 WIDTH="61" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$[ G2; G1 ]$"></SPAN> indicates that the fastest varying dimension 
is instead associated with the second grid dimension. 
Specific information about the grid, such as its size, type, topology are left to be defined 
by the specifier files. It is the associations between memory and the grid that are stressed with this syntax.

<P>
To distribute the grid, a distribution signifier is needed. 
The block distribution of each memory dimension is indicated by the signifier <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$B$"></SPAN>. 
Therefore <!-- MATH
 $[B1 \; G1; \; B2 \; G2; \; G3]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="148" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img5.png"
 ALT="$[B1 \; G1; \; B2 \; G2; \; G3]$"></SPAN> signifies that a 3D logically rectangular block of memory, 
which has a 3D associated grid, is distributed in its first two dimensions, and not its third.

<P>

<H4><A NAME="SECTION00075210000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid syntax</A>
</H4>
As we have already seen, the symbol <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$G$"></SPAN> in the problem descriptor string indicates 
that a dimension of a tensor grid is associated with a memory location. 
Alternatively, an unstructured grid is indicated with the symbol <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="$U$"></SPAN>.

<P>
As an example, consider a block of memory. To associate a tensor grid with specific dimensions of that block, 
the symbol <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="$G$"></SPAN> is used with a numerical  suffix  to indicate a specific dimension of the grid. 
The specific aspects of this grid are left undefined at this point, only the fact 
that a particular dimension of a grid is associated with a particular dimension 
of the memory block is implied by the grid syntax. 

<P>
The complete syntax for a tensor grid specification is <!-- MATH
 $G i_g \; + H \{ \# : \# \}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="124" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img7.png"
 ALT="$G i_g \; + H \{ \char93  : \char93  \}$"></SPAN> where

<UL>
<LI>where <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$i_g$"></SPAN> is the index of the grid axis,
</LI>
<LI><!-- MATH
 $H \{ \# : \# \}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="74" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.png"
 ALT="$H \{ \char93  : \char93  \}$"></SPAN>, is the optional signifier indicating the upper and lower sizes of the halo, where the <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img10.png"
 ALT="$\char93 $"></SPAN> symbols represent integer values. The option of a separate upper and lower values allow the indication of asymmetric haloes.
</LI>
</UL>
The symbol to indicate a halo is appended to the grid description through use of a <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.png"
 ALT="$+$"></SPAN> sign. Its absence indicates that there is no halo. Currently, only symmetric haloes are supported.

<P>
To illustrate the use of this syntax consider the following example.
<DIV ALIGN="CENTER">
</DIV><PRE>
 [ G1 ; G2 + H{1:1} ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
This string indicates that each memory location of a 2D block of memory is associated with a grid dimension. 
The first memory location with the first grid dimension, and the second memory location 
with the second grid dimension. In addition the second memory index has an asymmetric halo 
of size one at the low end, and size 1 at the high end.

<P>
At times a memory location might have no grid association. 
The symbol <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="$\ast$"></SPAN> is used in this case as a place holder. For example, 
<DIV ALIGN="CENTER">
</DIV><PRE>
 [ G2 ; G1 ; * ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
indicates that only the first two memory locations are associated with grid dimensions. 
The symbol <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="$\ast$"></SPAN> located in the last memory location is a placeholder that indicates 
that location in memory has no associations. 
We will see later that the <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="$\ast$"></SPAN> can be used to indicate that a memory location 
has both no grid and no distribution association. 

<P>
In this example, the grid association has been reversed from from its natural order. 
The first memory location is associated with the second grid dimension, 
and the second memory location with the first grid dimension. 

<P>

<H4><A NAME="SECTION00075220000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Distribution syntax</A>
</H4>
The distribution syntax describes how a contiguous chunk of memory is distributed among the DEs. 
The syntax is analogous to the grid description syntax.Three styles of memory distribution are supported;
<DL>
<DT><STRONG>simple block</STRONG></DT>
<DD><SPAN CLASS="MATH"><IMG
 WIDTH="38" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img13.png"
 ALT="$B \; i_D$"></SPAN>; where <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img14.png"
 ALT="$i_D$"></SPAN> is the distribution space axis.
   
</DD>
<DT><STRONG>full block-cyclic</STRONG></DT>
<DD><SPAN CLASS="MATH"><IMG
 WIDTH="38" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img15.png"
 ALT="$C \; i_D$"></SPAN>; where <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img14.png"
 ALT="$i_D$"></SPAN> is the distribution space axis.  
   
</DD>
<DT><STRONG>arbitrary</STRONG></DT>
<DD><SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img16.png"
 ALT="$A$"></SPAN>
</DD>
</DL>
Assuming a two dimensional distribution, the expression <!-- MATH
 $[ B1 \; G1; \; B2 \; G2 ]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="116" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.png"
 ALT="$[ B1 \; G1; \; B2 \; G2 ]$"></SPAN> indicates 
that the two dimensional logically rectangular block of memory is;

<UL>
<LI>associated with a two dimensional grid, in its natural order.
</LI>
<LI>the first memory dimension is distributed according to the first distribution axis.
</LI>
<LI>the second memory dimension is distributed according to the second distribution axis.
</LI>
</UL>
The order of the distribution signifiers can be reversed just as with the grid association. 

<P>
As was mentioned before, the symbol <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="$\ast$"></SPAN> is used as a place holder to indicate a lack of association. 
If the third memory location of an undistributed block of memory has no grid association, it would look like this;
<DIV ALIGN="CENTER">
</DIV><PRE>
[ G1; G2; * ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
Alternatively if the first two dimensions of a block of memory are distributed, 
but all three have associated grid dimensions it would take the form;
<DIV ALIGN="CENTER">
</DIV><PRE>
[ B1 G1; B2 G2; * G3 ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
An example of where the third memory location would have a grid association, but no distribution, 
is the case where the domain has been decomposed along the horizontal, but not the vertical. 
This is common for a 3D field such as the ocean or atmosphere. 

<P>
Lastly, if the last memory location has no associations, it would look like;
<DIV ALIGN="CENTER">
</DIV><PRE>
[ B1 G1; B2 G2; * * ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
The purpose of the <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="$\ast$"></SPAN> symbols is increase readability by acting as a place holder. 
An illustrative example of this memory configuration is a two dimensional spatial field 
with multiple species or tracers represented by the third dimension.

<P>

<H4><A NAME="SECTION00075230000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Transformation method</A>
</H4>
The action of redistribution and remapping are signified by the symbols <SPAN CLASS="MATH"><IMG
 WIDTH="38" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$-- \!\!\! &gt;$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="60" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$=\chi=&gt;$"></SPAN> 
respectively, where <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img20.png"
 ALT="$\chi$"></SPAN> refers to a character key representing a specific interpolation method. 
The currently supported interpolation methods are <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$B$"></SPAN> for first order bilinear and <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img21.png"
 ALT="$P$"></SPAN> 
for the patch recovery method, which provides a smoother first order surface, which can meaningly differentiated. 
Future implementations will include <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.png"
 ALT="$C$"></SPAN>, for first order conservative, <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img23.png"
 ALT="$S$"></SPAN> for second order bilinear, 
and <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.png"
 ALT="$N$"></SPAN> for nearest neighbor. The character <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img25.png"
 ALT="$X$"></SPAN> is reserved for unknown or user provided methods. 

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img20.png"
 ALT="$\chi$"></SPAN></TD>
<TD ALIGN="CENTER"><EM>Action</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">B</TD>
<TD ALIGN="CENTER">first order bilinear interpolation</TD>
</TR>
<TR><TD ALIGN="CENTER">P</TD>
<TD ALIGN="CENTER">patch recovery interpolation</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="CENTER">C</TD>
<TD ALIGN="CENTER">first order conservative interpolation</TD>
</TR>
<TR><TD ALIGN="CENTER">S</TD>
<TD ALIGN="CENTER">second order conservative interpolation</TD>
</TR>
<TR><TD ALIGN="CENTER">N</TD>
<TD ALIGN="CENTER">nearest neighbor distance weighted average interpolation</TD>
</TR>
<TR><TD ALIGN="CENTER">X</TD>
<TD ALIGN="CENTER">unknown or user provided interpolation</TD>
</TR>
</TABLE>
</DIV>

<P>
The problem descriptor string
<DIV ALIGN="CENTER">
</DIV><PRE>
      [B1 G1; B2 G2 ] --&gt; [B1 G1; B2 G2 ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
indicates an ensemble of redistribution problems where a 2D distributed source field, associated with a 2D grid, is redistributed into a new  2D <EM>destination</EM> distribution. 

<P>
Alternatively the example 
<DIV ALIGN="CENTER">
</DIV><PRE>
      [ B1 G1; B2 G2 ] =C=&gt;  [ B1 G1; B2 G2 ]
</PRE>
<DIV ALIGN="CENTER">
</DIV>
indicates the interpolation of one distributed 2D gridded field to another 2D grid using a first order conservative method. The interpolation method of first order conservative is indicated by placing a character <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.png"
 ALT="$C$"></SPAN> in between a pair of equal <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.png"
 ALT="$=$"></SPAN> signs. 

<P>

<H4><A NAME="SECTION00075240000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Staggering syntax (Not currently implemented)</A>
</H4>
In addition to the default grid description, the stagger of the associated grid
can be indicated by appending a key with an @ sign to the end of the block memory syntax. Since the stagger relates to the whole grid and not individual components of the grid, it is natural for it to be located outside of the block memory syntax <SPAN CLASS="MATH"><IMG
 WIDTH="31" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img27.png"
 ALT="$[ \cdots ]$"></SPAN>.
<DIV ALIGN="CENTER">
</DIV><PRE>
      [ B1 G1; B2 G2 ] @{#,#}
</PRE>
<DIV ALIGN="CENTER">
</DIV>
The key consists of values enclosed by a pair of brackets <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img28.png"
 ALT="$\{ \cdots \}$"></SPAN>. The rank of these values, equals the rank of the associated grid. Thus in the above example, there are two values indicating the stagger since the grid is of rank two. 

<P>
The stagger location key represents the location of a field with respect to the cell center location. It is indicated by relative cartesian coordinates of a unit square, cube etc. To illustrate this further, consider the example of a 2D grid. The cell is represented by a unit square with the xy axis placed at its center, with the positive x-axis oriented <EM>East</EM> and the positive y-axis oriented <EM>North</EM>. The actual values are suppressed, only the directions <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.png"
 ALT="$+$"></SPAN>, and <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img29.png"
 ALT="$0$"></SPAN> are used. This geometry is for reference purposes only, and does not literally represent the shape of an actual cell. 

<P>
The cell center, located at the origin of the cell, is indicated by <SPAN CLASS="MATH"><IMG
 WIDTH="43" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\{ 0,0 \}$"></SPAN>. The corner of the cell is indicated by <SPAN CLASS="MATH"><IMG
 WIDTH="52" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\{ +,+ \}$"></SPAN>, where the ones have been dropped to just leave the plus signs. The cell face normal to the X axis (right wall) is indicated by <SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img32.png"
 ALT="$\{ +, 0 \}$"></SPAN>, while the face normal to the Y axis ( top wall) is indicated by <SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.png"
 ALT="$\{ 0,+ \}$"></SPAN>. This approach generalizes well to higher dimensions. 
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><EM>argument </EM></TD>
<TD ALIGN="CENTER"><EM>definition</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">Center</TD>
<TD ALIGN="CENTER">{ 0,0 }</TD>
</TR>
<TR><TD ALIGN="CENTER">Corner</TD>
<TD ALIGN="CENTER">{ +,+ }</TD>
</TR>
<TR><TD ALIGN="CENTER">Face normal to X axis</TD>
<TD ALIGN="CENTER">{+,0 }</TD>
</TR>
<TR><TD ALIGN="CENTER">Face normal to Y axis</TD>
<TD ALIGN="CENTER">{0,+ }</TD>
</TR>
</TABLE>
</DIV>

<P>
With these four locations, it is possible to indicate the standard Arakawa grid staggerings. A key of <SPAN CLASS="MATH"><IMG
 WIDTH="43" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\{ 0,0 \}$"></SPAN> would be equivalent to an Arakawa A-grid, while a key of <SPAN CLASS="MATH"><IMG
 WIDTH="52" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\{ +,+ \}$"></SPAN> would represent an Arakawa B-grid. Components of the C and D grids would be indicated by wall positions <SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img32.png"
 ALT="$\{ +, 0 \}$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.png"
 ALT="$\{ 0,+ \}$"></SPAN>.
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><EM>Grid Stagger </EM></TD>
<TD ALIGN="CENTER"><EM>coordinates</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">A-grid</TD>
<TD ALIGN="CENTER">{ 0,0 }</TD>
</TR>
<TR><TD ALIGN="CENTER">B-grid</TD>
<TD ALIGN="CENTER">{ 1,1 }</TD>
</TR>
<TR><TD ALIGN="CENTER">C-grid &amp; D-grid</TD>
<TD ALIGN="CENTER">{ 0,1 } and { 1,0}</TD>
</TR>
</TABLE>
</DIV>
Therefore a key of <SPAN CLASS="MATH"><IMG
 WIDTH="43" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\{ 0,0 \}$"></SPAN> in the previous example would indicate that the stagger is located at the cell center location, or the A-grid. Typically the stagger coordinates are suppressed for the A-grid. 

<P>
For example, the string
<PRE>
[B1 G1; B2 G2 ] =C=&gt; [B1 G1; B2 G2 ] @(+,+)
</PRE>
indicates that a collection of regridding tests are to be run where a block distributed two dimensional field, is interpolated from one two dimensional grid onto a second two dimensional grid, using a first order conservative method. The source field data is located at the cell centers (an A-grid stagger location) and the destination field is to be located at north east corner (a B-grid stagger location). Additional information about the pair of grids and their distributions must be specified to run an actual test. 

<P>
This process generalizes to higher dimensions. Consider 
<PRE>
[B1 G1; B2 G2 ; G3 ] =C=&gt; [B1 G1; B2 G2 ; G3 ] @(+,+,+)
</PRE>
indicates that a collection of regridding tests are to be run between a 3D source grid (cell centered) and a 3D destination grid where the field stagger location is the upper corner of the 3D cell (B-grid horizontally and top of the cell vertically).

<P>
A further discussion on grid staggers can be found in section on the ESMF Grid class in the Reference manual.  

<P>

<H3><A NAME="SECTION00075300000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> General Data Structures</A>
</H3>
It is possible to represent more general data structures which cannot be described as simple logically rectangular blocks of memory. These embedded structures are represented by combining multiple contiguous data chunks separated by commas. 

<P>
For example, in models with nested grids or which employ multi-grid methods, it is useful to have an indexed structure of  logically rectangular blocks of memory, where each block is generally a different shape and size. Such a structure can be represented with parentheses as delimiters, such as
<DIV ALIGN="CENTER">
</DIV><PRE>
   ( tile , [ B1 G1; B2 G2 ] )
</PRE>
<DIV ALIGN="CENTER">
</DIV>
Here we have a collection of 2D blocks of memory, each block being associated with a 2D grid and being distributed in both dimensions.

<P>

<H3><A NAME="SECTION00075400000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> Specifier files</A>
</H3>
The <SPAN  CLASS="textit">problem descriptor strings</SPAN> are augmented by two types of <SPAN  CLASS="textit">specifier files</SPAN> which complete the description of the test configuration. The specifier files indicate which members of the family described by the <TT>problem descriptor string</TT> are to be tested. The two types of specifier files define the grid and the distribution information needed to completely define a test. The two specifier files define information such as the type, size, and coordinates of the grid, the test function to be interpolated or redistributed, and the size of the distribution.  

<P>
The nature of the grid specifier file varies depending on whether the test is a redistribution or a regridding. A redistribution test takes a field associated with a grid and rearranges it in processor space. So while a source and destination distribution are needed, only a single grid is necessary to conduct the test. A regridding test, on the other hand, takes a field associated with a source grid and interpolates it to a destination grid thaty is also part of a field. In this case both source and destination grids are needed. It is also assumed that a source and destination distribution is specified.
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><EM>Redistribution</EM></TD>
<TD ALIGN="CENTER">source grid</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">source &amp; destination distribution</TD>
</TR>
<TR><TD ALIGN="CENTER"><EM>Regridding</EM></TD>
<TD ALIGN="CENTER">source &amp; destination grids</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER">source &amp; destination distribution</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00075500000000000000"></A>
<A NAME="sec:harness_gridspecifier"></A>
<BR>
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> Grid Specification
</H3>
For the purposes of the test harness, a grid is completely defined in terms of its type, size, coordinates, and units. From this information either a rectilinear or a curvilinear grid is generated. 

<P>
The first step of the grid generation is to generate a rectilinear grid of specified size, range of coordinates, and either uniform or gaussian spacing between the coordinates. If only a rectilinear grid needed, the grid generation is finished. If a curvilinear grid is desired, the rectilinear grid is taken as a base grid and its coordinates are smoothly stretched and/or shrunk according to an analytical function, to produce a curvilinear mesh according.

<P>

<H4><A NAME="SECTION00075510000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Curvilinear Grid Coordinate Generation (For Future Implementation)</A>
</H4>
If a curvilinear grid is desired, the rectilinear grid is taken as a base grid and its coordinates are smoothly stretched and/or shrunk according to an analytical function, to produce a curvilinear mesh according.  
The algebraic grid generation takes the form
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{eqnarray*}
X_{ij} &=& \hat{x}_{i} + \epsilon \Delta x \Gamma_{x}(x_{i},y_{j}) \\
Y_{ij} &=& \hat{y}_{j} + \epsilon \Delta y  \Gamma_{y}(x_{i},y_{j})
\end{eqnarray*}
 -->
<IMG
 WIDTH="197" HEIGHT="53" BORDER="0"
 SRC="img34.png"
 ALT="\begin{eqnarray*}
X_{ij} &amp;=&amp; \hat{x}_{i} + \epsilon \Delta x \Gamma_{x}(x_{i},y_...
...{ij} &amp;=&amp; \hat{y}_{j} + \epsilon \Delta y \Gamma_{y}(x_{i},y_{j})
\end{eqnarray*}"></DIV>
<BR CLEAR="ALL"><P></P>
<BR CLEAR="ALL"><P></P>
where the new curvilinear coordinates <SPAN CLASS="MATH"><IMG
 WIDTH="28" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$X_{ij}$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="25" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.png"
 ALT="$Y_{ij}$"></SPAN> are functions of  the original rectilinear grid coordinates <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.png"
 ALT="$\hat{x}_{i}$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$\hat{y}_{j}$"></SPAN>, a small parameter <!-- MATH
 $0 < \epsilon < 1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="69" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.png"
 ALT="$0 &lt; \epsilon &lt; 1$"></SPAN>, the smallest mesh spacings <SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img40.png"
 ALT="$\Delta x$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$\Delta y$"></SPAN>, and an analytical function of the coordinates <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img42.png"
 ALT="$\Gamma$"></SPAN>. Four forms of <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img42.png"
 ALT="$\Gamma$"></SPAN> are supported, a contacted grid, an expanded grid, a symmetric sine perturbed grid, and an asymmetric sine perturbed grid. 

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>key word </EM></TD>
<TD ALIGN="LEFT"><EM>formula </EM><!-- MATH
 $\Gamma(x_{i},y_{j})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="62" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img43.png"
 ALT="$\Gamma(x_{i},y_{j})$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT">contracting</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{x}(x_{i},y_{j}) = -(x_{i}/L_{x})(1-x_{i}/L_{x})(0.5-x_{i}/L_{x} )(y_{j}/L_{y})(1-y_{j}/L_{y})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="466" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$\Gamma_{x}(x_{i},y_{j}) = -(x_{i}/L_{x})(1-x_{i}/L_{x})(0.5-x_{i}/L_{x} )(y_{j}/L_{y})(1-y_{j}/L_{y})$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{y}(x_{i},y_{j}) = -(y_{j}/L_{y})(1-y_{j}/L_{y})(0.5-y_{j}/L_{y} )(x_{i}/L_{x})(1-x_{i}/L_{x})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="465" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img45.png"
 ALT="$\Gamma_{y}(x_{i},y_{j}) = -(y_{j}/L_{y})(1-y_{j}/L_{y})(0.5-y_{j}/L_{y} )(x_{i}/L_{x})(1-x_{i}/L_{x})$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT">expanding</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{x}(x_{i},y_{j}) = +(x_{i}/L_{x})(1-x_{i}/L_{x} )(0.5-x_{i}/L_{x} )(y_{j}/L_{y})(1-y_{j}/L_{y})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="466" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img46.png"
 ALT="$\Gamma_{x}(x_{i},y_{j}) = +(x_{i}/L_{x})(1-x_{i}/L_{x} )(0.5-x_{i}/L_{x} )(y_{j}/L_{y})(1-y_{j}/L_{y})$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{y}(x_{i},y_{j}) = +(y_{j}/L_{y})(1-y_{j}/L_{y})(0.5-y_{j}/L_{y} )(x_{i}/L_{x})(1-x_{i}/L_{x})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="465" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.png"
 ALT="$\Gamma_{y}(x_{i},y_{j}) = +(y_{j}/L_{y})(1-y_{j}/L_{y})(0.5-y_{j}/L_{y} )(x_{i}/L_{x})(1-x_{i}/L_{x})$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT">symmetric_sin</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{x}(x_{i},y_{j}) = \sin(4 \pi x{i}/L_{x}) \cos(6 \pi y_{j})/L_{y})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="284" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img48.png"
 ALT="$\Gamma_{x}(x_{i},y_{j}) = \sin(4 \pi x{i}/L_{x}) \cos(6 \pi y_{j})/L_{y})$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{y}(x_{i},y_{j}) = \sin(4 \pi x{i}/L_{x}) \cos(6 \pi y_{j})/L_{y})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="283" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img49.png"
 ALT="$\Gamma_{y}(x_{i},y_{j}) = \sin(4 \pi x{i}/L_{x}) \cos(6 \pi y_{j})/L_{y})$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT">asymmetric_sin</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{x}(x_{i},y_{j}) = \sin(4 \pi x{i}/L_{x}) \cos(6 \pi y_{j})/L_{y})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="284" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img48.png"
 ALT="$\Gamma_{x}(x_{i},y_{j}) = \sin(4 \pi x{i}/L_{x}) \cos(6 \pi y_{j})/L_{y})$"></SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><!-- MATH
 $\Gamma_{y}(x_{i},y_{j}) = \sin(4 \pi y{j}/L_{y}) \cos(6 \pi x_{i})/L_{x})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="284" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$\Gamma_{y}(x_{i},y_{j}) = \sin(4 \pi y{j}/L_{y}) \cos(6 \pi x_{i})/L_{x})$"></SPAN></TD>
</TR>
</TABLE>
</DIV>

<P>
These four choices for <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img42.png"
 ALT="$\Gamma$"></SPAN> equate into four options for analytically generated curvilinear grids.

<P>
Examples of these four curvilinear grid options are plotted in figure&nbsp;<A HREF="#fig:harness_smoothGrids">1</A>.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:harness_smoothGrids"></A><A NAME="1369"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
The four options for smooth curvilinear grids; clockwise from the top left corner, a contacted grid, an expanded grid, a symmetric sine perturbed grid, and an asymmetric sine perturbed grid.</CAPTION>
<TR><TD><TABLE CELLPADDING=3 ALIGN="CENTER">
<TR><TD ALIGN="LEFT"><!-- MATH
 $\scalebox{0.3}{\includegraphics{Harness_ContractedGrid} }$
 -->
<IMG
 WIDTH="210" HEIGHT="166" ALIGN="BOTTOM" BORDER="0"
 SRC="img51.png"
 ALT="\scalebox{0.3}{\includegraphics{Harness_ContractedGrid} }"></TD>
<TD ALIGN="LEFT"><!-- MATH
 $\scalebox{0.3}{\includegraphics{Harness_ExpandedGrid} }$
 -->
<IMG
 WIDTH="210" HEIGHT="166" ALIGN="BOTTOM" BORDER="0"
 SRC="img52.png"
 ALT="\scalebox{0.3}{\includegraphics{Harness_ExpandedGrid} }"></TD>
</TR>
<TR><TD ALIGN="LEFT"><!-- MATH
 $\scalebox{0.3}{\includegraphics{Harness_SymmetricGrid} }$
 -->
<IMG
 WIDTH="210" HEIGHT="166" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.png"
 ALT="\scalebox{0.3}{\includegraphics{Harness_SymmetricGrid} }"></TD>
<TD ALIGN="LEFT"><!-- MATH
 $\scalebox{0.3}{\includegraphics{Harness_AsymmetricGrid} }$
 -->
<IMG
 WIDTH="210" HEIGHT="166" ALIGN="BOTTOM" BORDER="0"
 SRC="img54.png"
 ALT="\scalebox{0.3}{\includegraphics{Harness_AsymmetricGrid} }"></TD>
</TR>
</TABLE></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
This adds up to a total of 2 types of rectilinear grids (uniform and gaussian), each with three options (no connection, spherical pole connection, and a periodic option). A large variety of grids can be formed by mixing and matching the grid types and options. For example a standard latitude-longitude grid on a sphere is formed by using the pair of grid types uniform_periodic and uniform_pole. A gaussian grid is formed with uniform_periodic and gaussian_pole. And a regional grid on a sphere, without periodicity, with uniform and uniform. A summary of the rectilinear grid types is given below. 
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN>Rectilinear grid options</SPAN></TD>
</TR>
<TR><TD ALIGN="CENTER"><EM>grid type </EM></TD>
<TD ALIGN="LEFT"><EM>modifier</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">UNIFORM</TD>
<TD ALIGN="LEFT"><EM>none </EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
<TR><TD ALIGN="CENTER">GAUSSIAN</TD>
<TD ALIGN="LEFT"><EM>none </EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
</TABLE>
</DIV>

<P>
The various curvilinear grid types are created in the same way of mixing and matching grid type options. A regional expanding grid is formed using the grid types expanding and expanding. Likewise a rotated regional grid is created by
using the grid types rotation_15degrees and rotation_15degrees to indicate the grid type. A summary of the curvilinear grid types is given below. 
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN>Curvilinear grid options</SPAN></TD>
</TR>
<TR><TD ALIGN="CENTER"><EM>grid type </EM></TD>
<TD ALIGN="LEFT"><EM>modifier</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">CONTRACTING</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
<TR><TD ALIGN="CENTER">EXPANDING</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
<TR><TD ALIGN="CENTER">SYMMETRIC_SIN</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
<TR><TD ALIGN="CENTER">ASYMMETRIC_SIN</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_POLE</TD>
</TR>
<TR><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">_PERIODIC</TD>
</TR>
<TR><TD ALIGN="CENTER">rotation_15degrees</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">rotation_30degrees</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
<TR><TD ALIGN="CENTER">rotation_30degrees</TD>
<TD ALIGN="LEFT"><EM>none</EM></TD>
</TR>
</TABLE>
</DIV>
It should be noted that the rotated grid type only supports non-connected domains, and therefore has no option for _pole and _periodic connectivity.

<P>

<H4><A NAME="SECTION00075520000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Specifier file syntax for redistribution</A>
</H4>
Since a redistribution test takes either an array or a field and rearranges it in processor space, the test requires only a single grid for the source and destination. The information required is:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>parameters to define a grid for redistribution </EM></TD>
</TR>
<TR><TD ALIGN="LEFT">Grid rank</TD>
</TR>
<TR><TD ALIGN="LEFT">Grid dimensions</TD>
</TR>
<TR><TD ALIGN="LEFT">Range of the coordinate axis</TD>
</TR>
<TR><TD ALIGN="LEFT">Coordinate units</TD>
</TR>
</TABLE>
</DIV>

<P>
This is the information is provided by the redistribution grid specifier file.
An example of a redistribution grid specifier file is provided below. 
<DIV ALIGN="CENTER">
</DIV><PRE>
# grid.rc
########################################
map_type: REDISTRIBUTION

# regular rectilinear Grid specification 
map_redist::
#rank spacing  size  range (min/max)  units
#
2  'UNIFORM'  120  -3.14159  3.14159  'RAD'   'UNIFORM'  90  -1.57  1.57  'RAD'   
#
2  'UNIFORM'  400  -180   180  'DEG_E'  'GAUSSIAN'  200 -88   88   'DEG_N'  
::
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
The first piece of information required for the file is the <TT>map_type</TT> key. It should be set to <TT>REDISTRIBUTION</TT> to indicate that it is intended to define grids for a redistribution test. Next is a configuration table which specifies multiple grids. The specification can be stretched over multiple table lines by use of the continuation symbol <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img55.png"
 ALT="$\&amp;$"></SPAN>. The order of information is as follows:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>parameters to define a grid for redistribution </EM></TD>
</TR>
<TR><TD ALIGN="LEFT">Grid rank</TD>
</TR>
<TR><TD ALIGN="LEFT">Grid axis type</TD>
</TR>
<TR><TD ALIGN="LEFT">Grid size</TD>
</TR>
<TR><TD ALIGN="LEFT">Range of the coordinate axis</TD>
</TR>
<TR><TD ALIGN="LEFT">Coordinate units</TD>
</TR>
</TABLE>
</DIV>

<P>
There are two 2D grids specified in the file. The first is a standard uniformly spaced latitude-longitude grid, where none of the grid coordinates has any topological connections. The horizontal coordinates are in radians. The second 2D grid is a gaussian spherical grid. The gaussian grid has a spherical topology and is in degrees. 

<P>
Four types of coordinate units are supported; degrees, radians, meters and kilometers.  Each has multiple equivalent key words. 
 <DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN> Supported units </SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT"><EM>name </EM></TD>
<TD ALIGN="LEFT"><EM>key word</EM></TD>
</TR>
<TR><TD ALIGN="LEFT">Degrees</TD>
<TD ALIGN="LEFT">DEGREES</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">DEG</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">DEG_E</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">DEG_N</TD>
</TR>
<TR><TD ALIGN="LEFT">Radians</TD>
<TD ALIGN="LEFT">RADIANS</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">RAD</TD>
</TR>
<TR><TD ALIGN="LEFT">Meters</TD>
<TD ALIGN="LEFT">METERS</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">M</TD>
</TR>
<TR><TD ALIGN="LEFT">Kilometers</TD>
<TD ALIGN="LEFT">KILOMETERS</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">KM</TD>
</TR>
</TABLE>
</DIV>

<P>

<H4><A NAME="SECTION00075530000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> Specifier file syntax for regridding</A>
</H4>
The process of regridding takes a distributed test field from a source grid and interpolates it to a distributed destination grid. Therefore it requires information specifying both a source and destination grid, and an explicit test function to interpolate. The information required is:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>parameters to define a grid for remapping </EM></TD>
</TR>
<TR><TD ALIGN="LEFT">source and destination grid rank</TD>
</TR>
<TR><TD ALIGN="LEFT">source and destination grid axis type</TD>
</TR>
<TR><TD ALIGN="LEFT">source and destination grid dimensions</TD>
</TR>
<TR><TD ALIGN="LEFT">source and destination range of coordinate axis</TD>
</TR>
<TR><TD ALIGN="LEFT">source and destination coordinate units</TD>
</TR>
<TR><TD ALIGN="LEFT">test function with parameters to interpolate</TD>
</TR>
</TABLE>
</DIV>

<P>
This information is provided by the regridding grid specifier file.
An example of a regridding grid specifier file is provided below. 
<DIV ALIGN="CENTER">
</DIV><PRE>
# grid.rc
########################################
map_type: REGRID

################################################################################
# grid | source | grid    |    grid   | grid  | units | destination | 
# rank |  tag   | spacing | dimension | range |       |    tag      |
################################################################################
# Grid specification for regridding

#rank spacing  size  range (min/max)  units
map_regrid::
# example of a pair of 2D periodic grids 
2   SRC    UNIFORM_PERIODIC   120   -3.14159  3.14159  RADIANS   
&amp;              UNIFORM_POLE             90    -1.57        1.57        RADIANS   
&amp;   DST    UNIFORM_PERIODIC   120  -180      180             DEG_E   
&amp;              GAUSSIAN_POLE           88    -88        88             DEG_N   
&amp;   FUNCTION    CONSTANT   2.1 0.1  END
::
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
The first piece of information required for the file is the <TT>map_type</TT> key. It should be set to <TT>REGRID</TT> to indicate that it is intended to define grids for a regridding test. Next is a configuration table which specifies multiple pairs of grids. The specification can be stretched over multiple table lines by use of the continuation symbol <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img55.png"
 ALT="$\&amp;$"></SPAN>. The order of information is as follows:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>parameters to define a grid for reremapping </EM></TD>
</TR>
<TR><TD ALIGN="LEFT">Grid rank</TD>
</TR>
<TR><TD ALIGN="LEFT">Source grid axis type</TD>
</TR>
<TR><TD ALIGN="LEFT">Source grid size</TD>
</TR>
<TR><TD ALIGN="LEFT">Source range of the coordinate axis</TD>
</TR>
<TR><TD ALIGN="LEFT">Source coordinate units</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination grid axis type</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination grid size</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination range of the coordinate axis</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination coordinate units</TD>
</TR>
<TR><TD ALIGN="LEFT">Test function and parameters</TD>
</TR>
</TABLE>
</DIV>

<P>
The regridding grid specifier file contains a pair of 2D grids. The source grid is a standard latitude-longitude grid on a spherical topology. The destination grid is a spherical gaussian grid also on a spherical topology. The source grid is in radians, while the destination grid is in degrees. The test function is a periodic function of the grid coordinates. 

<P>
The one new piece of information for the regridding specifier files are the predefined test functions. The test functions provide a physical field to be interpolated and are generated as an analytical function of the grid coordinates. Supported options include:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER" COLSPAN=2><SPAN> Test functions </SPAN></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT"><EM>name </EM></TD>
<TD ALIGN="LEFT"><EM>function</EM></TD>
<TD ALIGN="LEFT"><EM>parameters</EM></TD>
</TR>
<TR><TD ALIGN="LEFT">constant</TD>
<TD ALIGN="LEFT">set value at all locations</TD>
<TD ALIGN="LEFT">value, relative error</TD>
</TR>
<TR><TD ALIGN="LEFT">coordinate</TD>
<TD ALIGN="LEFT">set to a multiple of the coordinate values</TD>
<TD ALIGN="LEFT">scale, relative error</TD>
</TR>
<TR><TD ALIGN="LEFT">spherical harmonic</TD>
<TD ALIGN="LEFT">periodic function of the grid coordinates</TD>
<TD ALIGN="LEFT">amplitudes and phases, relative error</TD>
</TR>
</TABLE>
</DIV>

<P>
The CONSTANT value test function sets the field to the value of the first parameter following the name. The second value is the relative error threshold. For example, the test function specification:

<P>
<DIV ALIGN="CENTER">
</DIV><PRE>
&amp;   FUNCTION    CONSTANT   2.1 0.1  END
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
indicates that the field is set to the constant value of <SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img56.png"
 ALT="$2.1$"></SPAN>, with a relative error threshold 
of <SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img57.png"
 ALT="$0.1$"></SPAN>. This test function specification holds for grids of any rank. 

<P>
The COORDINATE test function sets the field to the value of the one of the grid coordinates multiplied by the value of the first parameter following the name. The second value is the relative error threshold. For example, the test function specification:

<P>
<DIV ALIGN="CENTER">
</DIV><PRE>
&amp;   FUNCTION    COORDINATEX   0.5 0.1  END
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
indicates that the field is set to one half of the X coordinate values. For a 2D grid the coordinate options include COORDINATEX and COORDINATEY. For a 3D grid there is the additional option of COORDINATEZ. Again, the relative error threshold is <SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img57.png"
 ALT="$0.1$"></SPAN>.
This test function specification holds for grids of any rank. 

<P>
The SPHERICAL_HARMONIC test function sets the field to the periodic harmonic function 
<!-- MATH
 $|a+b| + a*\cos(2\pi * k_x * x/L_x ) + b*\sin(2\pi * l_y * x/L_y )$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="393" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.png"
 ALT="$\vert a+b\vert + a*\cos(2\pi * k_x * x/L_x ) + b*\sin(2\pi * l_y * x/L_y )$"></SPAN>.
The parameters follow the order

<P>
<DIV ALIGN="CENTER">
</DIV><PRE>
&amp;   FUNCTION    SPHERICAL_HARMONIC  a   kx  b   ly    rel_error  END
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
This test function specification is only valid for 2D grids.     

<P>

<H3><A NAME="SECTION00075600000000000000"></A>
<A NAME="sec:harness_distributionsspecifier"></A>
<BR>
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> Distribution Specification
</H3>
The purpose of the distribution specification is to characterize the distribution of the grid. It differs from the grid specification in that it is designed to specify the distribution as both absolute values such as <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img59.png"
 ALT="$2 \times 3$"></SPAN> PETs as well as in relative terms based on fractions of the total number of PETs. This second option is intended to allow the distribution space to scale with changing machine resources without having to change the distribution specification file.

<P>
Here is an example of a distribution specification file for block and block cyclic distributions.
<DIV ALIGN="CENTER">
</DIV><PRE>
##################################################
# descriptive | source | source | operator | destination | dest | operator | end
# string      |  tag   |  rank  |  &amp; value |     tag     | rank | &amp; value  | tag
##################################################

# table specifing 2D to 2D distributions
distgrid_block_2d2d::

# example with two fixed distribution sizes
 '(1,2)--&gt;(2,1)'  'SRC' 2  'D1==' 1  'D2==' 2  'DST' 2  'D1==' 2  'D2==' 1  'END'  

# example with one fixed and one variable distribution size
 '(1,n)--&gt;(n,1)'  'SRC' 2  'D1==' 1  'D2=*' 1  'DST' 2  'D1=*' 1  'D2==' 1  'END'  

# example with variable distribution sizes
 '(2n,n/2)--&gt;(n/2,2n)'  'SRC'  2  'D1=*'  2    'D2=*'  0.5  
 &amp;                      'DST'  2  'D1=*'  0.5  'D2=*'  2     'END'

# another example with variable distribution sizes
 '(2n,n/2)--&gt;(2n,(n/2)-1)'  'SRC' 2  'D1=*' 2  'D2=*'  0.5  
 &amp;                          'DST' 2  'D1=*' 2  'D2=*'  0.5  'D2=+' 1   'END'
::

# table specifing 3D to 3D distributions
distgrid_block_3d3d::

# example with two fixed distribution sizes
 '(1,2,1)--&gt;(2,1,1)'  'SRC' 3  'D1==' 1  'D2==' 2  'D3==' 1  
 &amp;                    'DST' 3  'D1==' 2  'D2==' 1  'D3==' 1  'END'  
::
</PRE>
<DIV ALIGN="CENTER">
</DIV>
The contents of the file are tables which specify pairs of distributions. Each table specifies a particular rank of distributions. The first table consists of 2D to 2D distributions, while the second table consists of a 3D to 3D pair of distributions. 
The order of information is as follows:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><EM>parameters to define a grid distribution </EM></TD>
</TR>
<TR><TD ALIGN="LEFT">Descriptive string</TD>
</TR>
<TR><TD ALIGN="LEFT">Source key</TD>
</TR>
<TR><TD ALIGN="LEFT">Source distribution rank</TD>
</TR>
<TR><TD ALIGN="LEFT">Source distribution axis and size for each dimension of the distribution</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination key</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination distribution rank</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination grid size</TD>
</TR>
<TR><TD ALIGN="LEFT">Destination distribution axis and size for each dimension of the distribution</TD>
</TR>
<TR><TD ALIGN="LEFT">Termination key</TD>
</TR>
</TABLE>
</DIV>
The first example in the table starts with a string used by the report as a brief description of the distribution. Such as  <SPAN CLASS="MATH"><IMG
 WIDTH="128" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img60.png"
 ALT="$(1,2)--&gt;(2,1)$"></SPAN> which indicates a source distribution of <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$1 \times 2$"></SPAN> and a destination distribution of <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$2 \times 1$"></SPAN>. Next comes a key word, either <TT>SRC</TT> or <TT>DST</TT> to indicate the beginning of the source and destination descriptions, respectively. Following each tag is a specification of the distribution. In the first case a fixed source distribution is specified by the entries <SPAN CLASS="MATH"><IMG
 WIDTH="67" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img63.png"
 ALT="$D1==1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="55" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img64.png"
 ALT="$D2=2$"></SPAN>. This indicates that the source distribution is fixed to be <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$1 \times 2$"></SPAN>, provided that the test is running with at least two processors. Likewise the destination distribution is fixed to <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$2 \times 1$"></SPAN>.

<P>
The second example, illustrates how to indicate a scalable distribution. Again the entry <SPAN CLASS="MATH"><IMG
 WIDTH="67" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img63.png"
 ALT="$D1==1$"></SPAN> indicates that the first dimension of the distribution is set to one, but the entry <SPAN CLASS="MATH"><IMG
 WIDTH="63" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img65.png"
 ALT="$D2=*1$"></SPAN> has a different meaning. It takes the total number of PETs NPETS and scales it by one. Therefore the source distribution becomes <!-- MATH
 $1 \times NPETS$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img66.png"
 ALT="$1 \times NPETS$"></SPAN>. It automatically scales with the number of PETs. Likewise, the destination distribution is set to <!-- MATH
 $NPETS \times 1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="93" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img67.png"
 ALT="$NPETS \times 1$"></SPAN>.

<P>
The third example is completely dynamic. Since both <SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img68.png"
 ALT="$D1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img69.png"
 ALT="$D2$"></SPAN> are scalable, each dimension starts with <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.png"
 ALT="$N$"></SPAN> PETs, where <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.png"
 ALT="$N$"></SPAN> is the square root of <SPAN CLASS="MATH"><IMG
 WIDTH="66" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img70.png"
 ALT="$NPETS$"></SPAN> rounded down to the nearest integer. Therefore <!-- MATH
 $N\times N \leq NPETS$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="136" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img71.png"
 ALT="$N\times N \leq NPETS$"></SPAN>. So if <SPAN CLASS="MATH"><IMG
 WIDTH="95" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img72.png"
 ALT="$NPETS=4$"></SPAN>, Then <SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="$N=2$"></SPAN>. If <SPAN CLASS="MATH"><IMG
 WIDTH="95" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img74.png"
 ALT="$NPETS=6$"></SPAN> then <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.png"
 ALT="$N$"></SPAN> still equals <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img75.png"
 ALT="$4$"></SPAN>. This base value is then modified by the indicated entries. In this case the source distribution is <!-- MATH
 $2 N \times 1/2 N$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="84" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img76.png"
 ALT="$2 N \times 1/2 N$"></SPAN>, since the tag <SPAN CLASS="MATH"><IMG
 WIDTH="63" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img77.png"
 ALT="$D1=* 2$"></SPAN> indicates that first dimension is the result of the base value being multiplied by two, and the second dimension is the result of the base value being multiplied by one half. Likewise, the destination distribution is set to <!-- MATH
 $1/2 N \times 2N$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="84" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img78.png"
 ALT="$1/2 N \times 2N$"></SPAN>, no matter the number of <SPAN CLASS="MATH"><IMG
 WIDTH="66" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img70.png"
 ALT="$NPETS$"></SPAN>.

<P>
For a rank three scalable distribution, <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.png"
 ALT="$N$"></SPAN> is the cube root of NPETS rounded down to the next integer. And so on for higher rank distributions. 

<P>
The fourth example illustrates the last option in the syntax. Again, since the distribution specifies two scalable distributions, <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img24.png"
 ALT="$N$"></SPAN> is the square root of <SPAN CLASS="MATH"><IMG
 WIDTH="66" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img70.png"
 ALT="$NPETS$"></SPAN> rounded down to the nearest integer. The source distribution is exactly the same as in the third example, but destination distribution has a new entry <SPAN CLASS="MATH"><IMG
 WIDTH="67" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img79.png"
 ALT="$D2=+ 1$"></SPAN>. The first dimension of the destination distribution is set to <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img80.png"
 ALT="$2N$"></SPAN> by the entry <SPAN CLASS="MATH"><IMG
 WIDTH="63" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img77.png"
 ALT="$D1=* 2$"></SPAN>. the second dimension is first set to <SPAN CLASS="MATH"><IMG
 WIDTH="42" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img81.png"
 ALT="$1/2N$"></SPAN> by the entry <SPAN CLASS="MATH"><IMG
 WIDTH="75" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img82.png"
 ALT="$D2=* 0.5$"></SPAN>, but then modified further to <SPAN CLASS="MATH"><IMG
 WIDTH="95" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img83.png"
 ALT="$(1/2)(N) +1$"></SPAN> by the entry <SPAN CLASS="MATH"><IMG
 WIDTH="67" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img79.png"
 ALT="$D2=+ 1$"></SPAN>. The resulting destination distribution is <!-- MATH
 $2N \times (1/2)(N) +1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="137" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img84.png"
 ALT="$2N \times (1/2)(N) +1$"></SPAN>. 

<P>
The syntax for modifying the size of the distribution space combines according to the order of the operations. The entries <SPAN CLASS="MATH"><IMG
 WIDTH="75" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img82.png"
 ALT="$D2=* 0.5$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="67" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img79.png"
 ALT="$D2=+ 1$"></SPAN>, are not identical to <SPAN CLASS="MATH"><IMG
 WIDTH="67" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img79.png"
 ALT="$D2=+ 1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="75" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img82.png"
 ALT="$D2=* 0.5$"></SPAN>, which would result in a dimension of size <SPAN CLASS="MATH"><IMG
 WIDTH="95" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img85.png"
 ALT="$(1/2)(N+1)$"></SPAN>.

<P>
Three operations are supported:
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="CENTER"><EM>Distribution specification operations</EM></TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="CENTER">D# ==</TD>
<TD ALIGN="CENTER">specify a fixed value</TD>
</TR>
<TR><TD ALIGN="CENTER">D# =*</TD>
<TD ALIGN="CENTER">multiply a base value by a constant</TD>
</TR>
<TR><TD ALIGN="CENTER">D# =+</TD>
<TD ALIGN="CENTER">add a constant to the base value</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00075700000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class Specification</A>
</H3>
The class specific specifier file is current unused, but is made available for future test expansion.

<P>

<H2><A NAME="SECTION00076000000000000000">
<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> Reporting test results</A>
</H2>
The test harness offers the option of producing a human readable report on the test results. The report consists of a concise summary of the test configuration along with the test results. The test configuration is described in terms of the Field Taxonomy syntax and user provided strings. The intent is not to provide a exhaustive description of the test, but rather to provide a useful description of the failed tests.

<P>
Consider a problem descriptor string consisting of two descriptor strings describing an ensemble of remapping tests. 
<DIV ALIGN="CENTER">
</DIV><PRE>
[ B1 G1; B2 G2 ] =C=&gt; [ B1 G1; B2 G2 ] @{+,+}
[ B1 G1; B2 G2 ] =B=&gt; [ B1 G1; B2 G2 ] @{+,+}
</PRE>
<DIV ALIGN="CENTER">
</DIV>

<P>
Suppose the associated specifier files indicate that the source grid is rectilinear and is 100 X 50 in size. The destination grid is also rectilinear and is 80 X 20 in size. The remapping is conducted from the A-grid position of the source grid to the B-grid stagger of the destination grid. Both grids are block distributed in two ways, 1 X NPETS and NPETS X 1. And suppose that the first dimension of both the source and destination grids are periodic. If the test succeeds for the conservative remapping, but fails for one of the first order bilinear remapping configurations, the reported results
could look something like
<DIV ALIGN="CENTER">
</DIV><PRE>
SUCCESS: [B1 G1; B2 G2 ] =C=&gt; [B1 G1; B2 G2 ] @{+,+}
FAILURE: [B1{1} G1{100}+P; B2{npets} G2{50} ] =B=&gt; 
                         [B1{1} G1{80}+P; B2{npets} G2{20} ] @{+,+}
     failure at line 101 of test.F90
SUCCESS: [ B1{npets} G1{100} +P; B2{1} G2{50} ] =B=&gt; 
                         [ B1{npets} G1{80}+P; B2{1} G2{20} ] @{+,+}
</PRE>
<DIV ALIGN="CENTER">
</DIV>
Notice that the problem descriptor string differs from that of the configuration files. This is because it represents specific realizations of ensemble. For example 
<DIV ALIGN="CENTER">
</DIV><PRE>
[ B1{npets} G1{80}+P; B2{1} G2{20} ] @{+,+}
</PRE>
<DIV ALIGN="CENTER">
</DIV>
indicates that the 2D block of memory is periodic in the first dimension by the addition of the <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img86.png"
 ALT="$+P$"></SPAN> to the first grid key. The size of the grid is indicated as <SPAN CLASS="MATH"><IMG
 WIDTH="55" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img87.png"
 ALT="$80 \times 20$"></SPAN> by the size arguments appended to the grid indicators <SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img88.png"
 ALT="$G1 \{80 \}$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img89.png"
 ALT="$G2 \{ 20 \}$"></SPAN>. The size of the distribution is indicated in the same way as <!-- MATH
 $npets \times 1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="70" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$npets \times 1$"></SPAN> by the block distribution indicators <!-- MATH
 $B1 \{ npets \}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="79" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img91.png"
 ALT="$B1 \{ npets \}$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="49" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img92.png"
 ALT="$B2 \{ 1 \}$"></SPAN>.

<P>
The report indicates that all the test configurations for the conservative remapping are successful. This is indicated by the key word SUCCESS which is followed by the successful problem descriptor string. Since all of the tests in the first case pass,there is no need to include any of the specifier information. For the second ensemble of tests, one configuration passed, while the other failed. In this case, since there is a mixture of successes and failures, the report includes specifier information for all the configurations to help indicate the source of the test failure. 

<P>
The supplemental information, while not a complete problem description, since it lacks items such as the physical coordinates of the grid and the nature of the test field, includes information crucial to isolating the failed test.

<P>

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html537"
  HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html533"
  HREF="dev_guide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html527"
  HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html535"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html538"
  HREF="node8.html">7 Conventions</A>
<B> Up:</B> <A NAME="tex2html534"
  HREF="dev_guide.html">dev_guide</A>
<B> Previous:</B> <A NAME="tex2html528"
  HREF="node6.html">5 Apps</A>
 &nbsp; <B>  <A NAME="tex2html536"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
